// Generated by IcedCoffeeScript 1.6.3-g
(function() {
  var AES, C, KeyMaterial, Packet, Parser, RSA, S2K, SHA1, SHA256, Signature, UserID, bufeq_secure, calc_checksum, decrypt, encode, encrypt, iced, katch, make_time_packet, native_rng, symmetric, triplesec, uint_to_buffer, __iced_k, __iced_k_noop, _ref, _ref1, _ref2,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  iced = require('iced-coffee-script/lib/coffee-script/iced').runtime;
  __iced_k = __iced_k_noop = function() {};

  C = require('../const').openpgp;

  triplesec = require('triplesec');

  _ref = triplesec.hash, SHA1 = _ref.SHA1, SHA256 = _ref.SHA256;

  RSA = require('../rsa').Pair;

  AES = triplesec.ciphers.AES;

  native_rng = triplesec.prng.native_rng;

  _ref1 = require('../util'), bufeq_secure = _ref1.bufeq_secure, katch = _ref1.katch, make_time_packet = _ref1.make_time_packet, uint_to_buffer = _ref1.uint_to_buffer, calc_checksum = _ref1.calc_checksum;

  _ref2 = require('../cfb'), decrypt = _ref2.decrypt, encrypt = _ref2.encrypt;

  Packet = require('./base').Packet;

  UserID = require('./userid').UserID;

  Signature = require('./signature').Signature;

  encode = require('../encode/armor').encode;

  S2K = require('../s2k').S2K;

  symmetric = require('../symmetric').symmetric;

  KeyMaterial = (function(_super) {
    __extends(KeyMaterial, _super);

    function KeyMaterial(_arg) {
      this.key = _arg.key, this.timestamp = _arg.timestamp, this.userid = _arg.userid, this.passphrase = _arg.passphrase, this.skm = _arg.skm;
      this.timepacket = make_time_packet(this.timestamp);
      this.uidp = new UserID(this.userid);
      KeyMaterial.__super__.constructor.call(this);
    }

    KeyMaterial.prototype._write_private_enc = function(bufs, priv) {
      var c, ct, iv, ivlen, k, plaintext, salt, sha1hash;
      bufs.push(new Buffer([C.s2k_convention.sha1, C.symmetric_key_algorithms.AES256, C.s2k.salt_iter, C.hash_algorithms.SHA256]));
      sha1hash = (new SHA1).bufhash(priv);
      salt = native_rng(8);
      bufs.push(salt);
      c = 96;
      bufs.push(new Buffer([c]));
      k = (new S2K).write(this.passphrase, salt, c);
      ivlen = AES.blockSize;
      iv = native_rng(ivlen);
      bufs.push(iv);
      plaintext = Buffer.concat([priv, sha1hash]);
      ct = encrypt({
        block_cipher_class: AES,
        key: k,
        plaintext: plaintext,
        iv: iv
      });
      return bufs.push(ct);
    };

    KeyMaterial.prototype._write_private_clear = function(bufs, priv) {
      return bufs.push(new Buffer([C.s2k_convention.none]), priv, uint_to_buffer(16, calc_checksum(priv)));
    };

    KeyMaterial.prototype._write_public = function(bufs) {
      var pub;
      pub = this.key.pub.serialize();
      return bufs.push(new Buffer([C.versions.keymaterial.V4]), this.timepacket, new Buffer([this.key.type]), pub);
    };

    KeyMaterial.prototype.private_body = function() {
      var bufs, priv, ret;
      bufs = [];
      this._write_public(bufs);
      priv = this.key.priv.serialize();
      if (this.passphrase != null) {
        this._write_private_enc(bufs, priv);
      } else {
        this._write_private_clear(bufs, priv);
      }
      ret = Buffer.concat(bufs);
      return ret;
    };

    KeyMaterial.prototype.private_framed = function() {
      var body;
      body = this.private_body();
      return this.frame_packet(C.packet_tags.secret_key, body);
    };

    KeyMaterial.prototype.public_body = function() {
      var bufs;
      bufs = [];
      this._write_public(bufs);
      return Buffer.concat(bufs);
    };

    KeyMaterial.prototype.get_fingerprint = function() {
      var data;
      data = this.public_body();
      return (new SHA1).bufhash(Buffer.concat([new Buffer([C.signatures.key]), uint_to_buffer(16, data.length), data]));
    };

    KeyMaterial.prototype.get_key_id = function() {
      return this.get_fingerprint().slice(12, 20);
    };

    KeyMaterial.prototype.public_framed = function() {
      var body;
      body = this.public_body();
      return this.frame_packet(C.packet_tags.public_key, body);
    };

    KeyMaterial.prototype._self_sign_key = function(cb) {
      var err, payload, pk, sig, spkt, uid8, x, ___iced_passed_deferral, __iced_deferrals, __iced_k,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      pk = this.public_body();
      uid8 = this.uidp.utf8();
      x = [new Buffer([C.signatures.key]), uint_to_buffer(16, pk.length), pk, new Buffer([C.signatures.userid]), uint_to_buffer(32, uid8.length), uid8];
      payload = Buffer.concat(x);
      spkt = new Signature(this);
      (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: "src/packet/keymaterial.iced",
          funcname: "KeyMaterial._self_sign_key"
        });
        spkt.write(C.sig_subpacket.issuer, payload, __iced_deferrals.defer({
          assign_fn: (function() {
            return function() {
              err = arguments[0];
              return sig = arguments[1];
            };
          })(),
          lineno: 134
        }));
        __iced_deferrals._fulfill();
      })(function() {
        return cb(err, sig);
      });
    };

    KeyMaterial.prototype.export_keys = function(_arg, cb) {
      var armor, err, ret, sig, ___iced_passed_deferral, __iced_deferrals, __iced_k,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      armor = _arg.armor;
      err = ret = null;
      (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: "src/packet/keymaterial.iced",
          funcname: "KeyMaterial.export_keys"
        });
        _this._self_sign_key(__iced_deferrals.defer({
          assign_fn: (function() {
            return function() {
              err = arguments[0];
              return sig = arguments[1];
            };
          })(),
          lineno: 141
        }));
        __iced_deferrals._fulfill();
      })(function() {
        if (err == null) {
          ret = _this._encode_keys({
            sig: sig,
            armor: armor
          });
        }
        return cb(err, ret);
      });
    };

    KeyMaterial.prototype._encode_keys = function(_arg) {
      var armor, private_key, public_key, sig, uidp, _ref3;
      sig = _arg.sig, armor = _arg.armor;
      uidp = this.uidp.write();
      _ref3 = C.message_types, private_key = _ref3.private_key, public_key = _ref3.public_key;
      return {
        "public": encode(public_key, Buffer.concat([this.public_framed(), uidp, sig])),
        "private": encode(private_key, Buffer.concat([this.private_framed(), uidp, sig]))
      };
    };

    KeyMaterial.parse_public_key = function(slice) {
      return (new Parser(slice)).parse_public_key();
    };

    KeyMaterial.parse_private_key = function(slice) {
      return (new Parser(slice)).parse_private_key();
    };

    KeyMaterial.prototype.open = function(_arg, cb) {
      var c1, c2, end, err, h1, h2, passphrase, pt;
      passphrase = _arg.passphrase;
      err = null;
      pt = this.skm.s2k_convention !== C.s2k_convention.none ? decrypt({
        ciphertext: this.skm.payload,
        block_cipher_class: this.skm.cipher.klass,
        iv: this.skm.iv,
        key: this.skm.s2k.produce_key(passphrase, this.skm.cipher.key_size)
      }) : pt = this.skm.payload;
      switch (this.skm.s2k_convention) {
        case C.s2k_convention.sha1:
          end = pt.length - 20;
          h1 = pt.slice(end);
          pt = pt.slice(0, end);
          h2 = (new SHA1).bufhash(pt);
          if (!bufeq_secure(h1, h2)) {
            err = new Error("hash mismatch");
          }
          break;
        case C.s2k_convention.checksum:
        case C.s2k_convention.none:
          end = pt.length - 2;
          c1 = pt.readUInt32BE(end);
          pt = pt.slice(0, end);
          c2 = calc_checksum(pt);
          if (c1 !== c2) {
            err = new Error("checksum mismatch");
          }
      }
      if (err == null) {
        err = this.pk.read_priv(pt);
      }
      return cb(err);
    };

    return KeyMaterial;

  })(Packet);

  Parser = (function() {
    function Parser(slice) {
      this.slice = slice;
      this.key = null;
    }

    Parser.prototype.parse_public_key_v3 = function() {
      this.creationTime = new Date(this.slice.read_uint32() * 1000);
      this.expiration = this.slice.read_uint16();
      return this.parse_public_key_mpis();
    };

    Parser.prototype.parse_public_key_v4 = function() {
      this.creationTime = new Date(this.slice.read_uint32() * 1000);
      return this.parse_public_key_mpis();
    };

    Parser.prototype.parse_public_key_mpis = function() {
      var A, err, key, len, _ref3;
      this.algorithm = this.slice.read_uint8();
      A = C.public_key_algorithms;
      _ref3 = (function() {
        switch (this.algorithm) {
          case A.RSA:
          case A.RSA_ENCRYPT_ONLY:
          case A.RSA_SIGN_ONLY:
            return RSA.parse(this.slice.peek_rest_to_buffer());
          default:
            throw new Error("Can only deal with RSA right now");
        }
      }).call(this), err = _ref3[0], key = _ref3[1], len = _ref3[2];
      if (err != null) {
        throw err;
      }
      this.slice.advance(len);
      return key;
    };

    Parser.prototype._parse_public_key = function() {
      var version;
      switch ((version = this.slice.read_uint8())) {
        case C.versions.keymaterial.V3:
          return this.parse_public_key_v3();
        case C.versions.keymaterial.V4:
          return this.parse_public_key_v4();
        default:
          throw new Error("Unknown public key version: " + version);
      }
    };

    Parser.prototype.parse_public_key = function() {
      var key;
      key = this._parse_public_key();
      return new KeyMaterial({
        key: key
      });
    };

    Parser.prototype.parse_private_key = function() {
      var encrypted_private_key, iv_len, key, skm, sym_enc_alg, _ref3;
      skm = {};
      key = this._parse_public_key();
      encrypted_private_key = true;
      sym_enc_alg = null;
      if ((skm.s2k_convention = this.slice.read_uint8()) === C.s2k_convention.none) {
        encrypted_private_key = false;
      } else if ((_ref3 = skm.s2k_convention) === (C.s2k_convention_sha1 || C.s2k_convention.checksum)) {
        sym_enc_alg = this.slice.read_uint8();
        skm.s2k = (new S2K).read(this.slice);
      } else {
        sym_enc_alg = skm.s2k_convention;
      }
      if (sym_enc_alg) {
        skm.cipher = symmetric.get_cipher(sym_enc_alg);
        iv_len = skm.cipher_class.blockSize;
        skm.iv = this.slice.read_buffer(iv_len);
      }
      if ((skm.s2k_convention !== C.s2k_convention.none) && (skm.s2k.type === C.s2k.gnu)) {
        skm.payload = null;
      } else {
        skm.payload = this.slice.consume_rest_to_buffer();
      }
      return new KeyMaterial({
        key: key,
        skm: skm
      });
    };

    return Parser;

  })();

  exports.KeyMaterial = KeyMaterial;

}).call(this);
