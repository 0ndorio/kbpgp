// Generated by IcedCoffeeScript 1.6.3-g
(function() {
  var C, EmbeddedSignature, ExpirationTime, Exporatable, Features, Issuer, KeyExpirationTime, KeyFlags, KeyServerPreferences, NotationData, Packet, Parser, PolicyURI, Preference, PreferredCompressionAlgorithms, PreferredHashAlgorithms, PreferredKeyServer, PreferredSymmetricAlgorithms, PrimaryUserId, ReasonForRevocation, RegularExpression, Revocable, RevocationKey, SHA1, SHA512, SigCreationTime, SigExpirationTime, Signature, SignatureTarget, SignersUserID, SubPacket, Trust, alloc_or_throw, asymmetric, encode_length, make_time_packet, uint_to_buffer, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };



  Packet = require('./base').Packet;

  C = require('../const').openpgp;

  _ref = require('../util'), uint_to_buffer = _ref.uint_to_buffer, encode_length = _ref.encode_length, make_time_packet = _ref.make_time_packet;

  _ref1 = require('../hash'), alloc_or_throw = _ref1.alloc_or_throw, SHA512 = _ref1.SHA512, SHA1 = _ref1.SHA1;

  asymmetric = require('../asymmetric');

  Signature = (function(_super) {
    __extends(Signature, _super);

    function Signature(_arg) {
      this.key = _arg.key, this.hash = _arg.hash, this.key_id = _arg.key_id, this.sig_data = _arg.sig_data, this.public_key_class = _arg.public_key_class, this.signed_hash_value_hash = _arg.signed_hash_value_hash, this.subpackets = _arg.subpackets, this.time = _arg.time, this.sig = _arg.sig;
      if (this.hash == null) {
        this.hash = SHA512;
      }
    }

    Signature.prototype.subpacket = function(type, buf) {
      return Buffer.concat([encode_length(buf.length + 1), new Buffer([type]), buf]);
    };

    Signature.prototype.write = function(sigtype, data, cb) {
      var dsp, hash, isp, payload, result, result2, results, ret, sig, trailer;
      dsp = this.subpacket(C.sig_subpacket.creation_time, make_time_packet());
      isp = this.subpacket(C.sig_subpacket.issuer, this.keymaterial.get_key_id());
      result = Buffer.concat([new Buffer([C.versions.signature.V4, sigtype, this.key.type, this.hash.type]), uint_to_buffer(16, dsp.length + isp.length), dsp, isp]);
      trailer = Buffer.concat([new Buffer([C.versions.signature.V4, 0xff]), uint_to_buffer(32, result.length)]);
      payload = Buffer.concat([data, result, trailer]);
      hash = this.hash(payload);
      sig = this.key.pad_and_sign(payload, {
        hash: this.hash
      });
      result2 = Buffer.concat([new Buffer([0, 0, hash.readUInt8(0), hash.readUInt8(1)]), sig]);
      results = Buffer.concat([result, result2]);
      ret = this.frame_packet(C.packet_tags.signature, results);
      return cb(null, ret);
    };

    Signature.parse = function(slice) {
      return (new Parser(slice)).parse();
    };

    return Signature;

  })(Packet);

  SubPacket = (function() {
    function SubPacket() {}

    return SubPacket;

  })();

  ExpirationTime = (function(_super) {
    __extends(ExpirationTime, _super);

    function ExpirationTime(time) {
      this.time = time;
      this.never_expires = this.time === 0;
    }

    ExpirationTime.parse = function(slice, klass) {
      return new klass(slice.read_uint32());
    };

    return ExpirationTime;

  })(SubPacket);

  Preference = (function(_super) {
    __extends(Preference, _super);

    function Preference(v) {
      this.v = v;
    }

    Preference.parse = function(slice, klass) {
      var c, v;
      v = (function() {
        var _i, _len, _ref2, _results;
        _ref2 = slice.consume_rest_to_buffer();
        _results = [];
        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
          c = _ref2[_i];
          _results.push(c);
        }
        return _results;
      })();
      return new klass(v);
    };

    return Preference;

  })(SubPacket);

  SigCreationTime = (function(_super) {
    __extends(SigCreationTime, _super);

    function SigCreationTime(time) {
      this.time = time;
    }

    SigCreationTime.parse = function(slice) {
      var ret;
      ret = new SigCreationTime(new Date(slice.read_uint32() * 1000));
      console.log(ret.time);
      return ret;
    };

    return SigCreationTime;

  })(SubPacket);

  SigExpirationTime = (function(_super) {
    __extends(SigExpirationTime, _super);

    function SigExpirationTime() {
      _ref2 = SigExpirationTime.__super__.constructor.apply(this, arguments);
      return _ref2;
    }

    SigExpirationTime.parse = function(slice) {
      return ExpirationTime.parse(slice, SigExpirationTime);
    };

    return SigExpirationTime;

  })(ExpirationTime);

  Exporatable = (function(_super) {
    __extends(Exporatable, _super);

    function Exporatable(flag) {
      this.flag = flag;
    }

    Exporatable.parse = function(slice) {
      return new Exporatable(slice.read_uint8() === 1);
    };

    return Exporatable;

  })(SubPacket);

  Trust = (function(_super) {
    __extends(Trust, _super);

    function Trust(level, amount) {
      this.level = level;
      this.amount = amount;
    }

    Trust.parse = function(slice) {
      return new Trust(slice.read_uint8(), slice.read_uint8());
    };

    return Trust;

  })(SubPacket);

  RegularExpression = (function(_super) {
    __extends(RegularExpression, _super);

    function RegularExpression(re) {
      this.re = re;
    }

    RegularExpression.parse = function(slice) {
      var ret;
      ret = new RegularExpression(slice.consume_rest_to_buffer().toString('utf8'));
      console.log(ret.re);
      return ret;
    };

    return RegularExpression;

  })(SubPacket);

  Revocable = (function(_super) {
    __extends(Revocable, _super);

    function Revocable(flag) {
      this.flag = flag;
    }

    Revocable.parse = function(slice) {
      return new Revocable(slice.read_uint8() === 1);
    };

    return Revocable;

  })(SubPacket);

  KeyExpirationTime = (function(_super) {
    __extends(KeyExpirationTime, _super);

    function KeyExpirationTime() {
      _ref3 = KeyExpirationTime.__super__.constructor.apply(this, arguments);
      return _ref3;
    }

    KeyExpirationTime.parse = function(slice) {
      return ExpirationTime.parse(slice, KeyExpirationTime);
    };

    return KeyExpirationTime;

  })(ExpirationTime);

  PreferredSymmetricAlgorithms = (function(_super) {
    __extends(PreferredSymmetricAlgorithms, _super);

    function PreferredSymmetricAlgorithms() {
      _ref4 = PreferredSymmetricAlgorithms.__super__.constructor.apply(this, arguments);
      return _ref4;
    }

    PreferredSymmetricAlgorithms.parse = function(slice) {
      return Preference.parse(slice, PreferredSymmetricAlgorithms);
    };

    return PreferredSymmetricAlgorithms;

  })(Preference);

  RevocationKey = (function(_super) {
    __extends(RevocationKey, _super);

    function RevocationKey(key_class, alg, fingerprint) {
      this.key_class = key_class;
      this.alg = alg;
      this.fingerprint = fingerprint;
    }

    RevocationKey.parse = function(slice) {
      var fp, ka, kc;
      kc = slice.read_uint8();
      ka = slice.read_uint8();
      fp = slice.read_buffer(SHA1.output_size);
      return new RevocationKey(kc, ka, fp);
    };

    return RevocationKey;

  })(SubPacket);

  Issuer = (function(_super) {
    __extends(Issuer, _super);

    function Issuer(id) {
      this.id = id;
    }

    Issuer.parse = function(slice) {
      return new Issuer(slice.read_buffer(8));
    };

    return Issuer;

  })(SubPacket);

  NotationData = (function(_super) {
    __extends(NotationData, _super);

    function NotationData(flags, name, value) {
      this.flags = flags;
      this.name = name;
      this.value = value;
    }

    NotationData.parse = function(slice) {
      var flags, name, nl, value, vl;
      flags = slice.read_uint32();
      nl = slice.read_uint16();
      vl = slice.read_uint16();
      name = slice.read_buffer(nl);
      value = slice.read_buffer(vl);
      return new NotationData(flags, name, value);
    };

    return NotationData;

  })(SubPacket);

  PreferredHashAlgorithms = (function(_super) {
    __extends(PreferredHashAlgorithms, _super);

    function PreferredHashAlgorithms() {
      _ref5 = PreferredHashAlgorithms.__super__.constructor.apply(this, arguments);
      return _ref5;
    }

    PreferredHashAlgorithms.parse = function(slice) {
      return Preference.parse(slice, PreferredHashAlgorithms);
    };

    return PreferredHashAlgorithms;

  })(Preference);

  PreferredCompressionAlgorithms = (function(_super) {
    __extends(PreferredCompressionAlgorithms, _super);

    function PreferredCompressionAlgorithms() {
      _ref6 = PreferredCompressionAlgorithms.__super__.constructor.apply(this, arguments);
      return _ref6;
    }

    PreferredCompressionAlgorithms.parse = function(slice) {
      return Preference.parse(slice, PreferredCompressionAlgorithms);
    };

    return PreferredCompressionAlgorithms;

  })(Preference);

  KeyServerPreferences = (function(_super) {
    __extends(KeyServerPreferences, _super);

    function KeyServerPreferences() {
      _ref7 = KeyServerPreferences.__super__.constructor.apply(this, arguments);
      return _ref7;
    }

    KeyServerPreferences.parse = function(slice) {
      return Preference.parse(slice, PreferredKeyServer);
    };

    return KeyServerPreferences;

  })(Preference);

  Features = (function(_super) {
    __extends(Features, _super);

    function Features() {
      _ref8 = Features.__super__.constructor.apply(this, arguments);
      return _ref8;
    }

    Features.parse = function(slice) {
      return Preference.parse(slice, Features);
    };

    return Features;

  })(Preference);

  PreferredKeyServer = (function(_super) {
    __extends(PreferredKeyServer, _super);

    function PreferredKeyServer(server) {
      this.server = server;
    }

    PreferredKeyServer.parse = function(slice) {
      return new PreferredKeyServer(slice.consume_rest_to_buffer());
    };

    return PreferredKeyServer;

  })(SubPacket);

  PrimaryUserId = (function(_super) {
    __extends(PrimaryUserId, _super);

    function PrimaryUserId(flag) {
      this.flag = flag;
    }

    PrimaryUserId.parse = function(slice) {
      return new PrimaryUserId(slice.read_uint8() === 1);
    };

    return PrimaryUserId;

  })(SubPacket);

  PolicyURI = (function(_super) {
    __extends(PolicyURI, _super);

    function PolicyURI(flag) {
      this.flag = flag;
    }

    PolicyURI.parse = function(slice) {
      return new PolicyURI(slice.consume_rest_to_buffer());
    };

    return PolicyURI;

  })(SubPacket);

  KeyFlags = (function(_super) {
    __extends(KeyFlags, _super);

    function KeyFlags() {
      _ref9 = KeyFlags.__super__.constructor.apply(this, arguments);
      return _ref9;
    }

    KeyFlags.parse = function(slice) {
      return Preference.parse(slice, KeyFlags);
    };

    return KeyFlags;

  })(Preference);

  SignersUserID = (function(_super) {
    __extends(SignersUserID, _super);

    function SignersUserID(uid) {
      this.uid = uid;
    }

    SignersUserID.parse = function(slice) {
      return new SignersUserID(slice.consume_rest_to_buffer());
    };

    return SignersUserID;

  })(SubPacket);

  ReasonForRevocation = (function(_super) {
    __extends(ReasonForRevocation, _super);

    function ReasonForRevocation(flag, reason) {
      this.flag = flag;
      this.reason = reason;
    }

    ReasonForRevocation.parse = function(slice) {
      var flag, reason;
      flag = slice.read_uint8();
      reason = slice.consume_rest_to_buffer();
      return new ReasonForRevocation(flag, reason);
    };

    return ReasonForRevocation;

  })(SubPacket);

  SignatureTarget = (function(_super) {
    __extends(SignatureTarget, _super);

    function SignatureTarget(pub_key_alg, hasher, hval) {
      this.pub_key_alg = pub_key_alg;
      this.hasher = hasher;
      this.hval = hval;
    }

    SignatureTarget.parse = function(slice) {
      var hasher, hval, pka;
      pka = slice.read_uint8();
      hasher = alloc_or_throw(slice.read_uint8());
      hval = slice.read_buffer(ha.output_length);
      return new SignatureTarget(pka, hasher, hval);
    };

    return SignatureTarget;

  })(SubPacket);

  EmbeddedSignature = (function(_super) {
    __extends(EmbeddedSignature, _super);

    function EmbeddedSignature(sig) {
      this.sig = sig;
    }

    EmbeddedSignature.parse = function(slice) {
      return new EmbeddedSignature(Signature.parse(slice));
    };

    return EmbeddedSignature;

  })(SubPacket);

  exports.Signature = Signature;

  Parser = (function() {
    function Parser(slice) {
      this.slice = slice;
    }

    Parser.prototype.parse_v3 = function() {
      if (this.slice.read_uint8() !== 5) {
        throw new error("Bad one-octet length");
      }
      this.type = this.slice.read_uint8();
      this.time = new Date(this.slice.read_uint32() * 1000);
      this.sig_data = this.slice.peek_rest_to_buffer();
      this.key_id = this.slice.read_buffer(8);
      this.public_key_class = asymmetric.get_class(this.slice.read_uint8());
      this.hash = alloc_or_throw(this.slice.read_uint8());
      this.signed_hash_value_hash = this.slice.read_uint16();
      return this.sig = this.public_key_class.parse_sig(this.slice);
    };

    Parser.prototype.parse_v4 = function() {
      var end, hashed_subpacket_count;
      this.type = this.slice.read_uint8();
      this.public_key_class = asymmetric.get_class(this.slice.read_uint8());
      this.hash = alloc_or_throw(this.slice.read_uint8());
      hashed_subpacket_count = this.slice.read_uint16();
      this.sig_data = this.slice.peek_to_buffer(end);
      end = this.slice.i + hashed_subpacket_count;
      this.subpackets = ((function() {
        var _results;
        _results = [];
        while (this.slice.i < end) {
          _results.push(this.parse_subpacket());
        }
        return _results;
      }).call(this));
      this.signed_hash_value_hash = this.slice.read_uint16();
      return this.sig = this.public_key_class.parse_sig(this.slice);
    };

    Parser.prototype.parse_subpacket = function() {
      var S, end, klass, len, ret, type;
      len = this.slice.read_v4_length();
      type = this.slice.read_uint8() & 0x7f;
      S = C.sig_subpacket;
      end = this.slice.clamp(len - 1);
      klass = (function() {
        switch (type) {
          case S.creation_time:
            return SigCreationTime;
          case S.expiration_time:
            return SigExpirationTime;
          case S.exportable_certificate:
            return Exportable;
          case S.trust_signature:
            return Trust;
          case S.regular_expression:
            return RegularExpression;
          case S.revocable:
            return Revocable;
          case S.key_expiration_time:
            return KeyExpirationTime;
          case S.preferred_symmetric_algorithms:
            return PreferredSymmetricAlgorithms;
          case S.revocation_key:
            return RevocationKey;
          case S.issuer:
            return Issuer;
          case S.notation_data:
            return NotationData;
          case S.preferred_hash_algorithms:
            return PreferredHashAlgorithms;
          case S.preferred_compression_algorithms:
            return PreferredCompressionAlgorithms;
          case S.key_server_preferences:
            return KeyServerPreferences;
          case S.preferred_key_server:
            return PreferredKeyServer;
          case S.primary_user_id:
            return PrimaryUserId;
          case S.policy_uri:
            return PolicyURI;
          case S.key_flags:
            return KeyFlags;
          case S.signers_user_id:
            return SignersUserID;
          case S.reason_for_revocation:
            return ReasonForRevocation;
          case S.features:
            return Features;
          case S.signature_target:
            return SignatureTarget;
          case S.embedded_signature:
            return EmbeddedSignature;
          default:
            throw new Error("Unknown signature subpacket: " + type);
        }
      })();
      ret = klass.parse(this.slice);
      this.slice.unclamp(end);
      console.log("subpacket type -> " + type + " " + len);
      return ret;
    };

    Parser.prototype.parse = function() {
      var version;
      version = this.slice.read_uint8();
      switch (version) {
        case C.versions.signature.V3:
          return this.parse_v3();
        case C.versions.signature.V4:
          return this.parse_v4();
        default:
          throw new Error("Unknown signature version: " + version);
      }
    };

    return Parser;

  })();

}).call(this);
