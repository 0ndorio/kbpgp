// Generated by IcedCoffeeScript 1.6.3-g
(function() {
  var BigInteger, buffer_to_ui8a, mpi_byte_length, mpi_from_buffer, nbi, nbits, nbs, nbv, toMPI, _ref;



  _ref = require('openpgp').bigint, nbv = _ref.nbv, nbi = _ref.nbi, BigInteger = _ref.BigInteger, nbits = _ref.nbits;

  buffer_to_ui8a = require('./util').buffer_to_ui8a;

  nbs = function(s, base) {
    var r;
    if (base == null) {
      base = 10;
    }
    r = nbi();
    r.fromString(s, base);
    return r;
  };

  mpi_byte_length = function(bn) {
    return bn.toByteArray().length;
  };

  toMPI = function(bn) {
    var ba, hdr, size;
    ba = bn.toByteArray();
    size = (ba.length - 1) * 8 + nbits(ba[0]);
    hdr = new Buffer(2);
    hdr.writeUInt16BE(size, 0);
    return Buffer.concat([hdr, new Buffer(ba)]);
  };

  mpi_from_buffer = function(raw) {
    var a, err, hdr, i, n_bits, n_bytes;
    err = i = null;
    if (raw.length < 2) {
      err = new Error("need at least 2 bytes; got " + raw.length);
    } else {
      hdr = new Buffer(raw.slice(0, 2));
      raw = raw.slice(2);
      n_bits = hdr.readUInt16BE(0);
      n_bytes = Math.ceil(n_bits / 8);
      if (raw.length < n_bytes) {
        err = new Error("MPI said " + n_bytes + " bytes but only got " + raw.length);
      } else {
        a = buffer_to_ui8a(raw.slice(0, n_bytes));
        raw = raw.slice(n_bytes);
        i = nbi();
        i.fromString(a, 256, true);
      }
    }
    return [err, i, raw, n_bytes + 2];
  };

  exports.toMPI = toMPI;

  exports.nbs = nbs;

  exports.mpi_from_buffer = mpi_from_buffer;

  BigInteger.prototype.to_mpi_buffer = function() {
    return toMPI(this);
  };

  BigInteger.prototype.mpi_byte_length = function() {
    return mpi_byte_length(this);
  };

}).call(this);
