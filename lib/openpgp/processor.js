// Generated by IcedCoffeeScript 1.6.3-g
(function() {
  var C, KeyBlock, Message, OPS, armor, bufeq_secure, do_message, iced, import_key_pgp, konst, make_esc, parse, util, __iced_k, __iced_k_noop;

  iced = require('iced-coffee-script/lib/coffee-script/iced').runtime;
  __iced_k = __iced_k_noop = function() {};

  make_esc = require('iced-error').make_esc;

  OPS = require('../keyfetch').OPS;

  konst = require('../const');

  C = konst.openpgp;

  bufeq_secure = require('../util').bufeq_secure;

  parse = require('./parser').parse;

  import_key_pgp = require('../symmetric').import_key_pgp;

  util = require('util');

  armor = require('./armor');

  KeyBlock = (function() {
    function KeyBlock(packets) {
      this.packets = packets;
      this.verified_signatures = [];
      this.subkeys = [];
      this.primary = null;
      this.userids = [];
    }

    KeyBlock.prototype.to_obj = function() {
      return {
        subkeys: this.subkeys,
        primary: this.primary,
        userids: this.userids
      };
    };

    KeyBlock.prototype._extract_keys = function() {
      var err, i, p, _i, _len, _ref;
      err = null;
      if (!this.packets.length) {
        err = new Error("No packets; cannot extract a key");
      } else if (!(this.primary = this.packets[0]).is_primary()) {
        err = new Error("First packet must be the primary key");
      } else {
        _ref = this.packets.slice(1);
        for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
          p = _ref[i];
          if (p.is_key_material() && (err == null)) {
            if (!p.is_primary()) {
              this.subkeys.push(p);
            } else {
              err = new Error("cannot have 2 primary keys");
            }
          }
        }
      }
      return err;
    };

    KeyBlock.prototype._check_keys = function() {
      return this._check_primary() || this._check_subkeys();
    };

    KeyBlock.prototype._check_primary = function() {
      var err;
      return err = !this.primary.is_self_signed() ? new Error("no valid primary key self-signature") : (this.userids = this.primary.get_signed_userids()).length === 0 ? new Error("no valid Userid signed into key") : null;
    };

    KeyBlock.prototype._check_subkeys = function() {
      var err, i, k, subkeys, _i, _len;
      subkeys = this.subkeys;
      err = null;
      this.subkeys = [];
      for (i = _i = 0, _len = subkeys.length; _i < _len; i = ++_i) {
        k = subkeys[i];
        if (err == null) {
          if (k.is_signed_subkey_of(this.primary)) {
            this.subkeys.push(k);
          } else {
            err = new Error("Could not import subkey " + i);
          }
        }
      }
      return err;
    };

    KeyBlock.prototype.process = function(cb) {
      var err, ___iced_passed_deferral, __iced_deferrals, __iced_k,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      err = this._extract_keys();
      (function(__iced_k) {
        if (err == null) {
          (function(__iced_k) {
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              filename: "src/openpgp/processor.iced",
              funcname: "KeyBlock.process"
            });
            _this._verify_sigs(__iced_deferrals.defer({
              assign_fn: (function() {
                return function() {
                  return err = arguments[0];
                };
              })(),
              lineno: 71
            }));
            __iced_deferrals._fulfill();
          })(__iced_k);
        } else {
          return __iced_k();
        }
      })(function() {
        if (err == null) {
          err = _this._check_keys();
        }
        return cb(err);
      });
    };

    KeyBlock.prototype._verify_sigs = function(cb) {
      var data_packets, err, i, p, start, tmp, ___iced_passed_deferral, __iced_deferrals, __iced_k,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      start = 1;
      (function(__iced_k) {
        var _i, _len, _ref, _results, _while;
        _ref = _this.packets;
        _len = _ref.length;
        i = 0;
        _results = [];
        _while = function(__iced_k) {
          var _break, _continue, _next;
          _break = function() {
            return __iced_k(_results);
          };
          _continue = function() {
            return iced.trampoline(function() {
              ++i;
              return _while(__iced_k);
            });
          };
          _next = function(__iced_next_arg) {
            _results.push(__iced_next_arg);
            return _continue();
          };
          if (!(i < _len)) {
            return _break();
          } else {
            p = _ref[i];
            if (i >= start) {
              (function(__iced_k) {
                if (p.is_signature()) {
                  p.key = _this.primary.key;
                  p.primary = _this.primary;
                  data_packets = _this.packets.slice(start, i);
                  (function(__iced_k) {
                    __iced_deferrals = new iced.Deferrals(__iced_k, {
                      parent: ___iced_passed_deferral,
                      filename: "src/openpgp/processor.iced",
                      funcname: "KeyBlock._verify_sigs"
                    });
                    p.verify(data_packets, __iced_deferrals.defer({
                      assign_fn: (function() {
                        return function() {
                          return tmp = arguments[0];
                        };
                      })(),
                      lineno: 85
                    }));
                    __iced_deferrals._fulfill();
                  })(function() {
                    if (typeof tmp !== "undefined" && tmp !== null) {
                      console.log("Error in signature verification: " + (tmp.toString()));
                      err = tmp;
                    } else {
                      _this.verified_signatures.push(p);
                    }
                    return __iced_k(start = i + 1);
                  });
                } else {
                  return __iced_k();
                }
              })(_next);
            } else {
              return _continue();
            }
          }
        };
        _while(__iced_k);
      })(function() {
        return cb(err);
      });
    };

    return KeyBlock;

  })();

  Message = (function() {
    function Message(key_fetch) {
      this.key_fetch = key_fetch;
      this.literals = [];
      this.enc_data_packet = null;
    }

    Message.prototype._get_session_key = function(cb) {
      var enc, err, esk_packets, index, key_ids, obj, p, packet, sesskey, ___iced_passed_deferral, __iced_deferrals, __iced_k,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      key_ids = [];
      esk_packets = [];
      err = null;
      key_ids = (function() {
        var _results;
        _results = [];
        while (this.packets.length && (p = this.packets[0].to_esk_packet())) {
          esk_packets.push(p);
          this.packets.shift();
          _results.push(p.get_key_id());
        }
        return _results;
      }).call(this);
      (function(__iced_k) {
        if (key_ids.length) {
          enc = true;
          (function(__iced_k) {
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              filename: "src/openpgp/processor.iced",
              funcname: "Message._get_session_key"
            });
            _this.key_fetch.fetch(key_ids, [konst.ops.decrypt], __iced_deferrals.defer({
              assign_fn: (function() {
                return function() {
                  err = arguments[0];
                  obj = arguments[1];
                  return index = arguments[2];
                };
              })(),
              lineno: 125
            }));
            __iced_deferrals._fulfill();
          })(function() {
            (function(__iced_k) {
              if (err == null) {
                packet = esk_packets[index];
                (function(__iced_k) {
                  __iced_deferrals = new iced.Deferrals(__iced_k, {
                    parent: ___iced_passed_deferral,
                    filename: "src/openpgp/processor.iced",
                    funcname: "Message._get_session_key"
                  });
                  obj.key.decrypt_and_unpad(packet.ekey, __iced_deferrals.defer({
                    assign_fn: (function() {
                      return function() {
                        err = arguments[0];
                        return sesskey = arguments[1];
                      };
                    })(),
                    lineno: 128
                  }));
                  __iced_deferrals._fulfill();
                })(__iced_k);
              } else {
                return __iced_k();
              }
            })(__iced_k);
          });
        } else {
          return __iced_k(enc = false);
        }
      })(function() {
        return cb(err, enc, sesskey);
      });
    };

    Message.prototype._find_encrypted_data = function(cb) {
      var err, ret;
      err = ret = null;
      if (this.packets.length && (ret = this.packets[0].to_enc_data_packet())) {
        this.packets.pop();
      } else {
        err = new Error("Could not find encrypted data packet");
      }
      return cb(err, ret);
    };

    Message.prototype._decrypt_with_session_key = function(sesskey, edat, cb) {
      var cipher, e, err, ret;
      err = null;
      try {
        cipher = import_key_pgp(sesskey);
        ret = edat.decrypt(cipher);
      } catch (_error) {
        e = _error;
        err = e;
      }
      return cb(err, ret);
    };

    Message.prototype._parse = function(raw, cb) {
      var err, packets, _ref;
      _ref = parse(raw), err = _ref[0], packets = _ref[1];
      return cb(err, packets);
    };

    Message.prototype._decrypt = function(cb) {
      var edat, err, esc, is_enc, packets, plaintext, sesskey, ___iced_passed_deferral, __iced_deferrals, __iced_k,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      err = null;
      esc = make_esc(cb, "Message::decrypt");
      (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: "src/openpgp/processor.iced",
          funcname: "Message._decrypt"
        });
        _this._get_session_key(esc(__iced_deferrals.defer({
          assign_fn: (function() {
            return function() {
              is_enc = arguments[0];
              return sesskey = arguments[1];
            };
          })(),
          lineno: 165
        })));
        __iced_deferrals._fulfill();
      })(function() {
        (function(__iced_k) {
          if (is_enc) {
            (function(__iced_k) {
              __iced_deferrals = new iced.Deferrals(__iced_k, {
                parent: ___iced_passed_deferral,
                filename: "src/openpgp/processor.iced",
                funcname: "Message._decrypt"
              });
              _this._find_encrypted_data(esc(__iced_deferrals.defer({
                assign_fn: (function() {
                  return function() {
                    return edat = arguments[0];
                  };
                })(),
                lineno: 167
              })));
              __iced_deferrals._fulfill();
            })(function() {
              (function(__iced_k) {
                __iced_deferrals = new iced.Deferrals(__iced_k, {
                  parent: ___iced_passed_deferral,
                  filename: "src/openpgp/processor.iced",
                  funcname: "Message._decrypt"
                });
                _this._decrypt_with_session_key(sesskey, edat, esc(__iced_deferrals.defer({
                  assign_fn: (function() {
                    return function() {
                      return plaintext = arguments[0];
                    };
                  })(),
                  lineno: 168
                })));
                __iced_deferrals._fulfill();
              })(function() {
                (function(__iced_k) {
                  __iced_deferrals = new iced.Deferrals(__iced_k, {
                    parent: ___iced_passed_deferral,
                    filename: "src/openpgp/processor.iced",
                    funcname: "Message._decrypt"
                  });
                  _this._parse(plaintext, esc(__iced_deferrals.defer({
                    assign_fn: (function() {
                      return function() {
                        return packets = arguments[0];
                      };
                    })(),
                    lineno: 169
                  })));
                  __iced_deferrals._fulfill();
                })(function() {
                  return __iced_k(_this.packets = packets.concat(_this.packets));
                });
              });
            });
          } else {
            return __iced_k();
          }
        })(function() {
          return cb(err);
        });
      });
    };

    Message.prototype._inflate = function(cb) {
      var esc, inflated, p, packets, ___iced_passed_deferral, __iced_deferrals, __iced_k,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      packets = [];
      esc = make_esc(cb, "Message::_inflate");
      (function(__iced_k) {
        var _i, _len, _ref, _results, _while;
        _ref = _this.packets;
        _len = _ref.length;
        _i = 0;
        _results = [];
        _while = function(__iced_k) {
          var _break, _continue, _next;
          _break = function() {
            return __iced_k(_results);
          };
          _continue = function() {
            return iced.trampoline(function() {
              ++_i;
              return _while(__iced_k);
            });
          };
          _next = function(__iced_next_arg) {
            _results.push(__iced_next_arg);
            return _continue();
          };
          if (!(_i < _len)) {
            return _break();
          } else {
            p = _ref[_i];
            (function(__iced_k) {
              __iced_deferrals = new iced.Deferrals(__iced_k, {
                parent: ___iced_passed_deferral,
                filename: "src/openpgp/processor.iced",
                funcname: "Message._inflate"
              });
              p.inflate(esc(__iced_deferrals.defer({
                assign_fn: (function() {
                  return function() {
                    return inflated = arguments[0];
                  };
                })(),
                lineno: 179
              })));
              __iced_deferrals._fulfill();
            })(function() {
              (function(__iced_k) {
                if (typeof inflated !== "undefined" && inflated !== null) {
                  (function(__iced_k) {
                    __iced_deferrals = new iced.Deferrals(__iced_k, {
                      parent: ___iced_passed_deferral,
                      filename: "src/openpgp/processor.iced",
                      funcname: "Message._inflate"
                    });
                    _this._parse(inflated, esc(__iced_deferrals.defer({
                      assign_fn: (function() {
                        return function() {
                          return p = arguments[0];
                        };
                      })(),
                      lineno: 181
                    })));
                    __iced_deferrals._fulfill();
                  })(function() {
                    return __iced_k(packets.push.apply(packets, p));
                  });
                } else {
                  return __iced_k(packets.push(p));
                }
              })(_next);
            });
          }
        };
        _while(__iced_k);
      })(function() {
        _this.packets = packets;
        return cb(null);
      });
    };

    Message.prototype._frame_signatures = function() {
      var o, p, payload, ret, stack, _i, _j, _len, _len1, _ref;
      ret = [];
      stack = [];
      payload = [];
      _ref = this.packets;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        p = _ref[_i];
        if (p.tag === C.packet_tags.one_pass_sig) {
          stack.push({
            open: p
          });
        } else if (!stack.length) {

        } else if (p.tag === C.packet_tags.signature) {
          o = stack.pop();
          o.close = p;
          ret.push(o);
        } else {
          payload.push(p);
        }
      }
      for (_j = 0, _len1 = ret.length; _j < _len1; _j++) {
        o = ret[_j];
        o.payload = payload;
      }
      return ret;
    };

    Message.prototype._verify_sig = function(sig, cb) {
      var a, b, err, obj, ___iced_passed_deferral, __iced_deferrals, __iced_k,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      err = null;
      if (!bufeq_secure((a = sig.open.key_id), (b = sig.close.get_key_id()))) {
        err = new Error("signature mismatch: " + (a.toString('hex')) + "} != " + (b.toString('hex')));
      }
      (function(__iced_k) {
        if (err == null) {
          (function(__iced_k) {
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              filename: "src/openpgp/processor.iced",
              funcname: "Message._verify_sig"
            });
            _this.key_fetch.fetch([a], [konst.ops.verify], __iced_deferrals.defer({
              assign_fn: (function() {
                return function() {
                  err = arguments[0];
                  return obj = arguments[1];
                };
              })(),
              lineno: 219
            }));
            __iced_deferrals._fulfill();
          })(__iced_k);
        } else {
          return __iced_k();
        }
      })(function() {
        (function(__iced_k) {
          if (err == null) {
            sig.close.key = obj.key;
            sig.close.keyfetch_obj = obj;
            (function(__iced_k) {
              __iced_deferrals = new iced.Deferrals(__iced_k, {
                parent: ___iced_passed_deferral,
                filename: "src/openpgp/processor.iced",
                funcname: "Message._verify_sig"
              });
              sig.close.verify(sig.payload, __iced_deferrals.defer({
                assign_fn: (function() {
                  return function() {
                    return err = arguments[0];
                  };
                })(),
                lineno: 231
              }));
              __iced_deferrals._fulfill();
            })(__iced_k);
          } else {
            return __iced_k();
          }
        })(function() {
          return cb(err);
        });
      });
    };

    Message.prototype._verify = function(cb) {
      var esc, sig, sigs, ___iced_passed_deferral, __iced_deferrals, __iced_k,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      esc = make_esc(cb, "Message::_verify_sigs");
      sigs = this._frame_signatures();
      (function(__iced_k) {
        var _i, _len, _ref, _results, _while;
        _ref = sigs;
        _len = _ref.length;
        _i = 0;
        _results = [];
        _while = function(__iced_k) {
          var _break, _continue, _next;
          _break = function() {
            return __iced_k(_results);
          };
          _continue = function() {
            return iced.trampoline(function() {
              ++_i;
              return _while(__iced_k);
            });
          };
          _next = function(__iced_next_arg) {
            _results.push(__iced_next_arg);
            return _continue();
          };
          if (!(_i < _len)) {
            return _break();
          } else {
            sig = _ref[_i];
            (function(__iced_k) {
              __iced_deferrals = new iced.Deferrals(__iced_k, {
                parent: ___iced_passed_deferral,
                filename: "src/openpgp/processor.iced",
                funcname: "Message._verify"
              });
              _this._verify_sig(sig, esc(__iced_deferrals.defer({
                lineno: 241
              })));
              __iced_deferrals._fulfill();
            })(_next);
          }
        };
        _while(__iced_k);
      })(function() {
        return cb(null);
      });
    };

    Message.prototype.collect_literals = function() {
      var p, _i, _len, _ref, _results;
      _ref = this.packets;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        p = _ref[_i];
        if (p.tag === C.packet_tags.literal) {
          _results.push(p);
        }
      }
      return _results;
    };

    Message.prototype.process = function(packets, cb) {
      var esc, ___iced_passed_deferral, __iced_deferrals, __iced_k,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      this.packets = packets;
      esc = make_esc(cb, "Message:process");
      (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: "src/openpgp/processor.iced",
          funcname: "Message.process"
        });
        _this._decrypt(esc(__iced_deferrals.defer({
          lineno: 254
        })));
        __iced_deferrals._fulfill();
      })(function() {
        (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "src/openpgp/processor.iced",
            funcname: "Message.process"
          });
          _this._inflate(esc(__iced_deferrals.defer({
            lineno: 255
          })));
          __iced_deferrals._fulfill();
        })(function() {
          (function(__iced_k) {
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              filename: "src/openpgp/processor.iced",
              funcname: "Message.process"
            });
            _this._verify(esc(__iced_deferrals.defer({
              lineno: 256
            })));
            __iced_deferrals._fulfill();
          })(function() {
            return cb(null, _this.collect_literals());
          });
        });
      });
    };

    Message.prototype.parse_and_process = function(raw, cb) {
      var err, literals, packets, ___iced_passed_deferral, __iced_deferrals, __iced_k,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: "src/openpgp/processor.iced",
          funcname: "Message.parse_and_process"
        });
        _this._parse(raw, __iced_deferrals.defer({
          assign_fn: (function() {
            return function() {
              err = arguments[0];
              return packets = arguments[1];
            };
          })(),
          lineno: 262
        }));
        __iced_deferrals._fulfill();
      })(function() {
        (function(__iced_k) {
          if (typeof err === "undefined" || err === null) {
            (function(__iced_k) {
              __iced_deferrals = new iced.Deferrals(__iced_k, {
                parent: ___iced_passed_deferral,
                filename: "src/openpgp/processor.iced",
                funcname: "Message.parse_and_process"
              });
              _this.process(packets, __iced_deferrals.defer({
                assign_fn: (function() {
                  return function() {
                    err = arguments[0];
                    return literals = arguments[1];
                  };
                })(),
                lineno: 263
              }));
              __iced_deferrals._fulfill();
            })(__iced_k);
          } else {
            return __iced_k();
          }
        })(function() {
          return cb(err, literals);
        });
      });
    };

    return Message;

  })();

  exports.KeyBlock = KeyBlock;

  exports.Message = Message;

  exports.do_message = do_message = function(_arg, cb) {
    var armored, err, keyfetch, literals, msg, proc, ___iced_passed_deferral, __iced_deferrals, __iced_k, _ref,
      _this = this;
    __iced_k = __iced_k_noop;
    ___iced_passed_deferral = iced.findDeferral(arguments);
    armored = _arg.armored, keyfetch = _arg.keyfetch;
    _ref = armor.decode(armored), err = _ref[0], msg = _ref[1];
    literals = null;
    if ((err == null) && (msg.type !== C.message_types.generic)) {
      err = new Error("Needed a 'generic' PGP message, but got something else");
    }
    (function(__iced_k) {
      if (err == null) {
        proc = new Message(keyfetch);
        (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "src/openpgp/processor.iced",
            funcname: "do_message"
          });
          proc.parse_and_process(msg.body, __iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                err = arguments[0];
                return literals = arguments[1];
              };
            })(),
            lineno: 292
          }));
          __iced_deferrals._fulfill();
        })(__iced_k);
      } else {
        return __iced_k();
      }
    })(function() {
      return cb(err, literals);
    });
  };

}).call(this);
