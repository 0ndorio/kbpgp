// Generated by IcedCoffeeScript 1.6.3-g
(function() {
  var KeyBlock, iced, __iced_k, __iced_k_noop;

  iced = require('iced-coffee-script/lib/coffee-script/iced').runtime;
  __iced_k = __iced_k_noop = function() {};

  KeyBlock = (function() {
    function KeyBlock(packets) {
      this.packets = packets;
      this.verified_signatures = [];
      this.subkeys = [];
      this.primary = null;
      this.userid = null;
    }

    KeyBlock.prototype.to_obj = function() {
      return {
        subkeys: this.subkeys,
        primary: this.primary,
        userid: this.userid
      };
    };

    KeyBlock.prototype._extract_keys = function() {
      var err, i, p, _i, _len, _ref;
      err = null;
      _ref = this.packets;
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        p = _ref[i];
        if (p.is_key_material() && (err == null)) {
          if (!p.is_primary()) {
            this.subkeys.push(p);
          } else if (this.primary != null) {
            err = new Error("cannot have 2 primary keys");
          } else {
            this.primary = p;
          }
        }
      }
      if (this.primary == null) {
        err = new Error("No primary key found in keyblock");
      }
      return err;
    };

    KeyBlock.prototype._check_keys = function() {
      return this._check_primary() || this._check_subkeys();
    };

    KeyBlock.prototype._check_primary = function() {
      var err, _ref;
      return err = !((_ref = this.primary.self_sig) != null ? _ref.type : void 0) ? new Error("no valid primary key self-signature") : (this.userid = this.primary.self_sig.userid) == null ? new Error("no valid Userid signed into key") : null;
    };

    KeyBlock.prototype._check_subkeys = function() {
      var err, i, k, subkeys, _i, _len;
      subkeys = this.subkeys;
      err = null;
      this.subkeys = [];
      for (i = _i = 0, _len = subkeys.length; _i < _len; i = ++_i) {
        k = subkeys[i];
        if (err == null) {
          if (k.is_signed_subkey_of(this.primary)) {
            this.subkeys.push(k);
          } else {
            err = new Error("Could not import subkey " + i);
          }
        }
      }
      return err;
    };

    KeyBlock.prototype.process = function(cb) {
      var err, ___iced_passed_deferral, __iced_deferrals, __iced_k,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      err = this._extract_keys();
      (function(__iced_k) {
        if (err == null) {
          (function(__iced_k) {
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              filename: "src/openpgp/processor.iced",
              funcname: "KeyBlock.process"
            });
            _this._verify_sigs(__iced_deferrals.defer({
              assign_fn: (function() {
                return function() {
                  return err = arguments[0];
                };
              })(),
              lineno: 59
            }));
            __iced_deferrals._fulfill();
          })(__iced_k);
        } else {
          return __iced_k();
        }
      })(function() {
        if (err == null) {
          err = _this._check_keys();
        }
        return cb(err);
      });
    };

    KeyBlock.prototype._verify_sigs = function(cb) {
      var data_packets, err, i, p, start, tmp, ___iced_passed_deferral, __iced_deferrals, __iced_k,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      start = 0;
      (function(__iced_k) {
        var _i, _len, _ref, _results, _while;
        _ref = _this.packets;
        _len = _ref.length;
        i = 0;
        _results = [];
        _while = function(__iced_k) {
          var _break, _continue, _next;
          _break = function() {
            return __iced_k(_results);
          };
          _continue = function() {
            return iced.trampoline(function() {
              ++i;
              return _while(__iced_k);
            });
          };
          _next = function(__iced_next_arg) {
            _results.push(__iced_next_arg);
            return _continue();
          };
          if (!(i < _len)) {
            return _break();
          } else {
            p = _ref[i];
            (function(__iced_k) {
              if (p.is_signature()) {
                p.key = _this.primary.key;
                p.primary = _this.primary;
                data_packets = _this.packets.slice(start, i);
                (function(__iced_k) {
                  __iced_deferrals = new iced.Deferrals(__iced_k, {
                    parent: ___iced_passed_deferral,
                    filename: "src/openpgp/processor.iced",
                    funcname: "KeyBlock._verify_sigs"
                  });
                  p.verify(data_packets, __iced_deferrals.defer({
                    assign_fn: (function() {
                      return function() {
                        return tmp = arguments[0];
                      };
                    })(),
                    lineno: 72
                  }));
                  __iced_deferrals._fulfill();
                })(function() {
                  if (typeof tmp !== "undefined" && tmp !== null) {
                    console.log("Error in signature verification: " + (tmp.toString()));
                    err = tmp;
                  } else {
                    _this.verified_signatures.push(p);
                  }
                  return __iced_k(start = i + 1);
                });
              } else {
                return __iced_k();
              }
            })(_next);
          }
        };
        _while(__iced_k);
      })(function() {
        return cb(err);
      });
    };

    return KeyBlock;

  })();

  exports.KeyBlock = KeyBlock;

}).call(this);
