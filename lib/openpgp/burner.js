// Generated by IcedCoffeeScript 1.6.3-g
(function() {
  var Burner, C, CreationTime, Issuer, OnePassSignature, SHA512, SRF, Signature, export_key_pgp, get_cipher, iced, make_esc, scrub_buffer, triplesec, unix_time, __iced_k, __iced_k_noop, _ref, _ref1;

  iced = require('iced-coffee-script/lib/coffee-script/iced').runtime;
  __iced_k = __iced_k_noop = function() {};

  make_esc = require('iced-error').make_esc;

  OnePassSignature = require('./packet/one_pass_sig').OnePassSignature;

  _ref = require('./packet/signature'), Signature = _ref.Signature, CreationTime = _ref.CreationTime, Issuer = _ref.Issuer;

  unix_time = require('../util').unix_time;

  SRF = require('../rand').SRF;

  triplesec = require('triplesec');

  _ref1 = require('../symmetric'), export_key_pgp = _ref1.export_key_pgp, get_cipher = _ref1.get_cipher;

  scrub_buffer = triplesec.util.scrub_buffer;

  C = require('../const').openpgp;

  SHA512 = require('../hash').SHA512;

  Burner = (function() {
    function Burner(_arg) {
      this.literals = _arg.literals, this.signing_key = _arg.signing_key, this.encryption_key = _arg.encryption_key;
      this.packets = [];
    }

    Burner.prototype._frame_literals = function(cb) {
      var esc, l, p, ___iced_passed_deferral, __iced_deferrals, __iced_k,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      esc = make_esc(cb, "Burner::_frame_literals");
      (function(__iced_k) {
        var _i, _len, _ref2, _results, _while;
        _ref2 = _this.literals;
        _len = _ref2.length;
        _i = 0;
        _results = [];
        _while = function(__iced_k) {
          var _break, _continue, _next;
          _break = function() {
            return __iced_k(_results);
          };
          _continue = function() {
            return iced.trampoline(function() {
              ++_i;
              return _while(__iced_k);
            });
          };
          _next = function(__iced_next_arg) {
            _results.push(__iced_next_arg);
            return _continue();
          };
          if (!(_i < _len)) {
            return _break();
          } else {
            l = _ref2[_i];
            (function(__iced_k) {
              __iced_deferrals = new iced.Deferrals(__iced_k, {
                parent: ___iced_passed_deferral,
                filename: "src/openpgp/burner.iced",
                funcname: "Burner._frame_literals"
              });
              l.write(esc(__iced_deferrals.defer({
                assign_fn: (function() {
                  return function() {
                    return p = arguments[0];
                  };
                })(),
                lineno: 34
              })));
              __iced_deferrals._fulfill();
            })(function() {
              return _next(_this.packets.push(p));
            });
          }
        };
        _while(__iced_k);
      })(function() {
        return cb(null);
      });
    };

    Burner.prototype._sign = function(cb) {
      var err, esc, fp, ops, ops_framed, sig, ___iced_passed_deferral, __iced_deferrals, __iced_k,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      esc = make_esc(cb, "Burner::_sign'");
      ops = new OnePassSignature({
        sig_type: C.sig_types.binary_doc,
        hasher: SHA512,
        sig_klass: this.signing_key.get_klass(),
        key_id: this.signing_key.get_key_id(),
        is_final: 1
      });
      (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: "src/openpgp/burner.iced",
          funcname: "Burner._sign"
        });
        ops.write(esc(__iced_deferrals.defer({
          assign_fn: (function() {
            return function() {
              return ops_framed = arguments[0];
            };
          })(),
          lineno: 49
        })));
        __iced_deferrals._fulfill();
      })(function() {
        sig = new Signature({
          type: C.sig_types.binary_doc,
          key: _this.signing_key,
          hashed_subpackets: [new CreationTime(unix_time())],
          unhashed_subpackets: [new Issuer(_this.signing_key.get_key_id())]
        });
        (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "src/openpgp/burner.iced",
            funcname: "Burner._sign"
          });
          sig.write(_this.packets, __iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                err = arguments[0];
                return fp = arguments[1];
              };
            })(),
            lineno: 56
          }));
          __iced_deferrals._fulfill();
        })(function() {
          if (typeof err === "undefined" || err === null) {
            _this.packets.unshift(ops_framed);
            _this.packets.push(fp);
          }
          return cb(err);
        });
      });
    };

    Burner.prototype.collect_packets = function() {
      var ret;
      ret = Buffer.concat(this.packets);
      this.packets = [];
      return ret;
    };

    Burner.prototype._compress = function(cb) {
      var err, inflated, opkt, pkt, ___iced_passed_deferral, __iced_deferrals, __iced_k,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      inflated = this.collect_packets();
      pkt = new Compressed({
        algo: C.compression.zlib,
        inflated: inflated
      });
      (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: "src/openpgp/burner.iced",
          funcname: "Burner._compress"
        });
        pkt.write(__iced_deferrals.defer({
          assign_fn: (function() {
            return function() {
              err = arguments[0];
              return opkt = arguments[1];
            };
          })(),
          lineno: 74
        }));
        __iced_deferrals._fulfill();
      })(function() {
        if (typeof err === "undefined" || err === null) {
          _this.packets.push(opkt);
        }
        return cb(err);
      });
    };

    Burner.prototype._make_session_key = function(cb) {
      var ___iced_passed_deferral, __iced_deferrals, __iced_k,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      this._cipher_algo = C.symmetric_key_algorithms.AES256;
      this._cipher_info = get_cipher(this._cipher_algo);
      (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: "src/openpgp/burner.iced",
          funcname: "Burner._make_session_key"
        });
        SRF().random_bytes(_this._cipher_info.key_size >> 3, __iced_deferrals.defer({
          assign_fn: (function(__slot_1) {
            return function() {
              return __slot_1._session_key = arguments[0];
            };
          })(_this),
          lineno: 84
        }));
        __iced_deferrals._fulfill();
      })(function() {
        _this._cipher = new _this._cipher_info.klass(WordArray.from_buffer(_this._session_key));
        return cb(null);
      });
    };

    Burner.prototype.scrub = function() {
      if (this._cipher != null) {
        this._cipher.scrub();
      }
      if (this._session_key != null) {
        return scrub_buffer(this._session_key);
      }
    };

    Burner.prototype._encrypt_session_key = function(cb) {
      var ekey, err, k, payload, pkt, y, ___iced_passed_deferral, __iced_deferrals, __iced_k,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      payload = export_key_pgp(this._cipher_algo, this._session_key);
      k = this.encrypt_key.key;
      (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: "src/openpgp/burner.iced",
          funcname: "Burner._encrypt_session_key"
        });
        k.pad_and_encrypt(payload, __iced_deferrals.defer({
          assign_fn: (function() {
            return function() {
              err = arguments[0];
              return y = arguments[1];
            };
          })(),
          lineno: 99
        }));
        __iced_deferrals._fulfill();
      })(function() {
        (function(__iced_k) {
          if (typeof err === "undefined" || err === null) {
            ekey = k.export_output(y);
            pkt = new PKSESK({
              crypto_type: k.type,
              key_id: _this.encrypt_key.get_key_id(),
              ekey: {
                y: y
              }
            });
            (function(__iced_k) {
              __iced_deferrals = new iced.Deferrals(__iced_k, {
                parent: ___iced_passed_deferral,
                filename: "src/openpgp/burner.iced",
                funcname: "Burner._encrypt_session_key"
              });
              pkt.write(__iced_deferrals.defer({
                assign_fn: (function(__slot_1) {
                  return function() {
                    err = arguments[0];
                    return __slot_1._pkesk = arguments[1];
                  };
                })(_this),
                lineno: 107
              }));
              __iced_deferrals._fulfill();
            })(__iced_k);
          } else {
            return __iced_k();
          }
        })(function() {
          return cb(err);
        });
      });
    };

    Burner.prototype._encrypt_payload = function(cb) {
      var esc, pkt, plaintext, prefixrandom, ___iced_passed_deferral, __iced_deferrals, __iced_k,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      esc = make_esc(cb, "Burner::_encrypt_payload");
      plaintext = this.collect_packets();
      (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: "src/openpgp/burner.iced",
          funcname: "Burner._encrypt_payload"
        });
        SRF().random_bytes(_this._cipher.blockSize, __iced_deferrals.defer({
          assign_fn: (function() {
            return function() {
              return prefixrandom = arguments[0];
            };
          })(),
          lineno: 115
        }));
        __iced_deferrals._fulfill();
      })(function() {
        pkt = new SEPID({});
        (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "src/openpgp/burner.iced",
            funcname: "Burner._encrypt_payload"
          });
          pkt.encrypt({
            cipher: _this._cipher,
            plaintext: plaintext,
            prefixrandom: prefixrandom
          }, esc(__iced_deferrals.defer({
            lineno: 117
          })));
          __iced_deferrals._fulfill();
        })(function() {
          (function(__iced_k) {
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              filename: "src/openpgp/burner.iced",
              funcname: "Burner._encrypt_payload"
            });
            pkt.write(esc(__iced_deferrals.defer({
              assign_fn: (function() {
                return function() {
                  return pkt = arguments[0];
                };
              })(),
              lineno: 118
            })));
            __iced_deferrals._fulfill();
          })(function() {
            scrub_buffer(plaintext);
            _this.packets = [_this._pkesk, pkt];
            return cb(null);
          });
        });
      });
    };

    Burner.prototype._encrypt = function(cb) {
      var esc, ___iced_passed_deferral, __iced_deferrals, __iced_k,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      esc = make_esc(cb, "Burner::_encrypt");
      (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: "src/openpgp/burner.iced",
          funcname: "Burner._encrypt"
        });
        _this._make_session_key(esc(__iced_deferrals.defer({
          lineno: 127
        })));
        __iced_deferrals._fulfill();
      })(function() {
        (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "src/openpgp/burner.iced",
            funcname: "Burner._encrypt"
          });
          _this._encrypt_session_key(esc(__iced_deferrals.defer({
            lineno: 128
          })));
          __iced_deferrals._fulfill();
        })(function() {
          (function(__iced_k) {
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              filename: "src/openpgp/burner.iced",
              funcname: "Burner._encrypt"
            });
            _this._encrypt_payload(esc(__iced_deferrals.defer({
              lineno: 129
            })));
            __iced_deferrals._fulfill();
          })(function() {
            return cb(null);
          });
        });
      });
    };

    Burner.prototype.scrub = function() {};

    Burner.prototype.burn = function(cb) {
      var esc, output, ___iced_passed_deferral, __iced_deferrals, __iced_k,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      esc = make_esc(cb, "Burner::burn");
      (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: "src/openpgp/burner.iced",
          funcname: "Burner.burn"
        });
        _this._frame_literals(esc(__iced_deferrals.defer({
          lineno: 140
        })));
        __iced_deferrals._fulfill();
      })(function() {
        (function(__iced_k) {
          if (_this.signing_key) {
            (function(__iced_k) {
              __iced_deferrals = new iced.Deferrals(__iced_k, {
                parent: ___iced_passed_deferral,
                filename: "src/openpgp/burner.iced",
                funcname: "Burner.burn"
              });
              _this._sign(esc(__iced_deferrals.defer({
                lineno: 142
              })));
              __iced_deferrals._fulfill();
            })(__iced_k);
          } else {
            return __iced_k();
          }
        })(function() {
          (function(__iced_k) {
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              filename: "src/openpgp/burner.iced",
              funcname: "Burner.burn"
            });
            _this._compress(esc(__iced_deferrals.defer({
              lineno: 143
            })));
            __iced_deferrals._fulfill();
          })(function() {
            (function(__iced_k) {
              if (_this.encrypt_key) {
                (function(__iced_k) {
                  __iced_deferrals = new iced.Deferrals(__iced_k, {
                    parent: ___iced_passed_deferral,
                    filename: "src/openpgp/burner.iced",
                    funcname: "Burner.burn"
                  });
                  _this._encrypt(esc(__iced_deferrals.defer({
                    lineno: 145
                  })));
                  __iced_deferrals._fulfill();
                })(__iced_k);
              } else {
                return __iced_k();
              }
            })(function() {
              output = Buffer.concat(_this.packets);
              return cb(null, output);
            });
          });
        });
      });
    };

    return Burner;

  })();

  exports.Burner = Burner;

  exports.burn = function(_arg, cb) {
    var b, encryption_key, err, literals, out, signing_key, ___iced_passed_deferral, __iced_deferrals, __iced_k,
      _this = this;
    __iced_k = __iced_k_noop;
    ___iced_passed_deferral = iced.findDeferral(arguments);
    literals = _arg.literals, signing_key = _arg.signing_key, encryption_key = _arg.encryption_key;
    b = new Burner({
      literals: literals,
      signing_key: signing_key,
      encryption_key: encryption_key
    });
    (function(__iced_k) {
      __iced_deferrals = new iced.Deferrals(__iced_k, {
        parent: ___iced_passed_deferral,
        filename: "src/openpgp/burner.iced",
        funcname: "burn"
      });
      b.burn(__iced_deferrals.defer({
        assign_fn: (function() {
          return function() {
            err = arguments[0];
            return out = arguments[1];
          };
        })(),
        lineno: 157
      }));
      __iced_deferrals._fulfill();
    })(function() {
      b.scrub();
      return cb(err, out);
    });
  };

}).call(this);
