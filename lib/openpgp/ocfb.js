// Generated by IcedCoffeeScript 1.7.1-c
(function() {
  var AES, Base, Decryptor, Encryptor, Encryptor0, SlicerBuffer, WordArray, decrypt, encrypt, encrypt0, iced, make_esc, repeat, rng, test, triplesec, xbt, xxd, __iced_k, __iced_k_noop,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  iced = require('iced-runtime').iced;
  __iced_k = __iced_k_noop = function() {};

  WordArray = require('triplesec').WordArray;

  SlicerBuffer = require('./buffer').SlicerBuffer;

  triplesec = require('triplesec');

  AES = triplesec.ciphers.AES;

  xbt = require('../xbt');

  make_esc = require('iced-error').make_esc;

  xxd = require('../util').xxd;

  repeat = function(b, n) {
    return Buffer.concat([b, b.slice(b.length - n)]);
  };

  Base = (function(_super) {
    __extends(Base, _super);

    function Base(_arg) {
      var block_size, key;
      this.block_cipher_class = _arg.block_cipher_class, key = _arg.key, this.cipher = _arg.cipher, this.resync = _arg.resync;
      this.block_cipher_class || (this.block_cipher_class = AES);
      this.cipher || (this.cipher = new this.block_cipher_class(WordArray.from_buffer(key)));
      block_size = this.cipher.blockSize;
      this.out_bufs = [];
      this.bytes_flushed = 0;
      Base.__super__.constructor.call(this, block_size);
    }

    Base.prototype.compact = function() {
      var b;
      b = Buffer.concat(this.out_bufs);
      this.out_bufs = [b];
      return b;
    };

    Base.prototype._flush = function() {
      var out;
      out = Buffer.concat(this.out_bufs);
      this.out_bufs = [];
      this.bytes_flushed += out.length;
      return out;
    };

    return Base;

  })(xbt.InBlocker);

  Encryptor = (function(_super) {
    __extends(Encryptor, _super);

    function Encryptor(_arg) {
      var block_cipher_class, cipher, key, prefixrandom, resync;
      block_cipher_class = _arg.block_cipher_class, key = _arg.key, cipher = _arg.cipher, prefixrandom = _arg.prefixrandom, resync = _arg.resync;
      Encryptor.__super__.constructor.call(this, {
        block_cipher_class: block_cipher_class,
        key: key,
        cipher: cipher,
        resync: resync
      });
      this._init_iv(prefixrandom);
      this._first = true;
    }

    Encryptor.prototype._enc = function() {
      this.FRE = WordArray.from_buffer(this.FR);
      return this.cipher.encryptBlock(this.FRE.words, 0);
    };

    Encryptor.prototype._emit_buf = function(buf) {
      var wa;
      wa = WordArray.from_buffer(buf.slice(0, this.block_size));
      wa.xor(this.FRE, {
        n_words: Math.min(wa.words.length, this.FRE.words.length)
      });
      buf = wa.to_buffer();
      this.out_bufs.push(buf);
      return this.FR = new Buffer(buf);
    };

    Encryptor.prototype._init_iv = function(prefixrandom) {
      var b, canary, ct, i, offset;
      this.FR = new Buffer((function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 0, _ref = this.block_size; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(0);
        }
        return _results;
      }).call(this));
      prefixrandom = repeat(prefixrandom, 2);
      this._enc();
      this._emit_buf(prefixrandom);
      this._enc();
      b = this.FRE.to_buffer();
      canary = new Buffer((function() {
        var _i, _results;
        _results = [];
        for (i = _i = 0; _i < 2; i = ++_i) {
          _results.push(b.readUInt8(i) ^ prefixrandom.readUInt8(this.block_size + i));
        }
        return _results;
      }).call(this));
      this.out_bufs.push(canary);
      offset = this.resync ? 2 : 0;
      ct = this.compact();
      ct.copy(this.FR, 0, offset, offset + this.block_size);
      return this._enc();
    };

    Encryptor.prototype._v_init = function(cb) {
      if (!this.resync) {
        this._push_data(new Buffer([0, 0]));
      }
      return cb(null, null);
    };

    Encryptor.prototype._pad = function(_arg) {
      var a, b, data, eof, err;
      data = _arg.data, eof = _arg.eof;
      err = null;
      if ((a = data.length) > (b = this.block_size)) {
        err = new Error("Got overgrown data block; this should never happen: " + a + " > " + b);
      } else if (a === b) {

      } else if (!eof) {
        err = new Error("blocking error; got a block of size " + a + " != " + b + " midstream");
      } else {
        data = Buffer.concat([
          data, new Buffer((function() {
            var _i, _ref, _results;
            _results = [];
            for (_i = 0, _ref = b - a; 0 <= _ref ? _i < _ref : _i > _ref; 0 <= _ref ? _i++ : _i--) {
              _results.push(0);
            }
            return _results;
          })())
        ]);
      }
      return [err, data];
    };

    Encryptor.prototype._v_inblock_chunk = function(_arg, cb) {
      var data, eof, err, out, _ref, _ref1;
      data = _arg.data, eof = _arg.eof;
      out = null;
      _ref = this._pad({
        data: data,
        eof: eof
      }), err = _ref[0], data = _ref[1];
      if (err == null) {
        if (this._first) {
          this._first = false;
          this._do_first(data);
          data = null;
        }
        if (data != null ? data.length : void 0) {
          this._do_block(data);
        }
        _ref1 = this._flush_and_trunc(eof), err = _ref1[0], out = _ref1[1];
      }
      return cb(err, out);
    };

    Encryptor.prototype._do_first = function(data, cb) {
      var buf, ct, wa;
      if (this.resync) {
        return this._emit_buf(data);
      } else {
        wa = WordArray.from_buffer(data);
        wa.xor(this.FRE, {});
        buf = wa.to_buffer().slice(2);
        this.out_bufs.push(buf);
        ct = this.compact();
        return ct.copy(this.FR, 0, ct.length - this.block_size, ct.length);
      }
    };

    Encryptor.prototype._do_block = function(data, cb) {
      this._enc();
      return this._emit_buf(data);
    };

    Encryptor.prototype._flush_and_trunc = function(eof) {
      var err, n_wanted, out, overage;
      out = this._flush();
      err = null;
      if (eof) {
        n_wanted = this._input_len + this.block_size + 2;
        if ((overage = this.bytes_flushed - n_wanted) < 0) {
          err = new Error("Internal error: flushed " + this.bytes_flushed + " but needed " + n_wanted);
        } else if (overage > out.length) {
          err = new Error("Internal error: we had " + overage + " overage bytes, but only had " + out.length + " to trim");
        } else if (overage !== 0) {
          out = out.slice(0, -overage);
        }
      }
      return [err, out];
    };

    return Encryptor;

  })(Base);

  Decryptor = (function(_super) {
    __extends(Decryptor, _super);

    function Decryptor(_arg) {
      var block_cipher_class, cipher, key, prefixrandom, resync;
      block_cipher_class = _arg.block_cipher_class, key = _arg.key, cipher = _arg.cipher, prefixrandom = _arg.prefixrandom, resync = _arg.resync, this.ciphertext = _arg.ciphertext;
      Decryptor.__super__.constructor.call(this, {
        block_cipher_class: block_cipher_class,
        key: key,
        cipher: cipher,
        resync: resync
      });
      this._init();
    }

    Decryptor.prototype._init = function() {
      return this.reset();
    };

    Decryptor.prototype.reset = function() {
      return this.sb = new SlicerBuffer(this.ciphertext);
    };

    Decryptor.prototype.next_block = function() {
      return WordArray.from_buffer(this.sb.read_buffer_at_most(this.block_size));
    };

    Decryptor.prototype.get_prefix = function() {
      return this._prefix;
    };

    Decryptor.prototype.check = function() {
      var ablock, i, iblock, lhs, rhs;
      this.reset();
      iblock = new WordArray((function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 0, _ref = this.block_size / 4; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(0);
        }
        return _results;
      }).call(this));
      this.cipher.encryptBlock(iblock.words, 0);
      ablock = this.next_block();
      iblock.xor(ablock, {});
      this._prefix = iblock.to_buffer();
      this.cipher.encryptBlock(ablock.words, 0);
      lhs = iblock.words.slice(-1)[0] & 0xffff;
      rhs = (ablock.words[0] >>> 16) ^ (this.sb.peek_uint16());
      if (lhs === rhs) {
        return null;
      } else {
        return new Error("Canary block mismatch: " + lhs + " != " + rhs);
      }
    };

    Decryptor.prototype.dec = function() {
      var ablock, iblock, out;
      this.reset();
      if (this.resync) {
        this.sb.advance(2);
      }
      iblock = this.next_block();
      while (this.sb.rem()) {
        ablock = iblock;
        this.cipher.encryptBlock(ablock.words, 0);
        iblock = this.next_block();
        ablock.xor(iblock, {});
        this.out_bufs.push(ablock.to_buffer().slice(0, iblock.sigBytes));
      }
      out = this.compact();
      if (!this.resync) {
        out = out.slice(2);
      }
      return out;
    };

    return Decryptor;

  })(Base);

  Encryptor0 = (function(_super) {
    __extends(Encryptor0, _super);

    function Encryptor0(_arg) {
      var block_cipher_class, cipher, key, prefixrandom, resync;
      block_cipher_class = _arg.block_cipher_class, key = _arg.key, cipher = _arg.cipher, prefixrandom = _arg.prefixrandom, resync = _arg.resync;
      Encryptor0.__super__.constructor.call(this, {
        block_cipher_class: block_cipher_class,
        key: key,
        cipher: cipher,
        resync: resync
      });
      this._init(prefixrandom);
    }

    Encryptor0.prototype._enc = function() {
      this.FRE = WordArray.from_buffer(this.FR);
      return this.cipher.encryptBlock(this.FRE.words, 0);
    };

    Encryptor0.prototype._emit_sb = function(sb) {
      var buf, deficit, i, pad;
      buf = (deficit = this.block_size - sb.rem()) > 0 ? (pad = new Buffer((function() {
        var _i, _results;
        _results = [];
        for (i = _i = 0; 0 <= deficit ? _i < deficit : _i > deficit; i = 0 <= deficit ? ++_i : --_i) {
          _results.push(0);
        }
        return _results;
      })()), Buffer.concat([sb.consume_rest_to_buffer(), pad])) : sb.read_buffer(this.block_size);
      return this._emit_buf(buf);
    };

    Encryptor0.prototype._emit_buf = function(buf) {
      var wa;
      wa = WordArray.from_buffer(buf.slice(0, this.block_size));
      wa.xor(this.FRE, {
        n_words: Math.min(wa.words.length, this.FRE.words.length)
      });
      buf = wa.to_buffer();
      this.out_bufs.push(buf);
      return this.FR = new Buffer(buf);
    };

    Encryptor0.prototype._init = function(prefixrandom) {
      var b, canary, ct, i, offset;
      this.FR = new Buffer((function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 0, _ref = this.block_size; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(0);
        }
        return _results;
      }).call(this));
      prefixrandom = repeat(prefixrandom, 2);
      this._enc();
      this._emit_buf(prefixrandom);
      this._enc();
      b = this.FRE.to_buffer();
      canary = new Buffer((function() {
        var _i, _results;
        _results = [];
        for (i = _i = 0; _i < 2; i = ++_i) {
          _results.push(b.readUInt8(i) ^ prefixrandom.readUInt8(this.block_size + i));
        }
        return _results;
      }).call(this));
      this.out_bufs.push(canary);
      offset = this.resync ? 2 : 0;
      ct = this.compact();
      ct.copy(this.FR, 0, offset, offset + this.block_size);
      return this._enc();
    };

    Encryptor0.prototype.enc = function(plaintext) {
      var buf, ct, n_wanted, ret, sb, wa;
      sb = new SlicerBuffer(plaintext);
      if (this.resync) {
        this._emit_sb(sb);
      } else {
        buf = Buffer.concat([new Buffer([0, 0]), sb.read_buffer(this.block_size - 2)]);
        wa = WordArray.from_buffer(buf);
        wa.xor(this.FRE, {});
        buf = wa.to_buffer().slice(2);
        this.out_bufs.push(buf);
        ct = this.compact();
        ct.copy(this.FR, 0, ct.length - this.block_size, ct.length);
      }
      while (sb.rem()) {
        this._enc();
        this._emit_sb(sb);
      }
      ret = this.compact();
      n_wanted = plaintext.length + this.block_size + 2;
      return ret.slice(0, n_wanted);
    };

    return Encryptor0;

  })(Base);

  encrypt0 = function(_arg) {
    var block_cipher_class, cipher, eng, key, plaintext, prefixrandom, resync;
    block_cipher_class = _arg.block_cipher_class, key = _arg.key, cipher = _arg.cipher, prefixrandom = _arg.prefixrandom, resync = _arg.resync, plaintext = _arg.plaintext;
    eng = new Encryptor0({
      block_cipher_class: block_cipher_class,
      key: key,
      cipher: cipher,
      prefixrandom: prefixrandom,
      resync: resync
    });
    return eng.enc(plaintext);
  };

  encrypt = function(_arg, cb) {
    var block_cipher_class, cipher, eng, err, key, out, plaintext, prefixrandom, resync, ___iced_passed_deferral, __iced_deferrals, __iced_k;
    __iced_k = __iced_k_noop;
    ___iced_passed_deferral = iced.findDeferral(arguments);
    block_cipher_class = _arg.block_cipher_class, key = _arg.key, cipher = _arg.cipher, prefixrandom = _arg.prefixrandom, resync = _arg.resync, plaintext = _arg.plaintext;
    eng = new Encryptor({
      block_cipher_class: block_cipher_class,
      key: key,
      cipher: cipher,
      prefixrandom: prefixrandom,
      resync: resync
    });
    (function(_this) {
      return (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: "/Users/max/src/keybase/kbpgp/src/openpgp/ocfb.iced"
        });
        eng.chunk({
          data: plaintext,
          eof: true
        }, __iced_deferrals.defer({
          assign_fn: (function() {
            return function() {
              err = arguments[0];
              return out = arguments[1];
            };
          })(),
          lineno: 393
        }));
        __iced_deferrals._fulfill();
      });
    })(this)((function(_this) {
      return function() {
        return cb(err, out);
      };
    })(this));
  };

  decrypt = function(_arg) {
    var block_cipher_class, cipher, ciphertext, eng, err, key, resync;
    block_cipher_class = _arg.block_cipher_class, key = _arg.key, cipher = _arg.cipher, resync = _arg.resync, ciphertext = _arg.ciphertext;
    eng = new Decryptor({
      block_cipher_class: block_cipher_class,
      key: key,
      cipher: cipher,
      resync: resync,
      ciphertext: ciphertext
    });
    err = eng.check();
    if (err != null) {
      throw err;
    }
    return eng.dec();
  };

  exports.encrypt = encrypt;

  exports.decrypt = decrypt;

  exports.Decryptor = Decryptor;

  exports.Encryptor = Encryptor;

  rng = require('crypto').rng;

  test = function() {
    var block_cipher_class, ct, ct2, eng, err, i, key, out, outbufs, plaintext, prefixrandom, pt, ___iced_passed_deferral, __iced_deferrals, __iced_k, _begin, _end, _positive;
    __iced_k = __iced_k_noop;
    ___iced_passed_deferral = iced.findDeferral(arguments);
    plaintext = new Buffer("a man a plan a canal panama. and you know the rest");
    plaintext = Buffer.concat((function() {
      var _i, _results;
      _results = [];
      for (_i = 0; _i <= 48; _i++) {
        _results.push(plaintext);
      }
      return _results;
    })());
    key = rng(32);
    prefixrandom = new Buffer([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]);
    block_cipher_class = AES;
    (function(_this) {
      return (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: "/Users/max/src/keybase/kbpgp/src/openpgp/ocfb.iced"
        });
        encrypt({
          block_cipher_class: block_cipher_class,
          key: key,
          prefixrandom: prefixrandom,
          plaintext: plaintext
        }, __iced_deferrals.defer({
          assign_fn: (function() {
            return function() {
              err = arguments[0];
              return ct = arguments[1];
            };
          })(),
          lineno: 420
        }));
        __iced_deferrals._fulfill();
      });
    })(this)((function(_this) {
      return function() {
        eng = new Encryptor({
          block_cipher_class: block_cipher_class,
          key: key,
          prefixrandom: prefixrandom
        });
        outbufs = [];
        (function(__iced_k) {
          var _i, _results, _while;
          i = 0;
          _begin = 0;
          _end = plaintext.length;
          _positive = _end > _begin;
          _results = [];
          _while = function(__iced_k) {
            var _break, _continue, _next;
            _break = function() {
              return __iced_k(_results);
            };
            _continue = function() {
              return iced.trampoline(function() {
                if (_positive) {
                  i += 29;
                } else {
                  i -= 29;
                }
                return _while(__iced_k);
              });
            };
            _next = function(__iced_next_arg) {
              _results.push(__iced_next_arg);
              return _continue();
            };
            if (!!((_positive === true && i >= plaintext.length) || (_positive === false && i <= plaintext.length))) {
              return _break();
            } else {

              (function(__iced_k) {
                __iced_deferrals = new iced.Deferrals(__iced_k, {
                  parent: ___iced_passed_deferral,
                  filename: "/Users/max/src/keybase/kbpgp/src/openpgp/ocfb.iced"
                });
                process.nextTick(__iced_deferrals.defer({
                  lineno: 424
                }));
                __iced_deferrals._fulfill();
              })(function() {
                (function(__iced_k) {
                  __iced_deferrals = new iced.Deferrals(__iced_k, {
                    parent: ___iced_passed_deferral,
                    filename: "/Users/max/src/keybase/kbpgp/src/openpgp/ocfb.iced"
                  });
                  eng.chunk({
                    data: plaintext.slice(i, i + 29),
                    eof: false
                  }, __iced_deferrals.defer({
                    assign_fn: (function() {
                      return function() {
                        err = arguments[0];
                        return out = arguments[1];
                      };
                    })(),
                    lineno: 425
                  }));
                  __iced_deferrals._fulfill();
                })(function() {
                  if (err != null) {
                    throw err;
                  }
                  return _next(outbufs.push(out));
                });
              });
            }
          };
          _while(__iced_k);
        })(function() {
          console.log(outbufs);
          (function(__iced_k) {
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              filename: "/Users/max/src/keybase/kbpgp/src/openpgp/ocfb.iced"
            });
            eng.chunk({
              eof: true
            }, __iced_deferrals.defer({
              assign_fn: (function() {
                return function() {
                  err = arguments[0];
                  return out = arguments[1];
                };
              })(),
              lineno: 429
            }));
            __iced_deferrals._fulfill();
          })(function() {
            if (typeof err !== "undefined" && err !== null) {
              throw err;
            }
            outbufs.push(out);
            ct = Buffer.concat(outbufs);
            console.log(err);
            console.log(xxd(ct));
            ct2 = encrypt0({
              block_cipher_class: block_cipher_class,
              key: key,
              prefixrandom: prefixrandom,
              plaintext: plaintext
            });
            console.log(xxd(ct2));
            pt = decrypt({
              block_cipher_class: block_cipher_class,
              key: key,
              prefixrandom: prefixrandom,
              ciphertext: ct
            });
            console.log(pt.toString('utf8'));
            return console.log(pt.length);
          });
        });
      };
    })(this));
  };

}).call(this);
