// Generated by IcedCoffeeScript 1.7.1-c
(function() {
  var BaseBurner, C, CreationTime, Issuer, OnePassSignature, PKESK, SEIPD, SHA512, SRF, Signature, WordArray, clearsign, encode, export_key_pgp, get_cipher, iced, make_esc, triplesec, unix_time, __iced_k, __iced_k_noop, _ref, _ref1, _ref2;

  iced = require('iced-runtime').iced;
  __iced_k = __iced_k_noop = function() {};

  make_esc = require('iced-error').make_esc;

  OnePassSignature = require('./packet/one_pass_sig').OnePassSignature;

  _ref = require('./packet/signature'), Signature = _ref.Signature, CreationTime = _ref.CreationTime, Issuer = _ref.Issuer;

  _ref1 = require('../symmetric'), export_key_pgp = _ref1.export_key_pgp, get_cipher = _ref1.get_cipher;

  _ref2 = require('./packet/sess'), SEIPD = _ref2.SEIPD, PKESK = _ref2.PKESK;

  SHA512 = require('../hash').SHA512;

  encode = require('./armor').encode;

  clearsign = require('./clearsign');

  BaseBurner = require('./baseburner').BaseBurner;

  C = require('../const').openpgp;

  unix_time = require('../util').unix_time;

  SRF = require('../rand').SRF;

  triplesec = require('triplesec');

  WordArray = triplesec.WordArray;

  exports.BaseBurner = BaseBurner = (function() {
    function BaseBurner(_arg) {
      this.sign_with = _arg.sign_with, this.encrypt_for = _arg.encrypt_for, this.signing_key = _arg.signing_key, this.encryption_key = _arg.encryption_key;
      this.packets = [];
    }

    BaseBurner.prototype._find_keys = function(cb) {
      var esc, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      esc = make_esc(cb, "find_keys");
      (function(_this) {
        return (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/Users/max/src/keybase/kbpgp/src/openpgp/baseburner.iced",
            funcname: "BaseBurner._find_keys"
          });
          _this._find_signing_key(esc(__iced_deferrals.defer({
            lineno: 28
          })));
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          (function(__iced_k) {
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              filename: "/Users/max/src/keybase/kbpgp/src/openpgp/baseburner.iced",
              funcname: "BaseBurner._find_keys"
            });
            _this._find_encryption_key(esc(__iced_deferrals.defer({
              lineno: 29
            })));
            __iced_deferrals._fulfill();
          })(function() {
            (function(__iced_k) {
              __iced_deferrals = new iced.Deferrals(__iced_k, {
                parent: ___iced_passed_deferral,
                filename: "/Users/max/src/keybase/kbpgp/src/openpgp/baseburner.iced",
                funcname: "BaseBurner._find_keys"
              });
              _this._assert_one(esc(__iced_deferrals.defer({
                lineno: 30
              })));
              __iced_deferrals._fulfill();
            })(function() {
              return cb(null);
            });
          });
        };
      })(this));
    };

    BaseBurner.prototype.can_pass_through = function() {
      return False;
    };

    BaseBurner.prototype._assert_one = function(cb) {
      var err;
      err = null;
      if (!(this.signing_key != null) && !(this.encryption_key != null) && !(this.can_pass_through())) {
        err = new Error("need either an encryption or signing key, or both");
      }
      return cb(err);
    };

    BaseBurner.prototype._find_signing_key = function(cb) {
      var err;
      err = null;
      if ((this.sign_with != null) && (this.signing_key != null)) {
        err = new Error("specify either `sign_with` or `signing_key` but not both");
      } else if ((this.sign_with != null) && ((this.signing_key = this.sign_with.find_signing_pgp_key()) == null)) {
        err = new Error("cannot sign with the given KeyManager");
      }
      return cb(err);
    };

    BaseBurner.prototype._find_encryption_key = function(cb) {
      var err;
      err = null;
      if ((this.encrypt_for != null) && (this.encryption_key != null)) {
        err = new Error("specify either `encrypt_for` or `encryption_key` but not both");
      } else if ((this.encrypt_for != null) && ((this.encryption_key = this.encrypt_for.find_crypt_pgp_key()) == null)) {
        err = new Error("cannot encrypt with the given KeyManager");
      }
      return cb(err);
    };

    BaseBurner.prototype._make_session_key = function(cb) {
      var ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      this._cipher_algo = C.symmetric_key_algorithms.AES256;
      this._cipher_info = get_cipher(this._cipher_algo);
      (function(_this) {
        return (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/Users/max/src/keybase/kbpgp/src/openpgp/baseburner.iced",
            funcname: "BaseBurner._make_session_key"
          });
          SRF().random_bytes(_this._cipher_info.key_size, __iced_deferrals.defer({
            assign_fn: (function(__slot_1) {
              return function() {
                return __slot_1._session_key = arguments[0];
              };
            })(_this),
            lineno: 70
          }));
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          _this.cipher = new _this._cipher_info.klass(WordArray.from_buffer(_this._session_key));
          return cb(null);
        };
      })(this));
    };

    BaseBurner.prototype._encrypt_session_key = function(cb) {
      var ekey, esc, fingerprint, key_id, payload, pkt, pub_k, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      esc = make_esc(cb, "_encrypt_session_key");
      payload = export_key_pgp(this._cipher_algo, this._session_key);
      pub_k = this.encryption_key.key;
      fingerprint = this.encryption_key.get_fingerprint();
      (function(_this) {
        return (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/Users/max/src/keybase/kbpgp/src/openpgp/baseburner.iced",
            funcname: "BaseBurner._encrypt_session_key"
          });
          pub_k.pad_and_encrypt(payload, {
            fingerprint: fingerprint
          }, esc(__iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                return ekey = arguments[0];
              };
            })(),
            lineno: 81
          })));
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          (function(__iced_k) {
            if (_this.opts.hide) {
              key_id = dummy_key_id;
              (function(__iced_k) {
                var _ref3, _ref4;
                __iced_deferrals = new iced.Deferrals(__iced_k, {
                  parent: ___iced_passed_deferral,
                  filename: "/Users/max/src/keybase/kbpgp/src/openpgp/baseburner.iced",
                  funcname: "BaseBurner._encrypt_session_key"
                });
                ekey.hide({
                  max: (_ref3 = _this.opts.hide) != null ? _ref3.max : void 0,
                  slosh: (_ref4 = _this.opts.hide) != null ? _ref4.slosh : void 0,
                  key: pub_k
                }, esc(__iced_deferrals.defer({
                  lineno: 84
                })));
                __iced_deferrals._fulfill();
              })(__iced_k);
            } else {
              return __iced_k(key_id = _this.encryption_key.get_key_id());
            }
          })(function() {
            pkt = new PKESK({
              crypto_type: pub_k.type,
              key_id: key_id,
              ekey: ekey
            });
            (function(__iced_k) {
              __iced_deferrals = new iced.Deferrals(__iced_k, {
                parent: ___iced_passed_deferral,
                filename: "/Users/max/src/keybase/kbpgp/src/openpgp/baseburner.iced",
                funcname: "BaseBurner._encrypt_session_key"
              });
              pkt.write(esc(__iced_deferrals.defer({
                assign_fn: (function(__slot_1) {
                  return function() {
                    return __slot_1.pkesk = arguments[0];
                  };
                })(_this),
                lineno: 92
              })));
              __iced_deferrals._fulfill();
            })(function() {
              return cb(null);
            });
          });
        };
      })(this));
    };

    BaseBurner.prototype._generate_iv = function(cb) {
      var ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      (function(_this) {
        return (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/Users/max/src/keybase/kbpgp/src/openpgp/baseburner.iced",
            funcname: "BaseBurner._generate_iv"
          });
          SRF().random_bytes(_this.cipher.blockSize, __iced_deferrals.defer({
            assign_fn: (function(__slot_1) {
              return function() {
                return __slot_1.prefixrandom = arguments[0];
              };
            })(_this),
            lineno: 98
          }));
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          return cb(null);
        };
      })(this));
    };

    BaseBurner.prototype._setup_encryption = function(cb) {
      var esc, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      esc = make_esc(cb, "_setup_encryption");
      (function(_this) {
        return (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/Users/max/src/keybase/kbpgp/src/openpgp/baseburner.iced",
            funcname: "BaseBurner._setup_encryption"
          });
          _this._make_session_key(esc(__iced_deferrals.defer({
            lineno: 105
          })));
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          (function(__iced_k) {
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              filename: "/Users/max/src/keybase/kbpgp/src/openpgp/baseburner.iced",
              funcname: "BaseBurner._setup_encryption"
            });
            _this._encrypt_session_key(esc(__iced_deferrals.defer({
              lineno: 106
            })));
            __iced_deferrals._fulfill();
          })(function() {
            (function(__iced_k) {
              __iced_deferrals = new iced.Deferrals(__iced_k, {
                parent: ___iced_passed_deferral,
                filename: "/Users/max/src/keybase/kbpgp/src/openpgp/baseburner.iced",
                funcname: "BaseBurner._setup_encryption"
              });
              _this._generate_iv(esc(__iced_deferrals.defer({
                lineno: 107
              })));
              __iced_deferrals._fulfill();
            })(function() {
              return cb(null, _this.pkesk);
            });
          });
        };
      })(this));
    };

    BaseBurner.prototype._make_ops_packet = function() {
      return new OnePassSignature({
        sig_type: C.sig_types.binary_doc,
        hasher: this.hasher || SHA512,
        sig_klass: this.signing_key.get_klass(),
        key_id: this.signing_key.get_key_id(),
        is_final: 1
      });
    };

    BaseBurner.prototype._make_sig_packet = function(_arg) {
      var hasher;
      hasher = _arg.hasher;
      return new Signature({
        type: C.sig_types.binary_doc,
        key: this.signing_key.key,
        hashed_subpackets: [new CreationTime(unix_time())],
        unhashed_subpackets: [new Issuer(this.signing_key.get_key_id())],
        hasher: hasher
      });
    };

    return BaseBurner;

  })();

}).call(this);
