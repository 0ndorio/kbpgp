// Generated by IcedCoffeeScript 1.7.1-c
(function() {
  var C, Ch, MT, Parser, XbtArmorer, armor, bufeq_fast, decode, k, katch, r_type_table, type_table, uint_to_buffer, v, xbt, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  _ref = require('../util'), katch = _ref.katch, bufeq_fast = _ref.bufeq_fast, uint_to_buffer = _ref.uint_to_buffer;

  C = require('../const');

  Ch = require('../header');

  armor = require('pgp-utils').armor;

  xbt = require('../xbt');

  MT = C.openpgp.message_types;

  type_table = {
    "PUBLIC KEY BLOCK": MT.public_key,
    "PRIVATE KEY BLOCK": MT.private_key,
    "SIGNATURE": MT.signature,
    "MESSAGE": MT.generic
  };

  r_type_table = {};

  for (k in type_table) {
    v = type_table[k];
    r_type_table[v] = k;
  }

  exports.encode = function(type, data) {
    var mt;
    mt = C.openpgp.message_types;
    if ((type = r_type_table[type]) == null) {
      throw new Error("Cannot encode tag type " + type);
    }
    return armor.encode(Ch, type, data);
  };

  Parser = (function(_super) {
    __extends(Parser, _super);

    function Parser() {
      return Parser.__super__.constructor.apply(this, arguments);
    }

    Parser.prototype.parse_type = function() {
      if ((this.ret.type = type_table[this.type]) == null) {
        throw new Error("Unknown message type: " + this.type);
      } else if ((this.ret.type === MT.clearsign) && !this.ret.clearsign) {
        throw new Error("Signed message, but not clear-signed");
      }
      return this.ret.fields.type = this.type;
    };

    return Parser;

  })(armor.Parser);

  exports.XbtArmorer = XbtArmorer = (function(_super) {
    __extends(XbtArmorer, _super);

    function XbtArmorer(_arg) {
      var type;
      type = _arg.type;
      this._enc = new armor.Encoder(Ch);
      if (!(type = type_table[type])) {
        this._err = new Error("Bad type");
      }
      this._frame = this._enc.frame(type);
      this._out_width = 64;
      this._in_width = (this._out_width / 4) * 3;
      XbtArmorer.__super__.constructor.call(this, this._in_width);
      this._crc = null;
    }

    XbtArmorer.prototype._v_init = function(cb) {
      var buf, hdr;
      if (this._err == null) {
        hdr = this._frame.begin.concat(this._enc.header(), "\n");
        buf = new Buffer(hdr, 'utf8');
      }
      return cb(this._err, buf);
    };

    XbtArmorer.prototype._v_inblock_chunk = function(_arg, cb) {
      var buf, chksum, data, eof, strings;
      data = _arg.data, eof = _arg.eof;
      strings = [];
      if (data != null) {
        strings.push(data.toString('base64'));
        this._crc = armor.compute_crc24(data, this._crc);
      }
      if (eof) {
        chksum = "=" + uint_to_buffer(32, this._crc).slice(1, 4).toString('base64');
        strings.push(chksum);
        strings.push(this._frame.end);
      }
      buf = new Buffer(strings.join("\n"), "utf8");
      return cb(null, buf);
    };

    return XbtArmorer;

  })(xbt.InBlocker);

  exports.Message = armor.Message;

  exports.decode = decode = function(data) {
    return katch(function() {
      return (new Parser(data)).parse();
    });
  };

  exports.mdecode = decode = function(data) {
    return katch(function() {
      return (new Parser(data)).mparse();
    });
  };

}).call(this);
