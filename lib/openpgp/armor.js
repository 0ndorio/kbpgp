// Generated by IcedCoffeeScript 1.7.1-c
(function() {
  var C, Ch, MT, Parser, XbtArmorer, XbtDearmorer, XbtDemux, XbtTokenizer, armor, bufeq_fast, decode, iced, k, katch, r_type_table, type_table, uint_to_buffer, v, xbt, __iced_k, __iced_k_noop, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  iced = require('iced-runtime').iced;
  __iced_k = __iced_k_noop = function() {};

  _ref = require('../util'), katch = _ref.katch, bufeq_fast = _ref.bufeq_fast, uint_to_buffer = _ref.uint_to_buffer;

  C = require('../const');

  Ch = require('../header');

  armor = require('pgp-utils').armor;

  xbt = require('../xbt');

  MT = C.openpgp.message_types;

  type_table = {
    "PUBLIC KEY BLOCK": MT.public_key,
    "PRIVATE KEY BLOCK": MT.private_key,
    "SIGNATURE": MT.signature,
    "MESSAGE": MT.generic
  };

  r_type_table = {};

  for (k in type_table) {
    v = type_table[k];
    r_type_table[v] = k;
  }

  exports.encode = function(type, data) {
    var mt;
    mt = C.openpgp.message_types;
    if ((type = r_type_table[type]) == null) {
      throw new Error("Cannot encode tag type " + type);
    }
    return armor.encode(Ch, type, data);
  };

  Parser = (function(_super) {
    __extends(Parser, _super);

    function Parser() {
      return Parser.__super__.constructor.apply(this, arguments);
    }

    Parser.prototype.parse_type = function() {
      if ((this.ret.type = type_table[this.type]) == null) {
        throw new Error("Unknown message type: " + this.type);
      } else if ((this.ret.type === MT.clearsign) && !this.ret.clearsign) {
        throw new Error("Signed message, but not clear-signed");
      }
      return this.ret.fields.type = this.type;
    };

    return Parser;

  })(armor.Parser);

  exports.XbtArmorer = XbtArmorer = (function(_super) {
    __extends(XbtArmorer, _super);

    function XbtArmorer(_arg) {
      var type;
      type = _arg.type;
      this._enc = new armor.Encoder(Ch);
      if ((type = r_type_table[type]) == null) {
        this._err = new Error("Bad type");
      }
      this._frame = this._enc.frame(type);
      this._out_width = 64;
      this._in_width = (this._out_width / 4) * 3;
      XbtArmorer.__super__.constructor.call(this, this._in_width);
      this._crc = null;
    }

    XbtArmorer.prototype._v_init = function(cb) {
      var buf, hdr;
      if (this._err == null) {
        hdr = this._frame.begin.concat(this._enc.header(), "\n");
        buf = new Buffer(hdr, 'utf8');
      }
      return cb(this._err, buf);
    };

    XbtArmorer.prototype._v_inblock_chunk = function(_arg, cb) {
      var buf, chksum, data, eof, strings;
      data = _arg.data, eof = _arg.eof;
      strings = [];
      if (data != null) {
        strings.push(data.toString('base64') + "\n");
        this._crc = armor.compute_crc24(data, this._crc);
      }
      if (eof) {
        chksum = armor.crc24_to_base64(this._crc);
        strings.push(chksum + "\n");
        strings.push(this._frame.end);
      }
      buf = new Buffer(strings.join(""), "utf8");
      return cb(null, buf);
    };

    return XbtArmorer;

  })(xbt.InBlocker);

  exports.XbtDemux = XbtDemux = (function(_super) {
    __extends(XbtDemux, _super);

    function XbtDemux(mt) {
      this._prefix = "-----BEGIN PGP";
      XbtDemux.__super__.constructor.apply(this, arguments);
    }

    XbtDemux.prototype.peek_bytes = function() {
      return this._prefix.length;
    };

    XbtDemux.prototype._demux = function(_arg, cb) {
      var data, eof, ret;
      data = _arg.data, eof = _arg.eof;
      if ((data != null) && data.toString('utf8') === this._prefix) {
        ret = new XbtDearmorer();
      } else {
        ret = new xbt.Passthrough();
      }
      return cb(null, ret, data);
    };

    return XbtDemux;

  })(xbt.Demux);

  XbtTokenizer = (function(_super) {
    __extends(XbtTokenizer, _super);

    function XbtTokenizer() {
      XbtTokenizer.__super__.constructor.call(this, {
        maxline: 4096,
        mod: 4
      });
    }

    XbtTokenizer.prototype._v_line_chunk = function(_arg, cb) {
      var data, eof, err, m, newline, out, s, tok, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      data = _arg.data, newline = _arg.newline, eof = _arg.eof;
      tok = data == null ? null : (s = data.toString('utf8'), (m = s.match(/^-{5}\s?(BEGIN|END) PGP ([\w\s]+?)\s?-{5}$/)) != null ? {
        type: 'frame',
        begin: m[1] === 'BEGIN',
        msg_type: m[2]
      } : (m = s.match(/^(\w+): (.*)$/)) != null ? {
        type: 'comment',
        name: m[1],
        value: m[2]
      } : (m = s.match(/^=([a-zA-Z0-9+/]){4}/)) ? {
        type: 'checksum',
        value: m[1]
      } : data.length === 0 ? {
        type: 'empty'
      } : {
        type: 'data',
        value: s
      });
      (function(_this) {
        return (function(__iced_k) {
          if ((tok != null) || eof) {
            (function(__iced_k) {
              __iced_deferrals = new iced.Deferrals(__iced_k, {
                parent: ___iced_passed_deferral,
                filename: "/home/max/src/keybase/kbpgp/src/openpgp/armor.iced",
                funcname: "XbtTokenizer._v_line_chunk"
              });
              _this._v_token_chunk({
                tok: tok,
                eof: eof
              }, __iced_deferrals.defer({
                assign_fn: (function() {
                  return function() {
                    err = arguments[0];
                    return out = arguments[1];
                  };
                })(),
                lineno: 111
              }));
              __iced_deferrals._fulfill();
            })(__iced_k);
          } else {
            return __iced_k();
          }
        });
      })(this)((function(_this) {
        return function() {
          return cb(err, out);
        };
      })(this));
    };

    return XbtTokenizer;

  })(xbt.Gets);

  exports.XbtDearmorer = XbtDearmorer = (function(_super) {
    __extends(XbtDearmorer, _super);

    function XbtDearmorer() {
      this._state = 0;
      this._msg_type = null;
      this._crc24 = null;
      XbtDearmorer.__super__.constructor.call(this);
    }

    XbtDearmorer.prototype.get_root_metadata = function() {
      return XbtDearmorer.__super__.get_root_metadata.call(this, 'armor');
    };

    XbtDearmorer.prototype.headers_out = function() {
      var _base;
      return (_base = this.get_root_metadata()).headers || (_base.headers = {});
    };

    XbtDearmorer.prototype._v_token_chunk = function(_arg, cb) {
      var chksum, eof, err, out, tok;
      tok = _arg.tok, eof = _arg.eof;
      err = out = null;
      if (tok != null) {
        switch (this._state) {
          case 0:
            if ((tok.type === 'frame') && tok.begin) {
              this.get_root_metadata().type = this._msg_type = tok.msg_type;
              this._state++;
            } else {
              err = new Error("Failed to get valid '-----BEGIN PGP ...' block ");
            }
            break;
          case 1:
            if (tok.type === 'comment') {
              this.headers_out()[tok.name] = tok.value;
            } else if (tok.type === 'empty') {
              this._state++;
            } else {
              err = new Error("Got bad field in comment region");
            }
            break;
          case 2:
            if (tok.type === 'data') {
              out = new Buffer(tok.value, 'base64');
              this._crc24 = armor.compute_crc24(out, this._crc24);
            } else if (tok.type === 'checksum') {
              this._checksum = new Buffer(tok.value, 'base64');
              this._state++;
            } else {
              err = new Error("Got bad data on " + this._lineno);
            }
            break;
          case 3:
            if ((tok.type !== 'frame') || tok.begin) {
              err = new Error("On line " + this._lineno + ": expected a END PGP closer");
            } else if (tok.msg_type !== this._msg_type) {
              err = new Error("Opened type " + this._msg_type + " != " + tok.msg_type);
            } else {
              this._state++;
            }
            break;
          default:
            if (tok.type !== 'empty') {
              err = new Error("Should not still be getting data in end state");
            }
        }
      }
      if (!eof) {

      } else if (this._state !== 4) {
        err = new Error("EOF before close of message");
      } else {
        chksum = armor.crc24_to_base64(this._crc24, false);
        if (chksum !== this._checksum) {
          err = new Error("Checksum failure: " + chksum + " != " + this._checksum);
        }
      }
      return cb(err, out);
    };

    return XbtDearmorer;

  })(XbtTokenizer);

  exports.Message = armor.Message;

  exports.decode = decode = function(data) {
    return katch(function() {
      return (new Parser(data)).parse();
    });
  };

  exports.mdecode = decode = function(data) {
    return katch(function() {
      return (new Parser(data)).mparse();
    });
  };

}).call(this);
