// Generated by IcedCoffeeScript 1.7.1-c
(function() {
  var C, Decryptor, Encryptor, MDC, MDC_Parser, MDC_XbtOut, PKESK, PKESK_Parser, Packet, Packetizer, SEIPD, SEIPD_Parser, SEIPD_XbtOut, SHA1, asymmetric, bufcat, bufeq_fast, bufeq_secure, encrypt, hashmod, iced, make_esc, uint_to_buffer, xbt, __iced_k, __iced_k_noop, _ref, _ref1,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  iced = require('iced-runtime').iced;
  __iced_k = __iced_k_noop = function() {};

  Packet = require('./base').Packet;

  C = require('../../const').openpgp;

  asymmetric = require('../../asymmetric');

  hashmod = require('../../hash');

  SHA1 = hashmod.SHA1;

  _ref = require('../../util'), bufcat = _ref.bufcat, uint_to_buffer = _ref.uint_to_buffer, bufeq_secure = _ref.bufeq_secure, bufeq_fast = _ref.bufeq_fast;

  _ref1 = require('../ocfb'), encrypt = _ref1.encrypt, Encryptor = _ref1.Encryptor, Decryptor = _ref1.Decryptor;

  Packetizer = require('./xbt_packetizer').Packetizer;

  xbt = require('../../xbt');

  make_esc = require('iced-error').make_esc;

  PKESK = (function(_super) {
    __extends(PKESK, _super);

    function PKESK(_arg) {
      this.crypto_type = _arg.crypto_type, this.key_id = _arg.key_id, this.ekey = _arg.ekey;
    }

    PKESK.parse = function(slice) {
      return (new PKESK_Parser(slice)).parse();
    };

    PKESK.prototype.to_esk_packet = function() {
      return this;
    };

    PKESK.prototype.get_key_id = function() {
      return this.key_id;
    };

    PKESK.prototype.write_unframed = function(cb) {
      var bufs, err, ret;
      bufs = [uint_to_buffer(8, C.versions.PKESK), this.key_id, uint_to_buffer(8, this.crypto_type), this.ekey.output()];
      ret = Buffer.concat(bufs);
      err = null;
      return cb(err, ret);
    };

    PKESK.prototype.write = function(cb) {
      var err, ret, unframed, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      ret = null;
      (function(_this) {
        return (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/Users/max/src/keybase/kbpgp/src/openpgp/packet/sess.iced",
            funcname: "PKESK.write"
          });
          _this.write_unframed(__iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                err = arguments[0];
                return unframed = arguments[1];
              };
            })(),
            lineno: 38
          }));
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          if (typeof err === "undefined" || err === null) {
            ret = _this.frame_packet(C.packet_tags.PKESK, unframed);
          }
          return cb(err, ret);
        };
      })(this));
    };

    return PKESK;

  })(Packet);

  SEIPD = (function(_super) {
    __extends(SEIPD, _super);

    function SEIPD(_arg) {
      this.ciphertext = _arg.ciphertext;
    }

    SEIPD.parse = function(slice) {
      return (new SEIPD_Parser(slice)).parse();
    };

    SEIPD.TAG = C.packet_tags.SEIPD;

    SEIPD.prototype.TAG = SEIPD.TAG;

    SEIPD.prototype.to_enc_data_packet = function() {
      return this;
    };

    SEIPD.prototype.check = function() {};

    SEIPD.prototype.decrypt = function(cipher) {
      var eng, err, mdc, plaintext, prefix, pt, _ref2;
      eng = new Decryptor({
        cipher: cipher,
        ciphertext: this.ciphertext
      });
      err = eng.check();
      if (err != null) {
        throw err;
      }
      pt = eng.dec();
      _ref2 = MDC.parse(pt), mdc = _ref2[0], plaintext = _ref2[1];
      prefix = eng.get_prefix();
      mdc.compute({
        prefix: prefix,
        plaintext: plaintext
      });
      if (!mdc.check()) {
        throw new Error("MDC mismatch");
      }
      return plaintext;
    };

    SEIPD.prototype.encrypt = function(_arg, cb) {
      var cipher, mdc, mdc_buf, plaintext, prefixrandom;
      cipher = _arg.cipher, plaintext = _arg.plaintext, prefixrandom = _arg.prefixrandom;
      mdc = new MDC({});
      mdc_buf = mdc.compute({
        plaintext: plaintext,
        prefix: prefixrandom
      });
      plaintext = Buffer.concat([plaintext, MDC.header, mdc_buf]);
      this.ciphertext = encrypt({
        cipher: cipher,
        plaintext: plaintext,
        prefixrandom: prefixrandom
      });
      return cb(null);
    };

    SEIPD.prototype.write_unframed = function(cb) {
      var bufs, err, ret;
      err = ret = null;
      bufs = [uint_to_buffer(8, C.versions.SEIPD)];
      if (this.ciphertext != null) {
        bufs.push(this.ciphertext);
      }
      ret = Buffer.concat(bufs);
      return cb(err, ret);
    };

    SEIPD.prototype.new_xbt = function(_arg) {
      var cipher, pkesk, prefixrandom;
      pkesk = _arg.pkesk, cipher = _arg.cipher, prefixrandom = _arg.prefixrandom;
      return new SEIPD_XbtOut({
        pkesk: pkesk,
        packet: this,
        cipher: cipher,
        prefixrandom: prefixrandom
      });
    };

    return SEIPD;

  })(Packet);

  exports.SEIPD_XbtOut = SEIPD_XbtOut = (function(_super) {
    __extends(SEIPD_XbtOut, _super);

    function SEIPD_XbtOut(_arg) {
      var cipher, packet, prefixrandom;
      packet = _arg.packet, this.pkesk = _arg.pkesk, cipher = _arg.cipher, prefixrandom = _arg.prefixrandom;
      SEIPD_XbtOut.__super__.constructor.call(this, {
        packet: packet
      });
      this._mdc = new MDC({});
      this._mdc_xbt = this._mdc.new_xbt({});
      this._ocfb = new Encryptor({
        cipher: cipher,
        prefixrandom: prefixrandom
      });
    }

    SEIPD_XbtOut.prototype._v_init = function(cb) {
      var err, out, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      (function(_this) {
        return (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/Users/max/src/keybase/kbpgp/src/openpgp/packet/sess.iced",
            funcname: "SEIPD_XbtOut._v_init"
          });
          SEIPD_XbtOut.__super__._v_init.call(_this, __iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                err = arguments[0];
                return out = arguments[1];
              };
            })(),
            lineno: 115
          }));
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          if (typeof err === "undefined" || err === null) {
            out = bufcat([_this.pkesk, out]);
          }
          return cb(err, out);
        };
      })(this));
    };

    SEIPD_XbtOut.prototype._v_chunk = function(_arg, cb) {
      var data, eof, esc, out, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      data = _arg.data, eof = _arg.eof;
      esc = make_esc(cb, "SEIPD_XbtOut::_v_chunk");
      (function(_this) {
        return (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/Users/max/src/keybase/kbpgp/src/openpgp/packet/sess.iced",
            funcname: "SEIPD_XbtOut._v_chunk"
          });
          _this._mdc_xbt.chunk({
            data: data,
            eof: eof
          }, esc(__iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                return out = arguments[0];
              };
            })(),
            lineno: 125
          })));
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          data = bufcat([data, out]);
          (function(__iced_k) {
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              filename: "/Users/max/src/keybase/kbpgp/src/openpgp/packet/sess.iced",
              funcname: "SEIPD_XbtOut._v_chunk"
            });
            _this._ocfb.chunk({
              data: data,
              eof: eof
            }, esc(__iced_deferrals.defer({
              assign_fn: (function() {
                return function() {
                  return out = arguments[0];
                };
              })(),
              lineno: 132
            })));
            __iced_deferrals._fulfill();
          })(function() {
            (function(__iced_k) {
              __iced_deferrals = new iced.Deferrals(__iced_k, {
                parent: ___iced_passed_deferral,
                filename: "/Users/max/src/keybase/kbpgp/src/openpgp/packet/sess.iced",
                funcname: "SEIPD_XbtOut._v_chunk"
              });
              SEIPD_XbtOut.__super__._v_chunk.call(_this, {
                data: out,
                eof: eof
              }, esc(__iced_deferrals.defer({
                assign_fn: (function() {
                  return function() {
                    return out = arguments[0];
                  };
                })(),
                lineno: 136
              })));
              __iced_deferrals._fulfill();
            })(function() {
              return cb(null, out);
            });
          });
        };
      })(this));
    };

    return SEIPD_XbtOut;

  })(Packetizer);

  MDC = (function(_super) {
    __extends(MDC, _super);

    MDC.header = new Buffer([0xc0 | C.packet_tags.MDC, SHA1.output_length]);

    MDC.prototype.header = MDC.header;

    function MDC(_arg) {
      this.digest = _arg.digest;
    }

    MDC.parse = function(buf) {
      return (new MDC_Parser(buf)).parse();
    };

    MDC.prototype.compute = function(_arg) {
      var plaintext, prefix;
      plaintext = _arg.plaintext, prefix = _arg.prefix;
      this.computed = SHA1(Buffer.concat([prefix, prefix.slice(-2), plaintext, this.header]));
      return this.computed;
    };

    MDC.prototype.check = function() {
      return bufeq_secure(this.digest, this.computed);
    };

    MDC.TAG = C.packet_tags.MDC;

    MDC.prototype.TAG = MDC.TAG;

    MDC.prototype.write_unframed = function(cb) {
      return cb(null, this.digest);
    };

    MDC.prototype.new_xbt = function() {
      return new MDC_XbtOut({
        mdc: this
      });
    };

    return MDC;

  })(Packet);

  exports.MDC_XbtOut = MDC_XbtOut = (function(_super) {
    __extends(MDC_XbtOut, _super);

    function MDC_XbtOut(_arg) {
      this.mdc = _arg.mdc;
      this.hasher = hashmod.streamers.SHA1();
    }

    MDC_XbtOut.prototype.chunk = function(_arg, cb) {
      var data, eof, err, out, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      data = _arg.data, eof = _arg.eof;
      if (data != null) {
        this.hasher.update(data);
      }
      err = out = null;
      (function(_this) {
        return (function(__iced_k) {
          if (eof) {
            _this.mdc.digest = _this.hasher();
            (function(__iced_k) {
              __iced_deferrals = new iced.Deferrals(__iced_k, {
                parent: ___iced_passed_deferral,
                filename: "/Users/max/src/keybase/kbpgp/src/openpgp/packet/sess.iced",
                funcname: "MDC_XbtOut.chunk"
              });
              _this.mdc.write(__iced_deferrals.defer({
                assign_fn: (function() {
                  return function() {
                    err = arguments[0];
                    return out = arguments[1];
                  };
                })(),
                lineno: 175
              }));
              __iced_deferrals._fulfill();
            })(__iced_k);
          } else {
            return __iced_k();
          }
        });
      })(this)((function(_this) {
        return function() {
          return cb(err, out);
        };
      })(this));
    };

    return MDC_XbtOut;

  })(xbt.Base);

  MDC_Parser = (function() {
    function MDC_Parser(buf) {
      this.buf = buf;
    }

    MDC_Parser.prototype.parse = function() {
      var chunk, digest, hl, len, rem;
      hl = MDC.header.length;
      len = SHA1.output_length + hl;
      rem = this.buf.slice(0, -len);
      chunk = this.buf.slice(-len);
      if (!bufeq_fast(chunk.slice(0, hl), MDC.header)) {
        throw new Error('Missing MDC header');
      }
      digest = chunk.slice(hl);
      return [
        new MDC({
          digest: digest
        }), rem
      ];
    };

    return MDC_Parser;

  })();

  SEIPD_Parser = (function() {
    function SEIPD_Parser(slice) {
      this.slice = slice;
    }

    SEIPD_Parser.prototype.payload_split = function(raw) {};

    SEIPD_Parser.prototype.parse = function() {
      var ciphertext, v;
      if ((v = this.slice.read_uint8()) !== C.versions.SEIPD) {
        throw new Error("Unknown SEIPD version " + v);
      }
      ciphertext = this.slice.consume_rest_to_buffer();
      return new SEIPD({
        ciphertext: ciphertext
      });
    };

    return SEIPD_Parser;

  })();

  PKESK_Parser = (function() {
    function PKESK_Parser(slice) {
      this.slice = slice;
    }

    PKESK_Parser.prototype.parse = function() {
      var crypto_type, ekey, key_id, klass, v;
      if ((v = this.slice.read_uint8()) !== C.versions.PKESK) {
        throw new Error("Unknown PKESK version: " + v);
      }
      key_id = this.slice.read_buffer(8);
      crypto_type = this.slice.read_uint8();
      klass = asymmetric.get_class(crypto_type);
      ekey = klass.parse_output(this.slice.consume_rest_to_buffer());
      return new PKESK({
        crypto_type: crypto_type,
        key_id: key_id,
        ekey: ekey
      });
    };

    return PKESK_Parser;

  })();

  exports.SEIPD = SEIPD;

  exports.PKESK = PKESK;

  exports.MDC = MDC;

}).call(this);
