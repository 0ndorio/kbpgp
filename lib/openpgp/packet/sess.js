// Generated by IcedCoffeeScript 1.6.3-g
(function() {
  var C, Decryptor, MDC, MDC_Parser, PKESK, PKESK_Parser, Packet, SEIPD, SEIPD_Parser, SHA1, asymmetric, bufeq_fast, bufeq_secure, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };



  Packet = require('./base').Packet;

  C = require('../../const').openpgp;

  asymmetric = require('../../asymmetric');

  SHA1 = require('../../hash').SHA1;

  _ref = require('../../util'), bufeq_secure = _ref.bufeq_secure, bufeq_fast = _ref.bufeq_fast;

  Decryptor = require('../ocfb').Decryptor;

  PKESK = (function(_super) {
    __extends(PKESK, _super);

    function PKESK(_arg) {
      this.crypto_type = _arg.crypto_type, this.key_id = _arg.key_id, this.ekey = _arg.ekey;
    }

    PKESK.parse = function(slice) {
      return (new PKESK_Parser(slice)).parse();
    };

    PKESK.prototype.to_esk_packet = function() {
      return this;
    };

    PKESK.prototype.get_key_id = function() {
      return this.key_id;
    };

    return PKESK;

  })(Packet);

  SEIPD = (function(_super) {
    __extends(SEIPD, _super);

    function SEIPD(_arg) {
      this.ciphertext = _arg.ciphertext;
    }

    SEIPD.parse = function(slice) {
      return (new SEIPD_Parser(slice)).parse();
    };

    SEIPD.prototype.to_enc_data_packet = function() {
      return this;
    };

    SEIPD.prototype.check = function() {};

    SEIPD.prototype.decrypt = function(cipher) {
      var bufs, computed, eng, err, mdc, plaintext, prefix, _ref1;
      eng = new Decryptor({
        cipher: cipher,
        ciphertext: this.ciphertext
      });
      err = eng.check();
      if (err != null) {
        throw err;
      }
      _ref1 = MDC.parse(eng.dec()), mdc = _ref1[0], plaintext = _ref1[1];
      prefix = eng.get_prefix();
      bufs = Buffer.concat([prefix, prefix.slice(-2), plaintext, mdc.header]);
      computed = SHA1(bufs);
      if (!bufeq_secure(computed, mdc.digest)) {
        throw new Error("MDC mismatch");
      }
      return plaintext;
    };

    return SEIPD;

  })(Packet);

  MDC = (function(_super) {
    __extends(MDC, _super);

    function MDC(_arg) {
      this.digest = _arg.digest, this.header = _arg.header;
    }

    MDC.parse = function(buf) {
      return (new MDC_Parser(buf)).parse();
    };

    return MDC;

  })(Packet);

  MDC_Parser = (function() {
    function MDC_Parser(buf) {
      this.buf = buf;
      this.header = new Buffer([0xc0 | C.packet_tags.MDC, SHA1.output_length]);
    }

    MDC_Parser.prototype.parse = function() {
      var chunk, digest, hl, len, rem;
      hl = this.header.length;
      len = SHA1.output_length + hl;
      rem = this.buf.slice(0, -len);
      chunk = this.buf.slice(-len);
      if (!bufeq_fast(chunk.slice(0, hl), this.header)) {
        throw new Error('Missing MDC header');
      }
      digest = chunk.slice(hl);
      return [
        new MDC({
          digest: digest,
          header: this.header
        }), rem
      ];
    };

    return MDC_Parser;

  })();

  SEIPD_Parser = (function() {
    function SEIPD_Parser(slice) {
      this.slice = slice;
    }

    SEIPD_Parser.prototype.payload_split = function(raw) {};

    SEIPD_Parser.prototype.parse = function() {
      var ciphertext, v;
      if ((v = this.slice.read_uint8()) !== C.versions.SEIPD) {
        throw new Error("Unknown SEIPD version " + v);
      }
      ciphertext = this.slice.consume_rest_to_buffer();
      return new SEIPD({
        ciphertext: ciphertext
      });
    };

    return SEIPD_Parser;

  })();

  PKESK_Parser = (function() {
    function PKESK_Parser(slice) {
      this.slice = slice;
    }

    PKESK_Parser.prototype.parse = function() {
      var crypto_type, ekey, key_id, klass, v;
      if ((v = this.slice.read_uint8()) !== C.versions.PKESK) {
        throw new Error("Unknown PKESK version: " + v);
      }
      key_id = this.slice.read_buffer(8);
      crypto_type = this.slice.read_uint8();
      klass = asymmetric.get_class(crypto_type);
      ekey = klass.parse_output(this.slice.consume_rest_to_buffer());
      return new PKESK({
        crypto_type: crypto_type,
        key_id: key_id,
        ekey: ekey
      });
    };

    return PKESK_Parser;

  })();

  exports.SEIPD = SEIPD;

  exports.PKESK = PKESK;

  exports.MDC = MDC;

}).call(this);
