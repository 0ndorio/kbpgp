// Generated by IcedCoffeeScript 1.6.3-g
(function() {
  var C, Decryptor, MDC, MDC_Parser, PKESK, PKESK_Parser, Packet, SEIPD, SEIPD_Parser, SHA1, asymmetric, bufeq_fast,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };



  Packet = require('./base').Packet;

  C = require('../../const').openpgp;

  asymmetric = require('../../asymmetric');

  SHA1 = require('../../hash').SHA1;

  bufeq_fast = require('../../util').bufeq_fast;

  Decryptor = require('../ocfb').Decryptor;

  PKESK = (function(_super) {
    __extends(PKESK, _super);

    function PKESK(_arg) {
      this.crypto_type = _arg.crypto_type, this.key_id = _arg.key_id, this.ekey = _arg.ekey;
    }

    PKESK.parse = function(slice) {
      return (new PKESK_Parser(slice)).parse();
    };

    PKESK.prototype.to_esk_packet = function() {
      return this;
    };

    PKESK.prototype.get_key_id = function() {
      return this.key_id;
    };

    return PKESK;

  })(Packet);

  SEIPD = (function(_super) {
    __extends(SEIPD, _super);

    function SEIPD(_arg) {
      this.ciphertext = _arg.ciphertext, this.mdc = _arg.mdc;
    }

    SEIPD.parse = function(slice) {
      return (new SEIPD_Parser(slice)).parse();
    };

    SEIPD.prototype.to_enc_data_packet = function() {
      return this;
    };

    SEIPD.prototype.decrypt = function(cipher) {
      var eng, err, mdcp;
      eng = new Decryptor({
        cipher: cipher,
        ciphertext: this.ciphertext
      });
      err = eng.check();
      if (err != null) {
        throw err;
      }
      mdcp = new MDC_Parser(eng.dec());
      this.mdc = mdcp.parse();
      this.prefix = eng.get_prefix();
      return (this.plaintext = mdcp.rem());
    };

    return SEIPD;

  })(Packet);

  MDC = (function(_super) {
    __extends(MDC, _super);

    function MDC(_arg) {
      this.digest = _arg.digest;
    }

    MDC.parse = function(buf) {
      return (new MDC_Parser(buf)).parse();
    };

    return MDC;

  })(Packet);

  MDC_Parser = (function() {
    function MDC_Parser(buf) {
      this.buf = buf;
      this.header = new Buffer([0xc0 | C.packet_tags.MDC, SHA1.output_length]);
    }

    MDC_Parser.prototype.parse = function() {
      var chunk, digest, hl, len;
      hl = this.header.length;
      len = SHA1.output_length + hl;
      this._rem = this.buf.slice(0, -len);
      chunk = this.buf.slice(-len);
      if (!bufeq_fast(chunk.slice(0, hl), this.header)) {
        throw new Error('Missing MDC header');
      }
      digest = chunk.slice(hl);
      return new MDC({
        digest: digest
      });
    };

    MDC_Parser.prototype.rem = function() {
      return this._rem;
    };

    return MDC_Parser;

  })();

  SEIPD_Parser = (function() {
    function SEIPD_Parser(slice) {
      this.slice = slice;
    }

    SEIPD_Parser.prototype.payload_split = function(raw) {};

    SEIPD_Parser.prototype.parse = function() {
      var ciphertext, v;
      if ((v = this.slice.read_uint8()) !== C.versions.SEIPD) {
        throw new Error("Unknown SEIPD version " + v);
      }
      ciphertext = this.slice.consume_rest_to_buffer();
      return new SEIPD({
        ciphertext: ciphertext
      });
    };

    return SEIPD_Parser;

  })();

  PKESK_Parser = (function() {
    function PKESK_Parser(slice) {
      this.slice = slice;
    }

    PKESK_Parser.prototype.parse = function() {
      var crypto_type, ekey, key_id, klass, v;
      if ((v = this.slice.read_uint8()) !== C.versions.PKESK) {
        throw new Error("Unknown PKESK version: " + v);
      }
      key_id = this.slice.read_buffer(8);
      crypto_type = this.slice.read_uint8();
      klass = asymmetric.get_class(crypto_type);
      ekey = klass.parse_output(this.slice.consume_rest_to_buffer());
      return new PKESK({
        crypto_type: crypto_type,
        key_id: key_id,
        ekey: ekey
      });
    };

    return PKESK_Parser;

  })();

  exports.SEIPD = SEIPD;

  exports.PKESK = PKESK;

  exports.MDC = MDC;

}).call(this);
