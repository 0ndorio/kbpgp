// Generated by IcedCoffeeScript 1.7.1-c
(function() {
  var C, OPS_Parser, OnePassSignature, Packet, PacketParser, XbtIn, XbtOut, asymmetric, hash, iced, make_esc, uint_to_buffer, xbt, __iced_k, __iced_k_noop,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  iced = require('iced-runtime').iced;
  __iced_k = __iced_k_noop = function() {};

  Packet = require('./base').Packet;

  C = require('../../const').openpgp;

  asymmetric = require('../../asymmetric');

  hash = require('../../hash');

  uint_to_buffer = require('../../util').uint_to_buffer;

  xbt = require('../../xbt');

  make_esc = require('iced-error').make_esc;

  PacketParser = require('./xbt_depacketizer').PacketParser;

  OnePassSignature = (function(_super) {
    __extends(OnePassSignature, _super);

    OnePassSignature.TAG = C.packet_tags.one_pass_sig;

    OnePassSignature.prototype.TAG = OnePassSignature.TAG;

    function OnePassSignature(_arg) {
      this.sig_type = _arg.sig_type, this.hasher = _arg.hasher, this.sig_klass = _arg.sig_klass, this.key_id = _arg.key_id, this.is_final = _arg.is_final;
    }

    OnePassSignature.parse = function(slice) {
      return (new OPS_Parser(slice)).parse();
    };

    OnePassSignature.prototype.new_xbt = function(_arg) {
      var literal, sig;
      sig = _arg.sig, literal = _arg.literal;
      return new XbtOut({
        header: this,
        footer: sig,
        literal: literal
      });
    };

    OnePassSignature.prototype.write_unframed = function(cb) {
      var bufs, unframed, vals, x;
      vals = [C.versions.one_pass_sig, this.sig_type, this.hasher.type, this.sig_klass.type];
      bufs = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = vals.length; _i < _len; _i++) {
          x = vals[_i];
          _results.push(uint_to_buffer(8, x));
        }
        return _results;
      })();
      bufs.push(this.key_id);
      bufs.push(uint_to_buffer(8, this.is_final));
      unframed = Buffer.concat(bufs);
      return cb(null, unframed);
    };

    return OnePassSignature;

  })(Packet);

  OPS_Parser = (function() {
    function OPS_Parser(slice) {
      this.slice = slice;
    }

    OPS_Parser.prototype.parse = function() {
      var hasher, is_final, key_id, sig_klass, sig_type, version;
      version = this.slice.read_uint8();
      sig_type = this.slice.read_uint8();
      hasher = this.slice.read_uint8();
      sig_klass = this.slice.read_uint8();
      key_id = this.slice.read_buffer(8);
      is_final = this.slice.read_uint8();
      return OPS_Parser._alloc({
        version: version,
        sig_type: sig_type,
        hasher: hasher,
        sig_klass: sig_klass,
        key_id: key_id,
        is_final: is_final
      });
    };

    OPS_Parser._alloc = function(_arg) {
      var hasher, is_final, key_id, sig_klass, sig_type, streaming, version;
      version = _arg.version, sig_type = _arg.sig_type, hasher = _arg.hasher, sig_klass = _arg.sig_klass, key_id = _arg.key_id, is_final = _arg.is_final, streaming = _arg.streaming;
      if (version !== C.versions.one_pass_sig) {
        throw new Error("Unknown OnePassSignature version " + version);
      }
      hasher = hash.alloc_or_throw(hasher, streaming);
      sig_klass = asymmetric.get_class(sig_klass);
      return new OnePassSignature({
        sig_type: sig_type,
        hasher: hasher,
        sig_klass: sig_klass,
        key_id: key_id,
        is_final: is_final
      });
    };

    OPS_Parser.alloc = function(args, cb) {
      var e, err, ret;
      ret = err = null;
      try {
        ret = this._alloc(args);
      } catch (_error) {
        e = _error;
        err = e;
      }
      return cb(err, ret);
    };

    return OPS_Parser;

  })();

  exports.OnePassSignature = OnePassSignature;

  exports.XbtOut = XbtOut = (function(_super) {
    __extends(XbtOut, _super);

    function XbtOut(_arg) {
      var literal;
      this.header = _arg.header, this.footer = _arg.footer, literal = _arg.literal;
      XbtOut.__super__.constructor.call(this);
      this._literal_xbt = literal.new_xbt();
    }

    XbtOut.prototype._v_init = function(cb) {
      var buf, err, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      (function(_this) {
        return (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/home/max/src/keybase/kbpgp/src/openpgp/packet/one_pass_sig.iced",
            funcname: "XbtOut._v_init"
          });
          _this.header.write(__iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                err = arguments[0];
                return buf = arguments[1];
              };
            })(),
            lineno: 97
          }));
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          return cb(err, buf);
        };
      })(this));
    };

    XbtOut.prototype._v_chunk = function(_arg, cb) {
      var b, bufs, data, eof, esc, ftr, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      data = _arg.data, eof = _arg.eof;
      esc = make_esc(cb, "XbtOut");
      if (data != null) {
        this.footer.hasher.update(data);
      }
      bufs = [];
      (function(_this) {
        return (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/home/max/src/keybase/kbpgp/src/openpgp/packet/one_pass_sig.iced",
            funcname: "XbtOut._v_chunk"
          });
          _this._literal_xbt.chunk({
            data: data,
            eof: eof
          }, esc(__iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                return b = arguments[0];
              };
            })(),
            lineno: 104
          })));
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          if (typeof b !== "undefined" && b !== null) {
            bufs.push(b);
          }
          (function(__iced_k) {
            if (eof) {
              (function(__iced_k) {
                __iced_deferrals = new iced.Deferrals(__iced_k, {
                  parent: ___iced_passed_deferral,
                  filename: "/home/max/src/keybase/kbpgp/src/openpgp/packet/one_pass_sig.iced",
                  funcname: "XbtOut._v_chunk"
                });
                _this.footer.write(new Buffer([]), esc(__iced_deferrals.defer({
                  assign_fn: (function() {
                    return function() {
                      return ftr = arguments[0];
                    };
                  })(),
                  lineno: 107
                })));
                __iced_deferrals._fulfill();
              })(function() {
                return __iced_k(bufs.push(ftr));
              });
            } else {
              return __iced_k();
            }
          })(function() {
            return cb(null, Buffer.concat(bufs));
          });
        };
      })(this));
    };

    return XbtOut;

  })(xbt.SimpleInit);

  exports.XbtIn = XbtIn = (function(_super) {
    __extends(XbtIn, _super);

    function XbtIn(arg) {
      XbtIn.__super__.constructor.call(this, arg);
    }

    XbtIn.prototype.xbt_type = function() {
      return "OnePassSignature.XbtIn";
    };

    XbtIn.prototype._parse_header = function(cb) {
      var aargs, err, esc, hasher, is_final, key_id, packet, sig_klass, sig_type, version, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      err = null;
      esc = make_esc(cb, "_parse_header");
      (function(_this) {
        return (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/home/max/src/keybase/kbpgp/src/openpgp/packet/one_pass_sig.iced",
            funcname: "XbtIn._parse_header"
          });
          _this._read_uint8(esc(__iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                return version = arguments[0];
              };
            })(),
            lineno: 123
          })));
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          (function(__iced_k) {
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              filename: "/home/max/src/keybase/kbpgp/src/openpgp/packet/one_pass_sig.iced",
              funcname: "XbtIn._parse_header"
            });
            _this._read_uint8(esc(__iced_deferrals.defer({
              assign_fn: (function() {
                return function() {
                  return sig_type = arguments[0];
                };
              })(),
              lineno: 124
            })));
            __iced_deferrals._fulfill();
          })(function() {
            (function(__iced_k) {
              __iced_deferrals = new iced.Deferrals(__iced_k, {
                parent: ___iced_passed_deferral,
                filename: "/home/max/src/keybase/kbpgp/src/openpgp/packet/one_pass_sig.iced",
                funcname: "XbtIn._parse_header"
              });
              _this._read_uint8(esc(__iced_deferrals.defer({
                assign_fn: (function() {
                  return function() {
                    return hasher = arguments[0];
                  };
                })(),
                lineno: 125
              })));
              __iced_deferrals._fulfill();
            })(function() {
              (function(__iced_k) {
                __iced_deferrals = new iced.Deferrals(__iced_k, {
                  parent: ___iced_passed_deferral,
                  filename: "/home/max/src/keybase/kbpgp/src/openpgp/packet/one_pass_sig.iced",
                  funcname: "XbtIn._parse_header"
                });
                _this._read_uint8(esc(__iced_deferrals.defer({
                  assign_fn: (function() {
                    return function() {
                      return sig_klass = arguments[0];
                    };
                  })(),
                  lineno: 126
                })));
                __iced_deferrals._fulfill();
              })(function() {
                (function(__iced_k) {
                  __iced_deferrals = new iced.Deferrals(__iced_k, {
                    parent: ___iced_passed_deferral,
                    filename: "/home/max/src/keybase/kbpgp/src/openpgp/packet/one_pass_sig.iced",
                    funcname: "XbtIn._parse_header"
                  });
                  _this._read({
                    exactly: 8
                  }, esc(__iced_deferrals.defer({
                    assign_fn: (function() {
                      return function() {
                        return key_id = arguments[0];
                      };
                    })(),
                    lineno: 127
                  })));
                  __iced_deferrals._fulfill();
                })(function() {
                  (function(__iced_k) {
                    __iced_deferrals = new iced.Deferrals(__iced_k, {
                      parent: ___iced_passed_deferral,
                      filename: "/home/max/src/keybase/kbpgp/src/openpgp/packet/one_pass_sig.iced",
                      funcname: "XbtIn._parse_header"
                    });
                    _this._read_uint8(esc(__iced_deferrals.defer({
                      assign_fn: (function() {
                        return function() {
                          return is_final = arguments[0];
                        };
                      })(),
                      lineno: 128
                    })));
                    __iced_deferrals._fulfill();
                  })(function() {
                    aargs = {
                      streaming: true,
                      version: version,
                      sig_type: sig_type,
                      hasher: hasher,
                      sig_klass: sig_klass,
                      key_id: key_id,
                      is_final: is_final
                    };
                    (function(__iced_k) {
                      __iced_deferrals = new iced.Deferrals(__iced_k, {
                        parent: ___iced_passed_deferral,
                        filename: "/home/max/src/keybase/kbpgp/src/openpgp/packet/one_pass_sig.iced",
                        funcname: "XbtIn._parse_header"
                      });
                      OPS_Parser.alloc(aargs, esc(__iced_deferrals.defer({
                        assign_fn: (function() {
                          return function() {
                            return packet = arguments[0];
                          };
                        })(),
                        lineno: 130
                      })));
                      __iced_deferrals._fulfill();
                    })(function() {
                      _this.get_root().push_hasher(packet.hasher);
                      console.log("all done, got packet ->");
                      console.log(packet);
                      console.log(_this._inq);
                      (function(__iced_k) {
                        __iced_deferrals = new iced.Deferrals(__iced_k, {
                          parent: ___iced_passed_deferral,
                          filename: "/home/max/src/keybase/kbpgp/src/openpgp/packet/one_pass_sig.iced",
                          funcname: "XbtIn._parse_header"
                        });
                        _this.set_root_metadata({
                          slice: 'ops',
                          value: packet
                        }, esc(__iced_deferrals.defer({
                          lineno: 135
                        })));
                        __iced_deferrals._fulfill();
                      })(function() {
                        return cb(null);
                      });
                    });
                  });
                });
              });
            });
          });
        };
      })(this));
    };

    XbtIn.prototype._run_body = function(cb) {
      return cb(null);
    };

    return XbtIn;

  })(PacketParser);

}).call(this);
