// Generated by IcedCoffeeScript 1.6.3-g
(function() {
  var C, OPS_Parser, OnePassSignature, Packet, asymmetric, hash,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };



  Packet = require('./base').Packet;

  C = require('../../const').openpgp;

  asymmetric = require('../../asymmetric');

  hash = require('../../hash');

  OnePassSignature = (function(_super) {
    __extends(OnePassSignature, _super);

    function OnePassSignature(_arg) {
      this.sig_type = _arg.sig_type, this.hasher = _arg.hasher, this.sig_klass = _arg.sig_klass, this.key_id = _arg.key_id, this.is_nested = _arg.is_nested;
    }

    OnePassSignature.parse = function(slice) {
      return (new OPS_Parser(slice)).parse();
    };

    return OnePassSignature;

  })(Packet);

  OPS_Parser = (function() {
    function OPS_Parser(slice) {
      this.slice = slice;
    }

    OPS_Parser.prototype.parse = function() {
      var hasher, is_nested, key_id, sig_klass, sig_type, v;
      if ((v = this.slice.read_uint8()) !== C.versions.one_pass_sig) {
        throw new Error("Unknown OnePassSignature version " + v);
      }
      sig_type = this.slice.read_uint8();
      hasher = hash.alloc_or_throw(this.slice.read_uint8());
      sig_klass = asymmetric.get_class(this.slice.read_uint8());
      key_id = this.slice.read_buffer(8);
      is_nested = this.slice.read_uint8();
      return new OnePassSignature({
        sig_type: sig_type,
        hasher: hasher,
        sig_klass: sig_klass,
        key_id: key_id,
        is_nested: is_nested
      });
    };

    return OPS_Parser;

  })();

  exports.OnePassSignature = OnePassSignature;

}).call(this);
