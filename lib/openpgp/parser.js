// Generated by IcedCoffeeScript 1.7.1-c
(function() {
  var C, Compressed, Demux, DemuxSequence, Depacketizer, Generic, KeyMaterial, Literal, MessageParser, OnePassSignature, PKESK, PacketParser, SEIPD, Signature, SlicerBuffer, UserAttribute, UserID, iced, inspect, parse, util, xbt, __iced_k, __iced_k_noop, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  iced = require('iced-runtime').iced;
  __iced_k = __iced_k_noop = function() {};

  util = require('../util');

  SlicerBuffer = require('./buffer').SlicerBuffer;

  C = require('../const').openpgp;

  KeyMaterial = require('./packet/keymaterial').KeyMaterial;

  Signature = require('./packet/signature').Signature;

  _ref = require('./packet/sess'), SEIPD = _ref.SEIPD, PKESK = _ref.PKESK;

  UserID = require('./packet/userid').UserID;

  UserAttribute = require('./packet/user_attribute').UserAttribute;

  Compressed = require('./packet/compressed').Compressed;

  Generic = require('./packet/generic').Generic;

  OnePassSignature = require('./packet/one_pass_sig').OnePassSignature;

  Literal = require('./packet/literal').Literal;

  inspect = require('util').inspect;

  xbt = require('../xbt');

  Depacketizer = require('./packet/xbt_depacketizer').Depacketizer;

  MessageParser = (function() {
    function MessageParser(slice) {
      this.slice = slice;
    }

    MessageParser.prototype.parse = function() {
      var _results;
      _results = [];
      while (this.slice.rem()) {
        _results.push(this.parse_packet());
      }
      return _results;
    };

    MessageParser.prototype.parse_packet = function() {
      return (new PacketParser(this.slice)).parse();
    };

    return MessageParser;

  })();

  PacketParser = (function() {
    function PacketParser(slice) {
      this.slice = slice;
      this.body = null;
      this.real_packet_len = null;
      this.tag = null;
      this.len = null;
      this.header_len = null;
    }

    PacketParser.prototype.parse_header = function() {
      this.parse_tag_and_len();
      this.header_len || (this.header_len = this.slice.offset());
      this.body || (this.body = new SlicerBuffer(this.slice.read_buffer(this.len)));
      this.real_packet_len || (this.real_packet_len = this.len);
      return this.slice.unclamp();
    };

    PacketParser.prototype.parse = function() {
      var ret;
      this.parse_header();
      ret = this.parse_body();
      return ret;
    };

    PacketParser.prototype.parse_body = function() {
      var packet, pt, raw, sb;
      pt = C.packet_tags;
      sb = this.body;
      raw = sb.peek_rest_to_buffer();
      packet = (function() {
        switch (this.tag) {
          case pt.PKESK:
            return PKESK.parse(sb);
          case pt.one_pass_sig:
            return OnePassSignature.parse(sb);
          case pt.secret_key:
            return KeyMaterial.parse_private_key(sb, {
              subkey: false
            });
          case pt.secret_subkey:
            return KeyMaterial.parse_private_key(sb, {
              subkey: true
            });
          case pt.public_key:
            return KeyMaterial.parse_public_key(sb, {
              subkey: false
            });
          case pt.public_subkey:
            return KeyMaterial.parse_public_key(sb, {
              subkey: true
            });
          case pt.signature:
            return Signature.parse(sb);
          case pt.userid:
            return UserID.parse(sb);
          case pt.user_attribute:
            return UserAttribute.parse(sb);
          case pt.SEIPD:
            return SEIPD.parse(sb);
          case pt.literal:
            return Literal.parse(sb);
          case pt.compressed:
            return Compressed.parse(sb);
          default:
            return new Generic(this.tag, sb);
        }
      }).call(this);
      packet.set({
        tag: this.tag,
        real_packet_len: this.real_packet_len,
        header_len: this.header_len,
        raw: raw
      });
      return packet;
    };

    PacketParser.prototype.parse_tag_and_len = function() {
      var c;
      if (this.slice.len() < 2 || ((c = this.slice.read_uint8()) & 0x80) === 0) {
        throw new Error("This doesn't look like a binary PGP packet (c=" + c + ")");
      }
      if ((c & 0x40) === 0) {
        return this.parse_tag_and_len_old(c);
      } else {
        return this.parse_tag_and_len_new(c);
      }
    };

    PacketParser.prototype.parse_tag_and_len_old = function(c) {
      this.tag = (c & 0x3f) >> 2;
      return this.len = (function() {
        switch (c & 0x03) {
          case 0:
            return this.slice.read_uint8();
          case 1:
            return this.slice.read_uint16();
          case 2:
            return this.slice.read_uint32();
          case 3:
            return this.slice.rem();
        }
      }).call(this);
    };

    PacketParser.prototype.parse_tag_and_len_new = function(c) {
      var ret;
      this.tag = c & 0x3f;
      ret = this.parse_tag_len_new();
      return ret;
    };

    PacketParser.prototype.parse_tag_len_new = function() {
      var c, d, go, lastlen, packet_length, segments;
      go = true;
      segments = [];
      this.len = 0;
      lastlen = 0;
      while (go) {
        go = false;
        c = this.slice.read_uint8();
        lastlen = c < 192 ? c : c === 255 ? this.slice.read_uint32() : c < 224 ? (d = this.slice.read_uint8(), ((c - 192) << 8) + (d + 192)) : (this.header_len || (this.header_len = this.slice.offset()), packet_length = 1 << (c & 0x1f), segments.push(this.slice.read_buffer(packet_length)), go = true, packet_length);
        this.len += lastlen;
      }
      if (segments.length) {
        segments.push(this.slice.read_buffer(lastlen));
        this.body = new SlicerBuffer(Buffer.concat(segments));
        this.len = this.body.length;
        return this.real_packet_len = this.slice.offset();
      }
    };

    return PacketParser;

  })();

  exports.DemuxSequence = DemuxSequence = (function(_super) {
    __extends(DemuxSequence, _super);

    function DemuxSequence() {
      return DemuxSequence.__super__.constructor.apply(this, arguments);
    }

    DemuxSequence.prototype.run = function(cb) {
      var d, esc, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      esc = make_esc(cb, "DemuxSequence::_process");
      (function(_this) {
        return (function(__iced_k) {
          var _results, _while;
          _results = [];
          _while = function(__iced_k) {
            var _break, _continue, _next;
            _break = function() {
              return __iced_k(_results);
            };
            _continue = function() {
              return iced.trampoline(function() {
                return _while(__iced_k);
              });
            };
            _next = function(__iced_next_arg) {
              _results.push(__iced_next_arg);
              return _continue();
            };
            if (!!_this._is_eof()) {
              return _break();
            } else {
              d = new Demux({});
              (function(__iced_k) {
                __iced_deferrals = new iced.Deferrals(__iced_k, {
                  parent: ___iced_passed_deferral,
                  filename: "/home/max/src/keybase/kbpgp/src/openpgp/parser.iced",
                  funcname: "DemuxSequence.run"
                });
                _this._stream_to(d, esc(__iced_deferrals.defer({
                  lineno: 138
                })));
                __iced_deferrals._fulfill();
              })(_next);
            }
          };
          _while(__iced_k);
        });
      })(this)((function(_this) {
        return function() {
          return cb(null);
        };
      })(this));
    };

    return DemuxSequence;

  })(xbt.PullBase);

  exports.Demux = Demux = (function(_super) {
    __extends(Demux, _super);

    function Demux() {
      return Demux.__super__.constructor.apply(this, arguments);
    }

    Demux.prototype.run = function(cb) {
      var b, esc, next, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      esc = make_esc(cb, "Demux::_process");
      (function(_this) {
        return (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/home/max/src/keybase/kbpgp/src/openpgp/parser.iced",
            funcname: "Demux.run"
          });
          _this._peek(1, esc(__iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                return b = arguments[0];
              };
            })(),
            lineno: 149
          })));
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          (function(__iced_k) {
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              filename: "/home/max/src/keybase/kbpgp/src/openpgp/parser.iced",
              funcname: "Demux.run"
            });
            _this._demux(b[0], esc(__iced_deferrals.defer({
              assign_fn: (function() {
                return function() {
                  return next = arguments[0];
                };
              })(),
              lineno: 150
            })));
            __iced_deferrals._fulfill();
          })(function() {
            (function(__iced_k) {
              __iced_deferrals = new iced.Deferrals(__iced_k, {
                parent: ___iced_passed_deferral,
                filename: "/home/max/src/keybase/kbpgp/src/openpgp/parser.iced",
                funcname: "Demux.run"
              });
              _this._stream_to(next, esc(__iced_deferrals.defer({
                lineno: 151
              })));
              __iced_deferrals._fulfill();
            })(function() {
              return cb(null);
            });
          });
        };
      })(this));
    };

    Demux.prototype._demux = function(c, cb) {
      var PT, depacketizer_xbt, err, klass, packet_version, packet_xbt, tag;
      err = xbt = packet_version = null;
      if (((c = data.readUInt8(0)) & 0x80) === 0) {
        err = new Error("This doesn't look like a binary PGP packet (c=" + c + ")");
      } else if ((c & 0x40) === 0) {
        tag = (c & 0x3f) >> 2;
        packet_version = C.packet_version.old;
      } else {
        tag = c & 0x3f;
        packet_version = C.packet_version.modern;
      }
      if (tag != null) {
        PT = C.packet_tags;
        klass = (function() {
          switch (tag) {
            case PT.literal:
              return Literal;
            case PT.compressed:
              return Compressed;
            default:
              return err = new Error("Can't stream packet type=" + tag);
          }
        })();
      } else if (eof) {
        err = new Error("EOF when looking for a new PGP packet");
      }
      if (klass != null) {
        depacketizer_xbt = new Depacketizer({
          packet_version: packet_version
        });
        packet_xbt = klass.new_xbt_parser({});
        xbt = new PullChain([depacketizer_xbt, packet_xbt]);
      }
      return cb(err, xbt, data);
    };

    return Demux;

  })(xbt.PullBase);

  exports.parse = parse = function(buf) {
    return util.katch(function() {
      return (new MessageParser(new SlicerBuffer(buf))).parse();
    });
  };

}).call(this);
