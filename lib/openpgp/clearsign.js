// Generated by IcedCoffeeScript 1.7.0-a
(function() {
  var C, ClearSigner, CreationTime, Issuer, SHA512, SRF, Signature, WordArray, clearsign_header, encode, export_key_pgp, get_cipher, iced, make_esc, scrub_buffer, triplesec, unix_time, __iced_k, __iced_k_noop, _ref, _ref1;

  iced = require('iced-coffee-script/lib/coffee-script/iced').runtime;
  __iced_k = __iced_k_noop = function() {};

  make_esc = require('iced-error').make_esc;

  _ref = require('./packet/signature'), Signature = _ref.Signature, CreationTime = _ref.CreationTime, Issuer = _ref.Issuer;

  unix_time = require('../util').unix_time;

  SRF = require('../rand').SRF;

  triplesec = require('triplesec');

  _ref1 = require('../symmetric'), export_key_pgp = _ref1.export_key_pgp, get_cipher = _ref1.get_cipher;

  scrub_buffer = triplesec.util.scrub_buffer;

  WordArray = triplesec.WordArray;

  C = require('../const').openpgp;

  SHA512 = require('../hash').SHA512;

  encode = require('./armor').encode;

  clearsign_header = require('pgp-utils').armor.clearsign_header;

  ClearSigner = (function() {
    var _fix_msg;

    function ClearSigner(_arg) {
      this.msg = _arg.msg, this.signing_key = _arg.signing_key;
      this.packets = [];
    }

    _fix_msg = function(cb) {
      var m, parts, txt;
      m = this.msg.toString('utf8');
      parts = m.split(/\n\r?/);
      if (parts.slice(-1)[0] !== '') {
        parts.push('');
      }
      txt = parts.join("\n\r");
      this.msg = new Buffer(txt, 'utf8');
      return cb(null);
    };

    ClearSigner.prototype._sign_msg = function(cb) {
      var err, fp, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      this.sig = new Signature({
        sig_type: C.sig_types.canonical_text,
        key: this.signing_key.key,
        hashed_subpackets: [new CreationTime(unix_time())],
        unhashed_subpackets: [new Issuer(this.signing_key.get_key_id())]
      });
      (function(_this) {
        return (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/Users/max/src/kbpgp/src/openpgp/clearsign.iced",
            funcname: "ClearSigner._sign_msg"
          });
          _this.sig.write(_this.msg, __iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                err = arguments[0];
                return fp = arguments[1];
              };
            })(),
            lineno: 50
          }));
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          if (typeof err === "undefined" || err === null) {
            _this.packets.push(fp);
          }
          return cb(err);
        };
      })(this));
    };

    ClearSigner.prototype.scrub = function() {};

    ClearSigner.prototype.hasher_name = function() {
      return this.sig.hasher.name;
    };

    ClearSigner.prototype.run = function(cb) {
      var esc, output, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      esc = make_esc(cb, "ClearSigner::run");
      (function(_this) {
        return (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/Users/max/src/kbpgp/src/openpgp/clearsign.iced",
            funcname: "ClearSigner.run"
          });
          _this._fix_msg(esc(__iced_deferrals.defer({
            lineno: 66
          })));
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          (function(__iced_k) {
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              filename: "/Users/max/src/kbpgp/src/openpgp/clearsign.iced",
              funcname: "ClearSigner.run"
            });
            _this._sign_msg(esc(__iced_deferrals.defer({
              lineno: 67
            })));
            __iced_deferrals._fulfill();
          })(function() {
            output = Buffer.concat(_this.packets);
            return cb(null, output);
          });
        };
      })(this));
    };

    return ClearSigner;

  })();

  exports.clearsign = function(_arg, cb) {
    var b, body, err, hdr, msg, raw, signing_key, ___iced_passed_deferral, __iced_deferrals, __iced_k;
    __iced_k = __iced_k_noop;
    ___iced_passed_deferral = iced.findDeferral(arguments);
    msg = _arg.msg, signing_key = _arg.signing_key;
    b = new ClearSigner({
      msg: msg,
      signing_key: signing_key
    });
    (function(_this) {
      return (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: "/Users/max/src/kbpgp/src/openpgp/clearsign.iced",
          funcname: "clearsign"
        });
        b.run(__iced_deferrals.defer({
          assign_fn: (function() {
            return function() {
              err = arguments[0];
              return raw = arguments[1];
            };
          })(),
          lineno: 79
        }));
        __iced_deferrals._fulfill();
      });
    })(this)((function(_this) {
      return function() {
        if ((typeof err === "undefined" || err === null) && (typeof raw !== "undefined" && raw !== null)) {
          hdr = clearsign_header(C, msg, b.hasher_name());
          body = encode(C.message_types.signature, raw);
        }
        return cb(err, hdr + body, raw);
      };
    })(this));
  };

}).call(this);
