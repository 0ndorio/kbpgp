// Generated by IcedCoffeeScript 1.7.1-b
(function() {
  var EncryptionEngine, Engine, SignatureEngine, burn, iced, processor, __iced_k, __iced_k_noop,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  iced = require('iced-coffee-script/lib/coffee-script/iced').runtime;
  __iced_k = __iced_k_noop = function() {};

  burn = require('./burner').burn;

  processor = require('./processor');

  Engine = (function() {
    function Engine(_arg) {
      this.km = _arg.km;
    }

    Engine.prototype.get_km = function() {
      return this.km;
    };

    Engine.prototype.unbox = function(msg, cb) {
      var eng;
      eng = new processor.Message(this.km);
      return eng.parse_and_process({
        body: msg.body
      }, cb);
    };

    Engine.prototype._box = function(_arg, cb) {
      var do_sign, encryption_key, err, msg, out, signing_key, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      msg = _arg.msg, encryption_key = _arg.encryption_key, do_sign = _arg.do_sign;
      out = {};
      signing_key = null;
      err = null;
      if (do_sign && ((signing_key = this.km.find_signing_pgp_key()) == null)) {
        err = new Error("No signing key found");
      }
      (function(_this) {
        return (function(__iced_k) {
          if (err == null) {
            (function(__iced_k) {
              __iced_deferrals = new iced.Deferrals(__iced_k, {
                parent: ___iced_passed_deferral,
                filename: "/Users/max/src/keybase/kbpgp/src/openpgp/hilev.iced",
                funcname: "Engine._box"
              });
              burn({
                msg: msg,
                signing_key: signing_key,
                encryption_key: encryption_key
              }, __iced_deferrals.defer({
                assign_fn: (function(__slot_1, __slot_2) {
                  return function() {
                    err = arguments[0];
                    __slot_1.pgp = arguments[1];
                    return __slot_2.raw = arguments[2];
                  };
                })(out, out),
                lineno: 28
              }));
              __iced_deferrals._fulfill();
            })(__iced_k);
          } else {
            return __iced_k();
          }
        });
      })(this)((function(_this) {
        return function() {
          return cb(err, out);
        };
      })(this));
    };

    return Engine;

  })();

  exports.SignatureEngine = SignatureEngine = (function(_super) {
    __extends(SignatureEngine, _super);

    function SignatureEngine() {
      return SignatureEngine.__super__.constructor.apply(this, arguments);
    }

    SignatureEngine.prototype.box = function(msg, cb) {
      return this._box({
        msg: msg,
        do_sign: true
      }, cb);
    };

    return SignatureEngine;

  })(Engine);

  exports.EncryptionEngine = EncryptionEngine = (function(_super) {
    __extends(EncryptionEngine, _super);

    function EncryptionEngine() {
      return EncryptionEngine.__super__.constructor.apply(this, arguments);
    }

    EncryptionEngine.prototype.box = function(d, cb) {
      return this._box(d, cb);
    };

    return EncryptionEngine;

  })(Engine);

}).call(this);
