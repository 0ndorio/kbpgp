// Generated by IcedCoffeeScript 1.6.3-g
(function() {
  var K, SHA256, alloc, bdecode, bencode, bufeq_secure, null_hash, pack, purepack, unpack, _ref;



  K = require('../const').kb;

  _ref = require('../hash'), alloc = _ref.alloc, SHA256 = _ref.SHA256;

  purepack = require('purepack');

  bufeq_secure = require('../util').bufeq_secure;

  null_hash = new Buffer(0);

  pack = function(x) {
    return purepack.pack(x, {
      sort_keys: true
    });
  };

  unpack = function(x) {
    return purepack.unpack(x);
  };

  bencode = function(type, obj) {
    var hasher, oo, packed;
    hasher = SHA256;
    oo = {
      version: K.versions.V1,
      type: type,
      body: obj,
      hash: {
        type: hasher.type,
        value: null_hash
      }
    };
    packed = pack(oo);
    oo.hash.value = hasher(packed);
    return pack(oo);
  };

  bdecode = function(buf) {
    var e, err, h, hasher, hv, oo, ret, t, _ref1;
    ret = null;
    err = null;
    try {
      oo = unpack(buf);
      if ((hv = oo != null ? (_ref1 = oo.hash) != null ? _ref1.value : void 0 : void 0) == null) {
        throw new Error("missing obj.hash.value");
      }
      oo.hash.value = null_hash;
      hasher = alloc((t = oo.hash.type));
      if (hasher == null) {
        throw new Error("unknown hash algo: " + t);
      }
      h = hasher(pack(oo));
      if (!bufeq_secure(h, hv)) {
        throw new Error("hash mismatch");
      }
      if (oo.version !== K.versions.V1) {
        throw new Error("unknown version");
      }
      ret = [oo.type, oo.body];
    } catch (_error) {
      e = _error;
      err = e;
    }
    return [err, ret];
  };

  exports.bencode = bencode;

  exports.pack = pack;

  exports.unpack = unpack;

  exports.bdecode = bdecode;

}).call(this);
