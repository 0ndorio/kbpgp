// Generated by IcedCoffeeScript 1.6.3-g
(function() {
  var C, Encryption, Engine, K, KeyBlock, KeyManager, KeybaseEngine, Lifespan, PgpEngine, Primary, RSA, Subkey, UserIds, box, bufeq_secure, bufferify, decode, encode, iced, kpkts, make_esc, opkts, parse, read_base64, unbox, unix_time, __iced_k, __iced_k_noop, _ref, _ref1, _ref2, _ref3,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  iced = require('iced-coffee-script/lib/coffee-script/iced').runtime;
  __iced_k = __iced_k_noop = function() {};

  RSA = require('./rsa').RSA;

  K = require('./const').kb;

  C = require('./const').openpgp;

  make_esc = require('iced-error').make_esc;

  _ref = require('./util'), bufeq_secure = _ref.bufeq_secure, unix_time = _ref.unix_time, bufferify = _ref.bufferify;

  _ref1 = require('./keywrapper'), UserIds = _ref1.UserIds, Lifespan = _ref1.Lifespan, Subkey = _ref1.Subkey, Primary = _ref1.Primary;

  _ref2 = require('./keybase/encode'), read_base64 = _ref2.read_base64, box = _ref2.box, unbox = _ref2.unbox;

  _ref3 = require('./openpgp/armor'), encode = _ref3.encode, decode = _ref3.decode;

  parse = require('./openpgp/parser').parse;

  KeyBlock = require('./openpgp/processor').KeyBlock;

  opkts = require('./openpgp/packet/all');

  kpkts = require('./keybase/packet/all');

  Encryption = (function() {
    function Encryption(_arg) {
      var passphrase;
      this.tsenc = _arg.tsenc, passphrase = _arg.passphrase;
      this.passphrase = bufferify(passphrase);
      this.tsenc || (this.tsenc = new triplesec.Encryptor({
        version: 2,
        passphrase: this.passphrase
      }));
    }

    return Encryption;

  })();

  Engine = (function() {
    function Engine(_arg) {
      this.primary = _arg.primary, this.subkeys = _arg.subkeys, this.userids = _arg.userids;
      this.packets = [];
      this.messages = [];
      this._allocate_key_packets();
    }

    Engine.prototype.ekid = function(k) {
      return this.key(k).ekid();
    };

    Engine.prototype._allocate_key_packets = function() {
      var key, _i, _len, _ref4, _results;
      _ref4 = this._all_keys();
      _results = [];
      for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
        key = _ref4[_i];
        _results.push(this._v_allocate_key_packet(key));
      }
      return _results;
    };

    Engine.prototype._all_keys = function() {
      return [this.primary].concat(this.subkeys);
    };

    Engine.prototype.self_sign_primary = function(args, cb) {
      return this._v_self_sign_primary(args, cb);
    };

    Engine.prototype.sign_subkeys = function(_arg, cb) {
      var asp, err, subkey, ___iced_passed_deferral, __iced_deferrals, __iced_k,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      asp = _arg.asp;
      err = null;
      (function(__iced_k) {
        var _i, _len, _ref4, _results, _while;
        _ref4 = _this.subkeys;
        _len = _ref4.length;
        _i = 0;
        _results = [];
        _while = function(__iced_k) {
          var _break, _continue, _next;
          _break = function() {
            return __iced_k(_results);
          };
          _continue = function() {
            return iced.trampoline(function() {
              ++_i;
              return _while(__iced_k);
            });
          };
          _next = function(__iced_next_arg) {
            _results.push(__iced_next_arg);
            return _continue();
          };
          if (!(_i < _len)) {
            return _break();
          } else {
            subkey = _ref4[_i];
            if (err == null) {
              (function(__iced_k) {
                __iced_deferrals = new iced.Deferrals(__iced_k, {
                  parent: ___iced_passed_deferral,
                  filename: "src/keymanager.iced",
                  funcname: "Engine.sign_subkeys"
                });
                _this._v_sign_subkey({
                  asp: asp,
                  subkey: subkey
                }, __iced_deferrals.defer({
                  assign_fn: (function() {
                    return function() {
                      return err = arguments[0];
                    };
                  })(),
                  lineno: 57
                }));
                __iced_deferrals._fulfill();
              })(_next);
            } else {
              return _continue();
            }
          }
        };
        _while(__iced_k);
      })(function() {
        return cb(err);
      });
    };

    Engine.prototype.is_locked = function() {
      var i, k, _i, _len, _ref4;
      _ref4 = this._all_keys();
      for (i = _i = 0, _len = _ref4.length; _i < _len; i = ++_i) {
        k = _ref4[i];
        if (this.key(k).is_locked()) {
          return true;
        }
      }
      return false;
    };

    Engine.prototype.has_private = function() {
      var k, _i, _len, _ref4;
      _ref4 = this._all_keys();
      for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
        k = _ref4[_i];
        if (!this.key(k).has_private()) {
          return false;
        }
      }
      return true;
    };

    Engine.prototype.sign = function(_arg, cb) {
      var asp, err, ___iced_passed_deferral, __iced_deferrals, __iced_k,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      asp = _arg.asp;
      (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: "src/keymanager.iced",
          funcname: "Engine.sign"
        });
        _this.self_sign_primary({
          asp: asp
        }, __iced_deferrals.defer({
          assign_fn: (function() {
            return function() {
              return err = arguments[0];
            };
          })(),
          lineno: 77
        }));
        __iced_deferrals._fulfill();
      })(function() {
        (function(__iced_k) {
          if (typeof err === "undefined" || err === null) {
            (function(__iced_k) {
              __iced_deferrals = new iced.Deferrals(__iced_k, {
                parent: ___iced_passed_deferral,
                filename: "src/keymanager.iced",
                funcname: "Engine.sign"
              });
              _this.sign_subkeys({
                asp: asp
              }, __iced_deferrals.defer({
                assign_fn: (function() {
                  return function() {
                    return err = arguments[0];
                  };
                })(),
                lineno: 78
              }));
              __iced_deferrals._fulfill();
            })(__iced_k);
          } else {
            return __iced_k();
          }
        })(function() {
          return cb(err);
        });
      });
    };

    Engine.prototype.merge_private = function(eng2) {
      var err, i, key, _i, _len, _ref4;
      err = null;
      if (!this.key(eng2.primary).has_private()) {
        err = new Error("Expected a private key; got a public key!");
      } else if (!this._merge_1_private(this.primary, eng2.primary)) {
        err = new Error("primary public key doesn't match private key");
      } else if (this.subkeys.length !== eng2.subkeys.length) {
        err = new Error("Different number of subkeys");
      } else {
        _ref4 = this.subkeys;
        for (i = _i = 0, _len = _ref4.length; _i < _len; i = ++_i) {
          key = _ref4[i];
          if (err == null) {
            if (!this.key(eng2.subkeys[i]).has_private()) {
              err = new Error("Subkey " + i + " doesn't have a private key");
            } else if (!this._merge_1_private(key, eng2.subkeys[i])) {
              err = new Error("Subkey " + i + " doesn't match its public key");
            }
          }
        }
      }
      return err;
    };

    Engine.prototype.unlock_keys = function(_arg, cb) {
      var asp, esc, passphrase, subkey, tsenc, ___iced_passed_deferral, __iced_deferrals, __iced_k,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      asp = _arg.asp, passphrase = _arg.passphrase, tsenc = _arg.tsenc;
      esc = make_esc(cb, "Engine::unlock_keys");
      (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: "src/keymanager.iced",
          funcname: "Engine.unlock_keys"
        });
        _this.key(_this.primary).unlock({
          asp: asp,
          tsenc: tsenc,
          passphrase: passphrase
        }, esc(__iced_deferrals.defer({
          lineno: 103
        })));
        __iced_deferrals._fulfill();
      })(function() {
        (function(__iced_k) {
          var _i, _len, _ref4, _results, _while;
          _ref4 = _this.subkeys;
          _len = _ref4.length;
          _i = 0;
          _results = [];
          _while = function(__iced_k) {
            var _break, _continue, _next;
            _break = function() {
              return __iced_k(_results);
            };
            _continue = function() {
              return iced.trampoline(function() {
                ++_i;
                return _while(__iced_k);
              });
            };
            _next = function(__iced_next_arg) {
              _results.push(__iced_next_arg);
              return _continue();
            };
            if (!(_i < _len)) {
              return _break();
            } else {
              subkey = _ref4[_i];
              (function(__iced_k) {
                __iced_deferrals = new iced.Deferrals(__iced_k, {
                  parent: ___iced_passed_deferral,
                  filename: "src/keymanager.iced",
                  funcname: "Engine.unlock_keys"
                });
                _this.key(subkey).unlock({
                  asp: asp,
                  tsenc: tsenc,
                  passphrase: passphrase
                }, esc(__iced_deferrals.defer({
                  lineno: 105
                })));
                __iced_deferrals._fulfill();
              })(_next);
            }
          };
          _while(__iced_k);
        })(function() {
          return cb(null);
        });
      });
    };

    Engine.prototype._merge_1_private = function(k1, k2) {
      if (bufeq_secure(this.ekid(k1), this.ekid(k2))) {
        this.key(k1).merge_private(this.key(k2));
        return true;
      } else {
        return false;
      }
    };

    return Engine;

  })();

  PgpEngine = (function(_super) {
    __extends(PgpEngine, _super);

    function PgpEngine(_arg) {
      var primary, subkeys, userids;
      primary = _arg.primary, subkeys = _arg.subkeys, userids = _arg.userids;
      PgpEngine.__super__.constructor.call(this, {
        primary: primary,
        subkeys: subkeys,
        userids: userids
      });
    }

    PgpEngine.prototype.key = function(k) {
      return k._pgp;
    };

    PgpEngine.prototype._v_allocate_key_packet = function(key) {
      if (key._pgp == null) {
        return key._pgp = new opkts.KeyMaterial({
          key: key.key,
          timestamp: key.lifespan.generated,
          userid: this.userids.get_openpgp()
        });
      }
    };

    PgpEngine.prototype.userid_packet = function() {
      if (this._uidp == null) {
        this._uidp = new opkts.UserID(this.userids.get_openpgp());
      }
      return this._uidp;
    };

    PgpEngine.prototype._v_self_sign_primary = function(_arg, cb) {
      var asp, err, ___iced_passed_deferral, __iced_deferrals, __iced_k,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      asp = _arg.asp;
      (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: "src/keymanager.iced",
          funcname: "PgpEngine._v_self_sign_primary"
        });
        _this.primary._pgp.self_sign_key({
          lifespan: _this.primary.lifespan,
          uidp: _this.userid_packet()
        }, __iced_deferrals.defer({
          assign_fn: (function(__slot_1) {
            return function() {
              err = arguments[0];
              return __slot_1.self_sig = arguments[1];
            };
          })(_this),
          lineno: 148
        }));
        __iced_deferrals._fulfill();
      })(function() {
        return cb(err);
      });
    };

    PgpEngine.prototype._v_sign_subkey = function(_arg, cb) {
      var asp, err, sig, subkey, ___iced_passed_deferral, __iced_deferrals, __iced_k,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      asp = _arg.asp, subkey = _arg.subkey;
      (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: "src/keymanager.iced",
          funcname: "PgpEngine._v_sign_subkey"
        });
        _this.primary._pgp.sign_subkey({
          subkey: subkey._pgp,
          lifespan: subkey.lifespan
        }, __iced_deferrals.defer({
          assign_fn: (function() {
            return function() {
              err = arguments[0];
              return sig = arguments[1];
            };
          })(),
          lineno: 154
        }));
        __iced_deferrals._fulfill();
      })(function() {
        subkey._pgp_sig = sig;
        return cb(err);
      });
    };

    PgpEngine.prototype.set_passphrase = function(pp) {
      var k, _i, _len, _ref4, _results;
      this.primary.passphrase = pp;
      _ref4 = this.subkeys;
      _results = [];
      for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
        k = _ref4[_i];
        _results.push(k.passphrase = pp);
      }
      return _results;
    };

    PgpEngine.prototype.export_keys = function(opts) {
      var buf, mt, packets, subkey, type, _i, _len, _ref4;
      packets = [this.primary._pgp.export_framed(opts), this.userid_packet().write(), this.self_sig];
      opts.subkey = true;
      _ref4 = this.subkeys;
      for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
        subkey = _ref4[_i];
        packets.push(subkey._pgp.export_framed(opts), subkey._pgp_sig);
      }
      buf = Buffer.concat(packets);
      mt = C.message_types;
      type = opts["private"] ? mt.private_key : mt.public_key;
      return encode(type, Buffer.concat(packets));
    };

    return PgpEngine;

  })(Engine);

  KeybaseEngine = (function(_super) {
    __extends(KeybaseEngine, _super);

    function KeybaseEngine(_arg) {
      var primary, subkeys, userids;
      primary = _arg.primary, subkeys = _arg.subkeys, userids = _arg.userids;
      KeybaseEngine.__super__.constructor.call(this, {
        primary: primary,
        subkeys: subkeys,
        userids: userids
      });
    }

    KeybaseEngine.prototype.key = function(k) {
      return k._keybase;
    };

    KeybaseEngine.prototype._check_can_sign = function(keys, cb) {
      var err, k, _i, _len;
      err = null;
      for (_i = 0, _len = keys.length; _i < _len; _i++) {
        k = keys[_i];
        if (err == null) {
          if (!k.key.can_sign()) {
            err = new Error("cannot sign; don't have private key");
          }
        }
      }
      return cb(err);
    };

    KeybaseEngine.prototype._v_allocate_key_packet = function(key) {
      if (key._keybase == null) {
        return key._keybase = new kpkts.KeyMaterial({
          key: key.key,
          timestamp: key.lifespan.generated
        });
      }
    };

    KeybaseEngine.prototype._v_self_sign_primary = function(_arg, cb) {
      var asp, esc, p, ___iced_passed_deferral, __iced_deferrals, __iced_k,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      asp = _arg.asp;
      esc = make_esc(cb, "KeybaseEngine::_v_self_sign_primary");
      (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: "src/keymanager.iced",
          funcname: "KeybaseEngine._v_self_sign_primary"
        });
        _this._check_can_sign([_this.primary], esc(__iced_deferrals.defer({
          lineno: 208
        })));
        __iced_deferrals._fulfill();
      })(function() {
        p = new kpkts.SelfSign({
          key_wrapper: _this.primary,
          userid: _this.userids.get_keybase()
        });
        (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "src/keymanager.iced",
            funcname: "KeybaseEngine._v_self_sign_primary"
          });
          p.sign({
            asp: asp,
            include_body: true
          }, esc(__iced_deferrals.defer({
            assign_fn: (function(__slot_1) {
              return function() {
                return __slot_1.self_sig = arguments[0];
              };
            })(_this),
            lineno: 210
          })));
          __iced_deferrals._fulfill();
        })(function() {
          return cb(null);
        });
      });
    };

    KeybaseEngine.prototype._v_sign_subkey = function(_arg, cb) {
      var asp, esc, p, subkey, ___iced_passed_deferral, __iced_deferrals, __iced_k,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      asp = _arg.asp, subkey = _arg.subkey;
      esc = make_esc(cb, "KeybaseEngine::_v_sign_subkey");
      subkey._keybase_sigs = {};
      (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: "src/keymanager.iced",
          funcname: "KeybaseEngine._v_sign_subkey"
        });
        _this._check_can_sign([_this.primary, subkey], esc(__iced_deferrals.defer({
          lineno: 218
        })));
        __iced_deferrals._fulfill();
      })(function() {
        p = new kpkts.Subkey({
          primary: _this.primary,
          subkey: subkey
        });
        (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "src/keymanager.iced",
            funcname: "KeybaseEngine._v_sign_subkey"
          });
          p.sign({
            asp: asp,
            include_body: true
          }, esc(__iced_deferrals.defer({
            assign_fn: (function(__slot_1) {
              return function() {
                return __slot_1.fwd = arguments[0];
              };
            })(subkey._keybase_sigs),
            lineno: 220
          })));
          __iced_deferrals._fulfill();
        })(function() {
          p = new kpkts.SubkeyReverse({
            primary: _this.primary,
            subkey: subkey
          });
          (function(__iced_k) {
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              filename: "src/keymanager.iced",
              funcname: "KeybaseEngine._v_sign_subkey"
            });
            p.sign({
              asp: asp,
              include_body: true
            }, esc(__iced_deferrals.defer({
              assign_fn: (function(__slot_1) {
                return function() {
                  return __slot_1.rev = arguments[0];
                };
              })(subkey._keybase_sigs),
              lineno: 222
            })));
            __iced_deferrals._fulfill();
          })(function() {
            return cb(null);
          });
        });
      });
    };

    KeybaseEngine.prototype.export_keys = function(opts, cb) {
      var esc, k, key, primary, ret, ___iced_passed_deferral, __iced_deferrals, __iced_k,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      opts.tag = opts["private"] ? K.packet_tags.private_key_bundle : K.packet_tags.public_key_bundle;
      ret = new kpkts.KeyBundle.alloc(opts);
      esc = make_esc(cb, "KeybaseEngine::export_keys");
      (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: "src/keymanager.iced",
          funcname: "KeybaseEngine.export_keys"
        });
        _this.primary._keybase.export_key(opts, esc(__iced_deferrals.defer({
          assign_fn: (function() {
            return function() {
              return primary = arguments[0];
            };
          })(),
          lineno: 231
        })));
        __iced_deferrals._fulfill();
      })(function() {
        ret.set_primary({
          key: primary,
          sig: _this.self_sig
        });
        (function(__iced_k) {
          var _i, _len, _ref4, _results, _while;
          _ref4 = _this.subkeys;
          _len = _ref4.length;
          _i = 0;
          _results = [];
          _while = function(__iced_k) {
            var _break, _continue, _next;
            _break = function() {
              return __iced_k(_results);
            };
            _continue = function() {
              return iced.trampoline(function() {
                ++_i;
                return _while(__iced_k);
              });
            };
            _next = function(__iced_next_arg) {
              _results.push(__iced_next_arg);
              return _continue();
            };
            if (!(_i < _len)) {
              return _break();
            } else {
              k = _ref4[_i];
              (function(__iced_k) {
                __iced_deferrals = new iced.Deferrals(__iced_k, {
                  parent: ___iced_passed_deferral,
                  filename: "src/keymanager.iced",
                  funcname: "KeybaseEngine.export_keys"
                });
                k._keybase.export_key(opts, esc(__iced_deferrals.defer({
                  assign_fn: (function() {
                    return function() {
                      return key = arguments[0];
                    };
                  })(),
                  lineno: 237
                })));
                __iced_deferrals._fulfill();
              })(function() {
                return _next(ret.push_subkey({
                  key: key,
                  sigs: {
                    forward: k._keybase_sigs.fwd,
                    reverse: k._keybase_sigs.rev
                  }
                }));
              });
            }
          };
          _while(__iced_k);
        })(function() {
          return cb(null, ret.frame_packet());
        });
      });
    };

    return KeybaseEngine;

  })(Engine);

  KeyManager = (function() {
    function KeyManager(_arg) {
      this.primary = _arg.primary, this.subkeys = _arg.subkeys, this.userids = _arg.userids, this.armored_pgp_public = _arg.armored_pgp_public, this.armored_pgp_private = _arg.armored_pgp_private;
      this.pgp = new PgpEngine({
        primary: this.primary,
        subkeys: this.subkeys,
        userids: this.userids
      });
      this.keybase = new KeybaseEngine({
        primary: this.primary,
        subkeys: this.subkeys,
        userids: this.userids
      });
      this.engines = [this.pgp, this.keybase];
      this._signed = false;
    }

    KeyManager.generate = function(_arg, cb) {
      var asp, bundle, esc, generated, i, key, lifespan, nbits, nsubs, primary, subkeys, userid, userids, ___iced_passed_deferral, __iced_deferrals, __iced_k,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      asp = _arg.asp, nsubs = _arg.nsubs, userid = _arg.userid, nbits = _arg.nbits;
      userids = new UserIds({
        keybase: userid,
        openpgp: userid
      });
      generated = unix_time();
      esc = make_esc(cb, "KeyManager::generate");
      asp.section("primary");
      (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: "src/keymanager.iced",
          funcname: "KeyManager.generate"
        });
        RSA.generate({
          asp: asp,
          nbits: nbits || K.key_defaults.primary.nbits
        }, esc(__iced_deferrals.defer({
          assign_fn: (function() {
            return function() {
              return key = arguments[0];
            };
          })(),
          lineno: 266
        })));
        __iced_deferrals._fulfill();
      })(function() {
        lifespan = new Lifespan({
          generated: generated,
          expire_in: K.key_defaults.primary.expire_in
        });
        primary = new Primary({
          key: key,
          lifespan: lifespan
        });
        subkeys = [];
        lifespan = new Lifespan({
          generated: generated,
          expire_in: K.key_defaults.sub.expire_in
        });
        (function(__iced_k) {
          var _i, _results, _while;
          i = 0;
          _results = [];
          _while = function(__iced_k) {
            var _break, _continue, _next;
            _break = function() {
              return __iced_k(_results);
            };
            _continue = function() {
              return iced.trampoline(function() {
                ++i;
                return _while(__iced_k);
              });
            };
            _next = function(__iced_next_arg) {
              _results.push(__iced_next_arg);
              return _continue();
            };
            if (!(i < nsubs)) {
              return _break();
            } else {

              asp.section("subkey " + (i + 1));
              (function(__iced_k) {
                __iced_deferrals = new iced.Deferrals(__iced_k, {
                  parent: ___iced_passed_deferral,
                  filename: "src/keymanager.iced",
                  funcname: "KeyManager.generate"
                });
                RSA.generate({
                  asp: asp,
                  nbits: nbits || K.key_defaults.sub.nbits
                }, esc(__iced_deferrals.defer({
                  assign_fn: (function() {
                    return function() {
                      return key = arguments[0];
                    };
                  })(),
                  lineno: 273
                })));
                __iced_deferrals._fulfill();
              })(function() {
                return _next(subkeys.push(new Subkey({
                  key: key,
                  desc: "subkey " + i,
                  primary: primary,
                  lifespan: lifespan
                })));
              });
            }
          };
          _while(__iced_k);
        })(function() {
          bundle = new KeyManager({
            primary: primary,
            subkeys: subkeys,
            userids: userids
          });
          return cb(null, bundle);
        });
      });
    };

    KeyManager.prototype.set_enc = function(e) {
      return this.tsenc = e;
    };

    KeyManager.import_from_armored_pgp = function(_arg, cb) {
      var asp, bundle, err, k, kb, msg, packets, raw, userid, userids, ___iced_passed_deferral, __iced_deferrals, __iced_k, _ref4, _ref5, _ref6,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      raw = _arg.raw, asp = _arg.asp, userid = _arg.userid;
      _ref4 = decode(raw), err = _ref4[0], msg = _ref4[1];
      if (err == null) {
        if (!((_ref5 = msg.type) === C.message_types.public_key || _ref5 === C.message_types.private_key)) {
          err = new Error("Wanted a public or private key; got: " + msg.type);
        }
      }
      bundle = null;
      if (err == null) {
        _ref6 = parse(msg.body), err = _ref6[0], packets = _ref6[1];
      }
      (function(__iced_k) {
        if (err == null) {
          kb = new KeyBlock(packets);
          (function(__iced_k) {
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              filename: "src/keymanager.iced",
              funcname: "KeyManager.import_from_armored_pgp"
            });
            kb.process(__iced_deferrals.defer({
              assign_fn: (function() {
                return function() {
                  return err = arguments[0];
                };
              })(),
              lineno: 301
            }));
            __iced_deferrals._fulfill();
          })(__iced_k);
        } else {
          return __iced_k();
        }
      })(function() {
        if (err == null) {
          userids = new UserIds({
            openpgp: kb.userid,
            keybase: userid
          });
          bundle = new KeyManager({
            primary: KeyManager._wrap_pgp(Primary, kb.primary),
            subkeys: (function() {
              var _i, _len, _ref7, _results;
              _ref7 = kb.subkeys;
              _results = [];
              for (_i = 0, _len = _ref7.length; _i < _len; _i++) {
                k = _ref7[_i];
                _results.push(KeyManager._wrap_pgp(Subkey, k));
              }
              return _results;
            })(),
            armored_pgp_public: raw,
            userids: userids
          });
        }
        return cb(err, bundle);
      });
    };

    KeyManager.import_from_packed_keybase = function(_arg, cb) {
      var asp, bundle, err, raw, ret, tag_and_body, ___iced_passed_deferral, __iced_deferrals, __iced_k, _ref4, _ref5,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      raw = _arg.raw, asp = _arg.asp;
      _ref4 = unbox(read_base64(raw)), err = _ref4[0], tag_and_body = _ref4[1];
      if (err == null) {
        _ref5 = kpkts.KeyBundle.alloc_nothrow(tag_and_body), err = _ref5[0], bundle = _ref5[1];
      }
      (function(__iced_k) {
        if (err == null) {
          (function(__iced_k) {
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              filename: "src/keymanager.iced",
              funcname: "KeyManager.import_from_packed_keybase"
            });
            bundle.verify({
              asp: asp
            }, __iced_deferrals.defer({
              assign_fn: (function() {
                return function() {
                  return err = arguments[0];
                };
              })(),
              lineno: 317
            }));
            __iced_deferrals._fulfill();
          })(__iced_k);
        } else {
          return __iced_k();
        }
      })(function() {
        ret = err != null ? null : new KeyManager(bundle.export_to_obj());
        return cb(err, ret);
      });
    };

    KeyManager.prototype.merge_pgp_private = function(_arg, cb) {
      var asp, b2, err, raw, ___iced_passed_deferral, __iced_deferrals, __iced_k,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      raw = _arg.raw, asp = _arg.asp;
      (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: "src/keymanager.iced",
          funcname: "KeyManager.merge_pgp_private"
        });
        KeyManager.import_from_armored_pgp({
          raw: raw,
          asp: asp
        }, __iced_deferrals.defer({
          assign_fn: (function() {
            return function() {
              err = arguments[0];
              return b2 = arguments[1];
            };
          })(),
          lineno: 327
        }));
        __iced_deferrals._fulfill();
      })(function() {
        if (typeof err === "undefined" || err === null) {
          err = _this.pgp.merge_private(b2.pgp);
        }
        return cb(err);
      });
    };

    KeyManager.prototype.unlock_pgp = function(_arg, cb) {
      var err, passphrase, ___iced_passed_deferral, __iced_deferrals, __iced_k,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      passphrase = _arg.passphrase;
      (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: "src/keymanager.iced",
          funcname: "KeyManager.unlock_pgp"
        });
        _this.pgp.unlock_keys({
          passphrase: passphrase
        }, __iced_deferrals.defer({
          assign_fn: (function() {
            return function() {
              return err = arguments[0];
            };
          })(),
          lineno: 336
        }));
        __iced_deferrals._fulfill();
      })(function() {
        return cb(err);
      });
    };

    KeyManager.prototype.is_pgp_locked = function() {
      return this.pgp.is_locked();
    };

    KeyManager.prototype.is_keybase_locked = function() {
      return this.keybase.is_locked();
    };

    KeyManager.prototype.has_pgp_private = function() {
      return this.pgp.has_private();
    };

    KeyManager.prototype.has_keybase_private = function() {
      return this.keybase.has_private();
    };

    KeyManager.prototype.unlock_keybase = function(_arg, cb) {
      var asp, err, tsenc, ___iced_passed_deferral, __iced_deferrals, __iced_k,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      tsenc = _arg.tsenc, asp = _arg.asp;
      (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: "src/keymanager.iced",
          funcname: "KeyManager.unlock_keybase"
        });
        _this.keybase.unlock_keys({
          tsenc: tsenc,
          asp: asp
        }, __iced_deferrals.defer({
          assign_fn: (function() {
            return function() {
              return err = arguments[0];
            };
          })(),
          lineno: 351
        }));
        __iced_deferrals._fulfill();
      })(function() {
        return cb(err);
      });
    };

    KeyManager.prototype.export_private_to_server = function(_arg, cb) {
      var asp, err, keybase, pgp, ret, tsenc, ___iced_passed_deferral, __iced_deferrals, __iced_k,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      tsenc = _arg.tsenc, asp = _arg.asp;
      err = ret = null;
      (function(__iced_k) {
        if ((err = _this._assert_signed()) == null) {
          pgp = _this.pgp.export_keys({
            "private": false
          });
          (function(__iced_k) {
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              filename: "src/keymanager.iced",
              funcname: "KeyManager.export_private_to_server"
            });
            _this.keybase.export_keys({
              "private": true,
              tsenc: tsenc,
              asp: asp
            }, __iced_deferrals.defer({
              assign_fn: (function() {
                return function() {
                  err = arguments[0];
                  return keybase = arguments[1];
                };
              })(),
              lineno: 363
            }));
            __iced_deferrals._fulfill();
          })(__iced_k);
        } else {
          return __iced_k();
        }
      })(function() {
        ret = err != null ? null : {
          pgp: pgp,
          keybase: box(keybase).toString('base64')
        };
        return cb(err, ret);
      });
    };

    KeyManager.prototype.export_pgp_private_to_client = function(_arg, cb) {
      var asp, err, msg, passphrase, regen;
      passphrase = _arg.passphrase, asp = _arg.asp, regen = _arg.regen;
      err = msg = null;
      if (passphrase != null) {
        passphrase = bufferify(passphrase);
      }
      if ((regen == null) && (msg = this.armored_pgp_private)) {

      } else if ((err = this._assert_signed()) == null) {
        msg = this.pgp.export_keys({
          "private": true,
          passphrase: passphrase
        });
      }
      return cb(err, msg);
    };

    KeyManager.prototype.export_pgp_public = function(_arg, cb) {
      var asp, msg, regen;
      asp = _arg.asp, regen = _arg.regen;
      if (!regen) {
        msg = this.armored_pgp_public;
      }
      if (msg == null) {
        msg = this.pgp.export_keys({
          "private": false
        });
      }
      return cb(null, msg);
    };

    KeyManager.prototype.sign_pgp = function(_arg, cb) {
      var asp;
      asp = _arg.asp;
      return this.pgp.sign({
        asp: asp
      }, cb);
    };

    KeyManager.prototype.sign_keybase = function(_arg, cb) {
      var asp;
      asp = _arg.asp;
      return this.keybase.sign({
        asp: asp
      }, cb);
    };

    KeyManager.prototype.sign = function(_arg, cb) {
      var asp, err, ___iced_passed_deferral, __iced_deferrals, __iced_k,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      asp = _arg.asp;
      if (asp != null) {
        asp.section("sign");
      }
      if (asp != null) {
        asp.progress({
          what: "sign PGP",
          total: 1,
          i: 0
        });
      }
      (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: "src/keymanager.iced",
          funcname: "KeyManager.sign"
        });
        _this.sign_pgp({
          asp: asp
        }, __iced_deferrals.defer({
          assign_fn: (function() {
            return function() {
              return err = arguments[0];
            };
          })(),
          lineno: 398
        }));
        __iced_deferrals._fulfill();
      })(function() {
        if (asp != null) {
          asp.progress({
            what: "sign PGP",
            total: 1,
            i: 1
          });
        }
        if (asp != null) {
          asp.progress({
            what: "sign keybase",
            total: 1,
            i: 0
          });
        }
        (function(__iced_k) {
          if (typeof err === "undefined" || err === null) {
            (function(__iced_k) {
              __iced_deferrals = new iced.Deferrals(__iced_k, {
                parent: ___iced_passed_deferral,
                filename: "src/keymanager.iced",
                funcname: "KeyManager.sign"
              });
              _this.sign_keybase({
                asp: asp
              }, __iced_deferrals.defer({
                assign_fn: (function() {
                  return function() {
                    return err = arguments[0];
                  };
                })(),
                lineno: 401
              }));
              __iced_deferrals._fulfill();
            })(__iced_k);
          } else {
            return __iced_k();
          }
        })(function() {
          if (asp != null) {
            asp.progress({
              what: "sign keybase",
              total: 1,
              i: 1
            });
          }
          if (typeof err === "undefined" || err === null) {
            _this._signed = true;
          }
          return cb(err);
        });
      });
    };

    KeyManager.prototype._apply_to_engines = function(_arg, cb) {
      var args, e, err, meth, ___iced_passed_deferral, __iced_deferrals, __iced_k,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      args = _arg.args, meth = _arg.meth;
      err = null;
      (function(__iced_k) {
        var _i, _len, _ref4, _results, _while;
        _ref4 = _this.engines;
        _len = _ref4.length;
        _i = 0;
        _results = [];
        _while = function(__iced_k) {
          var _break, _continue, _next;
          _break = function() {
            return __iced_k(_results);
          };
          _continue = function() {
            return iced.trampoline(function() {
              ++_i;
              return _while(__iced_k);
            });
          };
          _next = function(__iced_next_arg) {
            _results.push(__iced_next_arg);
            return _continue();
          };
          if (!(_i < _len)) {
            return _break();
          } else {
            e = _ref4[_i];
            if (!err) {
              (function(__iced_k) {
                __iced_deferrals = new iced.Deferrals(__iced_k, {
                  parent: ___iced_passed_deferral,
                  filename: "src/keymanager.iced",
                  funcname: "KeyManager._apply_to_engines"
                });
                meth.call(e, args, __iced_deferrals.defer({
                  assign_fn: (function() {
                    return function() {
                      return err = arguments[0];
                    };
                  })(),
                  lineno: 412
                }));
                __iced_deferrals._fulfill();
              })(_next);
            } else {
              return _continue();
            }
          }
        };
        _while(__iced_k);
      })(function() {
        return cb(err);
      });
    };

    KeyManager.prototype._assert_signed = function() {
      if (this._signed) {
        return null;
      } else {
        return new Error("need to sign before export");
      }
    };

    KeyManager._wrap_pgp = function(klass, kmp) {
      return new klass({
        key: kmp.key,
        lifespan: new Lifespan({
          generated: kmp.timestamp
        }),
        _pgp: kmp
      });
    };

    return KeyManager;

  })();

  exports.KeyManager = KeyManager;

  exports.Encryption = Encryption;

  exports.UserIds = UserIds;

}).call(this);
