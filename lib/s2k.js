// Generated by IcedCoffeeScript 1.6.3-g
(function() {
  var C, S2K, SHA256, alloc, triplesec, _ref;



  triplesec = require('triplesec');

  C = require('./const').openpgp;

  _ref = require('./hash'), alloc = _ref.alloc, SHA256 = _ref.SHA256;

  S2K = (function() {
    S2K.prototype._count = function(c, bias) {
      return (16 + (c & 15)) << ((c >> 4) + bias);
    };

    function S2K() {
      this.hash = SHA256;
    }

    S2K.prototype.set_hash_algorithm = function(which) {
      if ((this.hash = alloc(which)) == null) {
        console.warn("No such hash: " + which + "; defaulting to SHA-256");
        return this.hash = SHA256;
      }
    };

    S2K.prototype.read = function(input, position) {
      var c, gnuExtType, match, mypos;
      mypos = position;
      this.type = input.readUInt8(mypos++);
      match = false;
      switch (this.type) {
        case 0:
          this.set_hash_algorithm(input.readUInt8(mypos++));
          this.s2kLength = 1;
          match = true;
          break;
        case 1:
          this.set_hash_algorithm(input.readUInt8(mypos++));
          this.salt = input.slice(mypos, mypos + 8);
          mypos += 8;
          this.s2kLength = 9;
          match = true;
          break;
        case 3:
          this.set_hash_algorithm(input.readUInt8(mypos++));
          this.salt = input.slice(mypos, mypos + 8);
          mypos += 8;
          this.s2kLength = 9;
          this.EXPBIAS = 6;
          c = input.readUInt8(mypos++);
          this.count = this._count(c, this.EXPBIAS);
          this.s2kLength = 10;
          match = true;
          break;
        case 101:
          if (input.slice(mypos + 1, mypos + 4) === "GNU") {
            this.set_hash_algorithm(input.readUInt8(mypos++));
            mypos += 3;
            gnuExtType = 1000 + input.readUInt8(mypos++);
            match = true;
            if (gnuExtType === 1001) {
              this.type = gnuExtType;
              this.s2kLength = 5;
            } else {
              console.warn("unknown s2k gnu protection mode! " + gnuExtType);
            }
          }
      }
      if (!match) {
        console.warn("unknown s2k type! " + this.type);
        return null;
      } else {
        return this;
      }
    };

    S2K.prototype.write = function(passphrase, salt, c) {
      var type;
      this.type = type = 3;
      this.salt = salt;
      this.count = this._count(c, 6);
      this.s2kLength = 10;
      return this.produce_key(passphrase);
    };

    S2K.prototype.produce_key = function(passphrase, numBytes) {
      var i, isp, key, n, ret, seed;
      ret = (function() {
        switch (this.type) {
          case C.s2k.plain:
            return this.hash(passphrase);
          case C.s2k.salt:
            return this.hash(Buffer.concat([this.salt, passphrase]));
          case C.s2k.salt_iter:
            seed = Buffer.concat([this.salt, passphrase]);
            n = Math.ceil(this.count / seed.length);
            isp = Buffer.concat((function() {
              var _i, _results;
              _results = [];
              for (i = _i = 0; 0 <= n ? _i < n : _i > n; i = 0 <= n ? ++_i : --_i) {
                _results.push(seed);
              }
              return _results;
            })()).slice(0, this.count);
            if ((numBytes != null) && (numBytes === 24 || numBytes === 32)) {
              key = this.hash(isp);
              return Buffer.concat([key, this.hash(Buffer.concat([new Buffer([0]), isp]))]);
            } else {
              return this.hash(isp);
            }
            break;
          default:
            return null;
        }
      }).call(this);
      return ret;
    };

    return S2K;

  })();

  exports.S2K = S2K;

}).call(this);
