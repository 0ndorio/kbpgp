// Generated by IcedCoffeeScript 1.6.3-g
(function() {
  var ASP, C, RSA, UserID, encode, encoding, generate_keypair, iced, kbkm, make_esc, make_time_packet, msg, openpgp, openpgpkm, packet, test, triplesec, uint_to_buffer, unix_time, util, __iced_k, __iced_k_noop, _generate_keypair, _ref, _ref1;

  iced = require('iced-coffee-script/lib/coffee-script/iced').runtime;
  __iced_k = __iced_k_noop = function() {};

  RSA = require('./rsa').RSA;

  triplesec = require('triplesec');

  _ref = require('openpgp'), util = _ref.util, openpgp = _ref.openpgp, packet = _ref.packet, msg = _ref.msg, encoding = _ref.encoding;

  _ref1 = require('./util'), unix_time = _ref1.unix_time, ASP = _ref1.ASP, uint_to_buffer = _ref1.uint_to_buffer, make_time_packet = _ref1.make_time_packet;

  C = require('./const').openpgp;

  make_esc = require('iced-error').make_esc;

  UserID = require('./packet/userid').UserID;

  openpgpkm = require('./packet/keymaterial');

  kbkm = require('./kbpacket/keymaterial');

  encode = require('./encode/armor').encode;

  generate_keypair = function(_arg, cb) {
    var asp, delay, nbits, passphrase, progress_hook, userid;
    nbits = _arg.nbits, userid = _arg.userid, progress_hook = _arg.progress_hook, delay = _arg.delay, passphrase = _arg.passphrase;
    asp = new ASP({
      progress_hook: progress_hook,
      delay: delay
    });
    _generate_keypair({
      nbits: nbits,
      userid: userid,
      asp: asp,
      passphrase: passphrase
    }, cb);
    return asp.canceler();
  };

  _generate_keypair = function(_arg, cb) {
    var asp, esc, k, key, nbits, o, passphrase, ret, timestamp, userid, ___iced_passed_deferral, __iced_deferrals, __iced_k,
      _this = this;
    __iced_k = __iced_k_noop;
    ___iced_passed_deferral = iced.findDeferral(arguments);
    nbits = _arg.nbits, asp = _arg.asp, userid = _arg.userid, passphrase = _arg.passphrase;
    esc = make_esc(cb, "KeyFactor::_generate_keypair");
    (function(__iced_k) {
      __iced_deferrals = new iced.Deferrals(__iced_k, {
        parent: ___iced_passed_deferral,
        filename: "src/keygen.iced",
        funcname: "_generate_keypair"
      });
      RSA.generate({
        nbits: nbits,
        asp: asp
      }, esc(__iced_deferrals.defer({
        assign_fn: (function() {
          return function() {
            return key = arguments[0];
          };
        })(),
        lineno: 46
      })));
      __iced_deferrals._fulfill();
    })(function() {
      timestamp = unix_time();
      o = new openpgpkm.KeyMaterial({
        key: key,
        timestamp: timestamp,
        userid: userid,
        passphrase: passphrase
      });
      k = new kbkm.KeyMaterial({
        key: key,
        timestamp: timestamp,
        userid: userid,
        passphrase: passphrase
      });
      ret = {};
      (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: "src/keygen.iced",
          funcname: "_generate_keypair"
        });
        o.export_keys({}, esc(__iced_deferrals.defer({
          assign_fn: (function(__slot_1) {
            return function() {
              return __slot_1.openpgp = arguments[0];
            };
          })(ret),
          lineno: 55
        })));
        __iced_deferrals._fulfill();
      })(function() {
        (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "src/keygen.iced",
            funcname: "_generate_keypair"
          });
          k.export_keys({
            progress_hook: asp.progress_hook()
          }, esc(__iced_deferrals.defer({
            assign_fn: (function(__slot_1) {
              return function() {
                return __slot_1.keybase = arguments[0];
              };
            })(ret),
            lineno: 56
          })));
          __iced_deferrals._fulfill();
        })(function() {
          return cb(null, ret);
        });
      });
    });
  };

  test = function() {
    var err, key, progress_hook, res, ___iced_passed_deferral, __iced_deferrals, __iced_k,
      _this = this;
    __iced_k = __iced_k_noop;
    ___iced_passed_deferral = iced.findDeferral(arguments);
    progress_hook = function(obj) {
      var interval, s;
      if (obj.p != null) {
        s = obj.p.toString();
        s = "" + s.slice(0, 3) + "...." + s.slice(s.length - 6);
      } else {
        s = "";
      }
      interval = (obj.total != null) && (obj.i != null) ? "(" + obj.i + " of " + obj.total + ")" : "";
      return console.warn("+ " + obj.what + " " + interval + " " + s);
    };
    (function(__iced_k) {
      __iced_deferrals = new iced.Deferrals(__iced_k, {
        parent: ___iced_passed_deferral,
        filename: "src/keygen.iced",
        funcname: "test"
      });
      generate_keypair({
        nbits: 4096,
        userid: new Buffer('Rerl'),
        progress_hook: progress_hook,
        passphrase: new Buffer("asdfqwer")
      }, __iced_deferrals.defer({
        assign_fn: (function() {
          return function() {
            err = arguments[0];
            return res = arguments[1];
          };
        })(),
        lineno: 73
      }));
      __iced_deferrals._fulfill();
    })(function() {
      console.log(res.openpgp["private"]);
      console.log(res.openpgp["public"]);
      console.log(res.keybase["private"].toString('hex'));
      process.exit(0);
      openpgp.init();
      (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: "src/keygen.iced",
          funcname: "test"
        });
        generate_keypair({
          nbits: 4096,
          progress_hook: progress_hook,
          userid: "Max Krohn <max@keybase.io>",
          passphrase: "ejjejjee"
        }, __iced_deferrals.defer({
          assign_fn: (function() {
            return function() {
              err = arguments[0];
              return key = arguments[1];
            };
          })(),
          lineno: 79
        }));
        __iced_deferrals._fulfill();
      })(function() {
        return console.log(key);
      });
    });
  };

  exports.generate_keypair = generate_keypair;

}).call(this);
