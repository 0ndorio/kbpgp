// Generated by IcedCoffeeScript 1.6.3-g
(function() {
  var ASP, BigInteger, C, Pair, Priv, Pub, RSA, SHA512, bn, bufeq_secure, emsa_pkcs1_decode, emsa_pkcs1_encode, iced, make_esc, nbi, nbs, nbv, random_prime, __iced_k, __iced_k_noop, _ref, _ref1, _ref2, _ref3;

  iced = require('iced-coffee-script/lib/coffee-script/iced').runtime;
  __iced_k = __iced_k_noop = function() {};

  _ref = require('./primegen'), random_prime = _ref.random_prime, nbs = _ref.nbs;

  RSA = require('openpgp').ciphers.asymmetric.RSA;

  _ref1 = require('openpgp').bigint, nbv = _ref1.nbv, nbi = _ref1.nbi, BigInteger = _ref1.BigInteger;

  _ref2 = require('./util'), bufeq_secure = _ref2.bufeq_secure, ASP = _ref2.ASP;

  make_esc = require('iced-error').make_esc;

  C = require('./const').openpgp;

  bn = require('./bn');

  SHA512 = require('./hash').SHA512;

  _ref3 = require('./encode/pad'), emsa_pkcs1_decode = _ref3.emsa_pkcs1_decode, emsa_pkcs1_encode = _ref3.emsa_pkcs1_encode;

  Priv = (function() {
    function Priv(_arg) {
      this.p = _arg.p, this.q = _arg.q, this.d = _arg.d, this.dmp1 = _arg.dmp1, this.dmq1 = _arg.dmq1, this.u = _arg.u, this.pub = _arg.pub;
    }

    Priv.prototype.decrypt = function(c) {
      return c.modPow(this.d, this.pub.n);
    };

    Priv.prototype.sign = function(m) {
      return m.modPow(this.d, this.pub.n);
    };

    Priv.prototype.serialize = function() {
      return Buffer.concat([this.d.to_mpi_buffer(), this.p.to_mpi_buffer(), this.q.to_mpi_buffer(), this.u.to_mpi_buffer()]);
    };

    Priv.prototype.n = function() {
      return this.p.multiply(this.q);
    };

    Priv.prototype.phi = function() {
      return this.p.subtract(BigInteger.ONE).multiply(this.q.subtract(BigInteger.ONE));
    };

    Priv.prototype.lambda = function() {
      return this.phi.divide(this.p.subtract(BigInteger.ONE).gcd(this.q.subtract(BigInteger.ONE)));
    };

    Priv.alloc = function(raw, pub) {
      var d, err, i, mpis, orig_len, p, q, u, _i, _ref4;
      orig_len = raw.length;
      err = null;
      mpis = [];
      for (i = _i = 0; _i < 4; i = ++_i) {
        if (err == null) {
          _ref4 = bn.mpi_from_buffer(raw), err = _ref4[0], mpis[i] = _ref4[1], raw = _ref4[2];
        }
      }
      if (err) {
        return [err, null];
      } else {
        d = mpis[0], p = mpis[1], q = mpis[2], u = mpis[3];
        return [
          null, new Priv({
            p: p,
            d: d,
            q: q,
            u: u,
            pub: pub
          }), orig_len - raw.length
        ];
      }
    };

    return Priv;

  })();

  Pub = (function() {
    function Pub(_arg) {
      this.n = _arg.n, this.e = _arg.e;
    }

    Pub.prototype.encrypt = function(p) {
      return p.modPow(this.e, this.n);
    };

    Pub.prototype.verify = function(s) {
      return s.modPow(this.e, this.n);
    };

    Pub.prototype.serialize = function() {
      return Buffer.concat([this.n.to_mpi_buffer(), this.e.to_mpi_buffer()]);
    };

    Pub.alloc = function(raw) {
      var e, err, n, orig_len, _ref4, _ref5;
      orig_len = raw.length;
      _ref4 = bn.mpi_from_buffer(raw), err = _ref4[0], n = _ref4[1], raw = _ref4[2];
      if (err == null) {
        _ref5 = bn.mpi_from_buffer(raw), err = _ref5[0], e = _ref5[1], raw = _ref5[2];
      }
      if (err) {
        return [err, null];
      } else {
        return [
          null, new Pub({
            n: n,
            e: e
          }), orig_len - raw.length
        ];
      }
    };

    return Pub;

  })();

  Pair = (function() {
    Pair.type = C.public_key_algorithms.RSA;

    Pair.prototype.type = Pair.type;

    function Pair(_arg) {
      this.priv = _arg.priv, this.pub = _arg.pub;
      this.pub.parent = this;
      if (this.priv != null) {
        this.priv.parent = this;
      }
    }

    Pair.parse = function(pub_raw) {
      var err, key, len, _ref4;
      _ref4 = Pub.alloc(pub_raw), err = _ref4[0], key = _ref4[1], len = _ref4[2];
      if (key != null) {
        key = new Pair({
          pub: key
        });
      }
      return [err, key, len];
    };

    Pair.prototype.add_priv = function(priv_raw) {
      var err, len, _ref4;
      _ref4 = Priv.alloc(priv_raw), err = _ref4[0], this.priv = _ref4[1], len = _ref4[2];
      return [err, len];
    };

    Pair.alloc = function(_arg) {
      var err, priv, pub, _ref4, _ref5;
      pub = _arg.pub, priv = _arg.priv;
      _ref4 = Pub.alloc(pub), err = _ref4[0], pub = _ref4[1];
      if ((err == null) && (priv != null)) {
        _ref5 = Priv.alloc(priv, pub), err = _ref5[0], priv = _ref5[1];
      }
      if (err != null) {
        return [err, null];
      } else {
        return [
          null, new Pair({
            priv: priv,
            pub: pub
          })
        ];
      }
    };

    Pair.prototype.sanity_check = function() {
      var test;
      if (this.priv.n().compareTo(this.pub.n) !== 0) {
        return new Error("pq != n");
      }
      test = nbs("1111777111771");
      if (this.decrypt(this.encrypt(test)).compareTo(test) !== 0) {
        return "Decrypt/encrypt failed";
      }
      if (this.verify(this.sign(test)).compareTo(test) !== 0) {
        return "Sign/verify failed";
      }
      return null;
    };

    Pair.prototype.read_priv = function(raw_priv) {
      var err, _ref4;
      _ref4 = Priv.alloc(raw_priv, this.pub), err = _ref4[0], this.priv = _ref4[1];
      return err;
    };

    Pair.parse_sig = function(slice) {
      var err, n, raw, ret, _ref4;
      _ref4 = bn.mpi_from_buffer(slice.peek_rest_to_buffer()), err = _ref4[0], ret = _ref4[1], raw = _ref4[2], n = _ref4[3];
      if (err != null) {
        throw err;
      }
      slice.advance(n);
      return ret;
    };

    Pair.prototype.encrypt = function(p) {
      return this.pub.encrypt(p);
    };

    Pair.prototype.decrypt = function(c) {
      return this.priv.decrypt(c);
    };

    Pair.make = function(_arg) {
      var d, dmp1, dmq1, e, lambda, n, p, p1, phi, priv, pub, q, q1, u;
      p = _arg.p, q = _arg.q, e = _arg.e, phi = _arg.phi, p1 = _arg.p1, q1 = _arg.q1, lambda = _arg.lambda;
      n = p.multiply(q);
      d = e.modInverse(lambda);
      dmp1 = d.mod(p1);
      dmq1 = d.mod(q1);
      u = p.modInverse(q);
      pub = new Pub({
        n: n,
        e: e
      });
      priv = new Priv({
        p: p,
        q: q,
        d: d,
        dmp1: dmp1,
        dmq1: dmq1,
        u: u,
        pub: pub
      });
      return new Pair({
        priv: priv,
        pub: pub
      });
    };

    Pair.prototype.to_openpgp = function() {
      var key;
      key = new (new RSA).keyObject();
      key.n = this.pub.n;
      key.e = this.pub.e.intValue();
      key.ee = this.pub.e;
      key.d = this.priv.d;
      key.p = this.priv.p;
      key.q = this.priv.q;
      key.dmp1 = this.priv.dmp1;
      key.dmq1 = this.priv.dmq1;
      key.u = this.priv.u;
      return key;
    };

    Pair.prototype.sign = function(m) {
      return this.priv.sign(m);
    };

    Pair.prototype.verify = function(s) {
      return this.pub.verify(s);
    };

    Pair.prototype.pad_and_sign = function(data, _arg) {
      var hashed_data, hasher, m;
      hasher = _arg.hasher;
      hasher || (hasher = SHA512);
      hashed_data = hasher(data);
      m = emsa_pkcs1_encode(hashed_data, this.pub.n.mpi_byte_length(), {
        hasher: hasher
      });
      return this.sign(m).to_mpi_buffer();
    };

    Pair.prototype.verify_unpad_and_check_hash = function(sig, data, hasher) {
      var b, err, hd1, hd2, v, _ref4, _ref5;
      err = null;
      if (Buffer.isBuffer(sig)) {
        _ref4 = bn.mpi_from_buffer(sig), err = _ref4[0], sig = _ref4[1];
      }
      if (err == null) {
        v = this.verify(sig);
        b = new Buffer(v.toByteArray());
        _ref5 = emsa_pkcs1_decode(b, hasher), err = _ref5[0], hd1 = _ref5[1];
        if (err == null) {
          hd2 = hasher(data);
          if (!bufeq_secure(hd1, hd2)) {
            err = new Error("hash mismatch");
          }
        }
      }
      return err;
    };

    Pair.generate = function(_arg, cb) {
      var asp, e, e_orig, esc, go, iters, key, lambda, nbits, p, p1, phi, q, q1, ___iced_passed_deferral, __iced_deferrals, __iced_k,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      nbits = _arg.nbits, iters = _arg.iters, e = _arg.e, asp = _arg.asp;
      e || (e = (1 << 16) + 1);
      e_orig = e;
      nbits || (nbits = 4096);
      iters || (iters = 10);
      asp || (asp = new ASP({}));
      e = nbv(e_orig);
      esc = make_esc(cb, "generate_rsa_keypair");
      go = true;
      nbits >>= 1;
      (function(__iced_k) {
        var _results, _while;
        _results = [];
        _while = function(__iced_k) {
          var _break, _continue, _next;
          _break = function() {
            return __iced_k(_results);
          };
          _continue = function() {
            return iced.trampoline(function() {
              return _while(__iced_k);
            });
          };
          _next = function(__iced_next_arg) {
            _results.push(__iced_next_arg);
            return _continue();
          };
          if (!go) {
            return _break();
          } else {
            (function(__iced_k) {
              __iced_deferrals = new iced.Deferrals(__iced_k, {
                parent: ___iced_passed_deferral,
                filename: "src/rsa.iced",
                funcname: "Pair.generate"
              });
              random_prime({
                asp: asp.section('p'),
                e: e,
                nbits: nbits,
                iters: iters
              }, esc(__iced_deferrals.defer({
                assign_fn: (function() {
                  return function() {
                    return p = arguments[0];
                  };
                })(),
                lineno: 197
              })));
              __iced_deferrals._fulfill();
            })(function() {
              (function(__iced_k) {
                __iced_deferrals = new iced.Deferrals(__iced_k, {
                  parent: ___iced_passed_deferral,
                  filename: "src/rsa.iced",
                  funcname: "Pair.generate"
                });
                asp.progress({
                  what: "found",
                  p: p
                }, esc(__iced_deferrals.defer({
                  lineno: 198
                })));
                __iced_deferrals._fulfill();
              })(function() {
                (function(__iced_k) {
                  __iced_deferrals = new iced.Deferrals(__iced_k, {
                    parent: ___iced_passed_deferral,
                    filename: "src/rsa.iced",
                    funcname: "Pair.generate"
                  });
                  random_prime({
                    asp: asp.section('q'),
                    e: e,
                    nbits: nbits,
                    iters: iters
                  }, esc(__iced_deferrals.defer({
                    assign_fn: (function() {
                      return function() {
                        return q = arguments[0];
                      };
                    })(),
                    lineno: 199
                  })));
                  __iced_deferrals._fulfill();
                })(function() {
                  (function(__iced_k) {
                    __iced_deferrals = new iced.Deferrals(__iced_k, {
                      parent: ___iced_passed_deferral,
                      filename: "src/rsa.iced",
                      funcname: "Pair.generate"
                    });
                    asp.progress({
                      what: "found",
                      q: q
                    }, esc(__iced_deferrals.defer({
                      lineno: 200
                    })));
                    __iced_deferrals._fulfill();
                  })(function() {
                    var _ref4;
                    if (p.compareTo(q) <= 0) {
                      _ref4 = [q, p], p = _ref4[0], q = _ref4[1];
                    }
                    q1 = q.subtract(BigInteger.ONE);
                    p1 = p.subtract(BigInteger.ONE);
                    phi = p1.multiply(q1);
                    lambda = phi.divide(q1.gcd(p1));
                    return _next(phi.gcd(e).compareTo(BigInteger.ONE) !== 0 ? (typeof progress_hook === "function" ? progress_hook({
                      what: "unlucky_phi"
                    }) : void 0, go = true) : go = false);
                  });
                });
              });
            });
          }
        };
        _while(__iced_k);
      })(function() {
        key = Pair.make({
          p: p,
          q: q,
          e: e,
          phi: phi,
          p1: p1,
          q1: q1,
          lambda: lambda
        });
        return cb(null, key);
      });
    };

    return Pair;

  })();

  exports.RSA = exports.Pair = Pair;

}).call(this);
