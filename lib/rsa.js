// Generated by IcedCoffeeScript 1.6.3-g
(function() {
  var ASP, BigInteger, C, K, Pair, Priv, Pub, RSA, SHA512, bn, bufeq_secure, emsa_pkcs1_decode, emsa_pkcs1_encode, iced, make_esc, nbi, nbs, nbv, random_prime, __iced_k, __iced_k_noop, _ref, _ref1, _ref2, _ref3;

  iced = require('iced-coffee-script/lib/coffee-script/iced').runtime;
  __iced_k = __iced_k_noop = function() {};

  _ref = require('./primegen'), random_prime = _ref.random_prime, nbs = _ref.nbs;

  RSA = require('openpgp').ciphers.asymmetric.RSA;

  _ref1 = require('openpgp').bigint, nbv = _ref1.nbv, nbi = _ref1.nbi, BigInteger = _ref1.BigInteger;

  _ref2 = require('./util'), bufeq_secure = _ref2.bufeq_secure, ASP = _ref2.ASP;

  make_esc = require('iced-error').make_esc;

  C = require('./const').openpgp;

  K = require('./const').kb;

  bn = require('./bn');

  SHA512 = require('./hash').SHA512;

  _ref3 = require('./pad'), emsa_pkcs1_decode = _ref3.emsa_pkcs1_decode, emsa_pkcs1_encode = _ref3.emsa_pkcs1_encode;

  Priv = (function() {
    function Priv(_arg) {
      this.p = _arg.p, this.q = _arg.q, this.d = _arg.d, this.dmp1 = _arg.dmp1, this.dmq1 = _arg.dmq1, this.u = _arg.u, this.pub = _arg.pub;
    }

    Priv.prototype.decrypt = function(c) {
      return this.mod_pow(c, this.d);
    };

    Priv.prototype.sign = function(m) {
      return this.mod_pow(m, this.d);
    };

    Priv.prototype.serialize = function() {
      return Buffer.concat([this.d.to_mpi_buffer(), this.p.to_mpi_buffer(), this.q.to_mpi_buffer(), this.u.to_mpi_buffer()]);
    };

    Priv.prototype.n = function() {
      return this.p.multiply(this.q);
    };

    Priv.prototype.phi = function() {
      return this.p.subtract(BigInteger.ONE).multiply(this.q.subtract(BigInteger.ONE));
    };

    Priv.prototype.lambda = function() {
      return this.phi.divide(this.p.subtract(BigInteger.ONE).gcd(this.q.subtract(BigInteger.ONE)));
    };

    Priv.alloc = function(raw, pub) {
      var d, err, i, mpis, orig_len, p, q, u, _i, _ref4;
      orig_len = raw.length;
      err = null;
      mpis = [];
      for (i = _i = 0; _i < 4; i = ++_i) {
        if (err == null) {
          _ref4 = bn.mpi_from_buffer(raw), err = _ref4[0], mpis[i] = _ref4[1], raw = _ref4[2];
        }
      }
      if (err) {
        return [err, null];
      } else {
        d = mpis[0], p = mpis[1], q = mpis[2], u = mpis[3];
        return [
          null, new Priv({
            p: p,
            d: d,
            q: q,
            u: u,
            pub: pub
          }), orig_len - raw.length
        ];
      }
    };

    Priv.prototype.mod_pow = function(x, d) {
      var xp, xq;
      if (this.dP == null) {
        this.dP = this.d.mod(this.p.subtract(BigInteger.ONE));
      }
      if (this.dQ == null) {
        this.dQ = this.d.mod(this.q.subtract(BigInteger.ONE));
      }
      if (this.qInv == null) {
        this.qInv = this.q.modInverse(this.p);
      }

      /* Chinese remainder theorem (CRT) states:
      
        Suppose n1, n2, ..., nk are positive integers which are pairwise
        coprime (n1 and n2 have no common factors other than 1). For any
        integers x1, x2, ..., xk there exists an integer x solving the
        system of simultaneous congruences (where ~= means modularly
        congruent so a ~= b mod n means a mod n = b mod n):
      
        x ~= x1 mod n1
        x ~= x2 mod n2
        ...
        x ~= xk mod nk
      
        This system of congruences has a single simultaneous solution x
        between 0 and n - 1. Furthermore, each xk solution and x itself
        is congruent modulo the product n = n1*n2*...*nk.
        So x1 mod n = x2 mod n = xk mod n = x mod n.
      
        The single simultaneous solution x can be solved with the following
        equation:
      
        x = sum(xi*ri*si) mod n where ri = n/ni and si = ri^-1 mod ni.
      
        Where x is less than n, xi = x mod ni.
      
        For RSA we are only concerned with k = 2. The modulus n = pq, where
        p and q are coprime. The RSA decryption algorithm is:
      
        y = x^d mod n
      
        Given the above:
      
        x1 = x^d mod p
        r1 = n/p = q
        s1 = q^-1 mod p
        x2 = x^d mod q
        r2 = n/q = p
        s2 = p^-1 mod q
      
        So y = (x1r1s1 + x2r2s2) mod n
             = ((x^d mod p)q(q^-1 mod p) + (x^d mod q)p(p^-1 mod q)) mod n
      
        According to Fermat's Little Theorem, if the modulus P is prime,
        for any integer A not evenly divisible by P, A^(P-1) ~= 1 mod P.
        Since A is not divisible by P it follows that if:
        N ~= M mod (P - 1), then A^N mod P = A^M mod P. Therefore:
      
        A^N mod P = A^(M mod (P - 1)) mod P. (The latter takes less effort
        to calculate). In order to calculate x^d mod p more quickly the
        exponent d mod (p - 1) is stored in the RSA private key (the same
        is done for x^d mod q). These values are referred to as dP and dQ
        respectively. Therefore we now have:
      
        y = ((x^dP mod p)q(q^-1 mod p) + (x^dQ mod q)p(p^-1 mod q)) mod n
      
        Since we'll be reducing x^dP by modulo p (same for q) we can also
        reduce x by p (and q respectively) before hand. Therefore, let
      
        xp = ((x mod p)^dP mod p), and
        xq = ((x mod q)^dQ mod q), yielding:
      
        y = (xp*q*(q^-1 mod p) + xq*p*(p^-1 mod q)) mod n
      
        This can be further reduced to a simple algorithm that only
        requires 1 inverse (the q inverse is used) to be used and stored.
        The algorithm is called Garner's algorithm. If qInv is the
        inverse of q, we simply calculate:
      
        y = (qInv*(xp - xq) mod p) * q + xq
      
        However, there are two further complications. First, we need to
        ensure that xp > xq to prevent signed BigIntegers from being used
        so we add p until this is true (since we will be mod'ing with
        p anyway). Then, there is a known timing attack on algorithms
        using the CRT. To mitigate this risk, "cryptographic blinding"
        should be used (*Not yet implemented*). This requires simply
        generating a random number r between 0 and n-1 and its inverse
        and multiplying x by r^e before calculating y and then multiplying
        y by r^-1 afterwards.
      */
      xp = x.mod(this.p).modPow(this.dP, this.p);
      xq = x.mod(this.q).modPow(this.dQ, this.q);
      while (xp.compareTo(xq) < 0) {
        xp = xp.add(this.p);
      }
      return xp.subtract(xq).multiply(this.qInv).mod(this.p).multiply(this.q).add(xq);
    };

    return Priv;

  })();

  Pub = (function() {
    Pub.type = C.public_key_algorithms.RSA;

    Pub.prototype.type = Pub.type;

    function Pub(_arg) {
      this.n = _arg.n, this.e = _arg.e;
    }

    Pub.prototype.encrypt = function(p) {
      return p.modPow(this.e, this.n);
    };

    Pub.prototype.verify = function(s) {
      return s.modPow(this.e, this.n);
    };

    Pub.prototype.serialize = function() {
      return Buffer.concat([this.n.to_mpi_buffer(), this.e.to_mpi_buffer()]);
    };

    Pub.alloc = function(raw) {
      var e, err, n, orig_len, _ref4, _ref5;
      orig_len = raw.length;
      _ref4 = bn.mpi_from_buffer(raw), err = _ref4[0], n = _ref4[1], raw = _ref4[2];
      if (err == null) {
        _ref5 = bn.mpi_from_buffer(raw), err = _ref5[0], e = _ref5[1], raw = _ref5[2];
      }
      if (err) {
        return [err, null];
      } else {
        return [
          null, new Pub({
            n: n,
            e: e
          }), orig_len - raw.length
        ];
      }
    };

    Pub.prototype.hash = function() {
      return SHA512(this.serialize());
    };

    Pub.prototype.kid = function() {
      return Buffer.concat([this.fingerprint(), new Buffer([K.kid.trailer])]);
    };

    Pub.prototype.fingerprint = function() {
      return Buffer.concat([new Buffer([K.kid.version, this.type]), this.hash().slice(0, K.kid.len)]);
    };

    Pub.prototype.ekid = function() {
      return Buffer.concat([new Buffer([K.kid.version, this.type]), this.hash()]);
    };

    Pub.prototype.mod_pow = function(x, d) {
      return x.modPow(d, this.n);
    };

    return Pub;

  })();

  Pair = (function() {
    Pair.type = C.public_key_algorithms.RSA;

    Pair.prototype.type = Pair.type;

    function Pair(_arg) {
      this.priv = _arg.priv, this.pub = _arg.pub;
      this.pub.parent = this;
      if (this.priv != null) {
        this.priv.parent = this;
      }
    }

    Pair.prototype.hash = function() {
      return this.pub.hash();
    };

    Pair.prototype.kid = function() {
      return this.pub.kid();
    };

    Pair.prototype.ekid = function() {
      return this.pub.ekid();
    };

    Pair.prototype.fingerprint = function() {
      return this.pub.fingerprint();
    };

    Pair.prototype.can_sign = function() {
      return this.priv != null;
    };

    Pair.prototype.can_decrypt = function() {
      return this.priv != null;
    };

    Pair.parse = function(pub_raw) {
      var err, key, len, _ref4;
      _ref4 = Pub.alloc(pub_raw), err = _ref4[0], key = _ref4[1], len = _ref4[2];
      if (key != null) {
        key = new Pair({
          pub: key
        });
      }
      return [err, key, len];
    };

    Pair.prototype.add_priv = function(priv_raw) {
      var err, len, _ref4;
      _ref4 = Priv.alloc(priv_raw), err = _ref4[0], this.priv = _ref4[1], len = _ref4[2];
      return [err, len];
    };

    Pair.alloc = function(_arg) {
      var err, priv, pub, _ref4, _ref5;
      pub = _arg.pub, priv = _arg.priv;
      _ref4 = Pub.alloc(pub), err = _ref4[0], pub = _ref4[1];
      if ((err == null) && (priv != null)) {
        _ref5 = Priv.alloc(priv, pub), err = _ref5[0], priv = _ref5[1];
      }
      if (err != null) {
        return [err, null];
      } else {
        return [
          null, new Pair({
            priv: priv,
            pub: pub
          })
        ];
      }
    };

    Pair.prototype.sanity_check = function() {
      var test;
      if (this.priv.n().compareTo(this.pub.n) !== 0) {
        return new Error("pq != n");
      }
      test = nbs("1111777111771");
      if (this.decrypt(this.encrypt(test)).compareTo(test) !== 0) {
        return new Error("Decrypt/encrypt failed");
      }
      if (this.verify(this.sign(test)).compareTo(test) !== 0) {
        return new Error("Sign/verify failed");
      }
      return null;
    };

    Pair.prototype.read_priv = function(raw_priv) {
      var err, _ref4;
      _ref4 = Priv.alloc(raw_priv, this.pub), err = _ref4[0], this.priv = _ref4[1];
      return err;
    };

    Pair.parse_sig = function(slice) {
      var err, n, raw, ret, _ref4;
      _ref4 = bn.mpi_from_buffer(slice.peek_rest_to_buffer()), err = _ref4[0], ret = _ref4[1], raw = _ref4[2], n = _ref4[3];
      if (err != null) {
        throw err;
      }
      slice.advance(n);
      return ret;
    };

    Pair.prototype.encrypt = function(p) {
      return this.pub.encrypt(p);
    };

    Pair.prototype.decrypt = function(c) {
      return this.priv.decrypt(c);
    };

    Pair.make = function(_arg) {
      var d, dmp1, dmq1, e, lambda, n, p, p1, phi, priv, pub, q, q1, u;
      p = _arg.p, q = _arg.q, e = _arg.e, phi = _arg.phi, p1 = _arg.p1, q1 = _arg.q1, lambda = _arg.lambda;
      n = p.multiply(q);
      d = e.modInverse(lambda);
      dmp1 = d.mod(p1);
      dmq1 = d.mod(q1);
      u = p.modInverse(q);
      pub = new Pub({
        n: n,
        e: e
      });
      priv = new Priv({
        p: p,
        q: q,
        d: d,
        dmp1: dmp1,
        dmq1: dmq1,
        u: u,
        pub: pub
      });
      return new Pair({
        priv: priv,
        pub: pub
      });
    };

    Pair.prototype.to_openpgp = function() {
      var key;
      key = new (new RSA).keyObject();
      key.n = this.pub.n;
      key.e = this.pub.e.intValue();
      key.ee = this.pub.e;
      key.d = this.priv.d;
      key.p = this.priv.p;
      key.q = this.priv.q;
      key.dmp1 = this.priv.dmp1;
      key.dmq1 = this.priv.dmq1;
      key.u = this.priv.u;
      return key;
    };

    Pair.prototype.sign = function(m) {
      return this.priv.sign(m);
    };

    Pair.prototype.verify = function(s) {
      return this.pub.verify(s);
    };

    Pair.prototype.pad_and_sign = function(data, _arg) {
      var hashed_data, hasher, m;
      hasher = _arg.hasher;
      hasher || (hasher = SHA512);
      hashed_data = hasher(data);
      m = emsa_pkcs1_encode(hashed_data, this.pub.n.mpi_byte_length(), {
        hasher: hasher
      });
      return this.sign(m).to_mpi_buffer();
    };

    Pair.prototype.verify_unpad_and_check_hash = function(sig, data, hasher) {
      var b, err, hd1, hd2, v, _ref4, _ref5;
      err = null;
      if (Buffer.isBuffer(sig)) {
        _ref4 = bn.mpi_from_buffer(sig), err = _ref4[0], sig = _ref4[1];
      }
      if (err == null) {
        v = this.verify(sig);
        b = new Buffer(v.toByteArray());
        _ref5 = emsa_pkcs1_decode(b, hasher), err = _ref5[0], hd1 = _ref5[1];
        if (err == null) {
          hd2 = hasher(data);
          if (!bufeq_secure(hd1, hd2)) {
            err = new Error("hash mismatch");
          }
        }
      }
      return err;
    };

    Pair.generate = function(_arg, cb) {
      var asp, e, e_orig, esc, go, iters, key, lambda, nbits, p, p1, phi, q, q1, ___iced_passed_deferral, __iced_deferrals, __iced_k,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      nbits = _arg.nbits, iters = _arg.iters, e = _arg.e, asp = _arg.asp;
      e || (e = (1 << 16) + 1);
      e_orig = e;
      nbits || (nbits = 4096);
      iters || (iters = 10);
      asp || (asp = new ASP({}));
      e = nbv(e_orig);
      esc = make_esc(cb, "generate_rsa_keypair");
      go = true;
      nbits >>= 1;
      (function(__iced_k) {
        var _results, _while;
        _results = [];
        _while = function(__iced_k) {
          var _break, _continue, _next;
          _break = function() {
            return __iced_k(_results);
          };
          _continue = function() {
            return iced.trampoline(function() {
              return _while(__iced_k);
            });
          };
          _next = function(__iced_next_arg) {
            _results.push(__iced_next_arg);
            return _continue();
          };
          if (!go) {
            return _break();
          } else {
            (function(__iced_k) {
              __iced_deferrals = new iced.Deferrals(__iced_k, {
                parent: ___iced_passed_deferral,
                filename: "src/rsa.iced",
                funcname: "Pair.generate"
              });
              random_prime({
                asp: asp.section('p'),
                e: e,
                nbits: nbits,
                iters: iters
              }, esc(__iced_deferrals.defer({
                assign_fn: (function() {
                  return function() {
                    return p = arguments[0];
                  };
                })(),
                lineno: 338
              })));
              __iced_deferrals._fulfill();
            })(function() {
              (function(__iced_k) {
                __iced_deferrals = new iced.Deferrals(__iced_k, {
                  parent: ___iced_passed_deferral,
                  filename: "src/rsa.iced",
                  funcname: "Pair.generate"
                });
                asp.progress({
                  what: "found",
                  p: p
                }, esc(__iced_deferrals.defer({
                  lineno: 339
                })));
                __iced_deferrals._fulfill();
              })(function() {
                (function(__iced_k) {
                  __iced_deferrals = new iced.Deferrals(__iced_k, {
                    parent: ___iced_passed_deferral,
                    filename: "src/rsa.iced",
                    funcname: "Pair.generate"
                  });
                  random_prime({
                    asp: asp.section('q'),
                    e: e,
                    nbits: nbits,
                    iters: iters
                  }, esc(__iced_deferrals.defer({
                    assign_fn: (function() {
                      return function() {
                        return q = arguments[0];
                      };
                    })(),
                    lineno: 340
                  })));
                  __iced_deferrals._fulfill();
                })(function() {
                  (function(__iced_k) {
                    __iced_deferrals = new iced.Deferrals(__iced_k, {
                      parent: ___iced_passed_deferral,
                      filename: "src/rsa.iced",
                      funcname: "Pair.generate"
                    });
                    asp.progress({
                      what: "found",
                      q: q
                    }, esc(__iced_deferrals.defer({
                      lineno: 341
                    })));
                    __iced_deferrals._fulfill();
                  })(function() {
                    var _ref4;
                    if (p.compareTo(q) <= 0) {
                      _ref4 = [q, p], p = _ref4[0], q = _ref4[1];
                    }
                    q1 = q.subtract(BigInteger.ONE);
                    p1 = p.subtract(BigInteger.ONE);
                    phi = p1.multiply(q1);
                    lambda = phi.divide(q1.gcd(p1));
                    return _next(phi.gcd(e).compareTo(BigInteger.ONE) !== 0 ? (typeof progress_hook === "function" ? progress_hook({
                      what: "unlucky_phi"
                    }) : void 0, go = true) : go = false);
                  });
                });
              });
            });
          }
        };
        _while(__iced_k);
      })(function() {
        key = Pair.make({
          p: p,
          q: q,
          e: e,
          phi: phi,
          p1: p1,
          q1: q1,
          lambda: lambda
        });
        return cb(null, key);
      });
    };

    return Pair;

  })();

  exports.RSA = exports.Pair = Pair;

}).call(this);
