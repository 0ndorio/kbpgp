// Generated by IcedCoffeeScript 1.7.1-c
(function() {
  var ASP, BaseEccKey, BaseKey, BaseKeyPair, C, MRF, Output, Pair, Priv, Pub, SRF, SlicerBuffer, bn, bufeq_secure, eme_pkcs1_decode, eme_pkcs1_encode, hashmod, iced, konst, make_esc, sym, uint_to_buffer, xxd, __iced_k, __iced_k_noop, _ref, _ref1, _ref2, _ref3,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  iced = require('iced-runtime').iced;
  __iced_k = __iced_k_noop = function() {};

  bn = require('../bn');

  _ref = require('../util'), xxd = _ref.xxd, uint_to_buffer = _ref.uint_to_buffer, bufeq_secure = _ref.bufeq_secure, ASP = _ref.ASP;

  make_esc = require('iced-error').make_esc;

  konst = require('../const');

  C = konst.openpgp;

  _ref1 = require('../basekeypair'), BaseKeyPair = _ref1.BaseKeyPair, BaseKey = _ref1.BaseKey;

  _ref2 = require('../rand'), SRF = _ref2.SRF, MRF = _ref2.MRF;

  _ref3 = require('../pad'), eme_pkcs1_encode = _ref3.eme_pkcs1_encode, eme_pkcs1_decode = _ref3.eme_pkcs1_decode;

  BaseKeyPair = require('../basekeypair').BaseKeyPair;

  BaseEccKey = require('./base').BaseEccKey;

  hashmod = require('../hash');

  sym = require('../symmetric');

  SlicerBuffer = require('../openpgp/buffer').SlicerBuffer;

  Pub = (function(_super) {
    __extends(Pub, _super);

    function Pub() {
      return Pub.__super__.constructor.apply(this, arguments);
    }

    Pub.type = C.public_key_algorithms.ECDH;

    Pub.prototype.type = Pub.type;

    Pub.prototype.read_params = function(sb) {
      var size, val;
      if ((size = sb.read_uint8()) < 3) {
        throw new Error("Need at least 3 bytes of params; got " + size);
      }
      if ((val = sb.read_uint8()) !== 1) {
        throw new Error("Cannot deal with future extensions, byte=" + val);
      }
      this.hasher = hashmod.alloc_or_throw(sb.read_uint8());
      this.cipher = sym.get_cipher(sb.read_uint8());
      return sb.advance(size - 3);
    };

    Pub.alloc = function(raw) {
      return BaseEccKey.alloc(Pub, raw);
    };

    Pub.prototype.serialize = function() {
      var base;
      base = Pub.__super__.serialize.call(this);
      return Buffer.concat([base, uint_to_buffer(8, 3), uint_to_buffer(8, 1), uint_to_buffer(8, this.hasher.type), uint_to_buffer(8, this.cipher.type)]);
    };

    Pub.prototype.encrypt = function(m, cb) {
      var c, k, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      (function(_this) {
        return (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/Users/max/src/keybase/kbpgp/src/ecc/ecdh.iced",
            funcname: "Pub.encrypt"
          });
          SRF().random_zn(_this.p.subtract(bn.nbv(2)), __iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                return k = arguments[0];
              };
            })(),
            lineno: 51
          }));
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          k = k.add(bn.BigInteger.ONE);
          c = [_this.g.modPow(k, _this.p), _this.y.modPow(k, _this.p).multiply(m).mod(_this.p)];
          return cb(c);
        };
      })(this));
    };

    return Pub;

  })(BaseEccKey);

  Priv = (function(_super) {
    __extends(Priv, _super);

    Priv.ORDER = ['x'];

    Priv.prototype.ORDER = Priv.ORDER;

    function Priv(_arg) {
      this.x = _arg.x, this.pub = _arg.pub;
    }

    Priv.prototype.serialize = function() {
      return this.x.to_mpi_buffer();
    };

    Priv.alloc = function(raw, pub) {
      return BaseKey.alloc(Priv, raw, {
        pub: pub
      });
    };

    Priv.prototype.decrypt = function(c, cb) {
      var S, V, curve, err, esc, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      esc = make_esc(cb, "Priv::decrypt");
      curve = this.pub.curve;
      (function(_this) {
        return (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/Users/max/src/keybase/kbpgp/src/ecc/ecdh.iced",
            funcname: "Priv.decrypt"
          });
          c.load_V(curve, esc(__iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                return V = arguments[0];
              };
            })(),
            lineno: 84
          })));
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          S = V.multiply(_this.x);
          err = new Error("not finished!");
          return cb(err, null);
        };
      })(this));
    };

    return Priv;

  })(BaseKey);

  Pair = (function(_super) {
    __extends(Pair, _super);

    function Pair() {
      return Pair.__super__.constructor.apply(this, arguments);
    }

    Pair.Pub = Pub;

    Pair.prototype.Pub = Pub;

    Pair.Priv = Priv;

    Pair.prototype.Priv = Priv;

    Pair.type = C.public_key_algorithms.ECDH;

    Pair.prototype.type = Pair.type;

    Pair.prototype.fulfills_flags = function(flags) {
      var good_for;
      good_for = C.key_flags.encrypt_comm | C.key_flags.encrypt_storage;
      return (flags & good_for) === flags;
    };

    Pair.prototype.can_sign = function() {
      return false;
    };

    Pair.parse = function(pub_raw) {
      var ret;
      ret = BaseKeyPair.parse(Pair, pub_raw);
      return ret;
    };

    Pair.prototype.max_value = function() {
      return this.pub.p;
    };

    Pair.prototype.pad_and_encrypt = function(data, cb) {
      var c_mpis, err, m, ret, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      err = ret = null;
      (function(_this) {
        return (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/Users/max/src/keybase/kbpgp/src/ecc/ecdh.iced",
            funcname: "Pair.pad_and_encrypt"
          });
          eme_pkcs1_encode(data, _this.pub.p.mpi_byte_length(), __iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                err = arguments[0];
                return m = arguments[1];
              };
            })(),
            lineno: 131
          }));
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          (function(__iced_k) {
            if (err == null) {
              (function(__iced_k) {
                __iced_deferrals = new iced.Deferrals(__iced_k, {
                  parent: ___iced_passed_deferral,
                  filename: "/Users/max/src/keybase/kbpgp/src/ecc/ecdh.iced",
                  funcname: "Pair.pad_and_encrypt"
                });
                _this.pub.encrypt(m, __iced_deferrals.defer({
                  assign_fn: (function() {
                    return function() {
                      return c_mpis = arguments[0];
                    };
                  })(),
                  lineno: 133
                }));
                __iced_deferrals._fulfill();
              })(function() {
                return __iced_k(ret = _this.export_output({
                  c_mpis: c_mpis
                }));
              });
            } else {
              return __iced_k();
            }
          })(function() {
            return cb(err, ret);
          });
        };
      })(this));
    };

    Pair.prototype.decrypt_and_unpad = function(ciphertext, cb) {
      var b, err, m, ret, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      err = ret = null;
      (function(_this) {
        return (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/Users/max/src/keybase/kbpgp/src/ecc/ecdh.iced",
            funcname: "Pair.decrypt_and_unpad"
          });
          _this.priv.decrypt(ciphertext, __iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                err = arguments[0];
                return m = arguments[1];
              };
            })(),
            lineno: 141
          }));
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          var _ref4;
          if (err == null) {
            b = m.to_padded_octets(_this.pub.p);
            _ref4 = eme_pkcs1_decode(b), err = _ref4[0], ret = _ref4[1];
          }
          return cb(err, ret);
        };
      })(this));
    };

    Pair.parse_output = function(buf) {
      return Output.parse(buf);
    };

    Pair.prototype.export_output = function(args) {
      return new Output(args);
    };

    return Pair;

  })(BaseKeyPair);

  Output = (function() {
    function Output(_arg) {
      this.V_buf = _arg.V_buf, this.C_buf = _arg.C_buf;
    }

    Output.prototype.load_V = function(curve, cb) {
      var err, _ref4;
      _ref4 = curve.mpi_point_from_buffer(this.V_buf), err = _ref4[0], this.V = _ref4[1];
      return cb(err, this.V);
    };

    Output.parse = function(buf) {
      var C_buf, V_buf, a, n_bits, n_bytes, ret, sb;
      sb = new SlicerBuffer(buf);
      n_bits = sb.read_uint16();
      n_bytes = Math.ceil(n_bits / 8);
      V_buf = Buffer.concat([buf.slice(0, 2), sb.read_buffer(n_bytes)]);
      n_bytes = sb.read_uint8();
      C_buf = sb.consume_rest_to_buffer();
      if ((a = C_buf.length) !== n_bytes) {
        throw new Error("bad C input: wanted " + n_bytes + " bytes, but got " + a);
      }
      ret = new Output({
        V_buf: V_buf,
        C_buf: C_buf
      });
      return ret;
    };

    Output.prototype.hide = function(_arg, cb) {
      var key, max, slosh;
      key = _arg.key, max = _arg.max, slosh = _arg.slosh;
      return cb(new Error("not implemented for ECDH!"));
    };

    Output.prototype.find = function(_arg) {
      var key;
      key = _arg.key;
      throw new Error("not implemented for ECDH!");
    };

    Output.prototype.get_c_bufs = function() {
      var i;
      if (this.c_bufs != null) {
        return this.c_bufs;
      } else {
        return this.c_bufs = (function() {
          var _i, _len, _ref4, _results;
          _ref4 = this.c_mpis;
          _results = [];
          for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
            i = _ref4[_i];
            _results.push(i.to_mpi_buffer());
          }
          return _results;
        }).call(this);
      }
    };

    Output.prototype.output = function() {
      return Buffer.concat(this.get_c_bufs());
    };

    return Output;

  })();

  exports.ECDH = exports.Pair = Pair;

}).call(this);
