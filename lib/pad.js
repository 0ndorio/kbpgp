// Generated by IcedCoffeeScript 1.6.3-g
(function() {
  var C, SHA512, bufeq_secure, buffer_to_ui8a, emsa_pkcs1_decode, emsa_pkcs1_encode, hash_headers, iced, nbs, prng, __iced_k, __iced_k_noop, _ref;

  iced = require('iced-coffee-script/lib/coffee-script/iced').runtime;
  __iced_k = __iced_k_noop = function() {};

  SHA512 = require('./hash').SHA512;

  C = require('./const').openpgp;

  nbs = require('./bn').nbs;

  _ref = require('./util'), buffer_to_ui8a = _ref.buffer_to_ui8a, bufeq_secure = _ref.bufeq_secure;

  prng = require('triplesec').prng;

  hash_headers = {
    SHA1: [0x30, 0x21, 0x30, 0x09, 0x06, 0x05, 0x2b, 0x0e, 0x03, 0x02, 0x1a, 0x05, 0x00, 0x04, 0x14],
    SHA224: [0x30, 0x31, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x04, 0x05, 0x00, 0x04, 0x1C],
    SHA256: [0x30, 0x31, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x01, 0x05, 0x00, 0x04, 0x20],
    SHA512: [0x30, 0x51, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x03, 0x05, 0x00, 0x04, 0x40]
  };

  exports.emsa_pkcs1_encode = emsa_pkcs1_encode = function(hashed_data, len, opts) {
    var buf, hasher, headers, i, n;
    if (opts == null) {
      opts = {};
    }
    hasher = opts.hasher || SHA512;
    headers = hash_headers[hasher.algname];
    n = len - headers.length - 3 - hasher.output_length;
    buf = Buffer.concat([
      new Buffer([0x00, 0x01]), new Buffer((function() {
        var _i, _results;
        _results = [];
        for (i = _i = 0; 0 <= n ? _i < n : _i > n; i = 0 <= n ? ++_i : --_i) {
          _results.push(0xff);
        }
        return _results;
      })()), new Buffer([0x00]), new Buffer(headers), hashed_data
    ]);
    return nbs(buffer_to_ui8a(buf), 256);
  };

  exports.emsa_pkcs1_decode = emsa_pkcs1_decode = function(v, hasher) {
    var err, h, header, i, ret;
    err = ret = null;
    i = 0;
    if (v.length < 2) {
      err = new Error("signature was way too short: < 2 bytes");
    } else {
      if (v.readUInt16BE(0) !== 0x0001) {
        err = new Error("Sig verify error: Didn't get two-byte header 0x00 0x01");
      } else {
        i = 2;
        while (i < v.length && (v.readUInt8(i) === 0xff)) {
          i++;
        }
        if (i >= v.length || v.readUInt8(i) !== 0) {
          err = new Error("Sig verify error: Missed the 0x0 separator");
        } else {
          i++;
          header = hash_headers[hasher.algname];
          if (!bufeq_secure(new Buffer(header), v.slice(i, header.length + i))) {
            err = new Error("Sig verify error: missing ASN header for " + hasher.algname);
          } else {
            i += header.length;
            h = v.slice(i);
            if (h.length !== hasher.output_length) {
              err = new Error("Sig verify error: trailing garbage in signature");
            } else {
              ret = h;
            }
          }
        }
      }
    }
    return [err, ret];
  };

  exports.eme_pkcs1_encode = function(v, len, cb) {
    var PS, err, n_randos, ret, ___iced_passed_deferral, __iced_deferrals, __iced_k,
      _this = this;
    __iced_k = __iced_k_noop;
    ___iced_passed_deferral = iced.findDeferral(arguments);
    ret = err = null;
    (function(__iced_k) {
      if (v.length > len - 11) {
        return __iced_k(err = new Error("cannot encrypt message -- it's too long!"));
      } else {
        n_randos = len - 3 - v.length;
        (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "src/pad.iced",
            funcname: "eme_pkcs1_encode"
          });
          prng.generate(n_randos, __iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                return PS = arguments[0];
              };
            })(),
            lineno: 79
          }));
          __iced_deferrals._fulfill();
        })(function() {
          return __iced_k(ret = Buffer.concat([new Buffer([0x00, 0x02]), PS, new Buffer([0x00]), v]));
        });
      }
    })(function() {
      return cb(err, ret);
    });
  };

  exports.eme_pkcs1_decode = function(v) {
    var err, i, ret;
    err = ret = null;
    if (v.length < 12) {
      err = new Error("Ciphertext too short, needs to be >= 12 bytes");
    } else if (v.readUInt16BE(0) !== 0x0002) {
      err = new Error("Failed to find expected header: 0x00 0x02");
    } else {
      i = 2;
      while (i < v.length && (v.readUInt8(i) !== 0x0)) {
        i++;
      }
      if (i >= v.length) {
        err = new Error("didn't get 0x00 seperator octet");
      } else {
        i++;
        ret = v.slice(i);
      }
    }
    return [err, ret];
  };

}).call(this);
