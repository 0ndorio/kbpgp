// Generated by IcedCoffeeScript 1.6.3-g
(function() {
  var C, Encryption, Engine, K, KeyBlock, KeyBundle, KeybaseEngine, Lifespan, PgpEngine, Primary, RSA, Subkey, UserIds, bufferify, decode, encode, iced, kpkts, make_esc, opkts, parse, unix_time, __iced_k, __iced_k_noop, _ref, _ref1, _ref2,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  iced = require('iced-coffee-script/lib/coffee-script/iced').runtime;
  __iced_k = __iced_k_noop = function() {};

  RSA = require('./rsa').RSA;

  K = require('./const').kb;

  C = require('./const').openpgp;

  make_esc = require('iced-error').make_esc;

  _ref = require('./util'), unix_time = _ref.unix_time, bufferify = _ref.bufferify;

  _ref1 = require('./keywrapper'), Lifespan = _ref1.Lifespan, Subkey = _ref1.Subkey, Primary = _ref1.Primary;

  _ref2 = require('./openpgp/armor'), encode = _ref2.encode, decode = _ref2.decode;

  parse = require('./openpgp/parser').parse;

  KeyBlock = require('./openpgp/processor').KeyBlock;

  opkts = require('./openpgp/packet/all');

  kpkts = require('./keybase/packet/all');

  Encryption = (function() {
    function Encryption(_arg) {
      var passphrase;
      this.tsenc = _arg.tsenc, passphrase = _arg.passphrase;
      this.passphrase = bufferify(passphrase);
      this.tsenc || (this.tsenc = new triplesec.Encryptor({
        version: 2,
        passphrase: this.passphrase
      }));
    }

    return Encryption;

  })();

  UserIds = (function() {
    function UserIds(_arg) {
      this.openpgp = _arg.openpgp, this.keybase = _arg.keybase;
    }

    UserIds.prototype.get_keybase = function() {
      return this.keybase;
    };

    UserIds.prototype.get_openpgp = function() {
      return this.openpgp;
    };

    return UserIds;

  })();

  Engine = (function() {
    function Engine(_arg) {
      this.primary = _arg.primary, this.subkeys = _arg.subkeys, this.userids = _arg.userids;
      this.packets = [];
      this.messages = [];
      this._allocate_key_packets();
    }

    Engine.prototype._allocate_key_packets = function() {
      var key, _i, _len, _ref3, _results;
      _ref3 = this._all_keys();
      _results = [];
      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
        key = _ref3[_i];
        _results.push(this._v_allocate_key_packet(key));
      }
      return _results;
    };

    Engine.prototype._all_keys = function() {
      return [this.primary].concat(this.subkeys);
    };

    Engine.prototype.self_sign_primary = function(args, cb) {
      return this._v_self_sign_primary(args, cb);
    };

    Engine.prototype.sign_subkeys = function(_arg, cb) {
      var asp, err, subkey, ___iced_passed_deferral, __iced_deferrals, __iced_k,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      asp = _arg.asp;
      err = null;
      (function(__iced_k) {
        var _i, _len, _ref3, _results, _while;
        _ref3 = _this.subkeys;
        _len = _ref3.length;
        _i = 0;
        _results = [];
        _while = function(__iced_k) {
          var _break, _continue, _next;
          _break = function() {
            return __iced_k(_results);
          };
          _continue = function() {
            return iced.trampoline(function() {
              ++_i;
              return _while(__iced_k);
            });
          };
          _next = function(__iced_next_arg) {
            _results.push(__iced_next_arg);
            return _continue();
          };
          if (!(_i < _len)) {
            return _break();
          } else {
            subkey = _ref3[_i];
            if (err == null) {
              (function(__iced_k) {
                __iced_deferrals = new iced.Deferrals(__iced_k, {
                  parent: ___iced_passed_deferral,
                  filename: "src/keybundle.iced",
                  funcname: "Engine.sign_subkeys"
                });
                _this._v_sign_subkey({
                  asp: asp,
                  subkey: subkey
                }, __iced_deferrals.defer({
                  assign_fn: (function() {
                    return function() {
                      return err = arguments[0];
                    };
                  })(),
                  lineno: 52
                }));
                __iced_deferrals._fulfill();
              })(_next);
            } else {
              return _continue();
            }
          }
        };
        _while(__iced_k);
      })(function() {
        return cb(err);
      });
    };

    Engine.prototype.sign = function(_arg, cb) {
      var asp, err, ___iced_passed_deferral, __iced_deferrals, __iced_k,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      asp = _arg.asp;
      (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: "src/keybundle.iced",
          funcname: "Engine.sign"
        });
        _this.self_sign_primary({
          asp: asp
        }, __iced_deferrals.defer({
          assign_fn: (function() {
            return function() {
              return err = arguments[0];
            };
          })(),
          lineno: 58
        }));
        __iced_deferrals._fulfill();
      })(function() {
        (function(__iced_k) {
          if (typeof err === "undefined" || err === null) {
            (function(__iced_k) {
              __iced_deferrals = new iced.Deferrals(__iced_k, {
                parent: ___iced_passed_deferral,
                filename: "src/keybundle.iced",
                funcname: "Engine.sign"
              });
              _this.sign_subkeys({
                asp: asp
              }, __iced_deferrals.defer({
                assign_fn: (function() {
                  return function() {
                    return err = arguments[0];
                  };
                })(),
                lineno: 59
              }));
              __iced_deferrals._fulfill();
            })(__iced_k);
          } else {
            return __iced_k();
          }
        })(function() {
          return cb(err);
        });
      });
    };

    return Engine;

  })();

  PgpEngine = (function(_super) {
    __extends(PgpEngine, _super);

    function PgpEngine(_arg) {
      var primary, subkeys, userids;
      primary = _arg.primary, subkeys = _arg.subkeys, userids = _arg.userids;
      PgpEngine.__super__.constructor.call(this, {
        primary: primary,
        subkeys: subkeys,
        userids: userids
      });
    }

    PgpEngine.prototype._v_allocate_key_packet = function(key) {
      if (key._pgp == null) {
        return key._pgp = new opkts.KeyMaterial({
          key: key.key,
          timestamp: key.lifespan.generated,
          userid: this.userids.get_keybase()
        });
      }
    };

    PgpEngine.prototype.userid_packet = function() {
      if (this._uidp == null) {
        this._uidp = new opkts.UserID(this.userids.get_openpgp());
      }
      return this._uidp;
    };

    PgpEngine.prototype._v_self_sign_primary = function(_arg, cb) {
      var asp, err, ___iced_passed_deferral, __iced_deferrals, __iced_k,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      asp = _arg.asp;
      (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: "src/keybundle.iced",
          funcname: "PgpEngine._v_self_sign_primary"
        });
        _this.primary._pgp.self_sign_key({
          lifespan: _this.primary.lifespan,
          uidp: _this.userid_packet()
        }, __iced_deferrals.defer({
          assign_fn: (function(__slot_1) {
            return function() {
              err = arguments[0];
              return __slot_1.self_sig = arguments[1];
            };
          })(_this),
          lineno: 89
        }));
        __iced_deferrals._fulfill();
      })(function() {
        return cb(err);
      });
    };

    PgpEngine.prototype._v_sign_subkey = function(_arg, cb) {
      var asp, err, sig, subkey, ___iced_passed_deferral, __iced_deferrals, __iced_k,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      asp = _arg.asp, subkey = _arg.subkey;
      (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: "src/keybundle.iced",
          funcname: "PgpEngine._v_sign_subkey"
        });
        _this.primary._pgp.sign_subkey({
          subkey: subkey._pgp,
          lifespan: subkey.lifespan
        }, __iced_deferrals.defer({
          assign_fn: (function() {
            return function() {
              err = arguments[0];
              return sig = arguments[1];
            };
          })(),
          lineno: 95
        }));
        __iced_deferrals._fulfill();
      })(function() {
        subkey._pgp_sig = sig;
        return cb(err);
      });
    };

    PgpEngine.prototype.export_public_to_client = function() {
      var buf, packets, subkey, _i, _len, _ref3;
      packets = [this.primary._pgp.public_framed(), this.userid_packet().write(), this.self_sig];
      _ref3 = this.subkeys;
      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
        subkey = _ref3[_i];
        packets.push(subkey._pgp.public_framed({
          subkey: true
        }), subkey._pgp_sig);
      }
      buf = Buffer.concat(packets);
      return encode(C.message_types.public_key, Buffer.concat(packets));
    };

    return PgpEngine;

  })(Engine);

  KeybaseEngine = (function(_super) {
    __extends(KeybaseEngine, _super);

    function KeybaseEngine(_arg) {
      var primary, subkeys, userids;
      primary = _arg.primary, subkeys = _arg.subkeys, userids = _arg.userids;
      KeybaseEngine.__super__.constructor.call(this, {
        primary: primary,
        subkeys: subkeys,
        userids: userids
      });
    }

    KeybaseEngine.prototype._check_can_sign = function(keys, cb) {
      var err, k, _i, _len;
      err = null;
      for (_i = 0, _len = keys.length; _i < _len; _i++) {
        k = keys[_i];
        if (err == null) {
          if (!k.key.can_sign()) {
            err = new Error("cannot sign; don't have private key");
          }
        }
      }
      return cb(err);
    };

    KeybaseEngine.prototype._v_allocate_key_packet = function(key) {
      if (key._keybase == null) {
        return key._keybase = new kpkts.KeyMaterial({
          key: key.key,
          timestamp: key.lifespan.generated,
          userid: this.userids.get_keybase()
        });
      }
    };

    KeybaseEngine.prototype._v_self_sign_primary = function(_arg, cb) {
      var asp, esc, p, ___iced_passed_deferral, __iced_deferrals, __iced_k,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      asp = _arg.asp;
      esc = make_esc(cb, "KeybaseEngine::_v_self_sign_primary");
      (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: "src/keybundle.iced",
          funcname: "KeybaseEngine._v_self_sign_primary"
        });
        _this._check_can_sign([_this.primary], esc(__iced_deferrals.defer({
          lineno: 136
        })));
        __iced_deferrals._fulfill();
      })(function() {
        _this.self_sigs = {};
        p = new kpkts.SelfSignKeybaseUsername({
          key_wrapper: _this.primary,
          userids: _this.userids
        });
        (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "src/keybundle.iced",
            funcname: "KeybaseEngine._v_self_sign_primary"
          });
          p.sign({
            asp: asp
          }, esc(__iced_deferrals.defer({
            assign_fn: (function(__slot_1) {
              return function() {
                return __slot_1.openpgp = arguments[0];
              };
            })(_this.self_sigs),
            lineno: 139
          })));
          __iced_deferrals._fulfill();
        })(function() {
          p = new kpkts.SelfSignPgpUserid({
            key_wrapper: _this.primary,
            userids: _this.userids
          });
          (function(__iced_k) {
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              filename: "src/keybundle.iced",
              funcname: "KeybaseEngine._v_self_sign_primary"
            });
            p.sign({
              asp: asp
            }, esc(__iced_deferrals.defer({
              assign_fn: (function(__slot_1) {
                return function() {
                  return __slot_1.keybase = arguments[0];
                };
              })(_this.self_sigs),
              lineno: 141
            })));
            __iced_deferrals._fulfill();
          })(function() {
            return cb(null);
          });
        });
      });
    };

    KeybaseEngine.prototype._v_sign_subkey = function(_arg, cb) {
      var asp, err, p, sig, subkey, ___iced_passed_deferral, __iced_deferrals, __iced_k,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      asp = _arg.asp, subkey = _arg.subkey;
      (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: "src/keybundle.iced",
          funcname: "KeybaseEngine._v_sign_subkey"
        });
        _this._check_can_sign([_this.primary, subkey], esc(__iced_deferrals.defer({
          lineno: 147
        })));
        __iced_deferrals._fulfill();
      })(function() {
        p = new kpkts.SubkeySignature({
          primary: _this.primary,
          subkey: subkey
        });
        (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "src/keybundle.iced",
            funcname: "KeybaseEngine._v_sign_subkey"
          });
          p.sign({
            asp: asp
          }, __iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                err = arguments[0];
                return sig = arguments[1];
              };
            })(),
            lineno: 149
          }));
          __iced_deferrals._fulfill();
        })(function() {
          subkey._keybase_sig = sig;
          return cb(err);
        });
      });
    };

    return KeybaseEngine;

  })(Engine);

  KeyBundle = (function() {
    function KeyBundle(_arg) {
      this.primary = _arg.primary, this.subkeys = _arg.subkeys, this.userids = _arg.userids, this.armored_pgp_public = _arg.armored_pgp_public;
      this.tsenc = null;
      this.pgp = new PgpEngine({
        primary: this.primary,
        subkeys: this.subkeys,
        userids: this.userids
      });
      this.keybase = new KeybaseEngine({
        primary: this.primary,
        subkeys: this.subkeys,
        userids: this.userids
      });
      this.engines = [this.pgp, this.keybase];
    }

    KeyBundle.generate = function(_arg, cb) {
      var asp, bundle, esc, generated, i, key, lifespan, nsubs, primary, subkeys, userid, userids, ___iced_passed_deferral, __iced_deferrals, __iced_k,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      asp = _arg.asp, nsubs = _arg.nsubs, userid = _arg.userid;
      userids = new UserIds({
        keybase: userid
      });
      generated = unix_time();
      esc = make_esc(cb, "KeyBundle::generate");
      asp.section("primary");
      (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: "src/keybundle.iced",
          funcname: "KeyBundle.generate"
        });
        RSA.generate({
          asp: asp,
          nbits: K.key_defaults.primary.nbits
        }, esc(__iced_deferrals.defer({
          assign_fn: (function() {
            return function() {
              return key = arguments[0];
            };
          })(),
          lineno: 173
        })));
        __iced_deferrals._fulfill();
      })(function() {
        lifespan = new Lifespan({
          generated: generated,
          expire_in: K.key_defaults.primary.expire_in
        });
        primary = new Primary({
          key: key,
          lifespan: lifespan
        });
        subkeys = [];
        lifespan = new Lifespan({
          generated: generated,
          expire_in: K.key_defaults.sub.expire_in
        });
        (function(__iced_k) {
          var _i, _results, _while;
          i = 0;
          _results = [];
          _while = function(__iced_k) {
            var _break, _continue, _next;
            _break = function() {
              return __iced_k(_results);
            };
            _continue = function() {
              return iced.trampoline(function() {
                ++i;
                return _while(__iced_k);
              });
            };
            _next = function(__iced_next_arg) {
              _results.push(__iced_next_arg);
              return _continue();
            };
            if (!(i < nsubs)) {
              return _break();
            } else {

              asp.section("subkey " + (i + 1));
              (function(__iced_k) {
                __iced_deferrals = new iced.Deferrals(__iced_k, {
                  parent: ___iced_passed_deferral,
                  filename: "src/keybundle.iced",
                  funcname: "KeyBundle.generate"
                });
                RSA.generate({
                  asp: asp,
                  nbits: K.key_defaults.sub.nbits
                }, esc(__iced_deferrals.defer({
                  assign_fn: (function() {
                    return function() {
                      return key = arguments[0];
                    };
                  })(),
                  lineno: 180
                })));
                __iced_deferrals._fulfill();
              })(function() {
                return _next(subkeys.push(new Subkey({
                  key: key,
                  desc: "subkey " + i,
                  primary: primary,
                  lifespan: lifespan
                })));
              });
            }
          };
          _while(__iced_k);
        })(function() {
          bundle = new KeyBundle({
            primary: primary,
            subkeys: subkeys,
            userids: userids
          });
          return cb(null, bundle);
        });
      });
    };

    KeyBundle.prototype.set_enc = function(e) {
      return this.tsenc = e;
    };

    KeyBundle.import_from_armored_pgp_public = function(_arg, cb) {
      var asp, bundle, err, k, kb, msg, packets, raw, userid, userids, ___iced_passed_deferral, __iced_deferrals, __iced_k, _ref3, _ref4,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      raw = _arg.raw, asp = _arg.asp, userid = _arg.userid;
      _ref3 = decode(raw), err = _ref3[0], msg = _ref3[1];
      if (err == null) {
        if (msg.type !== C.message_types.public_key) {
          err = new Error("Wanted a public key; got: " + msg.type);
        }
      }
      bundle = null;
      if (err == null) {
        _ref4 = parse(msg.body), err = _ref4[0], packets = _ref4[1];
      }
      (function(__iced_k) {
        if (err == null) {
          kb = new KeyBlock(packets);
          (function(__iced_k) {
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              filename: "src/keybundle.iced",
              funcname: "KeyBundle.import_from_armored_pgp_public"
            });
            kb.process(__iced_deferrals.defer({
              assign_fn: (function() {
                return function() {
                  return err = arguments[0];
                };
              })(),
              lineno: 207
            }));
            __iced_deferrals._fulfill();
          })(__iced_k);
        } else {
          return __iced_k();
        }
      })(function() {
        if (err == null) {
          userids = new UserIds({
            openpgp: kb.userid,
            keybase: userid
          });
          bundle = new KeyBundle({
            primary: KeyBundle._wrap_pgp(Primary, kb.primary),
            subkeys: (function() {
              var _i, _len, _ref5, _results;
              _ref5 = kb.subkeys;
              _results = [];
              for (_i = 0, _len = _ref5.length; _i < _len; _i++) {
                k = _ref5[_i];
                _results.push(KeyBundle._wrap_pgp(Subkey, k));
              }
              return _results;
            })(),
            armored_pgp_public: raw,
            userids: userids
          });
        }
        return cb(err, bundle);
      });
    };

    KeyBundle.prototype.add_armored_pgp_private = function(_arg, cb) {
      var asp, raw;
      raw = _arg.raw, asp = _arg.asp;
    };

    KeyBundle.prototype.open_pgp = function(_arg, cb) {
      var passphrase;
      passphrase = _arg.passphrase;
    };

    KeyBundle.prototype.open_keybase = function(_arg, cb) {
      var asp;
      asp = _arg.asp;
    };

    KeyBundle.prototype.export_public_to_server = function(_arg, cb) {
      var asp;
      asp = _arg.asp;
    };

    KeyBundle.prototype.export_private_to_server = function(_arg, cb) {
      var asp;
      asp = _arg.asp;
    };

    KeyBundle.prototype.export_pgp_private_to_client = function(_arg, cb) {
      var asp;
      asp = _arg.asp;
    };

    KeyBundle.prototype.export_pgp_public_to_client = function(_arg, cb) {
      var asp, msg, regen;
      asp = _arg.asp, regen = _arg.regen;
      if (!regen) {
        msg = this.armored_pgp_public;
      }
      if (msg == null) {
        msg = this.pgp.export_public_to_client();
      }
      return cb(null, msg);
    };

    KeyBundle.prototype.sign_pgp = function(_arg, cb) {
      var asp;
      asp = _arg.asp;
      return this.pgp.sign({
        asp: asp
      }, cb);
    };

    KeyBundle.prototype._self_sign_primary = function(args, cb) {
      return this._apply_to_engines({
        args: args,
        meth: Engine.prototype.self_sign_primary
      }, cb);
    };

    KeyBundle.prototype._sign_subkeys = function(args, cb) {
      return this._apply_to_engines({
        args: args,
        meth: Engine.prototype.sign_subkeys
      }, cb);
    };

    KeyBundle.prototype._apply_to_engines = function(_arg, cb) {
      var args, e, err, meth, ___iced_passed_deferral, __iced_deferrals, __iced_k,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      args = _arg.args, meth = _arg.meth;
      err = null;
      (function(__iced_k) {
        var _i, _len, _ref3, _results, _while;
        _ref3 = _this.engines;
        _len = _ref3.length;
        _i = 0;
        _results = [];
        _while = function(__iced_k) {
          var _break, _continue, _next;
          _break = function() {
            return __iced_k(_results);
          };
          _continue = function() {
            return iced.trampoline(function() {
              ++_i;
              return _while(__iced_k);
            });
          };
          _next = function(__iced_next_arg) {
            _results.push(__iced_next_arg);
            return _continue();
          };
          if (!(_i < _len)) {
            return _break();
          } else {
            e = _ref3[_i];
            if (!err) {
              (function(__iced_k) {
                __iced_deferrals = new iced.Deferrals(__iced_k, {
                  parent: ___iced_passed_deferral,
                  filename: "src/keybundle.iced",
                  funcname: "KeyBundle._apply_to_engines"
                });
                meth.call(e, args, __iced_deferrals.defer({
                  assign_fn: (function() {
                    return function() {
                      return err = arguments[0];
                    };
                  })(),
                  lineno: 285
                }));
                __iced_deferrals._fulfill();
              })(_next);
            } else {
              return _continue();
            }
          }
        };
        _while(__iced_k);
      })(function() {
        return cb(err);
      });
    };

    KeyBundle._wrap_pgp = function(klass, kmp) {
      return new klass({
        key: kmp.key,
        lifespan: new Lifespan({
          generated: kmp.timestamp
        }),
        _pgp: kmp
      });
    };

    KeyBundle.prototype.to_openpgp_packet = function(_arg) {
      var passphrase, tsec;
      tsec = _arg.tsec, passphrase = _arg.passphrase;
    };

    KeyBundle.prototype.to_keybase_packet = function(_arg) {
      var passphrase, tsec;
      tsec = _arg.tsec, passphrase = _arg.passphrase;
    };

    return KeyBundle;

  })();

  exports.KeyBundle = KeyBundle;

  exports.Encryption = Encryption;

}).call(this);
