// Generated by IcedCoffeeScript 1.7.0-a
(function() {
  var BaseKeyPair, C, K, SHA512, konst;

  konst = require('./const');

  C = konst.openpgp;

  K = konst.kb;

  SHA512 = require('./hash').SHA512;

  exports.BaseKeyPair = BaseKeyPair = (function() {
    function BaseKeyPair(_arg) {
      this.priv = _arg.priv, this.pub = _arg.pub;
      this.pub.parent = this;
      if (this.priv != null) {
        this.priv.parent = this;
      }
    }

    BaseKeyPair.prototype.serialize = function() {
      return this.pub.serialize();
    };

    BaseKeyPair.prototype.hash = function() {
      return SHA512(this.serialize());
    };

    BaseKeyPair.prototype.ekid = function() {
      return Buffer.concat([new Buffer([k.kid.version, this.type]), this.hash()]);
    };

    BaseKeyPair.prototype.can_sign = function() {
      return this.priv != null;
    };

    BaseKeyPair.prototype.can_decrypt = function() {
      return this.priv != null;
    };

    BaseKeyPair.prototype.eq = function(k2) {
      return (this.type === k2.type) && (bufeq_secure(this.serialize(), k2.serialize()));
    };

    BaseKeyPair.prototype.can_perform = function(ops_mask) {
      if ((ops_mask & konst.ops.sign) && !this.can_sign()) {
        return false;
      } else if ((ops_mask & konst.ops.decrypt) && !this.can_decrypt()) {
        return false;
      } else {
        return true;
      }
    };

    BaseKeyPair.parse = function(klass, pub_raw) {
      var err, key, len, _ref;
      _ref = klass.Pub.alloc(pub_raw), err = _ref[0], key = _ref[1], len = _ref[2];
      if (key != null) {
        key = new klass({
          pub: key
        });
      }
      return [err, key, len];
    };

    BaseKeyPair.prototype.add_priv = function(priv_raw) {
      var err, len, _ref;
      _ref = Priv.alloc(priv_raw), err = _ref[0], this.priv = _ref[1], len = _ref[2];
      return [err, len];
    };

    BaseKeyPair.alloc = function(klass, _arg) {
      var err, priv, pub, _ref, _ref1;
      pub = _arg.pub, priv = _arg.priv;
      _ref = klass.Pub.alloc(pub), err = _ref[0], pub = _ref[1];
      if ((err == null) && (priv != null)) {
        _ref1 = klass.Priv.alloc(priv, pub), err = _ref1[0], priv = _ref1[1];
      }
      if (err != null) {
        return [err, null];
      } else {
        return [
          null, new klass({
            priv: priv,
            pub: pub
          })
        ];
      }
    };

    BaseKeyPair.prototype.read_priv = function(raw_priv) {
      var err, _ref;
      _ref = this.Priv.alloc(raw_priv, this.pub), err = _ref[0], this.priv = _ref[1];
      return err;
    };

    return BaseKeyPair;

  })();

}).call(this);
