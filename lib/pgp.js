// Generated by IcedCoffeeScript 1.6.3-g
(function() {
  var ASP, C, encoding, generate_keypair, generate_raw_keypair, generate_rsa_keypair, iced, make_esc, make_time_packet, msg, openpgp, packet, test, triplesec, uint_to_buffer, util, __iced_k, __iced_k_noop, _generate_keypair, _ref, _ref1;

  iced = require('iced-coffee-script/lib/coffee-script/iced').runtime;
  __iced_k = __iced_k_noop = function() {};

  generate_rsa_keypair = require('./rsa').generate_rsa_keypair;

  triplesec = require('triplesec');

  _ref = require('openpgp'), util = _ref.util, openpgp = _ref.openpgp, packet = _ref.packet, msg = _ref.msg, encoding = _ref.encoding;

  _ref1 = require('./util'), ASP = _ref1.ASP, uint_to_buffer = _ref1.uint_to_buffer, make_time_packet = _ref1.make_time_packet;

  C = require('./const').openpgp;

  make_esc = require('iced-error').make_esc;

  generate_raw_keypair = function(_arg, cb) {
    var asp, esc, key, nbits, priv, pub, ret, timePacket, type, ___iced_passed_deferral, __iced_deferrals, __iced_k,
      _this = this;
    __iced_k = __iced_k_noop;
    ___iced_passed_deferral = iced.findDeferral(arguments);
    nbits = _arg.nbits, asp = _arg.asp;
    nbits || (nbits = 4096);
    esc = make_esc("generate_raw_keypair");
    timePacket = make_time_packet();
    (function(__iced_k) {
      __iced_deferrals = new iced.Deferrals(__iced_k, {
        parent: ___iced_passed_deferral,
        filename: "src/pgp.iced",
        funcname: "generate_raw_keypair"
      });
      generate_rsa_keypair({
        nbits: nbits,
        iters: 10,
        asp: asp
      }, esc(__iced_deferrals.defer({
        assign_fn: (function() {
          return function() {
            return key = arguments[0];
          };
        })(),
        lineno: 27
      })));
      __iced_deferrals._fulfill();
    })(function() {
      type = C.public_key_algorithms.RSA;
      pub = (new packet.KeyMaterial()).write_public_key(type, key, timePacket);
      priv = (new packet.KeyMaterial()).write_private_key(type, key, null, null, null, timePacket);
      ret = {
        privateKey: priv,
        publicKey: pub
      };
      return cb(null, ret);
    });
  };

  generate_keypair = function(_arg, cb) {
    var asp, delay, nbits, progress_hook, userid;
    nbits = _arg.nbits, userid = _arg.userid, progress_hook = _arg.progress_hook, delay = _arg.delay;
    asp = new ASP({
      progress_hook: progress_hook,
      delay: delay
    });
    _generate_keypair({
      nbits: nbits,
      userid: userid,
      asp: asp
    }, cb);
    return asp.canceler();
  };

  _generate_keypair = function(_arg, cb) {
    var asp, bufs, err, esc, hashData, key, nbits, payload, privKey, privKeyPacket, privKeyString, publicKeyString, ret, signature, userIdString, userid, userid_buffer, ___iced_passed_deferral, __iced_deferrals, __iced_k,
      _this = this;
    __iced_k = __iced_k_noop;
    ___iced_passed_deferral = iced.findDeferral(arguments);
    nbits = _arg.nbits, asp = _arg.asp, userid = _arg.userid;
    userIdString = (new packet.UserID()).write_packet(userid);
    esc = make_esc("generate_keypair");
    (function(__iced_k) {
      __iced_deferrals = new iced.Deferrals(__iced_k, {
        parent: ___iced_passed_deferral,
        filename: "src/pgp.iced",
        funcname: "_generate_keypair"
      });
      generate_raw_keypair({
        nbits: nbits,
        asp: asp
      }, esc(__iced_deferrals.defer({
        assign_fn: (function() {
          return function() {
            return key = arguments[0];
          };
        })(),
        lineno: 64
      })));
      __iced_deferrals._fulfill();
    })(function() {
      privKeyString = key.privateKey.string;
      privKeyPacket = (new packet.KeyMaterial()).read_priv_key(privKeyString, 3, privKeyString.length);
      if (!privKeyPacket.decryptSecretMPIs()) {
        err = new Error('failed to read unencrypted secret key data');
        ret = null;
      } else {
        err = null;
        privKey = new msg.PrivateKey();
        privKey.privateKeyPacket = privKeyPacket;
        privKey.getPreferredSignatureHashAlgorithm = function() {
          return C.hash_algorithms.SHA512;
        };
        publicKeyString = privKey.privateKeyPacket.publicKey.data;
        userid_buffer = new Buffer(userid, 'utf8');
        bufs = [new Buffer([0x99]), uint_to_buffer(16, publicKeyString.length), new Buffer(publicKeyString, 'binary'), new Buffer([0xb4]), uint_to_buffer(32, userid_buffer.length), userid_buffer];
        hashData = Buffer.concat(bufs).toString('binary');
        signature = (new packet.Signature()).write_message_signature(C.subpacket_types.issuer, hashData, privKey);
        payload = function(which) {
          return which + userIdString + signature.openpgp;
        };
        ret = {
          publicKeyArmored: encoding.armor(C.message_types.public_key, payload(key.publicKey.string)),
          privateKeyObject: {
            signature: new Buffer(signature.openpgp, 'binary'),
            userid: userid,
            privateKey: new Buffer(privKeyString, 'binary')
          }
        };
      }
      return cb(err, ret);
    });
  };

  test = function() {
    var err, key, progress_hook, ___iced_passed_deferral, __iced_deferrals, __iced_k,
      _this = this;
    __iced_k = __iced_k_noop;
    ___iced_passed_deferral = iced.findDeferral(arguments);
    progress_hook = function(obj) {
      var interval, s;
      if (obj.p != null) {
        s = obj.p.toString();
        s = "" + s.slice(0, 3) + "...." + s.slice(s.length - 6);
      } else {
        s = "";
      }
      interval = (obj.total != null) && (obj.i != null) ? "(" + obj.i + " of " + obj.total + ")" : "";
      return console.log("+ " + obj.what + " " + interval + " " + s);
    };
    openpgp.init();
    (function(__iced_k) {
      __iced_deferrals = new iced.Deferrals(__iced_k, {
        parent: ___iced_passed_deferral,
        filename: "src/pgp.iced",
        funcname: "test"
      });
      generate_keypair({
        nbits: 1024,
        progress_hook: progress_hook,
        userid: "Max Krohn <max@keybase.io>"
      }, __iced_deferrals.defer({
        assign_fn: (function() {
          return function() {
            err = arguments[0];
            return key = arguments[1];
          };
        })(),
        lineno: 121
      }));
      __iced_deferrals._fulfill();
    })(function() {
      console.log(key);
      return process.exit(0);
    });
  };

  exports.generate_keypair = generate_keypair;

  exports.generate_raw_keypair = generate_raw_keypair;

}).call(this);
