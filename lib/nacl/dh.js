// Generated by IcedCoffeeScript 1.7.1-c
(function() {
  var BaseKey, BaseKeyPair, K, Pair, Priv, Pub, SRF, TYPE, b2u, box, bufeq_fast, iced, konst, u2b, __iced_k, __iced_k_noop, _ref, _ref1,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  iced = require('iced-runtime').iced;
  __iced_k = __iced_k_noop = function() {};

  box = require('tweetnacl').box;

  SRF = require('../rand').SRF;

  konst = require('../const');

  K = konst.kb;

  bufeq_fast = require('../util').bufeq_fast;

  _ref = require('../basekeypair'), BaseKey = _ref.BaseKey, BaseKeyPair = _ref.BaseKeyPair;

  _ref1 = require('./eddsa'), b2u = _ref1.b2u, u2b = _ref1.u2b;

  TYPE = K.public_key_algorithms.NACL_DH;

  b2u = function(b) {
    return new Uint8Array(b);
  };

  u2b = function(u) {
    return new Buffer(u);
  };

  Pub = (function() {
    Pub.HEADER = new Buffer([K.kid.version, TYPE]);

    Pub.TRAILER = new Buffer([K.kid.trailer]);

    Pub.LEN = Pub.HEADER.length + Pub.TRAILER.length + sign.publicKeyLength;

    function Pub(key) {
      this.key = key;
    }

    Pub.alloc_kb = function(kid) {
      var err, key;
      err = key = null;
      err = kid.length !== Pub.LEN ? new Error("bad key length") : !bufeq_fast(kid.slice(-1), Pub.TRAILER) ? new Error("bad trailing byte") : !bufeq_fast(kid.slice(0, 2), Pub.HEADER) ? new Error("bad header") : (key = new Pub(kid.slice(2, -1)), null);
      return [err, key];
    };

    Pub.prototype.serialize = function() {
      return this.key;
    };

    Pub.prototype.nbits = function() {
      return 255;
    };

    Pub.prototype.read_params = function(sb) {};

    Pub.prototype.encrypt = function(_arg, cb) {
      var nonce, payload, res, sender, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      payload = _arg.payload, sender = _arg.sender;
      (function(_this) {
        return (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/Users/max/src/keybase/kbpgp/src/nacl/dh.iced",
            funcname: "Pub.encrypt"
          });
          SRF().random_bytes(box.nonceLength, __iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                return nonce = arguments[0];
              };
            })(),
            lineno: 49
          }));
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          res = box(b2u(payload), b2u(nonce), b2u(_this.key), b2u(sender));
          return cb(null, u2b(res));
        };
      })(this));
    };

    return Pub;

  })();

  Priv = (function() {
    function Priv(key) {
      this.key = key;
    }

    Priv.prototype.alloc = function(raw) {
      var err, key;
      err = key = null;
      if (raw.length !== box.secretKeyLength) {
        err = new Error("Bad secret key length");
      } else {
        key = new Priv(raw);
      }
      return [err, key];
    };

    Priv.prototype.decrypt = function(_arg, cb) {
      var ciphertext, err, nonce, res, sender;
      ciphertext = _arg.ciphertext, nonce = _arg.nonce, sender = _arg.sender;
      err = res = null;
      res = box.open(b2u(ciphertext), b2u(nonce), b2u(sender), b2u(this.key));
      if (res === false) {
        err = new Error("decryption failed");
        res = null;
      } else {
        res = u2b(res);
      }
      return cb(err, res);
    };

    return Priv;

  })();

  Pair = (function(_super) {
    __extends(Pair, _super);

    function Pair() {
      return Pair.__super__.constructor.apply(this, arguments);
    }

    Pair.prototype.construct = function(_arg) {
      var priv, pub;
      pub = _arg.pub, priv = _arg.priv;
      return Pair.__super__.construct.call(this, {
        pub: pub,
        priv: priv
      });
    };

    return Pair;

  })(BaseKeyPair);

  exports.DH = exports.Pair = Pair;

}).call(this);
