;(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
var Buffer=require("__browserify_Buffer").Buffer;// Generated by IcedCoffeeScript 1.6.3-g
(function() {
  var BigInteger, nbi, nbits, nbs, nbv, toMPI, _ref;



  _ref = require('openpgp').bigint, nbv = _ref.nbv, nbi = _ref.nbi, BigInteger = _ref.BigInteger, nbits = _ref.nbits;

  nbs = function(s, base) {
    var r;
    if (base == null) {
      base = 10;
    }
    r = nbi();
    r.fromString(s, base);
    return r;
  };

  toMPI = function(bn) {
    var ba, hdr, size;
    ba = bn.toByteArray();
    size = (ba.length - 1) * 8 + nbits(ba[0]);
    hdr = new Buffer(2);
    hdr.writeUInt16BE(size, 0);
    return Buffer.concat([hdr, new Buffer(ba)]);
  };

  exports.toMPI = toMPI;

  exports.nbs = nbs;

  BigInteger.prototype.to_mpi_buffer = function() {
    return toMPI(this);
  };

}).call(this);

},{"__browserify_Buffer":18,"openpgp":25}],2:[function(require,module,exports){
var Buffer=require("__browserify_Buffer").Buffer;// Generated by IcedCoffeeScript 1.6.3-g
(function() {
  var AES, WordArray, ciphers, decrypt, encrypt, test, _ref;



  _ref = require('triplesec'), ciphers = _ref.ciphers, WordArray = _ref.WordArray;

  AES = ciphers.AES;

  encrypt = function(_arg) {
    var block_cipher_class, block_size, c, cipher, e, iv, key, list, plaintext, pos;
    block_cipher_class = _arg.block_cipher_class, key = _arg.key, cipher = _arg.cipher, plaintext = _arg.plaintext, iv = _arg.iv;
    block_cipher_class || (block_cipher_class = AES);
    cipher || (cipher = new block_cipher_class(WordArray.from_buffer(key)));
    block_size = cipher.blockSize;
    c = WordArray.from_buffer(iv.slice(0, block_size));
    pos = 0;
    list = (function() {
      var _results;
      _results = [];
      while (plaintext.length > pos) {
        cipher.encryptBlock(c.words, 0);
        e = c;
        c = WordArray.from_buffer(plaintext.slice(pos, pos + block_size));
        e.xor(c, {
          n_words: c.words.length
        });
        pos += block_size;
        c = e;
        _results.push(e.to_buffer());
      }
      return _results;
    })();
    return Buffer.concat(list);
  };

  decrypt = function(_arg) {
    var b, block_cipher_class, block_size, cipher, ciphertext, d, i, iv, key, list, pos;
    block_cipher_class = _arg.block_cipher_class, key = _arg.key, cipher = _arg.cipher, ciphertext = _arg.ciphertext, iv = _arg.iv;
    block_cipher_class || (block_cipher_class = AES);
    cipher || (cipher = new block_cipher_class(WordArray.from_buffer(key)));
    block_size = cipher.blockSize;
    iv || (iv = new Buffer((function() {
      var _i, _results;
      _results = [];
      for (i = _i = 0; 0 <= block_size ? _i < block_size : _i > block_size; i = 0 <= block_size ? ++_i : --_i) {
        _results.push(0);
      }
      return _results;
    })()));
    b = WordArray.from_buffer(iv.slice(0, block_size));
    pos = 0;
    list = (function() {
      var _results;
      _results = [];
      while (ciphertext.length > pos) {
        cipher.encryptBlock(b.words, 0);
        d = b;
        b = WordArray.from_buffer(ciphertext.slice(pos, pos + block_size));
        d.xor(b, {});
        pos += block_size;
        _results.push(d.to_buffer());
      }
      return _results;
    })();
    return Buffer.concat(list);
  };

  exports.encrypt = encrypt;

  exports.decrypt = decrypt;

  test = function() {};

  test();

}).call(this);

},{"__browserify_Buffer":18,"triplesec":35}],3:[function(require,module,exports){
// Generated by IcedCoffeeScript 1.6.3-g
(function() {


  exports.openpgp = {
    public_key_algorithms: {
      RSA: 1
    },
    symmetric_key_algorithms: {
      CAST5: 3,
      AES128: 7,
      AES192: 8,
      AES256: 9
    },
    hash_algorithms: {
      SHA1: 2,
      SHA256: 8,
      SHA384: 9,
      SHA512: 10,
      SHA224: 11
    },
    subpacket_types: {
      issuer: 16
    },
    message_types: {
      public_key: 4,
      private_key: 5
    }
  };

}).call(this);

},{}],4:[function(require,module,exports){
// Generated by IcedCoffeeScript 1.6.3-g
(function() {
  var ASP, Avg, BigInteger, MediumRandomFountain, Montgomery, PrimeFinder, StrongRandomFountain, Timer, fermat2_test, fta, iced, make_esc, miller_rabin, ms_random_word, native_rng, nbi, nbs, nbv, prime_search, prng, quickmod, random_prime, random_zn, small_primes, _MR_inner, _MR_small_check, __iced_k, __iced_k_noop, _ref;

  iced = require('iced-coffee-script/lib/coffee-script/iced').runtime;
  __iced_k = __iced_k_noop = function() {};

  _ref = require('openpgp').bigint, Montgomery = _ref.Montgomery, nbv = _ref.nbv, nbi = _ref.nbi, BigInteger = _ref.BigInteger;

  prng = require('triplesec').prng;

  native_rng = prng.native_rng;

  small_primes = require('./primes').small_primes;

  make_esc = require('iced-error').make_esc;

  ASP = require('./util').ASP;

  nbs = require('./bn').nbs;

  Timer = (function() {
    function Timer() {
      this.start = Date.now();
    }

    Timer.prototype.stop = function() {
      return Date.now() - this.start;
    };

    return Timer;

  })();

  Avg = (function() {
    function Avg() {
      this.tot = 0;
      this.n = 0;
    }

    Avg.prototype.start = function() {
      return this._t = Date.now();
    };

    Avg.prototype.stop = function() {
      var s;
      s = Date.now() - this._t;
      console.log("ran in " + s);
      this.tot += s;
      return this.n++;
    };

    Avg.prototype.avg = function() {
      return this.tot / this.n;
    };

    return Avg;

  })();

  quickmod = function(p, d) {
    return p.modInt(d);
  };

  fta = new Avg();

  fermat2_test = function(n) {
    var bl, i, ret, t, _i;
    t = nbv(1);
    bl = n.bitLength();
    bl--;
    for (i = _i = bl; bl <= 0 ? _i <= 0 : _i >= 0; i = bl <= 0 ? ++_i : --_i) {
      t = t.modPowInt(2, n);
      if (n.testBit(i)) {
        t = t.shiftLeft(1);
      }
    }
    if (t.compareTo(n) > 0) {
      t = t.mod(n);
    }
    ret = t.compareTo(nbv(2)) === 0;
    return ret;
  };

  ms_random_word = function() {
    return native_rng(4).readUInt32BE(0);
  };

  MediumRandomFountain = (function() {
    function MediumRandomFountain() {}

    MediumRandomFountain.prototype.nextBytes = function(v) {
      var b, c, i, _i, _len, _results;
      b = native_rng(v.length);
      _results = [];
      for (i = _i = 0, _len = b.length; _i < _len; i = ++_i) {
        c = b[i];
        _results.push(v[i] = c);
      }
      return _results;
    };

    return MediumRandomFountain;

  })();

  random_zn = function(rf, n) {
    var i;
    while (true) {
      i = new BigInteger(n.bitLength(), rf);
      if (i.compareTo(BigInteger.ONE) > 0 && i.compareTo(n) < 0) {
        return i;
      }
    }
  };

  _MR_inner = function(_arg) {
    var a, j, mrf, p, p1, r, s, y, _i, _ref1;
    mrf = _arg.mrf, s = _arg.s, r = _arg.r, p = _arg.p, p1 = _arg.p1;
    a = random_zn(mrf, p);
    y = a.modPow(r, p);
    if (y.compareTo(BigInteger.ONE) !== 0) {
      for (j = _i = _ref1 = s - 1; _ref1 <= 0 ? _i <= 0 : _i >= 0; j = _ref1 <= 0 ? ++_i : --_i) {
        if (!(y.compareTo(p1) !== 0)) {
          continue;
        }
        if (j === 0) {
          return false;
        }
        y = y.square().mod(p);
        if (y.compareTo(BigInteger.ONE) === 0) {
          return false;
        }
      }
    }
    return true;
  };

  _MR_small_check = function(_arg) {
    var p, _ref1;
    p = _arg.p;
    if (p.compareTo(BigInteger.ZERO) <= 0) {
      return false;
    } else if (p.compareTo(nbv(7) <= 0)) {
      return (_ref1 = p.intValue()) === 2 || _ref1 === 3 || _ref1 === 5 || _ref1 === 7;
    } else if (!p.testBit(0)) {
      return false;
    } else {
      return true;
    }
  };

  miller_rabin = function(_arg, cb) {
    var asp, esc, i, iter, mrf, p, p1, r, ret, s, ___iced_passed_deferral, __iced_deferrals, __iced_k,
      _this = this;
    __iced_k = __iced_k_noop;
    ___iced_passed_deferral = iced.findDeferral(arguments);
    p = _arg.p, iter = _arg.iter, asp = _arg.asp;
    asp || (asp = new ASP({}));
    iter || (iter = 10);
    esc = make_esc(cb, "miller_rabin");
    ret = _MR_small_check({
      p: p
    });
    (function(__iced_k) {
      if (ret) {
        p1 = p.subtract(BigInteger.ONE);
        s = p1.getLowestSetBit();
        r = p1.shiftRight(s);
        mrf = new MediumRandomFountain();
        ret = true;
        (function(__iced_k) {
          var _i, _results, _while;
          i = 0;
          _results = [];
          _while = function(__iced_k) {
            var _break, _continue, _next;
            _break = function() {
              return __iced_k(_results);
            };
            _continue = function() {
              return iced.trampoline(function() {
                ++i;
                return _while(__iced_k);
              });
            };
            _next = function(__iced_next_arg) {
              _results.push(__iced_next_arg);
              return _continue();
            };
            if (!(i < iter)) {
              return _break();
            } else {

              (function(__iced_k) {
                __iced_deferrals = new iced.Deferrals(__iced_k, {
                  parent: ___iced_passed_deferral,
                  filename: "src/primegen.iced",
                  funcname: "miller_rabin"
                });
                asp.progress({
                  what: "mr",
                  i: i,
                  total: iter,
                  p: p
                }, esc(__iced_deferrals.defer({
                  lineno: 146
                })));
                __iced_deferrals._fulfill();
              })(function() {
                (function(__iced_k) {
                  if (!_MR_inner({
                    mrf: mrf,
                    s: s,
                    r: r,
                    p: p,
                    p1: p1
                  })) {
                    ret = false;
                    (function(__iced_k) {
_break()
                    })(__iced_k);
                  } else {
                    return __iced_k();
                  }
                })(_next);
              });
            }
          };
          _while(__iced_k);
        })(function() {
          (function(__iced_k) {
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              filename: "src/primegen.iced",
              funcname: "miller_rabin"
            });
            asp.progress({
              what: "mr",
              i: iter,
              total: iter,
              p: p
            }, esc(__iced_deferrals.defer({
              lineno: 151
            })));
            __iced_deferrals._fulfill();
          })(__iced_k);
        });
      } else {
        return __iced_k();
      }
    })(function() {
      return cb(null, ret);
    });
  };

  PrimeFinder = (function() {
    function PrimeFinder(p, sieve) {
      this.p = p;
      this.sieve = sieve;
      this.inc = 0;
      this.maxinc = -1;
      this.sievepos = quickmod(this.p, this.sieve.length);
      this.calcmods();
    }

    PrimeFinder.prototype.getp = function() {
      return this.p;
    };

    PrimeFinder.prototype.setmax = function(i) {
      if (this.maxinc !== -1) {
        throw new Error("can only setmax() once");
      }
      return this.maxinc = i;
    };

    PrimeFinder.prototype.calcmods = function() {
      var sp;
      this.p = this.p.add(nbv(this.inc));
      if (this.maxinc !== -1) {
        this.maxinc -= this.inc;
      }
      this.inc = 0;
      return this.mods = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = small_primes.length; _i < _len; _i++) {
          sp = small_primes[_i];
          _results.push(quickmod(this.p, sp));
        }
        return _results;
      }).call(this);
    };

    PrimeFinder.prototype.decrement_mods_find_divisor = function() {
      var i, sp, _i, _len;
      for (i = _i = 0, _len = small_primes.length; _i < _len; i = ++_i) {
        sp = small_primes[i];
        while (this.mods[i] + this.inc >= sp) {
          this.mods[i] -= sp;
          if ((this.mods[i] + this.inc) === 0) {
            return true;
          }
        }
      }
      return false;
    };

    PrimeFinder.prototype.next_weak = function() {
      var step;
      while (true) {
        step = this.sieve[this.sievepos];
        this.sievepos = (this.sievepos + step) % this.sieve.length;
        this.inc += step;
        if (this.inc > this.maxinc && this.maxinc > 0) {
          this.tmp = nbv(0);
          return this.tmp;
        }
        if (this.inc < 0) {
          this.calcmods();
        }
        if (!this.decrement_mods_find_divisor()) {
          this.tmp = this.p.add(nbv(this.inc));
          return this.tmp;
        }
      }
    };

    PrimeFinder.prototype.next_fermat = function() {
      while (true) {
        this.next_weak();
        if (!this.tmp || fermat2_test(this.tmp)) {
          return this.tmp;
        }
      }
    };

    PrimeFinder.prototype.next_strong = function(iter) {
      if (iter == null) {
        iter = 32;
      }
      while (true) {
        this.next_weak();
        if (!this.tmp || (fermat2_test(this.tmp) && probab_prime(this.tmp, iter))) {
          return this.tmp;
        }
      }
    };

    return PrimeFinder;

  })();

  prime_search = function(_arg, cb) {
    var asp, esc, i, is_prime, iters, p, pf, pp, pvec, range, ret, sieve, start, tmp, ___iced_passed_deferral, __iced_deferrals, __iced_k,
      _this = this;
    __iced_k = __iced_k_noop;
    ___iced_passed_deferral = iced.findDeferral(arguments);
    start = _arg.start, range = _arg.range, sieve = _arg.sieve, asp = _arg.asp, iters = _arg.iters;
    iters || (iters = 20);
    pf = new PrimeFinder(start, sieve);
    pf.setmax(range);
    pvec = ((function() {
      var _results;
      _results = [];
      while ((pp = pf.next_weak()).compareTo(BigInteger.ZERO) > 0) {
        _results.push(pp);
      }
      return _results;
    })());
    esc = make_esc(cb, "prime_search");
    ret = null;
    (function(__iced_k) {
      var _results, _while;
      _results = [];
      _while = function(__iced_k) {
        var _break, _continue, _next;
        _break = function() {
          return __iced_k(_results);
        };
        _continue = function() {
          return iced.trampoline(function() {
            return _while(__iced_k);
          });
        };
        _next = function(__iced_next_arg) {
          _results.push(__iced_next_arg);
          return _continue();
        };
        if (!(pvec.length && (ret == null))) {
          return _break();
        } else {
          i = ms_random_word() % pvec.length;
          p = pvec[i];
          (function(__iced_k) {
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              filename: "src/primegen.iced",
              funcname: "prime_search"
            });
            asp.progress({
              what: "fermat",
              p: p
            }, esc(__iced_deferrals.defer({
              lineno: 250
            })));
            __iced_deferrals._fulfill();
          })(function() {
            (function(__iced_k) {
              if (!fermat2_test(p)) {
                return __iced_k();
              } else {
                (function(__iced_k) {
                  __iced_deferrals = new iced.Deferrals(__iced_k, {
                    parent: ___iced_passed_deferral,
                    filename: "src/primegen.iced",
                    funcname: "prime_search"
                  });
                  miller_rabin({
                    p: p,
                    iters: iters,
                    asp: asp
                  }, esc(__iced_deferrals.defer({
                    assign_fn: (function() {
                      return function() {
                        return is_prime = arguments[0];
                      };
                    })(),
                    lineno: 253
                  })));
                  __iced_deferrals._fulfill();
                })(function() {
                  (function(__iced_k) {
                    __iced_deferrals = new iced.Deferrals(__iced_k, {
                      parent: ___iced_passed_deferral,
                      filename: "src/primegen.iced",
                      funcname: "prime_search"
                    });
                    asp.progress({
                      what: "passed_mr",
                      p: p
                    }, esc(__iced_deferrals.defer({
                      lineno: 254
                    })));
                    __iced_deferrals._fulfill();
                  })(function() {
                    return __iced_k(is_prime ? ret = p : asp.progress({
                      what: "failed_mr",
                      p: p
                    }));
                  });
                });
              }
            })(function() {
              tmp = pvec.pop();
              return _next(i < pvec.length ? pvec[i] = tmp : void 0);
            });
          });
        }
      };
      _while(__iced_k);
    })(function() {
      if (ret == null) {
        ret = nbv(0);
      }
      return cb(null, ret);
    });
  };

  StrongRandomFountain = (function() {
    function StrongRandomFountain() {
      this.buf = null;
    }

    StrongRandomFountain.prototype.recharge = function(cb) {
      var tmp, ___iced_passed_deferral, __iced_deferrals, __iced_k,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: "src/primegen.iced",
          funcname: "StrongRandomFountain.recharge"
        });
        prng.generate(Math.floor(7000 / 8), __iced_deferrals.defer({
          assign_fn: (function() {
            return function() {
              return tmp = arguments[0];
            };
          })(),
          lineno: 272
        }));
        __iced_deferrals._fulfill();
      })(function() {
        _this.buf = tmp.to_buffer();
        return cb();
      });
    };

    StrongRandomFountain.prototype.nextBytes = function(v) {
      var i, _i, _ref1;
      if (this.buf == null) {
        throw new Error("need a recharge!");
      }
      for (i = _i = 0, _ref1 = v.length; 0 <= _ref1 ? _i < _ref1 : _i > _ref1; i = 0 <= _ref1 ? ++_i : --_i) {
        v[i] = this.buf[i];
      }
      return this.buf = null;
    };

    return StrongRandomFountain;

  })();

  random_prime = function(_arg, cb) {
    var asp, e, esc, go, iters, nbits, p, range, sieve, srf, ___iced_passed_deferral, __iced_deferrals, __iced_k,
      _this = this;
    __iced_k = __iced_k_noop;
    ___iced_passed_deferral = iced.findDeferral(arguments);
    nbits = _arg.nbits, iters = _arg.iters, asp = _arg.asp, e = _arg.e;
    srf = new StrongRandomFountain();
    sieve = [1, 2];
    go = true;
    esc = make_esc(cb, "random_prime");
    range = nbits;
    p = null;
    (function(__iced_k) {
      var _results, _while;
      _results = [];
      _while = function(__iced_k) {
        var _break, _continue, _next;
        _break = function() {
          return __iced_k(_results);
        };
        _continue = function() {
          return iced.trampoline(function() {
            return _while(__iced_k);
          });
        };
        _next = function(__iced_next_arg) {
          _results.push(__iced_next_arg);
          return _continue();
        };
        if (!go) {
          return _break();
        } else {
          (function(__iced_k) {
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              filename: "src/primegen.iced",
              funcname: "random_prime"
            });
            srf.recharge(__iced_deferrals.defer({
              lineno: 304
            }));
            __iced_deferrals._fulfill();
          })(function() {
            p = new BigInteger(nbits, srf);
            p = p.setBit(0).setBit(nbits - 1);
            (function(__iced_k) {
              if ((e == null) || p.subtract(BigInteger.ONE).gcd(e).compareTo(BigInteger.ONE) === 0) {
                (function(__iced_k) {
                  __iced_deferrals = new iced.Deferrals(__iced_k, {
                    parent: ___iced_passed_deferral,
                    filename: "src/primegen.iced",
                    funcname: "random_prime"
                  });
                  asp.progress({
                    what: "guess",
                    p: p
                  }, esc(__iced_deferrals.defer({
                    lineno: 308
                  })));
                  __iced_deferrals._fulfill();
                })(function() {
                  (function(__iced_k) {
                    __iced_deferrals = new iced.Deferrals(__iced_k, {
                      parent: ___iced_passed_deferral,
                      filename: "src/primegen.iced",
                      funcname: "random_prime"
                    });
                    prime_search({
                      start: p,
                      range: range,
                      sieve: sieve,
                      asp: asp,
                      iters: iters
                    }, esc(__iced_deferrals.defer({
                      assign_fn: (function() {
                        return function() {
                          return p = arguments[0];
                        };
                      })(),
                      lineno: 309
                    })));
                    __iced_deferrals._fulfill();
                  })(function() {
                    return __iced_k(go = (p == null) || (p.compareTo(BigInteger.ZERO) === 0));
                  });
                });
              } else {
                return __iced_k();
              }
            })(_next);
          });
        }
      };
      _while(__iced_k);
    })(function() {
      (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: "src/primegen.iced",
          funcname: "random_prime"
        });
        asp.progress({
          what: "found",
          p: p
        }, esc(__iced_deferrals.defer({
          lineno: 312
        })));
        __iced_deferrals._fulfill();
      })(function() {
        return cb(null, p);
      });
    });
  };

  exports.fermat2_test = fermat2_test;

  exports.nbs = nbs;

  exports.small_primes = small_primes;

  exports.miller_rabin = miller_rabin;

  exports.random_prime = random_prime;

  exports.random_zn = random_zn;

  exports.MediumRandomFountain = MediumRandomFountain;

  exports.StrongRandomFountain = StrongRandomFountain;

}).call(this);

},{"./bn":1,"./primes":5,"./util":7,"iced-coffee-script/lib/coffee-script/iced":22,"iced-error":23,"openpgp":25,"triplesec":35}],5:[function(require,module,exports){
// Generated by IcedCoffeeScript 1.6.3-g
(function() {


  exports.small_primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973, 10007, 10009, 10037, 10039, 10061, 10067, 10069, 10079, 10091, 10093, 10099, 10103, 10111, 10133, 10139, 10141, 10151, 10159, 10163, 10169, 10177, 10181, 10193, 10211, 10223, 10243, 10247, 10253, 10259, 10267, 10271, 10273, 10289, 10301, 10303, 10313, 10321, 10331, 10333, 10337, 10343, 10357, 10369, 10391, 10399, 10427, 10429, 10433, 10453, 10457, 10459, 10463, 10477, 10487, 10499, 10501, 10513, 10529, 10531, 10559, 10567, 10589, 10597, 10601, 10607, 10613, 10627, 10631, 10639, 10651, 10657, 10663, 10667, 10687, 10691, 10709, 10711, 10723, 10729, 10733, 10739, 10753, 10771, 10781, 10789, 10799, 10831, 10837, 10847, 10853, 10859, 10861, 10867, 10883, 10889, 10891, 10903, 10909, 10937, 10939, 10949, 10957, 10973, 10979, 10987, 10993, 11003, 11027, 11047, 11057, 11059, 11069, 11071, 11083, 11087, 11093, 11113, 11117, 11119, 11131, 11149, 11159, 11161, 11171, 11173, 11177, 11197, 11213, 11239, 11243, 11251, 11257, 11261, 11273, 11279, 11287, 11299, 11311, 11317, 11321, 11329, 11351, 11353, 11369, 11383, 11393, 11399, 11411, 11423, 11437, 11443, 11447, 11467, 11471, 11483, 11489, 11491, 11497, 11503, 11519, 11527, 11549, 11551, 11579, 11587, 11593, 11597, 11617, 11621, 11633, 11657, 11677, 11681, 11689, 11699, 11701, 11717, 11719, 11731, 11743, 11777, 11779, 11783, 11789, 11801, 11807, 11813, 11821, 11827, 11831, 11833, 11839, 11863, 11867, 11887, 11897, 11903, 11909, 11923, 11927, 11933, 11939, 11941, 11953, 11959, 11969, 11971, 11981, 11987, 12007, 12011, 12037, 12041, 12043, 12049, 12071, 12073, 12097, 12101, 12107, 12109, 12113, 12119, 12143, 12149, 12157, 12161, 12163, 12197, 12203, 12211, 12227, 12239, 12241, 12251, 12253, 12263, 12269, 12277, 12281, 12289, 12301, 12323, 12329, 12343, 12347, 12373, 12377, 12379, 12391, 12401, 12409, 12413, 12421, 12433, 12437, 12451, 12457, 12473, 12479, 12487, 12491, 12497, 12503, 12511, 12517, 12527, 12539, 12541, 12547, 12553, 12569, 12577, 12583, 12589, 12601, 12611, 12613, 12619, 12637, 12641, 12647, 12653, 12659, 12671, 12689, 12697, 12703, 12713, 12721, 12739, 12743, 12757, 12763, 12781, 12791, 12799, 12809, 12821, 12823, 12829, 12841, 12853, 12889, 12893, 12899, 12907, 12911, 12917, 12919, 12923, 12941, 12953, 12959, 12967, 12973, 12979, 12983, 13001, 13003, 13007, 13009, 13033, 13037, 13043, 13049, 13063, 13093, 13099, 13103, 13109, 13121, 13127, 13147, 13151, 13159, 13163, 13171, 13177, 13183, 13187, 13217, 13219, 13229, 13241, 13249, 13259, 13267, 13291, 13297, 13309, 13313, 13327, 13331, 13337, 13339, 13367, 13381, 13397, 13399, 13411, 13417, 13421, 13441, 13451, 13457, 13463, 13469, 13477, 13487, 13499, 13513, 13523, 13537, 13553, 13567, 13577, 13591, 13597, 13613, 13619, 13627, 13633, 13649, 13669, 13679, 13681, 13687, 13691, 13693, 13697, 13709, 13711, 13721, 13723, 13729, 13751, 13757, 13759, 13763, 13781, 13789, 13799, 13807, 13829, 13831, 13841, 13859, 13873, 13877, 13879, 13883, 13901, 13903, 13907, 13913, 13921, 13931, 13933, 13963, 13967, 13997, 13999, 14009, 14011, 14029, 14033, 14051, 14057, 14071, 14081, 14083, 14087, 14107, 14143, 14149, 14153, 14159, 14173, 14177, 14197, 14207, 14221, 14243, 14249, 14251, 14281, 14293, 14303, 14321, 14323, 14327, 14341, 14347, 14369, 14387, 14389, 14401, 14407, 14411, 14419, 14423, 14431, 14437, 14447, 14449, 14461, 14479, 14489, 14503, 14519, 14533, 14537, 14543, 14549, 14551, 14557, 14561, 14563, 14591, 14593, 14621, 14627, 14629, 14633, 14639, 14653, 14657, 14669, 14683, 14699, 14713, 14717, 14723, 14731, 14737, 14741, 14747, 14753, 14759, 14767, 14771, 14779, 14783, 14797, 14813, 14821, 14827, 14831, 14843, 14851, 14867, 14869, 14879, 14887, 14891, 14897, 14923, 14929, 14939, 14947, 14951, 14957, 14969, 14983, 15013, 15017, 15031, 15053, 15061, 15073, 15077, 15083, 15091, 15101, 15107, 15121, 15131, 15137, 15139, 15149, 15161, 15173, 15187, 15193, 15199, 15217, 15227, 15233, 15241, 15259, 15263, 15269, 15271, 15277, 15287, 15289, 15299, 15307, 15313, 15319, 15329, 15331, 15349, 15359, 15361, 15373, 15377, 15383, 15391, 15401, 15413, 15427, 15439, 15443, 15451, 15461, 15467, 15473, 15493, 15497, 15511, 15527, 15541, 15551, 15559, 15569, 15581, 15583, 15601, 15607, 15619, 15629, 15641, 15643, 15647, 15649, 15661, 15667, 15671, 15679, 15683, 15727, 15731, 15733, 15737, 15739, 15749, 15761, 15767, 15773, 15787, 15791, 15797, 15803, 15809, 15817, 15823, 15859, 15877, 15881, 15887, 15889, 15901, 15907, 15913, 15919, 15923, 15937, 15959, 15971, 15973, 15991, 16001, 16007, 16033, 16057, 16061, 16063, 16067, 16069, 16073, 16087, 16091, 16097, 16103, 16111, 16127, 16139, 16141, 16183, 16187, 16189, 16193, 16217, 16223, 16229, 16231, 16249, 16253, 16267, 16273, 16301, 16319, 16333, 16339, 16349, 16361, 16363, 16369, 16381, 16411, 16417, 16421, 16427, 16433, 16447, 16451, 16453, 16477, 16481, 16487, 16493, 16519, 16529, 16547, 16553, 16561, 16567, 16573, 16603, 16607, 16619, 16631, 16633, 16649, 16651, 16657, 16661, 16673, 16691, 16693, 16699, 16703, 16729, 16741, 16747, 16759, 16763, 16787, 16811, 16823, 16829, 16831, 16843, 16871, 16879, 16883, 16889, 16901, 16903, 16921, 16927, 16931, 16937, 16943, 16963, 16979, 16981, 16987, 16993, 17011, 17021, 17027, 17029, 17033, 17041, 17047, 17053, 17077, 17093, 17099, 17107, 17117, 17123, 17137, 17159, 17167, 17183, 17189, 17191, 17203, 17207, 17209, 17231, 17239, 17257, 17291, 17293, 17299, 17317, 17321, 17327, 17333, 17341, 17351, 17359, 17377, 17383, 17387, 17389, 17393, 17401, 17417, 17419, 17431, 17443, 17449, 17467, 17471, 17477, 17483, 17489, 17491, 17497, 17509, 17519, 17539, 17551, 17569, 17573, 17579, 17581, 17597, 17599, 17609, 17623, 17627, 17657, 17659, 17669, 17681, 17683, 17707, 17713, 17729, 17737, 17747, 17749, 17761, 17783, 17789, 17791, 17807, 17827, 17837, 17839, 17851, 17863, 17881, 17891, 17903, 17909, 17911, 17921, 17923, 17929, 17939, 17957, 17959, 17971, 17977, 17981, 17987, 17989, 18013, 18041, 18043, 18047, 18049, 18059, 18061, 18077, 18089, 18097, 18119, 18121, 18127, 18131, 18133, 18143, 18149, 18169, 18181, 18191, 18199, 18211, 18217, 18223, 18229, 18233, 18251, 18253, 18257, 18269, 18287, 18289, 18301, 18307, 18311, 18313, 18329, 18341, 18353, 18367, 18371, 18379, 18397, 18401, 18413, 18427, 18433, 18439, 18443, 18451, 18457, 18461, 18481, 18493, 18503, 18517, 18521, 18523, 18539, 18541, 18553, 18583, 18587, 18593, 18617, 18637, 18661, 18671, 18679, 18691, 18701, 18713, 18719, 18731, 18743, 18749, 18757, 18773, 18787, 18793, 18797, 18803, 18839, 18859, 18869, 18899, 18911, 18913, 18917, 18919, 18947, 18959, 18973, 18979, 19001, 19009, 19013, 19031, 19037, 19051, 19069, 19073, 19079, 19081, 19087, 19121, 19139, 19141, 19157, 19163, 19181, 19183, 19207, 19211, 19213, 19219, 19231, 19237, 19249, 19259, 19267, 19273, 19289, 19301, 19309, 19319, 19333, 19373, 19379, 19381, 19387, 19391, 19403, 19417, 19421, 19423, 19427, 19429, 19433, 19441, 19447, 19457, 19463, 19469, 19471, 19477, 19483, 19489, 19501, 19507, 19531, 19541, 19543, 19553, 19559, 19571, 19577, 19583, 19597, 19603, 19609, 19661, 19681, 19687, 19697, 19699, 19709, 19717, 19727, 19739, 19751, 19753, 19759, 19763, 19777, 19793, 19801, 19813, 19819, 19841, 19843, 19853, 19861, 19867, 19889, 19891, 19913, 19919, 19927, 19937, 19949, 19961, 19963, 19973, 19979, 19991, 19993, 19997, 20011, 20021, 20023, 20029, 20047, 20051, 20063, 20071, 20089, 20101, 20107, 20113, 20117, 20123, 20129, 20143, 20147, 20149, 20161, 20173, 20177, 20183, 20201, 20219, 20231, 20233, 20249, 20261, 20269, 20287, 20297, 20323, 20327, 20333, 20341, 20347, 20353, 20357, 20359, 20369, 20389, 20393, 20399, 20407, 20411, 20431, 20441, 20443, 20477, 20479, 20483, 20507, 20509, 20521, 20533, 20543, 20549, 20551, 20563, 20593, 20599, 20611, 20627, 20639, 20641, 20663, 20681, 20693, 20707, 20717, 20719, 20731, 20743, 20747, 20749, 20753, 20759, 20771, 20773, 20789, 20807, 20809, 20849, 20857, 20873, 20879, 20887, 20897, 20899, 20903, 20921, 20929, 20939, 20947, 20959, 20963, 20981, 20983, 21001, 21011, 21013, 21017, 21019, 21023, 21031, 21059, 21061, 21067, 21089, 21101, 21107, 21121, 21139, 21143, 21149, 21157, 21163, 21169, 21179, 21187, 21191, 21193, 21211, 21221, 21227, 21247, 21269, 21277, 21283, 21313, 21317, 21319, 21323, 21341, 21347, 21377, 21379, 21383, 21391, 21397, 21401, 21407, 21419, 21433, 21467, 21481, 21487, 21491, 21493, 21499, 21503, 21517, 21521, 21523, 21529, 21557, 21559, 21563, 21569, 21577, 21587, 21589, 21599, 21601, 21611, 21613, 21617, 21647, 21649, 21661, 21673, 21683, 21701, 21713, 21727, 21737, 21739, 21751, 21757, 21767, 21773, 21787, 21799, 21803, 21817, 21821, 21839, 21841, 21851, 21859, 21863, 21871, 21881, 21893, 21911, 21929, 21937, 21943, 21961, 21977, 21991, 21997, 22003, 22013, 22027, 22031, 22037, 22039, 22051, 22063, 22067, 22073, 22079, 22091, 22093, 22109, 22111, 22123, 22129, 22133, 22147, 22153, 22157, 22159, 22171, 22189, 22193, 22229, 22247, 22259, 22271, 22273, 22277, 22279, 22283, 22291, 22303, 22307, 22343, 22349, 22367, 22369, 22381, 22391, 22397, 22409, 22433, 22441, 22447, 22453, 22469, 22481, 22483, 22501, 22511, 22531, 22541, 22543, 22549, 22567, 22571, 22573, 22613, 22619, 22621, 22637, 22639, 22643, 22651, 22669, 22679, 22691, 22697, 22699, 22709, 22717, 22721, 22727, 22739, 22741, 22751, 22769, 22777, 22783, 22787, 22807, 22811, 22817, 22853, 22859, 22861, 22871, 22877, 22901, 22907, 22921, 22937, 22943, 22961, 22963, 22973, 22993, 23003, 23011, 23017, 23021, 23027, 23029, 23039, 23041, 23053, 23057, 23059, 23063, 23071, 23081, 23087, 23099, 23117, 23131, 23143, 23159, 23167, 23173, 23189, 23197, 23201, 23203, 23209, 23227, 23251, 23269, 23279, 23291, 23293, 23297, 23311, 23321, 23327, 23333, 23339, 23357, 23369, 23371, 23399, 23417, 23431, 23447, 23459, 23473, 23497, 23509, 23531, 23537, 23539, 23549, 23557, 23561, 23563, 23567, 23581, 23593, 23599, 23603, 23609, 23623, 23627, 23629, 23633, 23663, 23669, 23671, 23677, 23687, 23689, 23719, 23741, 23743, 23747, 23753, 23761, 23767, 23773, 23789, 23801, 23813, 23819, 23827, 23831, 23833, 23857, 23869, 23873, 23879, 23887, 23893, 23899, 23909, 23911, 23917, 23929, 23957, 23971, 23977, 23981, 23993, 24001, 24007, 24019, 24023, 24029, 24043, 24049, 24061, 24071, 24077, 24083, 24091, 24097, 24103, 24107, 24109, 24113, 24121, 24133, 24137, 24151, 24169, 24179, 24181, 24197, 24203, 24223, 24229, 24239, 24247, 24251, 24281, 24317, 24329, 24337, 24359, 24371, 24373, 24379, 24391, 24407, 24413, 24419, 24421, 24439, 24443, 24469, 24473, 24481, 24499, 24509, 24517, 24527, 24533, 24547, 24551, 24571, 24593, 24611, 24623, 24631, 24659, 24671, 24677, 24683, 24691, 24697, 24709, 24733, 24749, 24763, 24767, 24781, 24793, 24799, 24809, 24821, 24841, 24847, 24851, 24859, 24877, 24889, 24907, 24917, 24919, 24923, 24943, 24953, 24967, 24971, 24977, 24979, 24989, 25013, 25031, 25033, 25037, 25057, 25073, 25087, 25097, 25111, 25117, 25121, 25127, 25147, 25153, 25163, 25169, 25171, 25183, 25189, 25219, 25229, 25237, 25243, 25247, 25253, 25261, 25301, 25303, 25307, 25309, 25321, 25339, 25343, 25349, 25357, 25367, 25373, 25391, 25409, 25411, 25423, 25439, 25447, 25453, 25457, 25463, 25469, 25471, 25523, 25537, 25541, 25561, 25577, 25579, 25583, 25589, 25601, 25603, 25609, 25621, 25633, 25639, 25643, 25657, 25667, 25673, 25679, 25693, 25703, 25717, 25733, 25741, 25747, 25759, 25763, 25771, 25793, 25799, 25801, 25819, 25841, 25847, 25849, 25867, 25873, 25889, 25903, 25913, 25919, 25931, 25933, 25939, 25943, 25951, 25969, 25981, 25997, 25999, 26003, 26017, 26021, 26029, 26041, 26053, 26083, 26099, 26107, 26111, 26113, 26119, 26141, 26153, 26161, 26171, 26177, 26183, 26189, 26203, 26209, 26227, 26237, 26249, 26251, 26261, 26263, 26267, 26293, 26297, 26309, 26317, 26321, 26339, 26347, 26357, 26371, 26387, 26393, 26399, 26407, 26417, 26423, 26431, 26437, 26449, 26459, 26479, 26489, 26497, 26501, 26513, 26539, 26557, 26561, 26573, 26591, 26597, 26627, 26633, 26641, 26647, 26669, 26681, 26683, 26687, 26693, 26699, 26701, 26711, 26713, 26717, 26723, 26729, 26731, 26737, 26759, 26777, 26783, 26801, 26813, 26821, 26833, 26839, 26849, 26861, 26863, 26879, 26881, 26891, 26893, 26903, 26921, 26927, 26947, 26951, 26953, 26959, 26981, 26987, 26993, 27011, 27017, 27031, 27043, 27059, 27061, 27067, 27073, 27077, 27091, 27103, 27107, 27109, 27127, 27143, 27179, 27191, 27197, 27211, 27239, 27241, 27253, 27259, 27271, 27277, 27281, 27283, 27299, 27329, 27337, 27361, 27367, 27397, 27407, 27409, 27427, 27431, 27437, 27449, 27457, 27479, 27481, 27487, 27509, 27527, 27529, 27539, 27541, 27551, 27581, 27583, 27611, 27617, 27631, 27647, 27653, 27673, 27689, 27691, 27697, 27701, 27733, 27737, 27739, 27743, 27749, 27751, 27763, 27767, 27773, 27779, 27791, 27793, 27799, 27803, 27809, 27817, 27823, 27827, 27847, 27851, 27883, 27893, 27901, 27917, 27919, 27941, 27943, 27947, 27953, 27961, 27967, 27983, 27997, 28001, 28019, 28027, 28031, 28051, 28057, 28069, 28081, 28087, 28097, 28099, 28109, 28111, 28123, 28151, 28163, 28181, 28183, 28201, 28211, 28219, 28229, 28277, 28279, 28283, 28289, 28297, 28307, 28309, 28319, 28349, 28351, 28387, 28393, 28403, 28409, 28411, 28429, 28433, 28439, 28447, 28463, 28477, 28493, 28499, 28513, 28517, 28537, 28541, 28547, 28549, 28559, 28571, 28573, 28579, 28591, 28597, 28603, 28607, 28619, 28621, 28627, 28631, 28643, 28649, 28657, 28661, 28663, 28669, 28687, 28697, 28703, 28711, 28723, 28729, 28751, 28753, 28759, 28771, 28789, 28793, 28807, 28813, 28817, 28837, 28843, 28859, 28867, 28871, 28879, 28901, 28909, 28921, 28927, 28933, 28949, 28961, 28979, 29009, 29017, 29021, 29023, 29027, 29033, 29059, 29063, 29077, 29101, 29123, 29129, 29131, 29137, 29147, 29153, 29167, 29173, 29179, 29191, 29201, 29207, 29209, 29221, 29231, 29243, 29251, 29269, 29287, 29297, 29303, 29311, 29327, 29333, 29339, 29347, 29363, 29383, 29387, 29389, 29399, 29401, 29411, 29423, 29429, 29437, 29443, 29453, 29473, 29483, 29501, 29527, 29531, 29537, 29567, 29569, 29573, 29581, 29587, 29599, 29611, 29629, 29633, 29641, 29663, 29669, 29671, 29683, 29717, 29723, 29741, 29753, 29759, 29761, 29789, 29803, 29819, 29833, 29837, 29851, 29863, 29867, 29873, 29879, 29881, 29917, 29921, 29927, 29947, 29959, 29983, 29989, 30011, 30013, 30029, 30047, 30059, 30071, 30089, 30091, 30097, 30103, 30109, 30113, 30119, 30133, 30137, 30139, 30161, 30169, 30181, 30187, 30197, 30203, 30211, 30223, 30241, 30253, 30259, 30269, 30271, 30293, 30307, 30313, 30319, 30323, 30341, 30347, 30367, 30389, 30391, 30403, 30427, 30431, 30449, 30467, 30469, 30491, 30493, 30497, 30509, 30517, 30529, 30539, 30553, 30557, 30559, 30577, 30593, 30631, 30637, 30643, 30649, 30661, 30671, 30677, 30689, 30697, 30703, 30707, 30713, 30727, 30757, 30763, 30773, 30781, 30803, 30809, 30817, 30829, 30839, 30841, 30851, 30853, 30859, 30869, 30871, 30881, 30893, 30911, 30931, 30937, 30941, 30949, 30971, 30977, 30983, 31013, 31019, 31033, 31039, 31051, 31063, 31069, 31079, 31081, 31091, 31121, 31123, 31139, 31147, 31151, 31153, 31159, 31177, 31181, 31183, 31189, 31193, 31219, 31223, 31231, 31237, 31247, 31249, 31253, 31259, 31267, 31271, 31277, 31307, 31319, 31321, 31327, 31333, 31337, 31357, 31379, 31387, 31391, 31393, 31397, 31469, 31477, 31481, 31489, 31511, 31513, 31517, 31531, 31541, 31543, 31547, 31567, 31573, 31583, 31601, 31607, 31627, 31643, 31649, 31657, 31663, 31667, 31687, 31699, 31721, 31723, 31727, 31729, 31741, 31751, 31769, 31771, 31793, 31799, 31817, 31847, 31849, 31859, 31873, 31883, 31891, 31907, 31957, 31963, 31973, 31981, 31991, 32003, 32009, 32027, 32029, 32051, 32057, 32059, 32063, 32069, 32077, 32083, 32089, 32099, 32117, 32119, 32141, 32143, 32159, 32173, 32183, 32189, 32191, 32203, 32213, 32233, 32237, 32251, 32257, 32261, 32297, 32299, 32303, 32309, 32321, 32323, 32327, 32341, 32353, 32359, 32363, 32369, 32371, 32377, 32381, 32401, 32411, 32413, 32423, 32429, 32441, 32443, 32467, 32479, 32491, 32497, 32503, 32507, 32531, 32533, 32537, 32561, 32563, 32569, 32573, 32579, 32587, 32603, 32609, 32611, 32621, 32633, 32647, 32653, 32687, 32693, 32707, 32713, 32717, 32719, 32749, 32771, 32779, 32783, 32789, 32797, 32801, 32803, 32831, 32833, 32839, 32843, 32869, 32887, 32909, 32911, 32917, 32933, 32939, 32941, 32957, 32969, 32971, 32983, 32987, 32993, 32999, 33013, 33023, 33029, 33037, 33049, 33053, 33071, 33073, 33083, 33091, 33107, 33113, 33119, 33149, 33151, 33161, 33179, 33181, 33191, 33199, 33203, 33211, 33223, 33247, 33287, 33289, 33301, 33311, 33317, 33329, 33331, 33343, 33347, 33349, 33353, 33359, 33377, 33391, 33403, 33409, 33413, 33427, 33457, 33461, 33469, 33479, 33487, 33493, 33503, 33521, 33529, 33533, 33547, 33563, 33569, 33577, 33581, 33587, 33589, 33599, 33601, 33613, 33617, 33619, 33623, 33629, 33637, 33641, 33647, 33679, 33703, 33713, 33721, 33739, 33749, 33751, 33757, 33767, 33769, 33773, 33791, 33797, 33809, 33811, 33827, 33829, 33851, 33857, 33863, 33871, 33889, 33893, 33911, 33923, 33931, 33937, 33941, 33961, 33967, 33997, 34019, 34031, 34033, 34039, 34057, 34061, 34123, 34127, 34129, 34141, 34147, 34157, 34159, 34171, 34183, 34211, 34213, 34217, 34231, 34253, 34259, 34261, 34267, 34273, 34283, 34297, 34301, 34303, 34313, 34319, 34327, 34337, 34351, 34361, 34367, 34369, 34381, 34403, 34421, 34429, 34439, 34457, 34469, 34471, 34483, 34487, 34499, 34501, 34511, 34513, 34519, 34537, 34543, 34549, 34583, 34589, 34591, 34603, 34607, 34613, 34631, 34649, 34651, 34667, 34673, 34679, 34687, 34693, 34703, 34721, 34729, 34739, 34747, 34757, 34759, 34763, 34781, 34807, 34819, 34841, 34843, 34847, 34849, 34871, 34877, 34883, 34897, 34913, 34919, 34939, 34949, 34961, 34963, 34981, 35023, 35027, 35051, 35053, 35059, 35069, 35081, 35083, 35089, 35099, 35107, 35111, 35117, 35129, 35141, 35149, 35153, 35159, 35171, 35201, 35221, 35227, 35251, 35257, 35267, 35279, 35281, 35291, 35311, 35317, 35323, 35327, 35339, 35353, 35363, 35381, 35393, 35401, 35407, 35419, 35423, 35437, 35447, 35449, 35461, 35491, 35507, 35509, 35521, 35527, 35531, 35533, 35537, 35543, 35569, 35573, 35591, 35593, 35597, 35603, 35617, 35671, 35677, 35729, 35731, 35747, 35753, 35759, 35771, 35797, 35801, 35803, 35809, 35831, 35837, 35839, 35851, 35863, 35869, 35879, 35897, 35899, 35911, 35923, 35933, 35951, 35963, 35969, 35977, 35983, 35993, 35999, 36007, 36011, 36013, 36017, 36037, 36061, 36067, 36073, 36083, 36097, 36107, 36109, 36131, 36137, 36151, 36161, 36187, 36191, 36209, 36217, 36229, 36241, 36251, 36263, 36269, 36277, 36293, 36299, 36307, 36313, 36319, 36341, 36343, 36353, 36373, 36383, 36389, 36433, 36451, 36457, 36467, 36469, 36473, 36479, 36493, 36497, 36523, 36527, 36529, 36541, 36551, 36559, 36563, 36571, 36583, 36587, 36599, 36607, 36629, 36637, 36643, 36653, 36671, 36677, 36683, 36691, 36697, 36709, 36713, 36721, 36739, 36749, 36761, 36767, 36779, 36781, 36787, 36791, 36793, 36809, 36821, 36833, 36847, 36857, 36871, 36877, 36887, 36899, 36901, 36913, 36919, 36923, 36929, 36931, 36943, 36947, 36973, 36979, 36997, 37003, 37013, 37019, 37021, 37039, 37049, 37057, 37061, 37087, 37097, 37117, 37123, 37139, 37159, 37171, 37181, 37189, 37199, 37201, 37217, 37223, 37243, 37253, 37273, 37277, 37307, 37309, 37313, 37321, 37337, 37339, 37357, 37361, 37363, 37369, 37379, 37397, 37409, 37423, 37441, 37447, 37463, 37483, 37489, 37493, 37501, 37507, 37511, 37517, 37529, 37537, 37547, 37549, 37561, 37567, 37571, 37573, 37579, 37589, 37591, 37607, 37619, 37633, 37643, 37649, 37657, 37663, 37691, 37693, 37699, 37717, 37747, 37781, 37783, 37799, 37811, 37813, 37831, 37847, 37853, 37861, 37871, 37879, 37889, 37897, 37907, 37951, 37957, 37963, 37967, 37987, 37991, 37993, 37997, 38011, 38039, 38047, 38053, 38069, 38083, 38113, 38119, 38149, 38153, 38167, 38177, 38183, 38189, 38197, 38201, 38219, 38231, 38237, 38239, 38261, 38273, 38281, 38287, 38299, 38303, 38317, 38321, 38327, 38329, 38333, 38351, 38371, 38377, 38393, 38431, 38447, 38449, 38453, 38459, 38461, 38501, 38543, 38557, 38561, 38567, 38569, 38593, 38603, 38609, 38611, 38629, 38639, 38651, 38653, 38669, 38671, 38677, 38693, 38699, 38707, 38711, 38713, 38723, 38729, 38737, 38747, 38749, 38767, 38783, 38791, 38803, 38821, 38833, 38839, 38851, 38861, 38867, 38873, 38891, 38903, 38917, 38921, 38923, 38933, 38953, 38959, 38971, 38977, 38993, 39019, 39023, 39041, 39043, 39047, 39079, 39089, 39097, 39103, 39107, 39113, 39119, 39133, 39139, 39157, 39161, 39163, 39181, 39191, 39199, 39209, 39217, 39227, 39229, 39233, 39239, 39241, 39251, 39293, 39301, 39313, 39317, 39323, 39341, 39343, 39359, 39367, 39371, 39373, 39383, 39397, 39409, 39419, 39439, 39443, 39451, 39461, 39499, 39503, 39509, 39511, 39521, 39541, 39551, 39563, 39569, 39581, 39607, 39619, 39623, 39631, 39659, 39667, 39671, 39679, 39703, 39709, 39719, 39727, 39733, 39749, 39761, 39769, 39779, 39791, 39799, 39821, 39827, 39829, 39839, 39841, 39847, 39857, 39863, 39869, 39877, 39883, 39887, 39901, 39929, 39937, 39953, 39971, 39979, 39983, 39989, 40009, 40013, 40031, 40037, 40039, 40063, 40087, 40093, 40099, 40111, 40123, 40127, 40129, 40151, 40153, 40163, 40169, 40177, 40189, 40193, 40213, 40231, 40237, 40241, 40253, 40277, 40283, 40289, 40343, 40351, 40357, 40361, 40387, 40423, 40427, 40429, 40433, 40459, 40471, 40483, 40487, 40493, 40499, 40507, 40519, 40529, 40531, 40543, 40559, 40577, 40583, 40591, 40597, 40609, 40627, 40637, 40639, 40693, 40697, 40699, 40709, 40739, 40751, 40759, 40763, 40771, 40787, 40801, 40813, 40819, 40823, 40829, 40841, 40847, 40849, 40853, 40867, 40879, 40883, 40897, 40903, 40927, 40933, 40939, 40949, 40961, 40973, 40993, 41011, 41017, 41023, 41039, 41047, 41051, 41057, 41077, 41081, 41113, 41117, 41131, 41141, 41143, 41149, 41161, 41177, 41179, 41183, 41189, 41201, 41203, 41213, 41221, 41227, 41231, 41233, 41243, 41257, 41263, 41269, 41281, 41299, 41333, 41341, 41351, 41357, 41381, 41387, 41389, 41399, 41411, 41413, 41443, 41453, 41467, 41479, 41491, 41507, 41513, 41519, 41521, 41539, 41543, 41549, 41579, 41593, 41597, 41603, 41609, 41611, 41617, 41621, 41627, 41641, 41647, 41651, 41659, 41669, 41681, 41687, 41719, 41729, 41737, 41759, 41761, 41771, 41777, 41801, 41809, 41813, 41843, 41849, 41851, 41863, 41879, 41887, 41893, 41897, 41903, 41911, 41927, 41941, 41947, 41953, 41957, 41959, 41969, 41981, 41983, 41999, 42013, 42017, 42019, 42023, 42043, 42061, 42071, 42073, 42083, 42089, 42101, 42131, 42139, 42157, 42169, 42179, 42181, 42187, 42193, 42197, 42209, 42221, 42223, 42227, 42239, 42257, 42281, 42283, 42293, 42299, 42307, 42323, 42331, 42337, 42349, 42359, 42373, 42379, 42391, 42397, 42403, 42407, 42409, 42433, 42437, 42443, 42451, 42457, 42461, 42463, 42467, 42473, 42487, 42491, 42499, 42509, 42533, 42557, 42569, 42571, 42577, 42589, 42611, 42641, 42643, 42649, 42667, 42677, 42683, 42689, 42697, 42701, 42703, 42709, 42719, 42727, 42737, 42743, 42751, 42767, 42773, 42787, 42793, 42797, 42821, 42829, 42839, 42841, 42853, 42859, 42863, 42899, 42901, 42923, 42929, 42937, 42943, 42953, 42961, 42967, 42979, 42989, 43003, 43013, 43019, 43037, 43049, 43051, 43063, 43067, 43093, 43103, 43117, 43133, 43151, 43159, 43177, 43189, 43201, 43207, 43223, 43237, 43261, 43271, 43283, 43291, 43313, 43319, 43321, 43331, 43391, 43397, 43399, 43403, 43411, 43427, 43441, 43451, 43457, 43481, 43487, 43499, 43517, 43541, 43543, 43573, 43577, 43579, 43591, 43597, 43607, 43609, 43613, 43627, 43633, 43649, 43651, 43661, 43669, 43691, 43711, 43717, 43721, 43753, 43759, 43777, 43781, 43783, 43787, 43789, 43793, 43801, 43853, 43867, 43889, 43891, 43913, 43933, 43943, 43951, 43961, 43963, 43969, 43973, 43987, 43991, 43997, 44017, 44021, 44027, 44029, 44041, 44053, 44059, 44071, 44087, 44089, 44101, 44111, 44119, 44123, 44129, 44131, 44159, 44171, 44179, 44189, 44201, 44203, 44207, 44221, 44249, 44257, 44263, 44267, 44269, 44273, 44279, 44281, 44293, 44351, 44357, 44371, 44381, 44383, 44389, 44417, 44449, 44453, 44483, 44491, 44497, 44501, 44507, 44519, 44531, 44533, 44537, 44543, 44549, 44563, 44579, 44587, 44617, 44621, 44623, 44633, 44641, 44647, 44651, 44657, 44683, 44687, 44699, 44701, 44711, 44729, 44741, 44753, 44771, 44773, 44777, 44789, 44797, 44809, 44819, 44839, 44843, 44851, 44867, 44879, 44887, 44893, 44909, 44917, 44927, 44939, 44953, 44959, 44963, 44971, 44983, 44987, 45007, 45013, 45053, 45061, 45077, 45083, 45119, 45121, 45127, 45131, 45137, 45139, 45161, 45179, 45181, 45191, 45197, 45233, 45247, 45259, 45263, 45281, 45289, 45293, 45307, 45317, 45319, 45329, 45337, 45341, 45343, 45361, 45377, 45389, 45403, 45413, 45427, 45433, 45439, 45481, 45491, 45497, 45503, 45523, 45533, 45541, 45553, 45557, 45569, 45587, 45589, 45599, 45613, 45631, 45641, 45659, 45667, 45673, 45677, 45691, 45697, 45707, 45737, 45751, 45757, 45763, 45767, 45779, 45817, 45821, 45823, 45827, 45833, 45841, 45853, 45863, 45869, 45887, 45893, 45943, 45949, 45953, 45959, 45971, 45979, 45989, 46021, 46027, 46049, 46051, 46061, 46073, 46091, 46093, 46099, 46103, 46133, 46141, 46147, 46153, 46171, 46181, 46183, 46187, 46199, 46219, 46229, 46237, 46261, 46271, 46273, 46279, 46301, 46307, 46309, 46327, 46337, 46349, 46351, 46381, 46399, 46411, 46439, 46441, 46447, 46451, 46457, 46471, 46477, 46489, 46499, 46507, 46511, 46523, 46549, 46559, 46567, 46573, 46589, 46591, 46601, 46619, 46633, 46639, 46643, 46649, 46663, 46679, 46681, 46687, 46691, 46703, 46723, 46727, 46747, 46751, 46757, 46769, 46771, 46807, 46811, 46817, 46819, 46829, 46831, 46853, 46861, 46867, 46877, 46889, 46901, 46919, 46933, 46957, 46993, 46997, 47017, 47041, 47051, 47057, 47059, 47087, 47093, 47111, 47119, 47123, 47129, 47137, 47143, 47147, 47149, 47161, 47189, 47207, 47221, 47237, 47251, 47269, 47279, 47287, 47293, 47297, 47303, 47309, 47317, 47339, 47351, 47353, 47363, 47381, 47387, 47389, 47407, 47417, 47419, 47431, 47441, 47459, 47491, 47497, 47501, 47507, 47513, 47521, 47527, 47533, 47543, 47563, 47569, 47581, 47591, 47599, 47609, 47623, 47629, 47639, 47653, 47657, 47659, 47681, 47699, 47701, 47711, 47713, 47717, 47737, 47741, 47743, 47777, 47779, 47791, 47797, 47807, 47809, 47819, 47837, 47843, 47857, 47869, 47881, 47903, 47911, 47917, 47933, 47939, 47947, 47951, 47963, 47969, 47977, 47981, 48017, 48023, 48029, 48049, 48073, 48079, 48091, 48109, 48119, 48121, 48131, 48157, 48163, 48179, 48187, 48193, 48197, 48221, 48239, 48247, 48259, 48271, 48281, 48299, 48311, 48313, 48337, 48341, 48353, 48371, 48383, 48397, 48407, 48409, 48413, 48437, 48449, 48463, 48473, 48479, 48481, 48487, 48491, 48497, 48523, 48527, 48533, 48539, 48541, 48563, 48571, 48589, 48593, 48611, 48619, 48623, 48647, 48649, 48661, 48673, 48677, 48679, 48731, 48733, 48751, 48757, 48761, 48767, 48779, 48781, 48787, 48799, 48809, 48817, 48821, 48823, 48847, 48857, 48859, 48869, 48871, 48883, 48889, 48907, 48947, 48953, 48973, 48989, 48991, 49003, 49009, 49019, 49031, 49033, 49037, 49043, 49057, 49069, 49081, 49103, 49109, 49117, 49121, 49123, 49139, 49157, 49169, 49171, 49177, 49193, 49199, 49201, 49207, 49211, 49223, 49253, 49261, 49277, 49279, 49297, 49307, 49331, 49333, 49339, 49363, 49367, 49369, 49391, 49393, 49409, 49411, 49417, 49429, 49433, 49451, 49459, 49463, 49477, 49481, 49499, 49523, 49529, 49531, 49537, 49547, 49549, 49559, 49597, 49603, 49613, 49627, 49633, 49639, 49663, 49667, 49669, 49681, 49697, 49711, 49727, 49739, 49741, 49747, 49757, 49783, 49787, 49789, 49801, 49807, 49811, 49823, 49831, 49843, 49853, 49871, 49877, 49891, 49919, 49921, 49927, 49937, 49939, 49943, 49957, 49991, 49993, 49999, 50021, 50023, 50033, 50047, 50051, 50053, 50069, 50077, 50087, 50093, 50101, 50111, 50119, 50123, 50129, 50131, 50147, 50153, 50159, 50177, 50207, 50221, 50227, 50231, 50261, 50263, 50273, 50287, 50291, 50311, 50321, 50329, 50333, 50341, 50359, 50363, 50377, 50383, 50387, 50411, 50417, 50423, 50441, 50459, 50461, 50497, 50503, 50513, 50527, 50539, 50543, 50549, 50551, 50581, 50587, 50591, 50593, 50599, 50627, 50647, 50651, 50671, 50683, 50707, 50723, 50741, 50753, 50767, 50773, 50777, 50789, 50821, 50833, 50839, 50849, 50857, 50867, 50873, 50891, 50893, 50909, 50923, 50929, 50951, 50957, 50969, 50971, 50989, 50993, 51001, 51031, 51043, 51047, 51059, 51061, 51071, 51109, 51131, 51133, 51137, 51151, 51157, 51169, 51193, 51197, 51199, 51203, 51217, 51229, 51239, 51241, 51257, 51263, 51283, 51287, 51307, 51329, 51341, 51343, 51347, 51349, 51361, 51383, 51407, 51413, 51419, 51421, 51427, 51431, 51437, 51439, 51449, 51461, 51473, 51479, 51481, 51487, 51503, 51511, 51517, 51521, 51539, 51551, 51563, 51577, 51581, 51593, 51599, 51607, 51613, 51631, 51637, 51647, 51659, 51673, 51679, 51683, 51691, 51713, 51719, 51721, 51749, 51767, 51769, 51787, 51797, 51803, 51817, 51827, 51829, 51839, 51853, 51859, 51869, 51871, 51893, 51899, 51907, 51913, 51929, 51941, 51949, 51971, 51973, 51977, 51991, 52009, 52021, 52027, 52051, 52057, 52067, 52069, 52081, 52103, 52121, 52127, 52147, 52153, 52163, 52177, 52181, 52183, 52189, 52201, 52223, 52237, 52249, 52253, 52259, 52267, 52289, 52291, 52301, 52313, 52321, 52361, 52363, 52369, 52379, 52387, 52391, 52433, 52453, 52457, 52489, 52501, 52511, 52517, 52529, 52541, 52543, 52553, 52561, 52567, 52571, 52579, 52583, 52609, 52627, 52631, 52639, 52667, 52673, 52691, 52697, 52709, 52711, 52721, 52727, 52733, 52747, 52757, 52769, 52783, 52807, 52813, 52817, 52837, 52859, 52861, 52879, 52883, 52889, 52901, 52903, 52919, 52937, 52951, 52957, 52963, 52967, 52973, 52981, 52999, 53003, 53017, 53047, 53051, 53069, 53077, 53087, 53089, 53093, 53101, 53113, 53117, 53129, 53147, 53149, 53161, 53171, 53173, 53189, 53197, 53201, 53231, 53233, 53239, 53267, 53269, 53279, 53281, 53299, 53309, 53323, 53327, 53353, 53359, 53377, 53381, 53401, 53407, 53411, 53419, 53437, 53441, 53453, 53479, 53503, 53507, 53527, 53549, 53551, 53569, 53591, 53593, 53597, 53609, 53611, 53617, 53623, 53629, 53633, 53639, 53653, 53657, 53681, 53693, 53699, 53717, 53719, 53731, 53759, 53773, 53777, 53783, 53791, 53813, 53819, 53831, 53849, 53857, 53861, 53881, 53887, 53891, 53897, 53899, 53917, 53923, 53927, 53939, 53951, 53959, 53987, 53993, 54001, 54011, 54013, 54037, 54049, 54059, 54083, 54091, 54101, 54121, 54133, 54139, 54151, 54163, 54167, 54181, 54193, 54217, 54251, 54269, 54277, 54287, 54293, 54311, 54319, 54323, 54331, 54347, 54361, 54367, 54371, 54377, 54401, 54403, 54409, 54413, 54419, 54421, 54437, 54443, 54449, 54469, 54493, 54497, 54499, 54503, 54517, 54521, 54539, 54541, 54547, 54559, 54563, 54577, 54581, 54583, 54601, 54617, 54623, 54629, 54631, 54647, 54667, 54673, 54679, 54709, 54713, 54721, 54727, 54751, 54767, 54773, 54779, 54787, 54799, 54829, 54833, 54851, 54869, 54877, 54881, 54907, 54917, 54919, 54941, 54949, 54959, 54973, 54979, 54983, 55001, 55009, 55021, 55049, 55051, 55057, 55061, 55073, 55079, 55103, 55109, 55117, 55127, 55147, 55163, 55171, 55201, 55207, 55213, 55217, 55219, 55229, 55243, 55249, 55259, 55291, 55313, 55331, 55333, 55337, 55339, 55343, 55351, 55373, 55381, 55399, 55411, 55439, 55441, 55457, 55469, 55487, 55501, 55511, 55529, 55541, 55547, 55579, 55589, 55603, 55609, 55619, 55621, 55631, 55633, 55639, 55661, 55663, 55667, 55673, 55681, 55691, 55697, 55711, 55717, 55721, 55733, 55763, 55787, 55793, 55799, 55807, 55813, 55817, 55819, 55823, 55829, 55837, 55843, 55849, 55871, 55889, 55897, 55901, 55903, 55921, 55927, 55931, 55933, 55949, 55967, 55987, 55997, 56003, 56009, 56039, 56041, 56053, 56081, 56087, 56093, 56099, 56101, 56113, 56123, 56131, 56149, 56167, 56171, 56179, 56197, 56207, 56209, 56237, 56239, 56249, 56263, 56267, 56269, 56299, 56311, 56333, 56359, 56369, 56377, 56383, 56393, 56401, 56417, 56431, 56437, 56443, 56453, 56467, 56473, 56477, 56479, 56489, 56501, 56503, 56509, 56519, 56527, 56531, 56533, 56543, 56569, 56591, 56597, 56599, 56611, 56629, 56633, 56659, 56663, 56671, 56681, 56687, 56701, 56711, 56713, 56731, 56737, 56747, 56767, 56773, 56779, 56783, 56807, 56809, 56813, 56821, 56827, 56843, 56857, 56873, 56891, 56893, 56897, 56909, 56911, 56921, 56923, 56929, 56941, 56951, 56957, 56963, 56983, 56989, 56993, 56999, 57037, 57041, 57047, 57059, 57073, 57077, 57089, 57097, 57107, 57119, 57131, 57139, 57143, 57149, 57163, 57173, 57179, 57191, 57193, 57203, 57221, 57223, 57241, 57251, 57259, 57269, 57271, 57283, 57287, 57301, 57329, 57331, 57347, 57349, 57367, 57373, 57383, 57389, 57397, 57413, 57427, 57457, 57467, 57487, 57493, 57503, 57527, 57529, 57557, 57559, 57571, 57587, 57593, 57601, 57637, 57641, 57649, 57653, 57667, 57679, 57689, 57697, 57709, 57713, 57719, 57727, 57731, 57737, 57751, 57773, 57781, 57787, 57791, 57793, 57803, 57809, 57829, 57839, 57847, 57853, 57859, 57881, 57899, 57901, 57917, 57923, 57943, 57947, 57973, 57977, 57991, 58013, 58027, 58031, 58043, 58049, 58057, 58061, 58067, 58073, 58099, 58109, 58111, 58129, 58147, 58151, 58153, 58169, 58171, 58189, 58193, 58199, 58207, 58211, 58217, 58229, 58231, 58237, 58243, 58271, 58309, 58313, 58321, 58337, 58363, 58367, 58369, 58379, 58391, 58393, 58403, 58411, 58417, 58427, 58439, 58441, 58451, 58453, 58477, 58481, 58511, 58537, 58543, 58549, 58567, 58573, 58579, 58601, 58603, 58613, 58631, 58657, 58661, 58679, 58687, 58693, 58699, 58711, 58727, 58733, 58741, 58757, 58763, 58771, 58787, 58789, 58831, 58889, 58897, 58901, 58907, 58909, 58913, 58921, 58937, 58943, 58963, 58967, 58979, 58991, 58997, 59009, 59011, 59021, 59023, 59029, 59051, 59053, 59063, 59069, 59077, 59083, 59093, 59107, 59113, 59119, 59123, 59141, 59149, 59159, 59167, 59183, 59197, 59207, 59209, 59219, 59221, 59233, 59239, 59243, 59263, 59273, 59281, 59333, 59341, 59351, 59357, 59359, 59369, 59377, 59387, 59393, 59399, 59407, 59417, 59419, 59441, 59443, 59447, 59453, 59467, 59471, 59473, 59497, 59509, 59513, 59539, 59557, 59561, 59567, 59581, 59611, 59617, 59621, 59627, 59629, 59651, 59659, 59663, 59669, 59671, 59693, 59699, 59707, 59723, 59729, 59743, 59747, 59753, 59771, 59779, 59791, 59797, 59809, 59833, 59863, 59879, 59887, 59921, 59929, 59951, 59957, 59971, 59981, 59999, 60013, 60017, 60029, 60037, 60041, 60077, 60083, 60089, 60091, 60101, 60103, 60107, 60127, 60133, 60139, 60149, 60161, 60167, 60169, 60209, 60217, 60223, 60251, 60257, 60259, 60271, 60289, 60293, 60317, 60331, 60337, 60343, 60353, 60373, 60383, 60397, 60413, 60427, 60443, 60449, 60457, 60493, 60497, 60509, 60521, 60527, 60539, 60589, 60601, 60607, 60611, 60617, 60623, 60631, 60637, 60647, 60649, 60659, 60661, 60679, 60689, 60703, 60719, 60727, 60733, 60737, 60757, 60761, 60763, 60773, 60779, 60793, 60811, 60821, 60859, 60869, 60887, 60889, 60899, 60901, 60913, 60917, 60919, 60923, 60937, 60943, 60953, 60961, 61001, 61007, 61027, 61031, 61043, 61051, 61057, 61091, 61099, 61121, 61129, 61141, 61151, 61153, 61169, 61211, 61223, 61231, 61253, 61261, 61283, 61291, 61297, 61331, 61333, 61339, 61343, 61357, 61363, 61379, 61381, 61403, 61409, 61417, 61441, 61463, 61469, 61471, 61483, 61487, 61493, 61507, 61511, 61519, 61543, 61547, 61553, 61559, 61561, 61583, 61603, 61609, 61613, 61627, 61631, 61637, 61643, 61651, 61657, 61667, 61673, 61681, 61687, 61703, 61717, 61723, 61729, 61751, 61757, 61781, 61813, 61819, 61837, 61843, 61861, 61871, 61879, 61909, 61927, 61933, 61949, 61961, 61967, 61979, 61981, 61987, 61991, 62003, 62011, 62017, 62039, 62047, 62053, 62057, 62071, 62081, 62099, 62119, 62129, 62131, 62137, 62141, 62143, 62171, 62189, 62191, 62201, 62207, 62213, 62219, 62233, 62273, 62297, 62299, 62303, 62311, 62323, 62327, 62347, 62351, 62383, 62401, 62417, 62423, 62459, 62467, 62473, 62477, 62483, 62497, 62501, 62507, 62533, 62539, 62549, 62563, 62581, 62591, 62597, 62603, 62617, 62627, 62633, 62639, 62653, 62659, 62683, 62687, 62701, 62723, 62731, 62743, 62753, 62761, 62773, 62791, 62801, 62819, 62827, 62851, 62861, 62869, 62873, 62897, 62903, 62921, 62927, 62929, 62939, 62969, 62971, 62981, 62983, 62987, 62989, 63029, 63031, 63059, 63067, 63073, 63079, 63097, 63103, 63113, 63127, 63131, 63149, 63179, 63197, 63199, 63211, 63241, 63247, 63277, 63281, 63299, 63311, 63313, 63317, 63331, 63337, 63347, 63353, 63361, 63367, 63377, 63389, 63391, 63397, 63409, 63419, 63421, 63439, 63443, 63463, 63467, 63473, 63487, 63493, 63499, 63521, 63527, 63533, 63541, 63559, 63577, 63587, 63589, 63599, 63601, 63607, 63611, 63617, 63629, 63647, 63649, 63659, 63667, 63671, 63689, 63691, 63697, 63703, 63709, 63719, 63727, 63737, 63743, 63761, 63773, 63781, 63793, 63799, 63803, 63809, 63823, 63839, 63841, 63853, 63857, 63863, 63901, 63907, 63913, 63929, 63949, 63977, 63997, 64007, 64013, 64019, 64033, 64037, 64063, 64067, 64081, 64091, 64109, 64123, 64151, 64153, 64157, 64171, 64187, 64189, 64217, 64223, 64231, 64237, 64271, 64279, 64283, 64301, 64303, 64319, 64327, 64333, 64373, 64381, 64399, 64403, 64433, 64439, 64451, 64453, 64483, 64489, 64499, 64513, 64553, 64567, 64577, 64579, 64591, 64601, 64609, 64613, 64621, 64627, 64633, 64661, 64663, 64667, 64679, 64693, 64709, 64717, 64747, 64763, 64781, 64783, 64793, 64811, 64817, 64849, 64853, 64871, 64877, 64879, 64891, 64901, 64919, 64921, 64927, 64937, 64951, 64969, 64997, 65003, 65011, 65027, 65029, 65033, 65053, 65063, 65071, 65089, 65099, 65101, 65111, 65119, 65123, 65129, 65141, 65147, 65167, 65171, 65173, 65179, 65183, 65203, 65213, 65239, 65257, 65267, 65269, 65287, 65293, 65309, 65323, 65327, 65353, 65357, 65371, 65381, 65393, 65407, 65413, 65419, 65423, 65437, 65447, 65449, 65479, 65497, 65519, 65521, 65537, 65539, 65543, 65551, 65557, 65563, 65579, 65581, 65587, 65599, 65609, 65617, 65629, 65633, 65647, 65651, 65657, 65677, 65687, 65699, 65701, 65707, 65713, 65717, 65719, 65729, 65731, 65761, 65777, 65789, 65809, 65827, 65831, 65837, 65839, 65843, 65851, 65867, 65881, 65899, 65921, 65927, 65929, 65951, 65957, 65963, 65981, 65983, 65993, 66029, 66037, 66041, 66047, 66067, 66071, 66083, 66089, 66103, 66107, 66109, 66137, 66161, 66169, 66173, 66179, 66191, 66221, 66239, 66271, 66293, 66301, 66337, 66343, 66347, 66359, 66361, 66373, 66377, 66383, 66403, 66413, 66431, 66449, 66457, 66463, 66467, 66491, 66499, 66509, 66523, 66529, 66533, 66541, 66553, 66569, 66571, 66587, 66593, 66601, 66617, 66629, 66643, 66653, 66683, 66697, 66701, 66713, 66721, 66733, 66739, 66749, 66751, 66763, 66791, 66797, 66809, 66821, 66841, 66851, 66853, 66863, 66877, 66883, 66889, 66919, 66923, 66931, 66943, 66947, 66949, 66959, 66973, 66977, 67003, 67021, 67033, 67043, 67049, 67057, 67061, 67073, 67079, 67103, 67121, 67129, 67139, 67141, 67153, 67157, 67169, 67181, 67187, 67189, 67211, 67213, 67217, 67219, 67231, 67247, 67261, 67271, 67273, 67289, 67307, 67339, 67343, 67349, 67369, 67391, 67399, 67409, 67411, 67421, 67427, 67429, 67433, 67447, 67453, 67477, 67481, 67489, 67493, 67499, 67511, 67523, 67531, 67537, 67547, 67559, 67567, 67577, 67579, 67589, 67601, 67607, 67619, 67631, 67651, 67679, 67699, 67709, 67723, 67733, 67741, 67751, 67757, 67759, 67763, 67777, 67783, 67789, 67801, 67807, 67819, 67829, 67843, 67853, 67867, 67883, 67891, 67901, 67927, 67931, 67933, 67939, 67943, 67957, 67961, 67967, 67979, 67987, 67993, 68023, 68041, 68053, 68059, 68071, 68087, 68099, 68111, 68113, 68141, 68147, 68161, 68171, 68207, 68209, 68213, 68219, 68227, 68239, 68261, 68279, 68281, 68311, 68329, 68351, 68371, 68389, 68399, 68437, 68443, 68447, 68449, 68473, 68477, 68483, 68489, 68491, 68501, 68507, 68521, 68531, 68539, 68543, 68567, 68581, 68597, 68611, 68633, 68639, 68659, 68669, 68683, 68687, 68699, 68711, 68713, 68729, 68737, 68743, 68749, 68767, 68771, 68777, 68791, 68813, 68819, 68821, 68863, 68879, 68881, 68891, 68897, 68899, 68903, 68909, 68917, 68927, 68947, 68963, 68993, 69001, 69011, 69019, 69029, 69031, 69061, 69067, 69073, 69109, 69119, 69127, 69143, 69149, 69151, 69163, 69191, 69193, 69197, 69203, 69221, 69233, 69239, 69247, 69257, 69259, 69263, 69313, 69317, 69337, 69341, 69371, 69379, 69383, 69389, 69401, 69403, 69427, 69431, 69439, 69457, 69463, 69467, 69473, 69481, 69491, 69493, 69497, 69499, 69539, 69557, 69593, 69623, 69653, 69661, 69677, 69691, 69697, 69709, 69737, 69739, 69761, 69763, 69767, 69779, 69809, 69821, 69827, 69829, 69833, 69847, 69857, 69859, 69877, 69899, 69911, 69929, 69931, 69941, 69959, 69991, 69997, 70001, 70003, 70009, 70019, 70039, 70051, 70061, 70067, 70079, 70099, 70111, 70117, 70121, 70123, 70139, 70141, 70157, 70163, 70177, 70181, 70183, 70199, 70201, 70207, 70223, 70229, 70237, 70241, 70249, 70271, 70289, 70297, 70309, 70313, 70321, 70327, 70351, 70373, 70379, 70381, 70393, 70423, 70429, 70439, 70451, 70457, 70459, 70481, 70487, 70489, 70501, 70507, 70529, 70537, 70549, 70571, 70573, 70583, 70589, 70607, 70619, 70621, 70627, 70639, 70657, 70663, 70667, 70687, 70709, 70717, 70729, 70753, 70769, 70783, 70793, 70823, 70841, 70843, 70849, 70853, 70867, 70877, 70879, 70891, 70901, 70913, 70919, 70921, 70937, 70949, 70951, 70957, 70969, 70979, 70981, 70991, 70997, 70999, 71011, 71023, 71039, 71059, 71069, 71081, 71089, 71119, 71129, 71143, 71147, 71153, 71161, 71167, 71171, 71191, 71209, 71233, 71237, 71249, 71257, 71261, 71263, 71287, 71293, 71317, 71327, 71329, 71333, 71339, 71341, 71347, 71353, 71359, 71363, 71387, 71389, 71399, 71411, 71413, 71419, 71429, 71437, 71443, 71453, 71471, 71473, 71479, 71483, 71503, 71527, 71537, 71549, 71551, 71563, 71569, 71593, 71597, 71633, 71647, 71663, 71671, 71693, 71699, 71707, 71711, 71713, 71719, 71741, 71761, 71777, 71789, 71807, 71809, 71821, 71837, 71843, 71849, 71861, 71867, 71879, 71881, 71887, 71899, 71909, 71917, 71933, 71941, 71947, 71963, 71971, 71983, 71987, 71993, 71999, 72019, 72031, 72043, 72047, 72053, 72073, 72077, 72089, 72091, 72101, 72103, 72109, 72139, 72161, 72167, 72169, 72173, 72211, 72221, 72223, 72227, 72229, 72251, 72253, 72269, 72271, 72277, 72287, 72307, 72313, 72337, 72341, 72353, 72367, 72379, 72383, 72421, 72431, 72461, 72467, 72469, 72481, 72493, 72497, 72503, 72533, 72547, 72551, 72559, 72577, 72613, 72617, 72623, 72643, 72647, 72649, 72661, 72671, 72673, 72679, 72689, 72701, 72707, 72719, 72727, 72733, 72739, 72763, 72767, 72797, 72817, 72823, 72859, 72869, 72871, 72883, 72889, 72893, 72901, 72907, 72911, 72923, 72931, 72937, 72949, 72953, 72959, 72973, 72977, 72997, 73009, 73013, 73019, 73037, 73039, 73043, 73061, 73063, 73079, 73091, 73121, 73127, 73133, 73141, 73181, 73189, 73237, 73243, 73259, 73277, 73291, 73303, 73309, 73327, 73331, 73351, 73361, 73363, 73369, 73379, 73387, 73417, 73421, 73433, 73453, 73459, 73471, 73477, 73483, 73517, 73523, 73529, 73547, 73553, 73561, 73571, 73583, 73589, 73597, 73607, 73609, 73613, 73637, 73643, 73651, 73673, 73679, 73681, 73693, 73699, 73709, 73721, 73727, 73751, 73757, 73771, 73783, 73819, 73823, 73847, 73849, 73859, 73867, 73877, 73883, 73897, 73907, 73939, 73943, 73951, 73961, 73973, 73999, 74017, 74021, 74027, 74047, 74051, 74071, 74077, 74093, 74099, 74101, 74131, 74143, 74149, 74159, 74161, 74167, 74177, 74189, 74197, 74201, 74203, 74209, 74219, 74231, 74257, 74279, 74287, 74293, 74297, 74311, 74317, 74323, 74353, 74357, 74363, 74377, 74381, 74383, 74411, 74413, 74419, 74441, 74449, 74453, 74471, 74489, 74507, 74509, 74521, 74527, 74531, 74551, 74561, 74567, 74573, 74587, 74597, 74609, 74611, 74623, 74653, 74687, 74699, 74707, 74713, 74717, 74719, 74729, 74731, 74747, 74759, 74761, 74771, 74779, 74797, 74821, 74827, 74831, 74843, 74857, 74861, 74869, 74873, 74887, 74891, 74897, 74903, 74923, 74929, 74933, 74941, 74959, 75011, 75013, 75017, 75029, 75037, 75041, 75079, 75083, 75109, 75133, 75149, 75161, 75167, 75169, 75181, 75193, 75209, 75211, 75217, 75223, 75227, 75239, 75253, 75269, 75277, 75289, 75307, 75323, 75329, 75337, 75347, 75353, 75367, 75377, 75389, 75391, 75401, 75403, 75407, 75431, 75437, 75479, 75503, 75511, 75521, 75527, 75533, 75539, 75541, 75553, 75557, 75571, 75577, 75583, 75611, 75617, 75619, 75629, 75641, 75653, 75659, 75679, 75683, 75689, 75703, 75707, 75709, 75721, 75731, 75743, 75767, 75773, 75781, 75787, 75793, 75797, 75821, 75833, 75853, 75869, 75883, 75913, 75931, 75937, 75941, 75967, 75979, 75983, 75989, 75991, 75997, 76001, 76003, 76031, 76039, 76079, 76081, 76091, 76099, 76103, 76123, 76129, 76147, 76157, 76159, 76163, 76207, 76213, 76231, 76243, 76249, 76253, 76259, 76261, 76283, 76289, 76303, 76333, 76343, 76367, 76369, 76379, 76387, 76403, 76421, 76423, 76441, 76463, 76471, 76481, 76487, 76493, 76507, 76511, 76519, 76537, 76541, 76543, 76561, 76579, 76597, 76603, 76607, 76631, 76649, 76651, 76667, 76673, 76679, 76697, 76717, 76733, 76753, 76757, 76771, 76777, 76781, 76801, 76819, 76829, 76831, 76837, 76847, 76871, 76873, 76883, 76907, 76913, 76919, 76943, 76949, 76961, 76963, 76991, 77003, 77017, 77023, 77029, 77041, 77047, 77069, 77081, 77093, 77101, 77137, 77141, 77153, 77167, 77171, 77191, 77201, 77213, 77237, 77239, 77243, 77249, 77261, 77263, 77267, 77269, 77279, 77291, 77317, 77323, 77339, 77347, 77351, 77359, 77369, 77377, 77383, 77417, 77419, 77431, 77447, 77471, 77477, 77479, 77489, 77491, 77509, 77513, 77521, 77527, 77543, 77549, 77551, 77557, 77563, 77569, 77573, 77587, 77591, 77611, 77617, 77621, 77641, 77647, 77659, 77681, 77687, 77689, 77699, 77711, 77713, 77719, 77723, 77731, 77743, 77747, 77761, 77773, 77783, 77797, 77801, 77813, 77839, 77849, 77863, 77867, 77893, 77899, 77929, 77933, 77951, 77969, 77977, 77983, 77999, 78007, 78017, 78031, 78041, 78049, 78059, 78079, 78101, 78121, 78137, 78139, 78157, 78163, 78167, 78173, 78179, 78191, 78193, 78203, 78229, 78233, 78241, 78259, 78277, 78283, 78301, 78307, 78311, 78317, 78341, 78347, 78367, 78401, 78427, 78437, 78439, 78467, 78479, 78487, 78497, 78509, 78511, 78517, 78539, 78541, 78553, 78569, 78571, 78577, 78583, 78593, 78607, 78623, 78643, 78649, 78653, 78691, 78697, 78707, 78713, 78721, 78737, 78779, 78781, 78787, 78791, 78797, 78803, 78809, 78823, 78839, 78853, 78857, 78877, 78887, 78889, 78893, 78901, 78919, 78929, 78941, 78977, 78979, 78989, 79031, 79039, 79043, 79063, 79087, 79103, 79111, 79133, 79139, 79147, 79151, 79153, 79159, 79181, 79187, 79193, 79201, 79229, 79231, 79241, 79259, 79273, 79279, 79283, 79301, 79309, 79319, 79333, 79337, 79349, 79357, 79367, 79379, 79393, 79397, 79399, 79411, 79423, 79427, 79433, 79451, 79481, 79493, 79531, 79537, 79549, 79559, 79561, 79579, 79589, 79601, 79609, 79613, 79621, 79627, 79631, 79633, 79657, 79669, 79687, 79691, 79693, 79697, 79699, 79757, 79769, 79777, 79801, 79811, 79813, 79817, 79823, 79829, 79841, 79843, 79847, 79861, 79867, 79873, 79889, 79901, 79903, 79907, 79939, 79943, 79967, 79973, 79979, 79987, 79997, 79999, 80021, 80039, 80051, 80071, 80077, 80107, 80111, 80141, 80147, 80149, 80153, 80167, 80173, 80177, 80191, 80207, 80209, 80221, 80231, 80233, 80239, 80251, 80263, 80273, 80279, 80287, 80309, 80317, 80329, 80341, 80347, 80363, 80369, 80387, 80407, 80429, 80447, 80449, 80471, 80473, 80489, 80491, 80513, 80527, 80537, 80557, 80567, 80599, 80603, 80611, 80621, 80627, 80629, 80651, 80657, 80669, 80671, 80677, 80681, 80683, 80687, 80701, 80713, 80737, 80747, 80749, 80761, 80777, 80779, 80783, 80789, 80803, 80809, 80819, 80831, 80833, 80849, 80863, 80897, 80909, 80911, 80917, 80923, 80929, 80933, 80953, 80963, 80989, 81001, 81013, 81017, 81019, 81023, 81031, 81041, 81043, 81047, 81049, 81071, 81077, 81083, 81097, 81101, 81119, 81131, 81157, 81163, 81173, 81181, 81197, 81199, 81203, 81223, 81233, 81239, 81281, 81283, 81293, 81299, 81307, 81331, 81343, 81349, 81353, 81359, 81371, 81373, 81401, 81409, 81421, 81439, 81457, 81463, 81509, 81517, 81527, 81533, 81547, 81551, 81553, 81559, 81563, 81569, 81611, 81619, 81629, 81637, 81647, 81649, 81667, 81671, 81677, 81689, 81701, 81703, 81707, 81727, 81737, 81749, 81761, 81769, 81773, 81799, 81817, 81839, 81847, 81853, 81869, 81883, 81899, 81901, 81919, 81929, 81931, 81937, 81943, 81953, 81967, 81971, 81973, 82003, 82007, 82009, 82013, 82021, 82031, 82037, 82039, 82051, 82067, 82073, 82129, 82139, 82141, 82153, 82163, 82171, 82183, 82189, 82193, 82207, 82217, 82219, 82223, 82231, 82237, 82241, 82261, 82267, 82279, 82301, 82307, 82339, 82349, 82351, 82361, 82373, 82387, 82393, 82421, 82457, 82463, 82469, 82471, 82483, 82487, 82493, 82499, 82507, 82529, 82531, 82549, 82559, 82561, 82567, 82571, 82591, 82601, 82609, 82613, 82619, 82633, 82651, 82657, 82699, 82721, 82723, 82727, 82729, 82757, 82759, 82763, 82781, 82787, 82793, 82799, 82811, 82813, 82837, 82847, 82883, 82889, 82891, 82903, 82913, 82939, 82963, 82981, 82997, 83003, 83009, 83023, 83047, 83059, 83063, 83071, 83077, 83089, 83093, 83101, 83117, 83137, 83177, 83203, 83207, 83219, 83221, 83227, 83231, 83233, 83243, 83257, 83267, 83269, 83273, 83299, 83311, 83339, 83341, 83357, 83383, 83389, 83399, 83401, 83407, 83417, 83423, 83431, 83437, 83443, 83449, 83459, 83471, 83477, 83497, 83537, 83557, 83561, 83563, 83579, 83591, 83597, 83609, 83617, 83621, 83639, 83641, 83653, 83663, 83689, 83701, 83717, 83719, 83737, 83761, 83773, 83777, 83791, 83813, 83833, 83843, 83857, 83869, 83873, 83891, 83903, 83911, 83921, 83933, 83939, 83969, 83983, 83987, 84011, 84017, 84047, 84053, 84059, 84061, 84067, 84089, 84121, 84127, 84131, 84137, 84143, 84163, 84179, 84181, 84191, 84199, 84211, 84221, 84223, 84229, 84239, 84247, 84263, 84299, 84307, 84313, 84317, 84319, 84347, 84349, 84377, 84389, 84391, 84401, 84407, 84421, 84431, 84437, 84443, 84449, 84457, 84463, 84467, 84481, 84499, 84503, 84509, 84521, 84523, 84533, 84551, 84559, 84589, 84629, 84631, 84649, 84653, 84659, 84673, 84691, 84697, 84701, 84713, 84719, 84731, 84737, 84751, 84761, 84787, 84793, 84809, 84811, 84827, 84857, 84859, 84869, 84871, 84913, 84919, 84947, 84961, 84967, 84977, 84979, 84991, 85009, 85021, 85027, 85037, 85049, 85061, 85081, 85087, 85091, 85093, 85103, 85109, 85121, 85133, 85147, 85159, 85193, 85199, 85201, 85213, 85223, 85229, 85237, 85243, 85247, 85259, 85297, 85303, 85313, 85331, 85333, 85361, 85363, 85369, 85381, 85411, 85427, 85429, 85439, 85447, 85451, 85453, 85469, 85487, 85513, 85517, 85523, 85531, 85549, 85571, 85577, 85597, 85601, 85607, 85619, 85621, 85627, 85639, 85643, 85661, 85667, 85669, 85691, 85703, 85711, 85717, 85733, 85751, 85781, 85793, 85817, 85819, 85829, 85831, 85837, 85843, 85847, 85853, 85889, 85903, 85909, 85931, 85933, 85991, 85999, 86011, 86017, 86027, 86029, 86069, 86077, 86083, 86111, 86113, 86117, 86131, 86137, 86143, 86161, 86171, 86179, 86183, 86197, 86201, 86209, 86239, 86243, 86249, 86257, 86263, 86269, 86287, 86291, 86293, 86297, 86311, 86323, 86341, 86351, 86353, 86357, 86369, 86371, 86381, 86389, 86399, 86413, 86423, 86441, 86453, 86461, 86467, 86477, 86491, 86501, 86509, 86531, 86533, 86539, 86561, 86573, 86579, 86587, 86599, 86627, 86629, 86677, 86689, 86693, 86711, 86719, 86729, 86743, 86753, 86767, 86771, 86783, 86813, 86837, 86843, 86851, 86857, 86861, 86869, 86923, 86927, 86929, 86939, 86951, 86959, 86969, 86981, 86993, 87011, 87013, 87037, 87041, 87049, 87071, 87083, 87103, 87107, 87119, 87121, 87133, 87149, 87151, 87179, 87181, 87187, 87211, 87221, 87223, 87251, 87253, 87257, 87277, 87281, 87293, 87299, 87313, 87317, 87323, 87337, 87359, 87383, 87403, 87407, 87421, 87427, 87433, 87443, 87473, 87481, 87491, 87509, 87511, 87517, 87523, 87539, 87541, 87547, 87553, 87557, 87559, 87583, 87587, 87589, 87613, 87623, 87629, 87631, 87641, 87643, 87649, 87671, 87679, 87683, 87691, 87697, 87701, 87719, 87721, 87739, 87743, 87751, 87767, 87793, 87797, 87803, 87811, 87833, 87853, 87869, 87877, 87881, 87887, 87911, 87917, 87931, 87943, 87959, 87961, 87973, 87977, 87991, 88001, 88003, 88007, 88019, 88037, 88069, 88079, 88093, 88117, 88129, 88169, 88177, 88211, 88223, 88237, 88241, 88259, 88261, 88289, 88301, 88321, 88327, 88337, 88339, 88379, 88397, 88411, 88423, 88427, 88463, 88469, 88471, 88493, 88499, 88513, 88523, 88547, 88589, 88591, 88607, 88609, 88643, 88651, 88657, 88661, 88663, 88667, 88681, 88721, 88729, 88741, 88747, 88771, 88789, 88793, 88799, 88801, 88807, 88811, 88813, 88817, 88819, 88843, 88853, 88861, 88867, 88873, 88883, 88897, 88903, 88919, 88937, 88951, 88969, 88993, 88997, 89003, 89009, 89017, 89021, 89041, 89051, 89057, 89069, 89071, 89083, 89087, 89101, 89107, 89113, 89119, 89123, 89137, 89153, 89189, 89203, 89209, 89213, 89227, 89231, 89237, 89261, 89269, 89273, 89293, 89303, 89317, 89329, 89363, 89371, 89381, 89387, 89393, 89399, 89413, 89417, 89431, 89443, 89449, 89459, 89477, 89491, 89501, 89513, 89519, 89521, 89527, 89533, 89561, 89563, 89567, 89591, 89597, 89599, 89603, 89611, 89627, 89633, 89653, 89657, 89659, 89669, 89671, 89681, 89689, 89753, 89759, 89767, 89779, 89783, 89797, 89809, 89819, 89821, 89833, 89839, 89849, 89867, 89891, 89897, 89899, 89909, 89917, 89923, 89939, 89959, 89963, 89977, 89983, 89989, 90001, 90007, 90011, 90017, 90019, 90023, 90031, 90053, 90059, 90067, 90071, 90073, 90089, 90107, 90121, 90127, 90149, 90163, 90173, 90187, 90191, 90197, 90199, 90203, 90217, 90227, 90239, 90247, 90263, 90271, 90281, 90289, 90313, 90353, 90359, 90371, 90373, 90379, 90397, 90401, 90403, 90407, 90437, 90439, 90469, 90473, 90481, 90499, 90511, 90523, 90527, 90529, 90533, 90547, 90583, 90599, 90617, 90619, 90631, 90641, 90647, 90659, 90677, 90679, 90697, 90703, 90709, 90731, 90749, 90787, 90793, 90803, 90821, 90823, 90833, 90841, 90847, 90863, 90887, 90901, 90907, 90911, 90917, 90931, 90947, 90971, 90977, 90989, 90997, 91009, 91019, 91033, 91079, 91081, 91097, 91099, 91121, 91127, 91129, 91139, 91141, 91151, 91153, 91159, 91163, 91183, 91193, 91199, 91229, 91237, 91243, 91249, 91253, 91283, 91291, 91297, 91303, 91309, 91331, 91367, 91369, 91373, 91381, 91387, 91393, 91397, 91411, 91423, 91433, 91453, 91457, 91459, 91463, 91493, 91499, 91513, 91529, 91541, 91571, 91573, 91577, 91583, 91591, 91621, 91631, 91639, 91673, 91691, 91703, 91711, 91733, 91753, 91757, 91771, 91781, 91801, 91807, 91811, 91813, 91823, 91837, 91841, 91867, 91873, 91909, 91921, 91939, 91943, 91951, 91957, 91961, 91967, 91969, 91997, 92003, 92009, 92033, 92041, 92051, 92077, 92083, 92107, 92111, 92119, 92143, 92153, 92173, 92177, 92179, 92189, 92203, 92219, 92221, 92227, 92233, 92237, 92243, 92251, 92269, 92297, 92311, 92317, 92333, 92347, 92353, 92357, 92363, 92369, 92377, 92381, 92383, 92387, 92399, 92401, 92413, 92419, 92431, 92459, 92461, 92467, 92479, 92489, 92503, 92507, 92551, 92557, 92567, 92569, 92581, 92593, 92623, 92627, 92639, 92641, 92647, 92657, 92669, 92671, 92681, 92683, 92693, 92699, 92707, 92717, 92723, 92737, 92753, 92761, 92767, 92779, 92789, 92791, 92801, 92809, 92821, 92831, 92849, 92857, 92861, 92863, 92867, 92893, 92899, 92921, 92927, 92941, 92951, 92957, 92959, 92987, 92993, 93001, 93047, 93053, 93059, 93077, 93083, 93089, 93097, 93103, 93113, 93131, 93133, 93139, 93151, 93169, 93179, 93187, 93199, 93229, 93239, 93241, 93251, 93253, 93257, 93263, 93281, 93283, 93287, 93307, 93319, 93323, 93329, 93337, 93371, 93377, 93383, 93407, 93419, 93427, 93463, 93479, 93481, 93487, 93491, 93493, 93497, 93503, 93523, 93529, 93553, 93557, 93559, 93563, 93581, 93601, 93607, 93629, 93637, 93683, 93701, 93703, 93719, 93739, 93761, 93763, 93787, 93809, 93811, 93827, 93851, 93871, 93887, 93889, 93893, 93901, 93911, 93913, 93923, 93937, 93941, 93949, 93967, 93971, 93979, 93983, 93997, 94007, 94009, 94033, 94049, 94057, 94063, 94079, 94099, 94109, 94111, 94117, 94121, 94151, 94153, 94169, 94201, 94207, 94219, 94229, 94253, 94261, 94273, 94291, 94307, 94309, 94321, 94327, 94331, 94343, 94349, 94351, 94379, 94397, 94399, 94421, 94427, 94433, 94439, 94441, 94447, 94463, 94477, 94483, 94513, 94529, 94531, 94541, 94543, 94547, 94559, 94561, 94573, 94583, 94597, 94603, 94613, 94621, 94649, 94651, 94687, 94693, 94709, 94723, 94727, 94747, 94771, 94777, 94781, 94789, 94793, 94811, 94819, 94823, 94837, 94841, 94847, 94849, 94873, 94889, 94903, 94907, 94933, 94949, 94951, 94961, 94993, 94999, 95003, 95009, 95021, 95027, 95063, 95071, 95083, 95087, 95089, 95093, 95101, 95107, 95111, 95131, 95143, 95153, 95177, 95189, 95191, 95203, 95213, 95219, 95231, 95233, 95239, 95257, 95261, 95267, 95273, 95279, 95287, 95311, 95317, 95327, 95339, 95369, 95383, 95393, 95401, 95413, 95419, 95429, 95441, 95443, 95461, 95467, 95471, 95479, 95483, 95507, 95527, 95531, 95539, 95549, 95561, 95569, 95581, 95597, 95603, 95617, 95621, 95629, 95633, 95651, 95701, 95707, 95713, 95717, 95723, 95731, 95737, 95747, 95773, 95783, 95789, 95791, 95801, 95803, 95813, 95819, 95857, 95869, 95873, 95881, 95891, 95911, 95917, 95923, 95929, 95947, 95957, 95959, 95971, 95987, 95989, 96001, 96013, 96017, 96043, 96053, 96059, 96079, 96097, 96137, 96149, 96157, 96167, 96179, 96181, 96199, 96211, 96221, 96223, 96233, 96259, 96263, 96269, 96281, 96289, 96293, 96323, 96329, 96331, 96337, 96353, 96377, 96401, 96419, 96431, 96443, 96451, 96457, 96461, 96469, 96479, 96487, 96493, 96497, 96517, 96527, 96553, 96557, 96581, 96587, 96589, 96601, 96643, 96661, 96667, 96671, 96697, 96703, 96731, 96737, 96739, 96749, 96757, 96763, 96769, 96779, 96787, 96797, 96799, 96821, 96823, 96827, 96847, 96851, 96857, 96893, 96907, 96911, 96931, 96953, 96959, 96973, 96979, 96989, 96997, 97001, 97003, 97007, 97021, 97039, 97073, 97081, 97103, 97117, 97127, 97151, 97157, 97159, 97169, 97171, 97177, 97187, 97213, 97231, 97241, 97259, 97283, 97301, 97303, 97327, 97367, 97369, 97373, 97379, 97381, 97387, 97397, 97423, 97429, 97441, 97453, 97459, 97463, 97499, 97501, 97511, 97523, 97547, 97549, 97553, 97561, 97571, 97577, 97579, 97583, 97607, 97609, 97613, 97649, 97651, 97673, 97687, 97711, 97729, 97771, 97777, 97787, 97789, 97813, 97829, 97841, 97843, 97847, 97849, 97859, 97861, 97871, 97879, 97883, 97919, 97927, 97931, 97943, 97961, 97967, 97973, 97987, 98009, 98011, 98017, 98041, 98047, 98057, 98081, 98101, 98123, 98129, 98143, 98179, 98207, 98213, 98221, 98227, 98251, 98257, 98269, 98297, 98299, 98317, 98321, 98323, 98327, 98347, 98369, 98377, 98387, 98389, 98407, 98411, 98419, 98429, 98443, 98453, 98459, 98467, 98473, 98479, 98491, 98507, 98519, 98533, 98543, 98561, 98563, 98573, 98597, 98621, 98627, 98639, 98641, 98663, 98669, 98689, 98711, 98713, 98717, 98729, 98731, 98737, 98773, 98779, 98801, 98807, 98809, 98837, 98849, 98867, 98869, 98873, 98887, 98893, 98897, 98899, 98909, 98911, 98927, 98929, 98939, 98947, 98953, 98963, 98981, 98993, 98999, 99013, 99017, 99023, 99041, 99053, 99079, 99083, 99089, 99103, 99109, 99119, 99131, 99133, 99137, 99139, 99149, 99173, 99181, 99191, 99223, 99233, 99241, 99251, 99257, 99259, 99277, 99289, 99317, 99347, 99349, 99367, 99371, 99377, 99391, 99397, 99401, 99409, 99431, 99439, 99469, 99487, 99497, 99523, 99527, 99529, 99551, 99559, 99563, 99571, 99577, 99581, 99607, 99611, 99623, 99643, 99661, 99667, 99679, 99689, 99707, 99709, 99713, 99719, 99721, 99733, 99761, 99767, 99787, 99793, 99809, 99817, 99823, 99829, 99833, 99839, 99859, 99871, 99877, 99881, 99901, 99907, 99923, 99929, 99961, 99971, 99989, 99991, 100003, 100019, 100043, 100049, 100057, 100069, 100103, 100109, 100129, 100151, 100153, 100169, 100183, 100189, 100193, 100207, 100213, 100237, 100267, 100271, 100279, 100291, 100297, 100313, 100333, 100343, 100357, 100361, 100363, 100379, 100391, 100393, 100403, 100411, 100417, 100447, 100459, 100469, 100483, 100493, 100501, 100511, 100517, 100519, 100523, 100537, 100547, 100549, 100559, 100591, 100609, 100613, 100621, 100649, 100669, 100673, 100693, 100699, 100703, 100733, 100741, 100747, 100769, 100787, 100799, 100801, 100811, 100823, 100829, 100847, 100853, 100907, 100913, 100927, 100931, 100937, 100943, 100957, 100981, 100987, 100999, 101009, 101021, 101027, 101051, 101063, 101081, 101089, 101107, 101111, 101113, 101117, 101119, 101141, 101149, 101159, 101161, 101173, 101183, 101197, 101203, 101207, 101209, 101221, 101267, 101273, 101279, 101281, 101287, 101293, 101323, 101333, 101341, 101347, 101359, 101363, 101377, 101383, 101399, 101411, 101419, 101429, 101449, 101467, 101477, 101483, 101489, 101501, 101503, 101513, 101527, 101531, 101533, 101537, 101561, 101573, 101581, 101599, 101603, 101611, 101627, 101641, 101653, 101663, 101681, 101693, 101701, 101719, 101723, 101737, 101741, 101747, 101749, 101771, 101789, 101797, 101807, 101833, 101837, 101839, 101863, 101869, 101873, 101879, 101891, 101917, 101921, 101929, 101939, 101957, 101963, 101977, 101987, 101999, 102001, 102013, 102019, 102023, 102031, 102043, 102059, 102061, 102071, 102077, 102079, 102101, 102103, 102107, 102121, 102139, 102149, 102161, 102181, 102191, 102197, 102199, 102203, 102217, 102229, 102233, 102241, 102251, 102253, 102259, 102293, 102299, 102301, 102317, 102329, 102337, 102359, 102367, 102397, 102407, 102409, 102433, 102437, 102451, 102461, 102481, 102497, 102499, 102503, 102523, 102533, 102539, 102547, 102551, 102559, 102563, 102587, 102593, 102607, 102611, 102643, 102647, 102653, 102667, 102673, 102677, 102679, 102701, 102761, 102763, 102769, 102793, 102797, 102811, 102829, 102841, 102859, 102871, 102877, 102881, 102911, 102913, 102929, 102931, 102953, 102967, 102983, 103001, 103007, 103043, 103049, 103067, 103069, 103079, 103087, 103091, 103093, 103099, 103123, 103141, 103171, 103177, 103183, 103217, 103231, 103237, 103289, 103291, 103307, 103319, 103333, 103349, 103357, 103387, 103391, 103393, 103399, 103409, 103421, 103423, 103451, 103457, 103471, 103483, 103511, 103529, 103549, 103553, 103561, 103567, 103573, 103577, 103583, 103591, 103613, 103619, 103643, 103651, 103657, 103669, 103681, 103687, 103699, 103703, 103723, 103769, 103787, 103801, 103811, 103813, 103837, 103841, 103843, 103867, 103889, 103903, 103913, 103919, 103951, 103963, 103967, 103969, 103979, 103981, 103991, 103993, 103997, 104003, 104009, 104021, 104033, 104047, 104053, 104059, 104087, 104089, 104107, 104113, 104119, 104123, 104147, 104149, 104161, 104173, 104179, 104183, 104207, 104231, 104233, 104239, 104243, 104281, 104287, 104297, 104309, 104311, 104323, 104327, 104347, 104369, 104381, 104383, 104393, 104399, 104417, 104459, 104471, 104473, 104479, 104491, 104513, 104527, 104537, 104543, 104549, 104551, 104561, 104579, 104593, 104597, 104623, 104639, 104651, 104659, 104677, 104681, 104683, 104693, 104701, 104707, 104711, 104717, 104723, 104729];

}).call(this);

},{}],6:[function(require,module,exports){
// Generated by IcedCoffeeScript 1.6.3-g
(function() {
  var ASP, BigInteger, C, Pair, Priv, Pub, RSA, iced, make_esc, nbi, nbs, nbv, random_prime, __iced_k, __iced_k_noop, _ref, _ref1;

  iced = require('iced-coffee-script/lib/coffee-script/iced').runtime;
  __iced_k = __iced_k_noop = function() {};

  _ref = require('./primegen'), random_prime = _ref.random_prime, nbs = _ref.nbs;

  RSA = require('openpgp').ciphers.asymmetric.RSA;

  _ref1 = require('openpgp').bigint, nbv = _ref1.nbv, nbi = _ref1.nbi, BigInteger = _ref1.BigInteger;

  ASP = require('./util').ASP;

  make_esc = require('iced-error').make_esc;

  C = require('./const').openpgp;

  Priv = (function() {
    function Priv(_arg) {
      this.p = _arg.p, this.q = _arg.q, this.d = _arg.d, this.dmp1 = _arg.dmp1, this.dmq1 = _arg.dmq1, this.u = _arg.u, this.pub = _arg.pub;
    }

    Priv.prototype.decrypt = function(c) {
      return c.modPow(this.d, this.pub.n);
    };

    return Priv;

  })();

  Pub = (function() {
    function Pub(_arg) {
      this.n = _arg.n, this.e = _arg.e;
    }

    Pub.prototype.encrypt = function(p) {
      return p.modPow(this.e, this.n);
    };

    return Pub;

  })();

  Pair = (function() {
    Pair.type = C.public_key_algorithms.RSA;

    Pair.prototype.type = Pair.type;

    function Pair(_arg) {
      this.priv = _arg.priv, this.pub = _arg.pub;
    }

    Pair.prototype.encrypt = function(p) {
      return this.pub.encrypt(p);
    };

    Pair.prototype.decrypt = function(c) {
      return this.priv.decrypt(c);
    };

    Pair.make = function(_arg) {
      var d, dmp1, dmq1, e, n, p, p1, phi, priv, pub, q, q1, u;
      p = _arg.p, q = _arg.q, e = _arg.e, phi = _arg.phi, p1 = _arg.p1, q1 = _arg.q1;
      n = p.multiply(q);
      d = e.modInverse(phi);
      dmp1 = d.mod(p1);
      dmq1 = d.mod(q1);
      u = p.modInverse(q);
      pub = new Pub({
        n: n,
        e: e
      });
      priv = new Priv({
        p: p,
        q: q,
        d: d,
        dmp1: dmp1,
        dmq1: dmq1,
        u: u,
        pub: pub
      });
      return new Pair({
        priv: priv,
        pub: pub
      });
    };

    Pair.prototype.to_openpgp = function() {
      var key;
      key = new (new RSA).keyObject();
      key.n = this.pub.n;
      key.e = this.pub.e.intValue();
      key.ee = this.pub.e;
      key.d = this.priv.d;
      key.p = this.priv.p;
      key.q = this.priv.q;
      key.dmp1 = this.priv.dmp1;
      key.dmq1 = this.priv.dmq1;
      key.u = this.priv.u;
      return key;
    };

    Pair.generate = function(_arg, cb) {
      var asp, e, e_orig, esc, go, iters, key, nbits, p, p1, phi, q, q1, ___iced_passed_deferral, __iced_deferrals, __iced_k,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      nbits = _arg.nbits, iters = _arg.iters, e = _arg.e, asp = _arg.asp;
      e || (e = (1 << 16) + 1);
      e_orig = e;
      nbits || (nbits = 1024);
      iters || (iters = 10);
      asp || (asp = new ASP({}));
      e = nbv(e_orig);
      esc = make_esc(cb, "generate_rsa_keypair");
      go = true;
      nbits >>= 1;
      (function(__iced_k) {
        var _results, _while;
        _results = [];
        _while = function(__iced_k) {
          var _break, _continue, _next;
          _break = function() {
            return __iced_k(_results);
          };
          _continue = function() {
            return iced.trampoline(function() {
              return _while(__iced_k);
            });
          };
          _next = function(__iced_next_arg) {
            _results.push(__iced_next_arg);
            return _continue();
          };
          if (!go) {
            return _break();
          } else {
            (function(__iced_k) {
              __iced_deferrals = new iced.Deferrals(__iced_k, {
                parent: ___iced_passed_deferral,
                filename: "src/rsa.iced",
                funcname: "Pair.generate"
              });
              random_prime({
                asp: asp.section('p'),
                e: e,
                nbits: nbits,
                iters: iters
              }, esc(__iced_deferrals.defer({
                assign_fn: (function() {
                  return function() {
                    return p = arguments[0];
                  };
                })(),
                lineno: 74
              })));
              __iced_deferrals._fulfill();
            })(function() {
              (function(__iced_k) {
                __iced_deferrals = new iced.Deferrals(__iced_k, {
                  parent: ___iced_passed_deferral,
                  filename: "src/rsa.iced",
                  funcname: "Pair.generate"
                });
                asp.progress({
                  what: "found",
                  p: p
                }, esc(__iced_deferrals.defer({
                  lineno: 75
                })));
                __iced_deferrals._fulfill();
              })(function() {
                (function(__iced_k) {
                  __iced_deferrals = new iced.Deferrals(__iced_k, {
                    parent: ___iced_passed_deferral,
                    filename: "src/rsa.iced",
                    funcname: "Pair.generate"
                  });
                  random_prime({
                    asp: asp.section('q'),
                    e: e,
                    nbits: nbits,
                    iters: iters
                  }, esc(__iced_deferrals.defer({
                    assign_fn: (function() {
                      return function() {
                        return q = arguments[0];
                      };
                    })(),
                    lineno: 76
                  })));
                  __iced_deferrals._fulfill();
                })(function() {
                  (function(__iced_k) {
                    __iced_deferrals = new iced.Deferrals(__iced_k, {
                      parent: ___iced_passed_deferral,
                      filename: "src/rsa.iced",
                      funcname: "Pair.generate"
                    });
                    asp.progress({
                      what: "found",
                      q: q
                    }, esc(__iced_deferrals.defer({
                      lineno: 77
                    })));
                    __iced_deferrals._fulfill();
                  })(function() {
                    var _ref2;
                    if (p.compareTo(q) <= 0) {
                      _ref2 = [q, p], p = _ref2[0], q = _ref2[1];
                    }
                    q1 = q.subtract(BigInteger.ONE);
                    p1 = p.subtract(BigInteger.ONE);
                    phi = p1.multiply(q1);
                    return _next(phi.gcd(e).compareTo(BigInteger.ONE) !== 0 ? (typeof progress_hook === "function" ? progress_hook({
                      what: "unlucky_phi"
                    }) : void 0, go = true) : go = false);
                  });
                });
              });
            });
          }
        };
        _while(__iced_k);
      })(function() {
        key = Pair.make({
          p: p,
          q: q,
          e: e,
          phi: phi,
          p1: p1,
          q1: q1
        });
        return cb(null, key);
      });
    };

    return Pair;

  })();

  exports.RSA = Pair;

}).call(this);

},{"./const":3,"./primegen":4,"./util":7,"iced-coffee-script/lib/coffee-script/iced":22,"iced-error":23,"openpgp":25}],7:[function(require,module,exports){
var Buffer=require("__browserify_Buffer").Buffer;// Generated by IcedCoffeeScript 1.6.3-g
(function() {
  var ASP, Canceler, iced, __iced_k, __iced_k_noop;

  iced = require('iced-coffee-script/lib/coffee-script/iced').runtime;
  __iced_k = __iced_k_noop = function() {};

  Canceler = require('iced-error').Canceler;

  exports.make_time_packet = function(d) {
    var b;
    d || (d = Math.floor(Date.now() / 1000));
    b = new Buffer(4);
    b.writeUInt32BE(d, 0);
    return b.toString('binary');
  };

  exports.uint_to_buffer = function(nbits, i) {
    var ret;
    ret = null;
    switch (nbits) {
      case 16:
        ret = new Buffer(2);
        ret.writeUInt16BE(i, 0);
        break;
      case 32:
        ret = new Buffer(4);
        ret.writeUInt32BE(i, 0);
        break;
      case 8:
        ret = new Buffer(1);
        ret.writeUInt8(i, 0);
        break;
      default:
        throw new Error("Bit types not found: " + nbit);
    }
    return ret;
  };

  exports.ASP = ASP = (function() {
    function ASP(_arg) {
      var canceler, delay, progress_hook;
      progress_hook = _arg.progress_hook, delay = _arg.delay, canceler = _arg.canceler;
      this._delay = delay || 2;
      this._canceler = canceler || (new Canceler());
      this._progress_hook = progress_hook || (function(obj) {});
      this._section = null;
    }

    ASP.prototype.section = function(s) {
      this._section = s;
      return this;
    };

    ASP.prototype.progress = function(o, cb) {
      var err, ___iced_passed_deferral, __iced_deferrals, __iced_k,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      if (this._section) {
        o.section = this._section;
      }
      this._progress_hook(o);
      if (cb != null) {
        (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "src/util.iced",
            funcname: "ASP.progress"
          });
          _this.delay(__iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                return err = arguments[0];
              };
            })(),
            lineno: 55
          }));
          __iced_deferrals._fulfill();
        })(function() {
          return __iced_k(cb(err));
        });
      } else {
        return __iced_k();
      }
    };

    ASP.prototype.delay = function(cb) {
      var ___iced_passed_deferral, __iced_deferrals, __iced_k,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: "src/util.iced",
          funcname: "ASP.delay"
        });
        setTimeout(__iced_deferrals.defer({
          lineno: 59
        }), _this.delay);
        __iced_deferrals._fulfill();
      })(function() {
        return cb(_this._canceler.err());
      });
    };

    ASP.prototype.canceler = function() {
      return this._canceler;
    };

    return ASP;

  })();

}).call(this);

},{"__browserify_Buffer":18,"iced-coffee-script/lib/coffee-script/iced":22,"iced-error":23}],8:[function(require,module,exports){


//
// The shims in this file are not fully implemented shims for the ES5
// features, but do work for the particular usecases there is in
// the other modules.
//

var toString = Object.prototype.toString;
var hasOwnProperty = Object.prototype.hasOwnProperty;

// Array.isArray is supported in IE9
function isArray(xs) {
  return toString.call(xs) === '[object Array]';
}
exports.isArray = typeof Array.isArray === 'function' ? Array.isArray : isArray;

// Array.prototype.indexOf is supported in IE9
exports.indexOf = function indexOf(xs, x) {
  if (xs.indexOf) return xs.indexOf(x);
  for (var i = 0; i < xs.length; i++) {
    if (x === xs[i]) return i;
  }
  return -1;
};

// Array.prototype.filter is supported in IE9
exports.filter = function filter(xs, fn) {
  if (xs.filter) return xs.filter(fn);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    if (fn(xs[i], i, xs)) res.push(xs[i]);
  }
  return res;
};

// Array.prototype.forEach is supported in IE9
exports.forEach = function forEach(xs, fn, self) {
  if (xs.forEach) return xs.forEach(fn, self);
  for (var i = 0; i < xs.length; i++) {
    fn.call(self, xs[i], i, xs);
  }
};

// Array.prototype.map is supported in IE9
exports.map = function map(xs, fn) {
  if (xs.map) return xs.map(fn);
  var out = new Array(xs.length);
  for (var i = 0; i < xs.length; i++) {
    out[i] = fn(xs[i], i, xs);
  }
  return out;
};

// Array.prototype.reduce is supported in IE9
exports.reduce = function reduce(array, callback, opt_initialValue) {
  if (array.reduce) return array.reduce(callback, opt_initialValue);
  var value, isValueSet = false;

  if (2 < arguments.length) {
    value = opt_initialValue;
    isValueSet = true;
  }
  for (var i = 0, l = array.length; l > i; ++i) {
    if (array.hasOwnProperty(i)) {
      if (isValueSet) {
        value = callback(value, array[i], i, array);
      }
      else {
        value = array[i];
        isValueSet = true;
      }
    }
  }

  return value;
};

// String.prototype.substr - negative index don't work in IE8
if ('ab'.substr(-1) !== 'b') {
  exports.substr = function (str, start, length) {
    // did we get a negative start, calculate how much it is from the beginning of the string
    if (start < 0) start = str.length + start;

    // call the original function
    return str.substr(start, length);
  };
} else {
  exports.substr = function (str, start, length) {
    return str.substr(start, length);
  };
}

// String.prototype.trim is supported in IE9
exports.trim = function (str) {
  if (str.trim) return str.trim();
  return str.replace(/^\s+|\s+$/g, '');
};

// Function.prototype.bind is supported in IE9
exports.bind = function () {
  var args = Array.prototype.slice.call(arguments);
  var fn = args.shift();
  if (fn.bind) return fn.bind.apply(fn, args);
  var self = args.shift();
  return function () {
    fn.apply(self, args.concat([Array.prototype.slice.call(arguments)]));
  };
};

// Object.create is supported in IE9
function create(prototype, properties) {
  var object;
  if (prototype === null) {
    object = { '__proto__' : null };
  }
  else {
    if (typeof prototype !== 'object') {
      throw new TypeError(
        'typeof prototype[' + (typeof prototype) + '] != \'object\''
      );
    }
    var Type = function () {};
    Type.prototype = prototype;
    object = new Type();
    object.__proto__ = prototype;
  }
  if (typeof properties !== 'undefined' && Object.defineProperties) {
    Object.defineProperties(object, properties);
  }
  return object;
}
exports.create = typeof Object.create === 'function' ? Object.create : create;

// Object.keys and Object.getOwnPropertyNames is supported in IE9 however
// they do show a description and number property on Error objects
function notObject(object) {
  return ((typeof object != "object" && typeof object != "function") || object === null);
}

function keysShim(object) {
  if (notObject(object)) {
    throw new TypeError("Object.keys called on a non-object");
  }

  var result = [];
  for (var name in object) {
    if (hasOwnProperty.call(object, name)) {
      result.push(name);
    }
  }
  return result;
}

// getOwnPropertyNames is almost the same as Object.keys one key feature
//  is that it returns hidden properties, since that can't be implemented,
//  this feature gets reduced so it just shows the length property on arrays
function propertyShim(object) {
  if (notObject(object)) {
    throw new TypeError("Object.getOwnPropertyNames called on a non-object");
  }

  var result = keysShim(object);
  if (exports.isArray(object) && exports.indexOf(object, 'length') === -1) {
    result.push('length');
  }
  return result;
}

var keys = typeof Object.keys === 'function' ? Object.keys : keysShim;
var getOwnPropertyNames = typeof Object.getOwnPropertyNames === 'function' ?
  Object.getOwnPropertyNames : propertyShim;

if (new Error().hasOwnProperty('description')) {
  var ERROR_PROPERTY_FILTER = function (obj, array) {
    if (toString.call(obj) === '[object Error]') {
      array = exports.filter(array, function (name) {
        return name !== 'description' && name !== 'number' && name !== 'message';
      });
    }
    return array;
  };

  exports.keys = function (object) {
    return ERROR_PROPERTY_FILTER(object, keys(object));
  };
  exports.getOwnPropertyNames = function (object) {
    return ERROR_PROPERTY_FILTER(object, getOwnPropertyNames(object));
  };
} else {
  exports.keys = keys;
  exports.getOwnPropertyNames = getOwnPropertyNames;
}

// Object.getOwnPropertyDescriptor - supported in IE8 but only on dom elements
function valueObject(value, key) {
  return { value: value[key] };
}

if (typeof Object.getOwnPropertyDescriptor === 'function') {
  try {
    Object.getOwnPropertyDescriptor({'a': 1}, 'a');
    exports.getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
  } catch (e) {
    // IE8 dom element issue - use a try catch and default to valueObject
    exports.getOwnPropertyDescriptor = function (value, key) {
      try {
        return Object.getOwnPropertyDescriptor(value, key);
      } catch (e) {
        return valueObject(value, key);
      }
    };
  }
} else {
  exports.getOwnPropertyDescriptor = valueObject;
}

},{}],9:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// UTILITY
var util = require('util');
var shims = require('_shims');
var pSlice = Array.prototype.slice;

// 1. The assert module provides functions that throw
// AssertionError's when particular conditions are not met. The
// assert module must conform to the following interface.

var assert = module.exports = ok;

// 2. The AssertionError is defined in assert.
// new assert.AssertionError({ message: message,
//                             actual: actual,
//                             expected: expected })

assert.AssertionError = function AssertionError(options) {
  this.name = 'AssertionError';
  this.actual = options.actual;
  this.expected = options.expected;
  this.operator = options.operator;
  this.message = options.message || getMessage(this);
};

// assert.AssertionError instanceof Error
util.inherits(assert.AssertionError, Error);

function replacer(key, value) {
  if (util.isUndefined(value)) {
    return '' + value;
  }
  if (util.isNumber(value) && (isNaN(value) || !isFinite(value))) {
    return value.toString();
  }
  if (util.isFunction(value) || util.isRegExp(value)) {
    return value.toString();
  }
  return value;
}

function truncate(s, n) {
  if (util.isString(s)) {
    return s.length < n ? s : s.slice(0, n);
  } else {
    return s;
  }
}

function getMessage(self) {
  return truncate(JSON.stringify(self.actual, replacer), 128) + ' ' +
         self.operator + ' ' +
         truncate(JSON.stringify(self.expected, replacer), 128);
}

// At present only the three keys mentioned above are used and
// understood by the spec. Implementations or sub modules can pass
// other keys to the AssertionError's constructor - they will be
// ignored.

// 3. All of the following functions must throw an AssertionError
// when a corresponding condition is not met, with a message that
// may be undefined if not provided.  All assertion methods provide
// both the actual and expected values to the assertion error for
// display purposes.

function fail(actual, expected, message, operator, stackStartFunction) {
  throw new assert.AssertionError({
    message: message,
    actual: actual,
    expected: expected,
    operator: operator,
    stackStartFunction: stackStartFunction
  });
}

// EXTENSION! allows for well behaved errors defined elsewhere.
assert.fail = fail;

// 4. Pure assertion tests whether a value is truthy, as determined
// by !!guard.
// assert.ok(guard, message_opt);
// This statement is equivalent to assert.equal(true, !!guard,
// message_opt);. To test strictly for the value true, use
// assert.strictEqual(true, guard, message_opt);.

function ok(value, message) {
  if (!value) fail(value, true, message, '==', assert.ok);
}
assert.ok = ok;

// 5. The equality assertion tests shallow, coercive equality with
// ==.
// assert.equal(actual, expected, message_opt);

assert.equal = function equal(actual, expected, message) {
  if (actual != expected) fail(actual, expected, message, '==', assert.equal);
};

// 6. The non-equality assertion tests for whether two objects are not equal
// with != assert.notEqual(actual, expected, message_opt);

assert.notEqual = function notEqual(actual, expected, message) {
  if (actual == expected) {
    fail(actual, expected, message, '!=', assert.notEqual);
  }
};

// 7. The equivalence assertion tests a deep equality relation.
// assert.deepEqual(actual, expected, message_opt);

assert.deepEqual = function deepEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected)) {
    fail(actual, expected, message, 'deepEqual', assert.deepEqual);
  }
};

function _deepEqual(actual, expected) {
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;

  } else if (util.isBuffer(actual) && util.isBuffer(expected)) {
    if (actual.length != expected.length) return false;

    for (var i = 0; i < actual.length; i++) {
      if (actual[i] !== expected[i]) return false;
    }

    return true;

  // 7.2. If the expected value is a Date object, the actual value is
  // equivalent if it is also a Date object that refers to the same time.
  } else if (util.isDate(actual) && util.isDate(expected)) {
    return actual.getTime() === expected.getTime();

  // 7.3 If the expected value is a RegExp object, the actual value is
  // equivalent if it is also a RegExp object with the same source and
  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
    return actual.source === expected.source &&
           actual.global === expected.global &&
           actual.multiline === expected.multiline &&
           actual.lastIndex === expected.lastIndex &&
           actual.ignoreCase === expected.ignoreCase;

  // 7.4. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if (!util.isObject(actual) && !util.isObject(expected)) {
    return actual == expected;

  // 7.5 For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else {
    return objEquiv(actual, expected);
  }
}

function isArguments(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
}

function objEquiv(a, b) {
  if (util.isNullOrUndefined(a) || util.isNullOrUndefined(b))
    return false;
  // an identical 'prototype' property.
  if (a.prototype !== b.prototype) return false;
  //~~~I've managed to break Object.keys through screwy arguments passing.
  //   Converting to array solves the problem.
  if (isArguments(a)) {
    if (!isArguments(b)) {
      return false;
    }
    a = pSlice.call(a);
    b = pSlice.call(b);
    return _deepEqual(a, b);
  }
  try {
    var ka = shims.keys(a),
        kb = shims.keys(b),
        key, i;
  } catch (e) {//happens when one is a string literal and the other isn't
    return false;
  }
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length != kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] != kb[i])
      return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!_deepEqual(a[key], b[key])) return false;
  }
  return true;
}

// 8. The non-equivalence assertion tests for any deep inequality.
// assert.notDeepEqual(actual, expected, message_opt);

assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
  if (_deepEqual(actual, expected)) {
    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
  }
};

// 9. The strict equality assertion tests strict equality, as determined by ===.
// assert.strictEqual(actual, expected, message_opt);

assert.strictEqual = function strictEqual(actual, expected, message) {
  if (actual !== expected) {
    fail(actual, expected, message, '===', assert.strictEqual);
  }
};

// 10. The strict non-equality assertion tests for strict inequality, as
// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);

assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
  if (actual === expected) {
    fail(actual, expected, message, '!==', assert.notStrictEqual);
  }
};

function expectedException(actual, expected) {
  if (!actual || !expected) {
    return false;
  }

  if (Object.prototype.toString.call(expected) == '[object RegExp]') {
    return expected.test(actual);
  } else if (actual instanceof expected) {
    return true;
  } else if (expected.call({}, actual) === true) {
    return true;
  }

  return false;
}

function _throws(shouldThrow, block, expected, message) {
  var actual;

  if (util.isString(expected)) {
    message = expected;
    expected = null;
  }

  try {
    block();
  } catch (e) {
    actual = e;
  }

  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
            (message ? ' ' + message : '.');

  if (shouldThrow && !actual) {
    fail(actual, expected, 'Missing expected exception' + message);
  }

  if (!shouldThrow && expectedException(actual, expected)) {
    fail(actual, expected, 'Got unwanted exception' + message);
  }

  if ((shouldThrow && actual && expected &&
      !expectedException(actual, expected)) || (!shouldThrow && actual)) {
    throw actual;
  }
}

// 11. Expected to throw an error:
// assert.throws(block, Error_opt, message_opt);

assert.throws = function(block, /*optional*/error, /*optional*/message) {
  _throws.apply(this, [true].concat(pSlice.call(arguments)));
};

// EXTENSION! This is annoying to write outside this module.
assert.doesNotThrow = function(block, /*optional*/message) {
  _throws.apply(this, [false].concat(pSlice.call(arguments)));
};

assert.ifError = function(err) { if (err) {throw err;}};
},{"_shims":8,"util":14}],10:[function(require,module,exports){

// not implemented
// The reason for having an empty file and not throwing is to allow
// untraditional implementation of this module.

},{}],11:[function(require,module,exports){
var process=require("__browserify_process");// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var util = require('util');
var shims = require('_shims');

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.
var splitPathRe =
    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var splitPath = function(filename) {
  return splitPathRe.exec(filename).slice(1);
};

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (!util.isString(path)) {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(shims.filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = shims.substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(shims.filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(shims.filter(paths, function(p, index) {
    if (!util.isString(p)) {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function(path) {
  var result = splitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  }

  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
};


exports.basename = function(path, ext) {
  var f = splitPath(path)[2];
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPath(path)[3];
};

},{"__browserify_process":19,"_shims":8,"util":14}],12:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// Query String Utilities

var QueryString = exports;
var util = require('util');
var shims = require('_shims');
var Buffer = require('buffer').Buffer;

// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}


function charCode(c) {
  return c.charCodeAt(0);
}


// a safe fast alternative to decodeURIComponent
QueryString.unescapeBuffer = function(s, decodeSpaces) {
  var out = new Buffer(s.length);
  var state = 'CHAR'; // states: CHAR, HEX0, HEX1
  var n, m, hexchar;

  for (var inIndex = 0, outIndex = 0; inIndex <= s.length; inIndex++) {
    var c = s.charCodeAt(inIndex);
    switch (state) {
      case 'CHAR':
        switch (c) {
          case charCode('%'):
            n = 0;
            m = 0;
            state = 'HEX0';
            break;
          case charCode('+'):
            if (decodeSpaces) c = charCode(' ');
            // pass thru
          default:
            out[outIndex++] = c;
            break;
        }
        break;

      case 'HEX0':
        state = 'HEX1';
        hexchar = c;
        if (charCode('0') <= c && c <= charCode('9')) {
          n = c - charCode('0');
        } else if (charCode('a') <= c && c <= charCode('f')) {
          n = c - charCode('a') + 10;
        } else if (charCode('A') <= c && c <= charCode('F')) {
          n = c - charCode('A') + 10;
        } else {
          out[outIndex++] = charCode('%');
          out[outIndex++] = c;
          state = 'CHAR';
          break;
        }
        break;

      case 'HEX1':
        state = 'CHAR';
        if (charCode('0') <= c && c <= charCode('9')) {
          m = c - charCode('0');
        } else if (charCode('a') <= c && c <= charCode('f')) {
          m = c - charCode('a') + 10;
        } else if (charCode('A') <= c && c <= charCode('F')) {
          m = c - charCode('A') + 10;
        } else {
          out[outIndex++] = charCode('%');
          out[outIndex++] = hexchar;
          out[outIndex++] = c;
          break;
        }
        out[outIndex++] = 16 * n + m;
        break;
    }
  }

  // TODO support returning arbitrary buffers.

  return out.slice(0, outIndex - 1);
};


QueryString.unescape = function(s, decodeSpaces) {
  return QueryString.unescapeBuffer(s, decodeSpaces).toString();
};


QueryString.escape = function(str) {
  return encodeURIComponent(str);
};

var stringifyPrimitive = function(v) {
  if (util.isString(v))
    return v;
  if (util.isBoolean(v))
    return v ? 'true' : 'false';
  if (util.isNumber(v))
    return isFinite(v) ? v : '';
  return '';
};


QueryString.stringify = QueryString.encode = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (util.isNull(obj)) {
    obj = undefined;
  }

  if (util.isObject(obj)) {
    return shims.map(shims.keys(obj), function(k) {
      var ks = QueryString.escape(stringifyPrimitive(k)) + eq;
      if (util.isArray(obj[k])) {
        return shims.map(obj[k], function(v) {
          return ks + QueryString.escape(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + QueryString.escape(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return QueryString.escape(stringifyPrimitive(name)) + eq +
         QueryString.escape(stringifyPrimitive(obj));
};

// Parse a key=val string.
QueryString.parse = QueryString.decode = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (!util.isString(qs) || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && util.isNumber(options.maxKeys)) {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    try {
      k = decodeURIComponent(kstr);
      v = decodeURIComponent(vstr);
    } catch (e) {
      k = QueryString.unescape(kstr, true);
      v = QueryString.unescape(vstr, true);
    }

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (util.isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};
},{"_shims":8,"buffer":16,"util":14}],13:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var punycode = { encode : function (s) { return s } };
var util = require('util');
var shims = require('_shims');

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    querystring = require('querystring');

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && util.isObject(url) && url instanceof Url) return url;

  var u = new Url;
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
  if (!util.isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  var rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = shims.trim(rest);

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1)
      hostEnd = rest.length;

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' &&
        this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a puny coded representation of "domain".
      // It only converts the part of the domain name that
      // has non ASCII characters. I.e. it dosent matter if
      // you call it with a domain that already is in ASCII.
      var domainArray = this.hostname.split('.');
      var newOut = [];
      for (var i = 0; i < domainArray.length; ++i) {
        var s = domainArray[i];
        newOut.push(s.match(/[^A-Za-z0-9_-]/) ?
            'xn--' + punycode.encode(s) : s);
      }
      this.hostname = newOut.join('.');
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }


  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) this.pathname = rest;
  if (slashedProtocol[lowerProto] &&
      this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  //to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (util.isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function() {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ?
        this.hostname :
        '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query &&
      util.isObject(this.query) &&
      shims.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || (query && ('?' + query)) || '';

  if (protocol && shims.substr(protocol, -1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (this.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function(relative) {
  if (util.isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  shims.forEach(shims.keys(this), function(k) {
    result[k] = this[k];
  }, this);

  // hash is always overridden, no matter what.
  // even href="" will remove it.
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    shims.forEach(shims.keys(relative), function(k) {
      if (k !== 'protocol')
        result[k] = relative[k];
    });

    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] &&
        result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      shims.forEach(shims.keys(relative), function(k) {
        result[k] = relative[k];
      });
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (result.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;
      else srcPath.unshift(result.host);
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = (relative.host || relative.host === '') ?
                  relative.host : result.host;
    result.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!util.isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especialy happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = result.host && result.host.indexOf('@') > 0 ?
                       result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    //to support http.request
    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') +
                    (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null;
    //to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (result.host || relative.host) && (last === '.' || last === '..') ||
      last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last == '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (shims.substr(srcPath.join('/'), -1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especialy happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = result.host && result.host.indexOf('@') > 0 ?
                     result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  }

  //to support request.http
  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') +
                  (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function() {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) this.hostname = host;
};
},{"_shims":8,"querystring":12,"util":14}],14:[function(require,module,exports){
var Buffer=require("__browserify_Buffer").Buffer;// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var shims = require('_shims');

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};

/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  shims.forEach(array, function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = shims.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = shims.getOwnPropertyNames(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }

  shims.forEach(keys, function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = shims.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }

  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (shims.indexOf(ctx.seen, desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = shims.reduce(output, function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return shims.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) && objectToString(e) === '[object Error]';
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

function isBuffer(arg) {
  return arg instanceof Buffer;
}
exports.isBuffer = isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = function(ctor, superCtor) {
  ctor.super_ = superCtor;
  ctor.prototype = shims.create(superCtor.prototype, {
    constructor: {
      value: ctor,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
};

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = shims.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

},{"__browserify_Buffer":18,"_shims":8}],15:[function(require,module,exports){
exports.readIEEE754 = function(buffer, offset, isBE, mLen, nBytes) {
  var e, m,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      nBits = -7,
      i = isBE ? 0 : (nBytes - 1),
      d = isBE ? 1 : -1,
      s = buffer[offset + i];

  i += d;

  e = s & ((1 << (-nBits)) - 1);
  s >>= (-nBits);
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);

  m = e & ((1 << (-nBits)) - 1);
  e >>= (-nBits);
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity);
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.writeIEEE754 = function(buffer, value, offset, isBE, mLen, nBytes) {
  var e, m, c,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),
      i = isBE ? (nBytes - 1) : 0,
      d = isBE ? -1 : 1,
      s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);

  e = (e << mLen) | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);

  buffer[offset + i - d] |= s * 128;
};

},{}],16:[function(require,module,exports){
var assert;
exports.Buffer = Buffer;
exports.SlowBuffer = Buffer;
Buffer.poolSize = 8192;
exports.INSPECT_MAX_BYTES = 50;

function stringtrim(str) {
  if (str.trim) return str.trim();
  return str.replace(/^\s+|\s+$/g, '');
}

function Buffer(subject, encoding, offset) {
  if(!assert) assert= require('assert');
  if (!(this instanceof Buffer)) {
    return new Buffer(subject, encoding, offset);
  }
  this.parent = this;
  this.offset = 0;

  // Work-around: node's base64 implementation
  // allows for non-padded strings while base64-js
  // does not..
  if (encoding == "base64" && typeof subject == "string") {
    subject = stringtrim(subject);
    while (subject.length % 4 != 0) {
      subject = subject + "="; 
    }
  }

  var type;

  // Are we slicing?
  if (typeof offset === 'number') {
    this.length = coerce(encoding);
    // slicing works, with limitations (no parent tracking/update)
    // check https://github.com/toots/buffer-browserify/issues/19
    for (var i = 0; i < this.length; i++) {
        this[i] = subject.get(i+offset);
    }
  } else {
    // Find the length
    switch (type = typeof subject) {
      case 'number':
        this.length = coerce(subject);
        break;

      case 'string':
        this.length = Buffer.byteLength(subject, encoding);
        break;

      case 'object': // Assume object is an array
        this.length = coerce(subject.length);
        break;

      default:
        throw new Error('First argument needs to be a number, ' +
                        'array or string.');
    }

    // Treat array-ish objects as a byte array.
    if (isArrayIsh(subject)) {
      for (var i = 0; i < this.length; i++) {
        if (subject instanceof Buffer) {
          this[i] = subject.readUInt8(i);
        }
        else {
          this[i] = subject[i];
        }
      }
    } else if (type == 'string') {
      // We are a string
      this.length = this.write(subject, 0, encoding);
    } else if (type === 'number') {
      for (var i = 0; i < this.length; i++) {
        this[i] = 0;
      }
    }
  }
}

Buffer.prototype.get = function get(i) {
  if (i < 0 || i >= this.length) throw new Error('oob');
  return this[i];
};

Buffer.prototype.set = function set(i, v) {
  if (i < 0 || i >= this.length) throw new Error('oob');
  return this[i] = v;
};

Buffer.byteLength = function (str, encoding) {
  switch (encoding || "utf8") {
    case 'hex':
      return str.length / 2;

    case 'utf8':
    case 'utf-8':
      return utf8ToBytes(str).length;

    case 'ascii':
    case 'binary':
      return str.length;

    case 'base64':
      return base64ToBytes(str).length;

    default:
      throw new Error('Unknown encoding');
  }
};

Buffer.prototype.utf8Write = function (string, offset, length) {
  var bytes, pos;
  return Buffer._charsWritten =  blitBuffer(utf8ToBytes(string), this, offset, length);
};

Buffer.prototype.asciiWrite = function (string, offset, length) {
  var bytes, pos;
  return Buffer._charsWritten =  blitBuffer(asciiToBytes(string), this, offset, length);
};

Buffer.prototype.binaryWrite = Buffer.prototype.asciiWrite;

Buffer.prototype.base64Write = function (string, offset, length) {
  var bytes, pos;
  return Buffer._charsWritten = blitBuffer(base64ToBytes(string), this, offset, length);
};

Buffer.prototype.base64Slice = function (start, end) {
  var bytes = Array.prototype.slice.apply(this, arguments)
  return require("base64-js").fromByteArray(bytes);
};

Buffer.prototype.utf8Slice = function () {
  var bytes = Array.prototype.slice.apply(this, arguments);
  var res = "";
  var tmp = "";
  var i = 0;
  while (i < bytes.length) {
    if (bytes[i] <= 0x7F) {
      res += decodeUtf8Char(tmp) + String.fromCharCode(bytes[i]);
      tmp = "";
    } else
      tmp += "%" + bytes[i].toString(16);

    i++;
  }

  return res + decodeUtf8Char(tmp);
}

Buffer.prototype.asciiSlice = function () {
  var bytes = Array.prototype.slice.apply(this, arguments);
  var ret = "";
  for (var i = 0; i < bytes.length; i++)
    ret += String.fromCharCode(bytes[i]);
  return ret;
}

Buffer.prototype.binarySlice = Buffer.prototype.asciiSlice;

Buffer.prototype.inspect = function() {
  var out = [],
      len = this.length;
  for (var i = 0; i < len; i++) {
    out[i] = toHex(this[i]);
    if (i == exports.INSPECT_MAX_BYTES) {
      out[i + 1] = '...';
      break;
    }
  }
  return '<Buffer ' + out.join(' ') + '>';
};


Buffer.prototype.hexSlice = function(start, end) {
  var len = this.length;

  if (!start || start < 0) start = 0;
  if (!end || end < 0 || end > len) end = len;

  var out = '';
  for (var i = start; i < end; i++) {
    out += toHex(this[i]);
  }
  return out;
};


Buffer.prototype.toString = function(encoding, start, end) {
  encoding = String(encoding || 'utf8').toLowerCase();
  start = +start || 0;
  if (typeof end == 'undefined') end = this.length;

  // Fastpath empty strings
  if (+end == start) {
    return '';
  }

  switch (encoding) {
    case 'hex':
      return this.hexSlice(start, end);

    case 'utf8':
    case 'utf-8':
      return this.utf8Slice(start, end);

    case 'ascii':
      return this.asciiSlice(start, end);

    case 'binary':
      return this.binarySlice(start, end);

    case 'base64':
      return this.base64Slice(start, end);

    case 'ucs2':
    case 'ucs-2':
      return this.ucs2Slice(start, end);

    default:
      throw new Error('Unknown encoding');
  }
};


Buffer.prototype.hexWrite = function(string, offset, length) {
  offset = +offset || 0;
  var remaining = this.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = +length;
    if (length > remaining) {
      length = remaining;
    }
  }

  // must be an even number of digits
  var strLen = string.length;
  if (strLen % 2) {
    throw new Error('Invalid hex string');
  }
  if (length > strLen / 2) {
    length = strLen / 2;
  }
  for (var i = 0; i < length; i++) {
    var byte = parseInt(string.substr(i * 2, 2), 16);
    if (isNaN(byte)) throw new Error('Invalid hex string');
    this[offset + i] = byte;
  }
  Buffer._charsWritten = i * 2;
  return i;
};


Buffer.prototype.write = function(string, offset, length, encoding) {
  // Support both (string, offset, length, encoding)
  // and the legacy (string, encoding, offset, length)
  if (isFinite(offset)) {
    if (!isFinite(length)) {
      encoding = length;
      length = undefined;
    }
  } else {  // legacy
    var swap = encoding;
    encoding = offset;
    offset = length;
    length = swap;
  }

  offset = +offset || 0;
  var remaining = this.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = +length;
    if (length > remaining) {
      length = remaining;
    }
  }
  encoding = String(encoding || 'utf8').toLowerCase();

  switch (encoding) {
    case 'hex':
      return this.hexWrite(string, offset, length);

    case 'utf8':
    case 'utf-8':
      return this.utf8Write(string, offset, length);

    case 'ascii':
      return this.asciiWrite(string, offset, length);

    case 'binary':
      return this.binaryWrite(string, offset, length);

    case 'base64':
      return this.base64Write(string, offset, length);

    case 'ucs2':
    case 'ucs-2':
      return this.ucs2Write(string, offset, length);

    default:
      throw new Error('Unknown encoding');
  }
};

// slice(start, end)
function clamp(index, len, defaultValue) {
  if (typeof index !== 'number') return defaultValue;
  index = ~~index;  // Coerce to integer.
  if (index >= len) return len;
  if (index >= 0) return index;
  index += len;
  if (index >= 0) return index;
  return 0;
}

Buffer.prototype.slice = function(start, end) {
  var len = this.length;
  start = clamp(start, len, 0);
  end = clamp(end, len, len);
  return new Buffer(this, end - start, +start);
};

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function(target, target_start, start, end) {
  var source = this;
  start || (start = 0);
  if (end === undefined || isNaN(end)) {
    end = this.length;
  }
  target_start || (target_start = 0);

  if (end < start) throw new Error('sourceEnd < sourceStart');

  // Copy 0 bytes; we're done
  if (end === start) return 0;
  if (target.length == 0 || source.length == 0) return 0;

  if (target_start < 0 || target_start >= target.length) {
    throw new Error('targetStart out of bounds');
  }

  if (start < 0 || start >= source.length) {
    throw new Error('sourceStart out of bounds');
  }

  if (end < 0 || end > source.length) {
    throw new Error('sourceEnd out of bounds');
  }

  // Are we oob?
  if (end > this.length) {
    end = this.length;
  }

  if (target.length - target_start < end - start) {
    end = target.length - target_start + start;
  }

  var temp = [];
  for (var i=start; i<end; i++) {
    assert.ok(typeof this[i] !== 'undefined', "copying undefined buffer bytes!");
    temp.push(this[i]);
  }

  for (var i=target_start; i<target_start+temp.length; i++) {
    target[i] = temp[i-target_start];
  }
};

// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function fill(value, start, end) {
  value || (value = 0);
  start || (start = 0);
  end || (end = this.length);

  if (typeof value === 'string') {
    value = value.charCodeAt(0);
  }
  if (!(typeof value === 'number') || isNaN(value)) {
    throw new Error('value is not a number');
  }

  if (end < start) throw new Error('end < start');

  // Fill 0 bytes; we're done
  if (end === start) return 0;
  if (this.length == 0) return 0;

  if (start < 0 || start >= this.length) {
    throw new Error('start out of bounds');
  }

  if (end < 0 || end > this.length) {
    throw new Error('end out of bounds');
  }

  for (var i = start; i < end; i++) {
    this[i] = value;
  }
}

// Static methods
Buffer.isBuffer = function isBuffer(b) {
  return b instanceof Buffer || b instanceof Buffer;
};

Buffer.concat = function (list, totalLength) {
  if (!isArray(list)) {
    throw new Error("Usage: Buffer.concat(list, [totalLength])\n \
      list should be an Array.");
  }

  if (list.length === 0) {
    return new Buffer(0);
  } else if (list.length === 1) {
    return list[0];
  }

  if (typeof totalLength !== 'number') {
    totalLength = 0;
    for (var i = 0; i < list.length; i++) {
      var buf = list[i];
      totalLength += buf.length;
    }
  }

  var buffer = new Buffer(totalLength);
  var pos = 0;
  for (var i = 0; i < list.length; i++) {
    var buf = list[i];
    buf.copy(buffer, pos);
    pos += buf.length;
  }
  return buffer;
};

Buffer.isEncoding = function(encoding) {
  switch ((encoding + '').toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
    case 'raw':
      return true;

    default:
      return false;
  }
};

// helpers

function coerce(length) {
  // Coerce length to a number (possibly NaN), round up
  // in case it's fractional (e.g. 123.456) then do a
  // double negate to coerce a NaN to 0. Easy, right?
  length = ~~Math.ceil(+length);
  return length < 0 ? 0 : length;
}

function isArray(subject) {
  return (Array.isArray ||
    function(subject){
      return {}.toString.apply(subject) == '[object Array]'
    })
    (subject)
}

function isArrayIsh(subject) {
  return isArray(subject) || Buffer.isBuffer(subject) ||
         subject && typeof subject === 'object' &&
         typeof subject.length === 'number';
}

function toHex(n) {
  if (n < 16) return '0' + n.toString(16);
  return n.toString(16);
}

function utf8ToBytes(str) {
  var byteArray = [];
  for (var i = 0; i < str.length; i++)
    if (str.charCodeAt(i) <= 0x7F)
      byteArray.push(str.charCodeAt(i));
    else {
      var h = encodeURIComponent(str.charAt(i)).substr(1).split('%');
      for (var j = 0; j < h.length; j++)
        byteArray.push(parseInt(h[j], 16));
    }

  return byteArray;
}

function asciiToBytes(str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++ )
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push( str.charCodeAt(i) & 0xFF );

  return byteArray;
}

function base64ToBytes(str) {
  return require("base64-js").toByteArray(str);
}

function blitBuffer(src, dst, offset, length) {
  var pos, i = 0;
  while (i < length) {
    if ((i+offset >= dst.length) || (i >= src.length))
      break;

    dst[i + offset] = src[i];
    i++;
  }
  return i;
}

function decodeUtf8Char(str) {
  try {
    return decodeURIComponent(str);
  } catch (err) {
    return String.fromCharCode(0xFFFD); // UTF 8 invalid char
  }
}

// read/write bit-twiddling

Buffer.prototype.readUInt8 = function(offset, noAssert) {
  var buffer = this;

  if (!noAssert) {
    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (offset >= buffer.length) return;

  return buffer[offset];
};

function readUInt16(buffer, offset, isBigEndian, noAssert) {
  var val = 0;


  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (offset >= buffer.length) return 0;

  if (isBigEndian) {
    val = buffer[offset] << 8;
    if (offset + 1 < buffer.length) {
      val |= buffer[offset + 1];
    }
  } else {
    val = buffer[offset];
    if (offset + 1 < buffer.length) {
      val |= buffer[offset + 1] << 8;
    }
  }

  return val;
}

Buffer.prototype.readUInt16LE = function(offset, noAssert) {
  return readUInt16(this, offset, false, noAssert);
};

Buffer.prototype.readUInt16BE = function(offset, noAssert) {
  return readUInt16(this, offset, true, noAssert);
};

function readUInt32(buffer, offset, isBigEndian, noAssert) {
  var val = 0;

  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (offset >= buffer.length) return 0;

  if (isBigEndian) {
    if (offset + 1 < buffer.length)
      val = buffer[offset + 1] << 16;
    if (offset + 2 < buffer.length)
      val |= buffer[offset + 2] << 8;
    if (offset + 3 < buffer.length)
      val |= buffer[offset + 3];
    val = val + (buffer[offset] << 24 >>> 0);
  } else {
    if (offset + 2 < buffer.length)
      val = buffer[offset + 2] << 16;
    if (offset + 1 < buffer.length)
      val |= buffer[offset + 1] << 8;
    val |= buffer[offset];
    if (offset + 3 < buffer.length)
      val = val + (buffer[offset + 3] << 24 >>> 0);
  }

  return val;
}

Buffer.prototype.readUInt32LE = function(offset, noAssert) {
  return readUInt32(this, offset, false, noAssert);
};

Buffer.prototype.readUInt32BE = function(offset, noAssert) {
  return readUInt32(this, offset, true, noAssert);
};


/*
 * Signed integer types, yay team! A reminder on how two's complement actually
 * works. The first bit is the signed bit, i.e. tells us whether or not the
 * number should be positive or negative. If the two's complement value is
 * positive, then we're done, as it's equivalent to the unsigned representation.
 *
 * Now if the number is positive, you're pretty much done, you can just leverage
 * the unsigned translations and return those. Unfortunately, negative numbers
 * aren't quite that straightforward.
 *
 * At first glance, one might be inclined to use the traditional formula to
 * translate binary numbers between the positive and negative values in two's
 * complement. (Though it doesn't quite work for the most negative value)
 * Mainly:
 *  - invert all the bits
 *  - add one to the result
 *
 * Of course, this doesn't quite work in Javascript. Take for example the value
 * of -128. This could be represented in 16 bits (big-endian) as 0xff80. But of
 * course, Javascript will do the following:
 *
 * > ~0xff80
 * -65409
 *
 * Whoh there, Javascript, that's not quite right. But wait, according to
 * Javascript that's perfectly correct. When Javascript ends up seeing the
 * constant 0xff80, it has no notion that it is actually a signed number. It
 * assumes that we've input the unsigned value 0xff80. Thus, when it does the
 * binary negation, it casts it into a signed value, (positive 0xff80). Then
 * when you perform binary negation on that, it turns it into a negative number.
 *
 * Instead, we're going to have to use the following general formula, that works
 * in a rather Javascript friendly way. I'm glad we don't support this kind of
 * weird numbering scheme in the kernel.
 *
 * (BIT-MAX - (unsigned)val + 1) * -1
 *
 * The astute observer, may think that this doesn't make sense for 8-bit numbers
 * (really it isn't necessary for them). However, when you get 16-bit numbers,
 * you do. Let's go back to our prior example and see how this will look:
 *
 * (0xffff - 0xff80 + 1) * -1
 * (0x007f + 1) * -1
 * (0x0080) * -1
 */
Buffer.prototype.readInt8 = function(offset, noAssert) {
  var buffer = this;
  var neg;

  if (!noAssert) {
    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (offset >= buffer.length) return;

  neg = buffer[offset] & 0x80;
  if (!neg) {
    return (buffer[offset]);
  }

  return ((0xff - buffer[offset] + 1) * -1);
};

function readInt16(buffer, offset, isBigEndian, noAssert) {
  var neg, val;

  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'Trying to read beyond buffer length');
  }

  val = readUInt16(buffer, offset, isBigEndian, noAssert);
  neg = val & 0x8000;
  if (!neg) {
    return val;
  }

  return (0xffff - val + 1) * -1;
}

Buffer.prototype.readInt16LE = function(offset, noAssert) {
  return readInt16(this, offset, false, noAssert);
};

Buffer.prototype.readInt16BE = function(offset, noAssert) {
  return readInt16(this, offset, true, noAssert);
};

function readInt32(buffer, offset, isBigEndian, noAssert) {
  var neg, val;

  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to read beyond buffer length');
  }

  val = readUInt32(buffer, offset, isBigEndian, noAssert);
  neg = val & 0x80000000;
  if (!neg) {
    return (val);
  }

  return (0xffffffff - val + 1) * -1;
}

Buffer.prototype.readInt32LE = function(offset, noAssert) {
  return readInt32(this, offset, false, noAssert);
};

Buffer.prototype.readInt32BE = function(offset, noAssert) {
  return readInt32(this, offset, true, noAssert);
};

function readFloat(buffer, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset + 3 < buffer.length,
        'Trying to read beyond buffer length');
  }

  return require('./buffer_ieee754').readIEEE754(buffer, offset, isBigEndian,
      23, 4);
}

Buffer.prototype.readFloatLE = function(offset, noAssert) {
  return readFloat(this, offset, false, noAssert);
};

Buffer.prototype.readFloatBE = function(offset, noAssert) {
  return readFloat(this, offset, true, noAssert);
};

function readDouble(buffer, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset + 7 < buffer.length,
        'Trying to read beyond buffer length');
  }

  return require('./buffer_ieee754').readIEEE754(buffer, offset, isBigEndian,
      52, 8);
}

Buffer.prototype.readDoubleLE = function(offset, noAssert) {
  return readDouble(this, offset, false, noAssert);
};

Buffer.prototype.readDoubleBE = function(offset, noAssert) {
  return readDouble(this, offset, true, noAssert);
};


/*
 * We have to make sure that the value is a valid integer. This means that it is
 * non-negative. It has no fractional component and that it does not exceed the
 * maximum allowed value.
 *
 *      value           The number to check for validity
 *
 *      max             The maximum value
 */
function verifuint(value, max) {
  assert.ok(typeof (value) == 'number',
      'cannot write a non-number as a number');

  assert.ok(value >= 0,
      'specified a negative value for writing an unsigned value');

  assert.ok(value <= max, 'value is larger than maximum value for type');

  assert.ok(Math.floor(value) === value, 'value has a fractional component');
}

Buffer.prototype.writeUInt8 = function(value, offset, noAssert) {
  var buffer = this;

  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'trying to write beyond buffer length');

    verifuint(value, 0xff);
  }

  if (offset < buffer.length) {
    buffer[offset] = value;
  }
};

function writeUInt16(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'trying to write beyond buffer length');

    verifuint(value, 0xffff);
  }

  for (var i = 0; i < Math.min(buffer.length - offset, 2); i++) {
    buffer[offset + i] =
        (value & (0xff << (8 * (isBigEndian ? 1 - i : i)))) >>>
            (isBigEndian ? 1 - i : i) * 8;
  }

}

Buffer.prototype.writeUInt16LE = function(value, offset, noAssert) {
  writeUInt16(this, value, offset, false, noAssert);
};

Buffer.prototype.writeUInt16BE = function(value, offset, noAssert) {
  writeUInt16(this, value, offset, true, noAssert);
};

function writeUInt32(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'trying to write beyond buffer length');

    verifuint(value, 0xffffffff);
  }

  for (var i = 0; i < Math.min(buffer.length - offset, 4); i++) {
    buffer[offset + i] =
        (value >>> (isBigEndian ? 3 - i : i) * 8) & 0xff;
  }
}

Buffer.prototype.writeUInt32LE = function(value, offset, noAssert) {
  writeUInt32(this, value, offset, false, noAssert);
};

Buffer.prototype.writeUInt32BE = function(value, offset, noAssert) {
  writeUInt32(this, value, offset, true, noAssert);
};


/*
 * We now move onto our friends in the signed number category. Unlike unsigned
 * numbers, we're going to have to worry a bit more about how we put values into
 * arrays. Since we are only worrying about signed 32-bit values, we're in
 * slightly better shape. Unfortunately, we really can't do our favorite binary
 * & in this system. It really seems to do the wrong thing. For example:
 *
 * > -32 & 0xff
 * 224
 *
 * What's happening above is really: 0xe0 & 0xff = 0xe0. However, the results of
 * this aren't treated as a signed number. Ultimately a bad thing.
 *
 * What we're going to want to do is basically create the unsigned equivalent of
 * our representation and pass that off to the wuint* functions. To do that
 * we're going to do the following:
 *
 *  - if the value is positive
 *      we can pass it directly off to the equivalent wuint
 *  - if the value is negative
 *      we do the following computation:
 *         mb + val + 1, where
 *         mb   is the maximum unsigned value in that byte size
 *         val  is the Javascript negative integer
 *
 *
 * As a concrete value, take -128. In signed 16 bits this would be 0xff80. If
 * you do out the computations:
 *
 * 0xffff - 128 + 1
 * 0xffff - 127
 * 0xff80
 *
 * You can then encode this value as the signed version. This is really rather
 * hacky, but it should work and get the job done which is our goal here.
 */

/*
 * A series of checks to make sure we actually have a signed 32-bit number
 */
function verifsint(value, max, min) {
  assert.ok(typeof (value) == 'number',
      'cannot write a non-number as a number');

  assert.ok(value <= max, 'value larger than maximum allowed value');

  assert.ok(value >= min, 'value smaller than minimum allowed value');

  assert.ok(Math.floor(value) === value, 'value has a fractional component');
}

function verifIEEE754(value, max, min) {
  assert.ok(typeof (value) == 'number',
      'cannot write a non-number as a number');

  assert.ok(value <= max, 'value larger than maximum allowed value');

  assert.ok(value >= min, 'value smaller than minimum allowed value');
}

Buffer.prototype.writeInt8 = function(value, offset, noAssert) {
  var buffer = this;

  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'Trying to write beyond buffer length');

    verifsint(value, 0x7f, -0x80);
  }

  if (value >= 0) {
    buffer.writeUInt8(value, offset, noAssert);
  } else {
    buffer.writeUInt8(0xff + value + 1, offset, noAssert);
  }
};

function writeInt16(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'Trying to write beyond buffer length');

    verifsint(value, 0x7fff, -0x8000);
  }

  if (value >= 0) {
    writeUInt16(buffer, value, offset, isBigEndian, noAssert);
  } else {
    writeUInt16(buffer, 0xffff + value + 1, offset, isBigEndian, noAssert);
  }
}

Buffer.prototype.writeInt16LE = function(value, offset, noAssert) {
  writeInt16(this, value, offset, false, noAssert);
};

Buffer.prototype.writeInt16BE = function(value, offset, noAssert) {
  writeInt16(this, value, offset, true, noAssert);
};

function writeInt32(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to write beyond buffer length');

    verifsint(value, 0x7fffffff, -0x80000000);
  }

  if (value >= 0) {
    writeUInt32(buffer, value, offset, isBigEndian, noAssert);
  } else {
    writeUInt32(buffer, 0xffffffff + value + 1, offset, isBigEndian, noAssert);
  }
}

Buffer.prototype.writeInt32LE = function(value, offset, noAssert) {
  writeInt32(this, value, offset, false, noAssert);
};

Buffer.prototype.writeInt32BE = function(value, offset, noAssert) {
  writeInt32(this, value, offset, true, noAssert);
};

function writeFloat(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to write beyond buffer length');

    verifIEEE754(value, 3.4028234663852886e+38, -3.4028234663852886e+38);
  }

  require('./buffer_ieee754').writeIEEE754(buffer, value, offset, isBigEndian,
      23, 4);
}

Buffer.prototype.writeFloatLE = function(value, offset, noAssert) {
  writeFloat(this, value, offset, false, noAssert);
};

Buffer.prototype.writeFloatBE = function(value, offset, noAssert) {
  writeFloat(this, value, offset, true, noAssert);
};

function writeDouble(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 7 < buffer.length,
        'Trying to write beyond buffer length');

    verifIEEE754(value, 1.7976931348623157E+308, -1.7976931348623157E+308);
  }

  require('./buffer_ieee754').writeIEEE754(buffer, value, offset, isBigEndian,
      52, 8);
}

Buffer.prototype.writeDoubleLE = function(value, offset, noAssert) {
  writeDouble(this, value, offset, false, noAssert);
};

Buffer.prototype.writeDoubleBE = function(value, offset, noAssert) {
  writeDouble(this, value, offset, true, noAssert);
};

},{"./buffer_ieee754":15,"assert":9,"base64-js":17}],17:[function(require,module,exports){
(function (exports) {
	'use strict';

	var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

	function b64ToByteArray(b64) {
		var i, j, l, tmp, placeHolders, arr;
	
		if (b64.length % 4 > 0) {
			throw 'Invalid string. Length must be a multiple of 4';
		}

		// the number of equal signs (place holders)
		// if there are two placeholders, than the two characters before it
		// represent one byte
		// if there is only one, then the three characters before it represent 2 bytes
		// this is just a cheap hack to not do indexOf twice
		placeHolders = b64.indexOf('=');
		placeHolders = placeHolders > 0 ? b64.length - placeHolders : 0;

		// base64 is 4/3 + up to two characters of the original data
		arr = [];//new Uint8Array(b64.length * 3 / 4 - placeHolders);

		// if there are placeholders, only get up to the last complete 4 chars
		l = placeHolders > 0 ? b64.length - 4 : b64.length;

		for (i = 0, j = 0; i < l; i += 4, j += 3) {
			tmp = (lookup.indexOf(b64[i]) << 18) | (lookup.indexOf(b64[i + 1]) << 12) | (lookup.indexOf(b64[i + 2]) << 6) | lookup.indexOf(b64[i + 3]);
			arr.push((tmp & 0xFF0000) >> 16);
			arr.push((tmp & 0xFF00) >> 8);
			arr.push(tmp & 0xFF);
		}

		if (placeHolders === 2) {
			tmp = (lookup.indexOf(b64[i]) << 2) | (lookup.indexOf(b64[i + 1]) >> 4);
			arr.push(tmp & 0xFF);
		} else if (placeHolders === 1) {
			tmp = (lookup.indexOf(b64[i]) << 10) | (lookup.indexOf(b64[i + 1]) << 4) | (lookup.indexOf(b64[i + 2]) >> 2);
			arr.push((tmp >> 8) & 0xFF);
			arr.push(tmp & 0xFF);
		}

		return arr;
	}

	function uint8ToBase64(uint8) {
		var i,
			extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
			output = "",
			temp, length;

		function tripletToBase64 (num) {
			return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
		};

		// go through the array every three bytes, we'll deal with trailing stuff later
		for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
			temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);
			output += tripletToBase64(temp);
		}

		// pad the end with zeros, but make sure to not forget the extra bytes
		switch (extraBytes) {
			case 1:
				temp = uint8[uint8.length - 1];
				output += lookup[temp >> 2];
				output += lookup[(temp << 4) & 0x3F];
				output += '==';
				break;
			case 2:
				temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1]);
				output += lookup[temp >> 10];
				output += lookup[(temp >> 4) & 0x3F];
				output += lookup[(temp << 2) & 0x3F];
				output += '=';
				break;
		}

		return output;
	}

	module.exports.toByteArray = b64ToByteArray;
	module.exports.fromByteArray = uint8ToBase64;
}());

},{}],18:[function(require,module,exports){
require=(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
exports.readIEEE754 = function(buffer, offset, isBE, mLen, nBytes) {
  var e, m,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      nBits = -7,
      i = isBE ? 0 : (nBytes - 1),
      d = isBE ? 1 : -1,
      s = buffer[offset + i];

  i += d;

  e = s & ((1 << (-nBits)) - 1);
  s >>= (-nBits);
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);

  m = e & ((1 << (-nBits)) - 1);
  e >>= (-nBits);
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity);
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.writeIEEE754 = function(buffer, value, offset, isBE, mLen, nBytes) {
  var e, m, c,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),
      i = isBE ? (nBytes - 1) : 0,
      d = isBE ? -1 : 1,
      s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);

  e = (e << mLen) | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);

  buffer[offset + i - d] |= s * 128;
};

},{}],"q9TxCC":[function(require,module,exports){
var assert;
exports.Buffer = Buffer;
exports.SlowBuffer = Buffer;
Buffer.poolSize = 8192;
exports.INSPECT_MAX_BYTES = 50;

function stringtrim(str) {
  if (str.trim) return str.trim();
  return str.replace(/^\s+|\s+$/g, '');
}

function Buffer(subject, encoding, offset) {
  if(!assert) assert= require('assert');
  if (!(this instanceof Buffer)) {
    return new Buffer(subject, encoding, offset);
  }
  this.parent = this;
  this.offset = 0;

  // Work-around: node's base64 implementation
  // allows for non-padded strings while base64-js
  // does not..
  if (encoding == "base64" && typeof subject == "string") {
    subject = stringtrim(subject);
    while (subject.length % 4 != 0) {
      subject = subject + "="; 
    }
  }

  var type;

  // Are we slicing?
  if (typeof offset === 'number') {
    this.length = coerce(encoding);
    // slicing works, with limitations (no parent tracking/update)
    // check https://github.com/toots/buffer-browserify/issues/19
    for (var i = 0; i < this.length; i++) {
        this[i] = subject.get(i+offset);
    }
  } else {
    // Find the length
    switch (type = typeof subject) {
      case 'number':
        this.length = coerce(subject);
        break;

      case 'string':
        this.length = Buffer.byteLength(subject, encoding);
        break;

      case 'object': // Assume object is an array
        this.length = coerce(subject.length);
        break;

      default:
        throw new Error('First argument needs to be a number, ' +
                        'array or string.');
    }

    // Treat array-ish objects as a byte array.
    if (isArrayIsh(subject)) {
      for (var i = 0; i < this.length; i++) {
        if (subject instanceof Buffer) {
          this[i] = subject.readUInt8(i);
        }
        else {
          this[i] = subject[i];
        }
      }
    } else if (type == 'string') {
      // We are a string
      this.length = this.write(subject, 0, encoding);
    } else if (type === 'number') {
      for (var i = 0; i < this.length; i++) {
        this[i] = 0;
      }
    }
  }
}

Buffer.prototype.get = function get(i) {
  if (i < 0 || i >= this.length) throw new Error('oob');
  return this[i];
};

Buffer.prototype.set = function set(i, v) {
  if (i < 0 || i >= this.length) throw new Error('oob');
  return this[i] = v;
};

Buffer.byteLength = function (str, encoding) {
  switch (encoding || "utf8") {
    case 'hex':
      return str.length / 2;

    case 'utf8':
    case 'utf-8':
      return utf8ToBytes(str).length;

    case 'ascii':
    case 'binary':
      return str.length;

    case 'base64':
      return base64ToBytes(str).length;

    default:
      throw new Error('Unknown encoding');
  }
};

Buffer.prototype.utf8Write = function (string, offset, length) {
  var bytes, pos;
  return Buffer._charsWritten =  blitBuffer(utf8ToBytes(string), this, offset, length);
};

Buffer.prototype.asciiWrite = function (string, offset, length) {
  var bytes, pos;
  return Buffer._charsWritten =  blitBuffer(asciiToBytes(string), this, offset, length);
};

Buffer.prototype.binaryWrite = Buffer.prototype.asciiWrite;

Buffer.prototype.base64Write = function (string, offset, length) {
  var bytes, pos;
  return Buffer._charsWritten = blitBuffer(base64ToBytes(string), this, offset, length);
};

Buffer.prototype.base64Slice = function (start, end) {
  var bytes = Array.prototype.slice.apply(this, arguments)
  return require("base64-js").fromByteArray(bytes);
};

Buffer.prototype.utf8Slice = function () {
  var bytes = Array.prototype.slice.apply(this, arguments);
  var res = "";
  var tmp = "";
  var i = 0;
  while (i < bytes.length) {
    if (bytes[i] <= 0x7F) {
      res += decodeUtf8Char(tmp) + String.fromCharCode(bytes[i]);
      tmp = "";
    } else
      tmp += "%" + bytes[i].toString(16);

    i++;
  }

  return res + decodeUtf8Char(tmp);
}

Buffer.prototype.asciiSlice = function () {
  var bytes = Array.prototype.slice.apply(this, arguments);
  var ret = "";
  for (var i = 0; i < bytes.length; i++)
    ret += String.fromCharCode(bytes[i]);
  return ret;
}

Buffer.prototype.binarySlice = Buffer.prototype.asciiSlice;

Buffer.prototype.inspect = function() {
  var out = [],
      len = this.length;
  for (var i = 0; i < len; i++) {
    out[i] = toHex(this[i]);
    if (i == exports.INSPECT_MAX_BYTES) {
      out[i + 1] = '...';
      break;
    }
  }
  return '<Buffer ' + out.join(' ') + '>';
};


Buffer.prototype.hexSlice = function(start, end) {
  var len = this.length;

  if (!start || start < 0) start = 0;
  if (!end || end < 0 || end > len) end = len;

  var out = '';
  for (var i = start; i < end; i++) {
    out += toHex(this[i]);
  }
  return out;
};


Buffer.prototype.toString = function(encoding, start, end) {
  encoding = String(encoding || 'utf8').toLowerCase();
  start = +start || 0;
  if (typeof end == 'undefined') end = this.length;

  // Fastpath empty strings
  if (+end == start) {
    return '';
  }

  switch (encoding) {
    case 'hex':
      return this.hexSlice(start, end);

    case 'utf8':
    case 'utf-8':
      return this.utf8Slice(start, end);

    case 'ascii':
      return this.asciiSlice(start, end);

    case 'binary':
      return this.binarySlice(start, end);

    case 'base64':
      return this.base64Slice(start, end);

    case 'ucs2':
    case 'ucs-2':
      return this.ucs2Slice(start, end);

    default:
      throw new Error('Unknown encoding');
  }
};


Buffer.prototype.hexWrite = function(string, offset, length) {
  offset = +offset || 0;
  var remaining = this.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = +length;
    if (length > remaining) {
      length = remaining;
    }
  }

  // must be an even number of digits
  var strLen = string.length;
  if (strLen % 2) {
    throw new Error('Invalid hex string');
  }
  if (length > strLen / 2) {
    length = strLen / 2;
  }
  for (var i = 0; i < length; i++) {
    var byte = parseInt(string.substr(i * 2, 2), 16);
    if (isNaN(byte)) throw new Error('Invalid hex string');
    this[offset + i] = byte;
  }
  Buffer._charsWritten = i * 2;
  return i;
};


Buffer.prototype.write = function(string, offset, length, encoding) {
  // Support both (string, offset, length, encoding)
  // and the legacy (string, encoding, offset, length)
  if (isFinite(offset)) {
    if (!isFinite(length)) {
      encoding = length;
      length = undefined;
    }
  } else {  // legacy
    var swap = encoding;
    encoding = offset;
    offset = length;
    length = swap;
  }

  offset = +offset || 0;
  var remaining = this.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = +length;
    if (length > remaining) {
      length = remaining;
    }
  }
  encoding = String(encoding || 'utf8').toLowerCase();

  switch (encoding) {
    case 'hex':
      return this.hexWrite(string, offset, length);

    case 'utf8':
    case 'utf-8':
      return this.utf8Write(string, offset, length);

    case 'ascii':
      return this.asciiWrite(string, offset, length);

    case 'binary':
      return this.binaryWrite(string, offset, length);

    case 'base64':
      return this.base64Write(string, offset, length);

    case 'ucs2':
    case 'ucs-2':
      return this.ucs2Write(string, offset, length);

    default:
      throw new Error('Unknown encoding');
  }
};

// slice(start, end)
function clamp(index, len, defaultValue) {
  if (typeof index !== 'number') return defaultValue;
  index = ~~index;  // Coerce to integer.
  if (index >= len) return len;
  if (index >= 0) return index;
  index += len;
  if (index >= 0) return index;
  return 0;
}

Buffer.prototype.slice = function(start, end) {
  var len = this.length;
  start = clamp(start, len, 0);
  end = clamp(end, len, len);
  return new Buffer(this, end - start, +start);
};

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function(target, target_start, start, end) {
  var source = this;
  start || (start = 0);
  if (end === undefined || isNaN(end)) {
    end = this.length;
  }
  target_start || (target_start = 0);

  if (end < start) throw new Error('sourceEnd < sourceStart');

  // Copy 0 bytes; we're done
  if (end === start) return 0;
  if (target.length == 0 || source.length == 0) return 0;

  if (target_start < 0 || target_start >= target.length) {
    throw new Error('targetStart out of bounds');
  }

  if (start < 0 || start >= source.length) {
    throw new Error('sourceStart out of bounds');
  }

  if (end < 0 || end > source.length) {
    throw new Error('sourceEnd out of bounds');
  }

  // Are we oob?
  if (end > this.length) {
    end = this.length;
  }

  if (target.length - target_start < end - start) {
    end = target.length - target_start + start;
  }

  var temp = [];
  for (var i=start; i<end; i++) {
    assert.ok(typeof this[i] !== 'undefined', "copying undefined buffer bytes!");
    temp.push(this[i]);
  }

  for (var i=target_start; i<target_start+temp.length; i++) {
    target[i] = temp[i-target_start];
  }
};

// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function fill(value, start, end) {
  value || (value = 0);
  start || (start = 0);
  end || (end = this.length);

  if (typeof value === 'string') {
    value = value.charCodeAt(0);
  }
  if (!(typeof value === 'number') || isNaN(value)) {
    throw new Error('value is not a number');
  }

  if (end < start) throw new Error('end < start');

  // Fill 0 bytes; we're done
  if (end === start) return 0;
  if (this.length == 0) return 0;

  if (start < 0 || start >= this.length) {
    throw new Error('start out of bounds');
  }

  if (end < 0 || end > this.length) {
    throw new Error('end out of bounds');
  }

  for (var i = start; i < end; i++) {
    this[i] = value;
  }
}

// Static methods
Buffer.isBuffer = function isBuffer(b) {
  return b instanceof Buffer || b instanceof Buffer;
};

Buffer.concat = function (list, totalLength) {
  if (!isArray(list)) {
    throw new Error("Usage: Buffer.concat(list, [totalLength])\n \
      list should be an Array.");
  }

  if (list.length === 0) {
    return new Buffer(0);
  } else if (list.length === 1) {
    return list[0];
  }

  if (typeof totalLength !== 'number') {
    totalLength = 0;
    for (var i = 0; i < list.length; i++) {
      var buf = list[i];
      totalLength += buf.length;
    }
  }

  var buffer = new Buffer(totalLength);
  var pos = 0;
  for (var i = 0; i < list.length; i++) {
    var buf = list[i];
    buf.copy(buffer, pos);
    pos += buf.length;
  }
  return buffer;
};

Buffer.isEncoding = function(encoding) {
  switch ((encoding + '').toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
    case 'raw':
      return true;

    default:
      return false;
  }
};

// helpers

function coerce(length) {
  // Coerce length to a number (possibly NaN), round up
  // in case it's fractional (e.g. 123.456) then do a
  // double negate to coerce a NaN to 0. Easy, right?
  length = ~~Math.ceil(+length);
  return length < 0 ? 0 : length;
}

function isArray(subject) {
  return (Array.isArray ||
    function(subject){
      return {}.toString.apply(subject) == '[object Array]'
    })
    (subject)
}

function isArrayIsh(subject) {
  return isArray(subject) || Buffer.isBuffer(subject) ||
         subject && typeof subject === 'object' &&
         typeof subject.length === 'number';
}

function toHex(n) {
  if (n < 16) return '0' + n.toString(16);
  return n.toString(16);
}

function utf8ToBytes(str) {
  var byteArray = [];
  for (var i = 0; i < str.length; i++)
    if (str.charCodeAt(i) <= 0x7F)
      byteArray.push(str.charCodeAt(i));
    else {
      var h = encodeURIComponent(str.charAt(i)).substr(1).split('%');
      for (var j = 0; j < h.length; j++)
        byteArray.push(parseInt(h[j], 16));
    }

  return byteArray;
}

function asciiToBytes(str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++ )
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push( str.charCodeAt(i) & 0xFF );

  return byteArray;
}

function base64ToBytes(str) {
  return require("base64-js").toByteArray(str);
}

function blitBuffer(src, dst, offset, length) {
  var pos, i = 0;
  while (i < length) {
    if ((i+offset >= dst.length) || (i >= src.length))
      break;

    dst[i + offset] = src[i];
    i++;
  }
  return i;
}

function decodeUtf8Char(str) {
  try {
    return decodeURIComponent(str);
  } catch (err) {
    return String.fromCharCode(0xFFFD); // UTF 8 invalid char
  }
}

// read/write bit-twiddling

Buffer.prototype.readUInt8 = function(offset, noAssert) {
  var buffer = this;

  if (!noAssert) {
    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (offset >= buffer.length) return;

  return buffer[offset];
};

function readUInt16(buffer, offset, isBigEndian, noAssert) {
  var val = 0;


  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (offset >= buffer.length) return 0;

  if (isBigEndian) {
    val = buffer[offset] << 8;
    if (offset + 1 < buffer.length) {
      val |= buffer[offset + 1];
    }
  } else {
    val = buffer[offset];
    if (offset + 1 < buffer.length) {
      val |= buffer[offset + 1] << 8;
    }
  }

  return val;
}

Buffer.prototype.readUInt16LE = function(offset, noAssert) {
  return readUInt16(this, offset, false, noAssert);
};

Buffer.prototype.readUInt16BE = function(offset, noAssert) {
  return readUInt16(this, offset, true, noAssert);
};

function readUInt32(buffer, offset, isBigEndian, noAssert) {
  var val = 0;

  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (offset >= buffer.length) return 0;

  if (isBigEndian) {
    if (offset + 1 < buffer.length)
      val = buffer[offset + 1] << 16;
    if (offset + 2 < buffer.length)
      val |= buffer[offset + 2] << 8;
    if (offset + 3 < buffer.length)
      val |= buffer[offset + 3];
    val = val + (buffer[offset] << 24 >>> 0);
  } else {
    if (offset + 2 < buffer.length)
      val = buffer[offset + 2] << 16;
    if (offset + 1 < buffer.length)
      val |= buffer[offset + 1] << 8;
    val |= buffer[offset];
    if (offset + 3 < buffer.length)
      val = val + (buffer[offset + 3] << 24 >>> 0);
  }

  return val;
}

Buffer.prototype.readUInt32LE = function(offset, noAssert) {
  return readUInt32(this, offset, false, noAssert);
};

Buffer.prototype.readUInt32BE = function(offset, noAssert) {
  return readUInt32(this, offset, true, noAssert);
};


/*
 * Signed integer types, yay team! A reminder on how two's complement actually
 * works. The first bit is the signed bit, i.e. tells us whether or not the
 * number should be positive or negative. If the two's complement value is
 * positive, then we're done, as it's equivalent to the unsigned representation.
 *
 * Now if the number is positive, you're pretty much done, you can just leverage
 * the unsigned translations and return those. Unfortunately, negative numbers
 * aren't quite that straightforward.
 *
 * At first glance, one might be inclined to use the traditional formula to
 * translate binary numbers between the positive and negative values in two's
 * complement. (Though it doesn't quite work for the most negative value)
 * Mainly:
 *  - invert all the bits
 *  - add one to the result
 *
 * Of course, this doesn't quite work in Javascript. Take for example the value
 * of -128. This could be represented in 16 bits (big-endian) as 0xff80. But of
 * course, Javascript will do the following:
 *
 * > ~0xff80
 * -65409
 *
 * Whoh there, Javascript, that's not quite right. But wait, according to
 * Javascript that's perfectly correct. When Javascript ends up seeing the
 * constant 0xff80, it has no notion that it is actually a signed number. It
 * assumes that we've input the unsigned value 0xff80. Thus, when it does the
 * binary negation, it casts it into a signed value, (positive 0xff80). Then
 * when you perform binary negation on that, it turns it into a negative number.
 *
 * Instead, we're going to have to use the following general formula, that works
 * in a rather Javascript friendly way. I'm glad we don't support this kind of
 * weird numbering scheme in the kernel.
 *
 * (BIT-MAX - (unsigned)val + 1) * -1
 *
 * The astute observer, may think that this doesn't make sense for 8-bit numbers
 * (really it isn't necessary for them). However, when you get 16-bit numbers,
 * you do. Let's go back to our prior example and see how this will look:
 *
 * (0xffff - 0xff80 + 1) * -1
 * (0x007f + 1) * -1
 * (0x0080) * -1
 */
Buffer.prototype.readInt8 = function(offset, noAssert) {
  var buffer = this;
  var neg;

  if (!noAssert) {
    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (offset >= buffer.length) return;

  neg = buffer[offset] & 0x80;
  if (!neg) {
    return (buffer[offset]);
  }

  return ((0xff - buffer[offset] + 1) * -1);
};

function readInt16(buffer, offset, isBigEndian, noAssert) {
  var neg, val;

  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'Trying to read beyond buffer length');
  }

  val = readUInt16(buffer, offset, isBigEndian, noAssert);
  neg = val & 0x8000;
  if (!neg) {
    return val;
  }

  return (0xffff - val + 1) * -1;
}

Buffer.prototype.readInt16LE = function(offset, noAssert) {
  return readInt16(this, offset, false, noAssert);
};

Buffer.prototype.readInt16BE = function(offset, noAssert) {
  return readInt16(this, offset, true, noAssert);
};

function readInt32(buffer, offset, isBigEndian, noAssert) {
  var neg, val;

  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to read beyond buffer length');
  }

  val = readUInt32(buffer, offset, isBigEndian, noAssert);
  neg = val & 0x80000000;
  if (!neg) {
    return (val);
  }

  return (0xffffffff - val + 1) * -1;
}

Buffer.prototype.readInt32LE = function(offset, noAssert) {
  return readInt32(this, offset, false, noAssert);
};

Buffer.prototype.readInt32BE = function(offset, noAssert) {
  return readInt32(this, offset, true, noAssert);
};

function readFloat(buffer, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset + 3 < buffer.length,
        'Trying to read beyond buffer length');
  }

  return require('./buffer_ieee754').readIEEE754(buffer, offset, isBigEndian,
      23, 4);
}

Buffer.prototype.readFloatLE = function(offset, noAssert) {
  return readFloat(this, offset, false, noAssert);
};

Buffer.prototype.readFloatBE = function(offset, noAssert) {
  return readFloat(this, offset, true, noAssert);
};

function readDouble(buffer, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset + 7 < buffer.length,
        'Trying to read beyond buffer length');
  }

  return require('./buffer_ieee754').readIEEE754(buffer, offset, isBigEndian,
      52, 8);
}

Buffer.prototype.readDoubleLE = function(offset, noAssert) {
  return readDouble(this, offset, false, noAssert);
};

Buffer.prototype.readDoubleBE = function(offset, noAssert) {
  return readDouble(this, offset, true, noAssert);
};


/*
 * We have to make sure that the value is a valid integer. This means that it is
 * non-negative. It has no fractional component and that it does not exceed the
 * maximum allowed value.
 *
 *      value           The number to check for validity
 *
 *      max             The maximum value
 */
function verifuint(value, max) {
  assert.ok(typeof (value) == 'number',
      'cannot write a non-number as a number');

  assert.ok(value >= 0,
      'specified a negative value for writing an unsigned value');

  assert.ok(value <= max, 'value is larger than maximum value for type');

  assert.ok(Math.floor(value) === value, 'value has a fractional component');
}

Buffer.prototype.writeUInt8 = function(value, offset, noAssert) {
  var buffer = this;

  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'trying to write beyond buffer length');

    verifuint(value, 0xff);
  }

  if (offset < buffer.length) {
    buffer[offset] = value;
  }
};

function writeUInt16(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'trying to write beyond buffer length');

    verifuint(value, 0xffff);
  }

  for (var i = 0; i < Math.min(buffer.length - offset, 2); i++) {
    buffer[offset + i] =
        (value & (0xff << (8 * (isBigEndian ? 1 - i : i)))) >>>
            (isBigEndian ? 1 - i : i) * 8;
  }

}

Buffer.prototype.writeUInt16LE = function(value, offset, noAssert) {
  writeUInt16(this, value, offset, false, noAssert);
};

Buffer.prototype.writeUInt16BE = function(value, offset, noAssert) {
  writeUInt16(this, value, offset, true, noAssert);
};

function writeUInt32(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'trying to write beyond buffer length');

    verifuint(value, 0xffffffff);
  }

  for (var i = 0; i < Math.min(buffer.length - offset, 4); i++) {
    buffer[offset + i] =
        (value >>> (isBigEndian ? 3 - i : i) * 8) & 0xff;
  }
}

Buffer.prototype.writeUInt32LE = function(value, offset, noAssert) {
  writeUInt32(this, value, offset, false, noAssert);
};

Buffer.prototype.writeUInt32BE = function(value, offset, noAssert) {
  writeUInt32(this, value, offset, true, noAssert);
};


/*
 * We now move onto our friends in the signed number category. Unlike unsigned
 * numbers, we're going to have to worry a bit more about how we put values into
 * arrays. Since we are only worrying about signed 32-bit values, we're in
 * slightly better shape. Unfortunately, we really can't do our favorite binary
 * & in this system. It really seems to do the wrong thing. For example:
 *
 * > -32 & 0xff
 * 224
 *
 * What's happening above is really: 0xe0 & 0xff = 0xe0. However, the results of
 * this aren't treated as a signed number. Ultimately a bad thing.
 *
 * What we're going to want to do is basically create the unsigned equivalent of
 * our representation and pass that off to the wuint* functions. To do that
 * we're going to do the following:
 *
 *  - if the value is positive
 *      we can pass it directly off to the equivalent wuint
 *  - if the value is negative
 *      we do the following computation:
 *         mb + val + 1, where
 *         mb   is the maximum unsigned value in that byte size
 *         val  is the Javascript negative integer
 *
 *
 * As a concrete value, take -128. In signed 16 bits this would be 0xff80. If
 * you do out the computations:
 *
 * 0xffff - 128 + 1
 * 0xffff - 127
 * 0xff80
 *
 * You can then encode this value as the signed version. This is really rather
 * hacky, but it should work and get the job done which is our goal here.
 */

/*
 * A series of checks to make sure we actually have a signed 32-bit number
 */
function verifsint(value, max, min) {
  assert.ok(typeof (value) == 'number',
      'cannot write a non-number as a number');

  assert.ok(value <= max, 'value larger than maximum allowed value');

  assert.ok(value >= min, 'value smaller than minimum allowed value');

  assert.ok(Math.floor(value) === value, 'value has a fractional component');
}

function verifIEEE754(value, max, min) {
  assert.ok(typeof (value) == 'number',
      'cannot write a non-number as a number');

  assert.ok(value <= max, 'value larger than maximum allowed value');

  assert.ok(value >= min, 'value smaller than minimum allowed value');
}

Buffer.prototype.writeInt8 = function(value, offset, noAssert) {
  var buffer = this;

  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'Trying to write beyond buffer length');

    verifsint(value, 0x7f, -0x80);
  }

  if (value >= 0) {
    buffer.writeUInt8(value, offset, noAssert);
  } else {
    buffer.writeUInt8(0xff + value + 1, offset, noAssert);
  }
};

function writeInt16(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'Trying to write beyond buffer length');

    verifsint(value, 0x7fff, -0x8000);
  }

  if (value >= 0) {
    writeUInt16(buffer, value, offset, isBigEndian, noAssert);
  } else {
    writeUInt16(buffer, 0xffff + value + 1, offset, isBigEndian, noAssert);
  }
}

Buffer.prototype.writeInt16LE = function(value, offset, noAssert) {
  writeInt16(this, value, offset, false, noAssert);
};

Buffer.prototype.writeInt16BE = function(value, offset, noAssert) {
  writeInt16(this, value, offset, true, noAssert);
};

function writeInt32(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to write beyond buffer length');

    verifsint(value, 0x7fffffff, -0x80000000);
  }

  if (value >= 0) {
    writeUInt32(buffer, value, offset, isBigEndian, noAssert);
  } else {
    writeUInt32(buffer, 0xffffffff + value + 1, offset, isBigEndian, noAssert);
  }
}

Buffer.prototype.writeInt32LE = function(value, offset, noAssert) {
  writeInt32(this, value, offset, false, noAssert);
};

Buffer.prototype.writeInt32BE = function(value, offset, noAssert) {
  writeInt32(this, value, offset, true, noAssert);
};

function writeFloat(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to write beyond buffer length');

    verifIEEE754(value, 3.4028234663852886e+38, -3.4028234663852886e+38);
  }

  require('./buffer_ieee754').writeIEEE754(buffer, value, offset, isBigEndian,
      23, 4);
}

Buffer.prototype.writeFloatLE = function(value, offset, noAssert) {
  writeFloat(this, value, offset, false, noAssert);
};

Buffer.prototype.writeFloatBE = function(value, offset, noAssert) {
  writeFloat(this, value, offset, true, noAssert);
};

function writeDouble(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 7 < buffer.length,
        'Trying to write beyond buffer length');

    verifIEEE754(value, 1.7976931348623157E+308, -1.7976931348623157E+308);
  }

  require('./buffer_ieee754').writeIEEE754(buffer, value, offset, isBigEndian,
      52, 8);
}

Buffer.prototype.writeDoubleLE = function(value, offset, noAssert) {
  writeDouble(this, value, offset, false, noAssert);
};

Buffer.prototype.writeDoubleBE = function(value, offset, noAssert) {
  writeDouble(this, value, offset, true, noAssert);
};

},{"./buffer_ieee754":1,"assert":6,"base64-js":4}],"buffer-browserify":[function(require,module,exports){
module.exports=require('q9TxCC');
},{}],4:[function(require,module,exports){
(function (exports) {
	'use strict';

	var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

	function b64ToByteArray(b64) {
		var i, j, l, tmp, placeHolders, arr;
	
		if (b64.length % 4 > 0) {
			throw 'Invalid string. Length must be a multiple of 4';
		}

		// the number of equal signs (place holders)
		// if there are two placeholders, than the two characters before it
		// represent one byte
		// if there is only one, then the three characters before it represent 2 bytes
		// this is just a cheap hack to not do indexOf twice
		placeHolders = b64.indexOf('=');
		placeHolders = placeHolders > 0 ? b64.length - placeHolders : 0;

		// base64 is 4/3 + up to two characters of the original data
		arr = [];//new Uint8Array(b64.length * 3 / 4 - placeHolders);

		// if there are placeholders, only get up to the last complete 4 chars
		l = placeHolders > 0 ? b64.length - 4 : b64.length;

		for (i = 0, j = 0; i < l; i += 4, j += 3) {
			tmp = (lookup.indexOf(b64[i]) << 18) | (lookup.indexOf(b64[i + 1]) << 12) | (lookup.indexOf(b64[i + 2]) << 6) | lookup.indexOf(b64[i + 3]);
			arr.push((tmp & 0xFF0000) >> 16);
			arr.push((tmp & 0xFF00) >> 8);
			arr.push(tmp & 0xFF);
		}

		if (placeHolders === 2) {
			tmp = (lookup.indexOf(b64[i]) << 2) | (lookup.indexOf(b64[i + 1]) >> 4);
			arr.push(tmp & 0xFF);
		} else if (placeHolders === 1) {
			tmp = (lookup.indexOf(b64[i]) << 10) | (lookup.indexOf(b64[i + 1]) << 4) | (lookup.indexOf(b64[i + 2]) >> 2);
			arr.push((tmp >> 8) & 0xFF);
			arr.push(tmp & 0xFF);
		}

		return arr;
	}

	function uint8ToBase64(uint8) {
		var i,
			extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
			output = "",
			temp, length;

		function tripletToBase64 (num) {
			return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
		};

		// go through the array every three bytes, we'll deal with trailing stuff later
		for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
			temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);
			output += tripletToBase64(temp);
		}

		// pad the end with zeros, but make sure to not forget the extra bytes
		switch (extraBytes) {
			case 1:
				temp = uint8[uint8.length - 1];
				output += lookup[temp >> 2];
				output += lookup[(temp << 4) & 0x3F];
				output += '==';
				break;
			case 2:
				temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1]);
				output += lookup[temp >> 10];
				output += lookup[(temp >> 4) & 0x3F];
				output += lookup[(temp << 2) & 0x3F];
				output += '=';
				break;
		}

		return output;
	}

	module.exports.toByteArray = b64ToByteArray;
	module.exports.fromByteArray = uint8ToBase64;
}());

},{}],5:[function(require,module,exports){


//
// The shims in this file are not fully implemented shims for the ES5
// features, but do work for the particular usecases there is in
// the other modules.
//

var toString = Object.prototype.toString;
var hasOwnProperty = Object.prototype.hasOwnProperty;

// Array.isArray is supported in IE9
function isArray(xs) {
  return toString.call(xs) === '[object Array]';
}
exports.isArray = typeof Array.isArray === 'function' ? Array.isArray : isArray;

// Array.prototype.indexOf is supported in IE9
exports.indexOf = function indexOf(xs, x) {
  if (xs.indexOf) return xs.indexOf(x);
  for (var i = 0; i < xs.length; i++) {
    if (x === xs[i]) return i;
  }
  return -1;
};

// Array.prototype.filter is supported in IE9
exports.filter = function filter(xs, fn) {
  if (xs.filter) return xs.filter(fn);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    if (fn(xs[i], i, xs)) res.push(xs[i]);
  }
  return res;
};

// Array.prototype.forEach is supported in IE9
exports.forEach = function forEach(xs, fn, self) {
  if (xs.forEach) return xs.forEach(fn, self);
  for (var i = 0; i < xs.length; i++) {
    fn.call(self, xs[i], i, xs);
  }
};

// Array.prototype.map is supported in IE9
exports.map = function map(xs, fn) {
  if (xs.map) return xs.map(fn);
  var out = new Array(xs.length);
  for (var i = 0; i < xs.length; i++) {
    out[i] = fn(xs[i], i, xs);
  }
  return out;
};

// Array.prototype.reduce is supported in IE9
exports.reduce = function reduce(array, callback, opt_initialValue) {
  if (array.reduce) return array.reduce(callback, opt_initialValue);
  var value, isValueSet = false;

  if (2 < arguments.length) {
    value = opt_initialValue;
    isValueSet = true;
  }
  for (var i = 0, l = array.length; l > i; ++i) {
    if (array.hasOwnProperty(i)) {
      if (isValueSet) {
        value = callback(value, array[i], i, array);
      }
      else {
        value = array[i];
        isValueSet = true;
      }
    }
  }

  return value;
};

// String.prototype.substr - negative index don't work in IE8
if ('ab'.substr(-1) !== 'b') {
  exports.substr = function (str, start, length) {
    // did we get a negative start, calculate how much it is from the beginning of the string
    if (start < 0) start = str.length + start;

    // call the original function
    return str.substr(start, length);
  };
} else {
  exports.substr = function (str, start, length) {
    return str.substr(start, length);
  };
}

// String.prototype.trim is supported in IE9
exports.trim = function (str) {
  if (str.trim) return str.trim();
  return str.replace(/^\s+|\s+$/g, '');
};

// Function.prototype.bind is supported in IE9
exports.bind = function () {
  var args = Array.prototype.slice.call(arguments);
  var fn = args.shift();
  if (fn.bind) return fn.bind.apply(fn, args);
  var self = args.shift();
  return function () {
    fn.apply(self, args.concat([Array.prototype.slice.call(arguments)]));
  };
};

// Object.create is supported in IE9
function create(prototype, properties) {
  var object;
  if (prototype === null) {
    object = { '__proto__' : null };
  }
  else {
    if (typeof prototype !== 'object') {
      throw new TypeError(
        'typeof prototype[' + (typeof prototype) + '] != \'object\''
      );
    }
    var Type = function () {};
    Type.prototype = prototype;
    object = new Type();
    object.__proto__ = prototype;
  }
  if (typeof properties !== 'undefined' && Object.defineProperties) {
    Object.defineProperties(object, properties);
  }
  return object;
}
exports.create = typeof Object.create === 'function' ? Object.create : create;

// Object.keys and Object.getOwnPropertyNames is supported in IE9 however
// they do show a description and number property on Error objects
function notObject(object) {
  return ((typeof object != "object" && typeof object != "function") || object === null);
}

function keysShim(object) {
  if (notObject(object)) {
    throw new TypeError("Object.keys called on a non-object");
  }

  var result = [];
  for (var name in object) {
    if (hasOwnProperty.call(object, name)) {
      result.push(name);
    }
  }
  return result;
}

// getOwnPropertyNames is almost the same as Object.keys one key feature
//  is that it returns hidden properties, since that can't be implemented,
//  this feature gets reduced so it just shows the length property on arrays
function propertyShim(object) {
  if (notObject(object)) {
    throw new TypeError("Object.getOwnPropertyNames called on a non-object");
  }

  var result = keysShim(object);
  if (exports.isArray(object) && exports.indexOf(object, 'length') === -1) {
    result.push('length');
  }
  return result;
}

var keys = typeof Object.keys === 'function' ? Object.keys : keysShim;
var getOwnPropertyNames = typeof Object.getOwnPropertyNames === 'function' ?
  Object.getOwnPropertyNames : propertyShim;

if (new Error().hasOwnProperty('description')) {
  var ERROR_PROPERTY_FILTER = function (obj, array) {
    if (toString.call(obj) === '[object Error]') {
      array = exports.filter(array, function (name) {
        return name !== 'description' && name !== 'number' && name !== 'message';
      });
    }
    return array;
  };

  exports.keys = function (object) {
    return ERROR_PROPERTY_FILTER(object, keys(object));
  };
  exports.getOwnPropertyNames = function (object) {
    return ERROR_PROPERTY_FILTER(object, getOwnPropertyNames(object));
  };
} else {
  exports.keys = keys;
  exports.getOwnPropertyNames = getOwnPropertyNames;
}

// Object.getOwnPropertyDescriptor - supported in IE8 but only on dom elements
function valueObject(value, key) {
  return { value: value[key] };
}

if (typeof Object.getOwnPropertyDescriptor === 'function') {
  try {
    Object.getOwnPropertyDescriptor({'a': 1}, 'a');
    exports.getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
  } catch (e) {
    // IE8 dom element issue - use a try catch and default to valueObject
    exports.getOwnPropertyDescriptor = function (value, key) {
      try {
        return Object.getOwnPropertyDescriptor(value, key);
      } catch (e) {
        return valueObject(value, key);
      }
    };
  }
} else {
  exports.getOwnPropertyDescriptor = valueObject;
}

},{}],6:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// UTILITY
var util = require('util');
var shims = require('_shims');
var pSlice = Array.prototype.slice;

// 1. The assert module provides functions that throw
// AssertionError's when particular conditions are not met. The
// assert module must conform to the following interface.

var assert = module.exports = ok;

// 2. The AssertionError is defined in assert.
// new assert.AssertionError({ message: message,
//                             actual: actual,
//                             expected: expected })

assert.AssertionError = function AssertionError(options) {
  this.name = 'AssertionError';
  this.actual = options.actual;
  this.expected = options.expected;
  this.operator = options.operator;
  this.message = options.message || getMessage(this);
};

// assert.AssertionError instanceof Error
util.inherits(assert.AssertionError, Error);

function replacer(key, value) {
  if (util.isUndefined(value)) {
    return '' + value;
  }
  if (util.isNumber(value) && (isNaN(value) || !isFinite(value))) {
    return value.toString();
  }
  if (util.isFunction(value) || util.isRegExp(value)) {
    return value.toString();
  }
  return value;
}

function truncate(s, n) {
  if (util.isString(s)) {
    return s.length < n ? s : s.slice(0, n);
  } else {
    return s;
  }
}

function getMessage(self) {
  return truncate(JSON.stringify(self.actual, replacer), 128) + ' ' +
         self.operator + ' ' +
         truncate(JSON.stringify(self.expected, replacer), 128);
}

// At present only the three keys mentioned above are used and
// understood by the spec. Implementations or sub modules can pass
// other keys to the AssertionError's constructor - they will be
// ignored.

// 3. All of the following functions must throw an AssertionError
// when a corresponding condition is not met, with a message that
// may be undefined if not provided.  All assertion methods provide
// both the actual and expected values to the assertion error for
// display purposes.

function fail(actual, expected, message, operator, stackStartFunction) {
  throw new assert.AssertionError({
    message: message,
    actual: actual,
    expected: expected,
    operator: operator,
    stackStartFunction: stackStartFunction
  });
}

// EXTENSION! allows for well behaved errors defined elsewhere.
assert.fail = fail;

// 4. Pure assertion tests whether a value is truthy, as determined
// by !!guard.
// assert.ok(guard, message_opt);
// This statement is equivalent to assert.equal(true, !!guard,
// message_opt);. To test strictly for the value true, use
// assert.strictEqual(true, guard, message_opt);.

function ok(value, message) {
  if (!value) fail(value, true, message, '==', assert.ok);
}
assert.ok = ok;

// 5. The equality assertion tests shallow, coercive equality with
// ==.
// assert.equal(actual, expected, message_opt);

assert.equal = function equal(actual, expected, message) {
  if (actual != expected) fail(actual, expected, message, '==', assert.equal);
};

// 6. The non-equality assertion tests for whether two objects are not equal
// with != assert.notEqual(actual, expected, message_opt);

assert.notEqual = function notEqual(actual, expected, message) {
  if (actual == expected) {
    fail(actual, expected, message, '!=', assert.notEqual);
  }
};

// 7. The equivalence assertion tests a deep equality relation.
// assert.deepEqual(actual, expected, message_opt);

assert.deepEqual = function deepEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected)) {
    fail(actual, expected, message, 'deepEqual', assert.deepEqual);
  }
};

function _deepEqual(actual, expected) {
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;

  } else if (util.isBuffer(actual) && util.isBuffer(expected)) {
    if (actual.length != expected.length) return false;

    for (var i = 0; i < actual.length; i++) {
      if (actual[i] !== expected[i]) return false;
    }

    return true;

  // 7.2. If the expected value is a Date object, the actual value is
  // equivalent if it is also a Date object that refers to the same time.
  } else if (util.isDate(actual) && util.isDate(expected)) {
    return actual.getTime() === expected.getTime();

  // 7.3 If the expected value is a RegExp object, the actual value is
  // equivalent if it is also a RegExp object with the same source and
  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
    return actual.source === expected.source &&
           actual.global === expected.global &&
           actual.multiline === expected.multiline &&
           actual.lastIndex === expected.lastIndex &&
           actual.ignoreCase === expected.ignoreCase;

  // 7.4. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if (!util.isObject(actual) && !util.isObject(expected)) {
    return actual == expected;

  // 7.5 For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else {
    return objEquiv(actual, expected);
  }
}

function isArguments(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
}

function objEquiv(a, b) {
  if (util.isNullOrUndefined(a) || util.isNullOrUndefined(b))
    return false;
  // an identical 'prototype' property.
  if (a.prototype !== b.prototype) return false;
  //~~~I've managed to break Object.keys through screwy arguments passing.
  //   Converting to array solves the problem.
  if (isArguments(a)) {
    if (!isArguments(b)) {
      return false;
    }
    a = pSlice.call(a);
    b = pSlice.call(b);
    return _deepEqual(a, b);
  }
  try {
    var ka = shims.keys(a),
        kb = shims.keys(b),
        key, i;
  } catch (e) {//happens when one is a string literal and the other isn't
    return false;
  }
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length != kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] != kb[i])
      return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!_deepEqual(a[key], b[key])) return false;
  }
  return true;
}

// 8. The non-equivalence assertion tests for any deep inequality.
// assert.notDeepEqual(actual, expected, message_opt);

assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
  if (_deepEqual(actual, expected)) {
    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
  }
};

// 9. The strict equality assertion tests strict equality, as determined by ===.
// assert.strictEqual(actual, expected, message_opt);

assert.strictEqual = function strictEqual(actual, expected, message) {
  if (actual !== expected) {
    fail(actual, expected, message, '===', assert.strictEqual);
  }
};

// 10. The strict non-equality assertion tests for strict inequality, as
// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);

assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
  if (actual === expected) {
    fail(actual, expected, message, '!==', assert.notStrictEqual);
  }
};

function expectedException(actual, expected) {
  if (!actual || !expected) {
    return false;
  }

  if (Object.prototype.toString.call(expected) == '[object RegExp]') {
    return expected.test(actual);
  } else if (actual instanceof expected) {
    return true;
  } else if (expected.call({}, actual) === true) {
    return true;
  }

  return false;
}

function _throws(shouldThrow, block, expected, message) {
  var actual;

  if (util.isString(expected)) {
    message = expected;
    expected = null;
  }

  try {
    block();
  } catch (e) {
    actual = e;
  }

  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
            (message ? ' ' + message : '.');

  if (shouldThrow && !actual) {
    fail(actual, expected, 'Missing expected exception' + message);
  }

  if (!shouldThrow && expectedException(actual, expected)) {
    fail(actual, expected, 'Got unwanted exception' + message);
  }

  if ((shouldThrow && actual && expected &&
      !expectedException(actual, expected)) || (!shouldThrow && actual)) {
    throw actual;
  }
}

// 11. Expected to throw an error:
// assert.throws(block, Error_opt, message_opt);

assert.throws = function(block, /*optional*/error, /*optional*/message) {
  _throws.apply(this, [true].concat(pSlice.call(arguments)));
};

// EXTENSION! This is annoying to write outside this module.
assert.doesNotThrow = function(block, /*optional*/message) {
  _throws.apply(this, [false].concat(pSlice.call(arguments)));
};

assert.ifError = function(err) { if (err) {throw err;}};
},{"_shims":5,"util":7}],7:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var shims = require('_shims');

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};

/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  shims.forEach(array, function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = shims.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = shims.getOwnPropertyNames(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }

  shims.forEach(keys, function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = shims.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }

  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (shims.indexOf(ctx.seen, desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = shims.reduce(output, function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return shims.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) && objectToString(e) === '[object Error]';
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

function isBuffer(arg) {
  return arg instanceof Buffer;
}
exports.isBuffer = isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = function(ctor, superCtor) {
  ctor.super_ = superCtor;
  ctor.prototype = shims.create(superCtor.prototype, {
    constructor: {
      value: ctor,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
};

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = shims.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

},{"_shims":5}]},{},[])
;;module.exports=require("buffer-browserify")

},{}],19:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};

process.nextTick = (function () {
    var canSetImmediate = typeof window !== 'undefined'
    && window.setImmediate;
    var canPost = typeof window !== 'undefined'
    && window.postMessage && window.addEventListener
    ;

    if (canSetImmediate) {
        return function (f) { return window.setImmediate(f) };
    }

    if (canPost) {
        var queue = [];
        window.addEventListener('message', function (ev) {
            if (ev.source === window && ev.data === 'process-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);

        return function nextTick(fn) {
            queue.push(fn);
            window.postMessage('process-tick', '*');
        };
    }

    return function nextTick(fn) {
        setTimeout(fn, 0);
    };
})();

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];

process.binding = function (name) {
    throw new Error('process.binding is not supported');
}

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};

},{}],20:[function(require,module,exports){
/*
colors.js

Copyright (c) 2010

Marak Squires
Alexis Sellier (cloudhead)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

*/

var isHeadless = false;

if (typeof module !== 'undefined') {
  isHeadless = true;
}

if (!isHeadless) {
  var exports = {};
  var module = {};
  var colors = exports;
  exports.mode = "browser";
} else {
  exports.mode = "console";
}

//
// Prototypes the string object to have additional method calls that add terminal colors
//
var addProperty = function (color, func) {
  exports[color] = function (str) {
    return func.apply(str);
  };
  String.prototype.__defineGetter__(color, func);
};

function stylize(str, style) {

  var styles;

  if (exports.mode === 'console') {
    styles = {
      //styles
      'bold'      : ['\x1B[1m',  '\x1B[22m'],
      'italic'    : ['\x1B[3m',  '\x1B[23m'],
      'underline' : ['\x1B[4m',  '\x1B[24m'],
      'inverse'   : ['\x1B[7m',  '\x1B[27m'],
      'strikethrough' : ['\x1B[9m',  '\x1B[29m'],
      //text colors
      //grayscale
      'white'     : ['\x1B[37m', '\x1B[39m'],
      'grey'      : ['\x1B[90m', '\x1B[39m'],
      'black'     : ['\x1B[30m', '\x1B[39m'],
      //colors
      'blue'      : ['\x1B[34m', '\x1B[39m'],
      'cyan'      : ['\x1B[36m', '\x1B[39m'],
      'green'     : ['\x1B[32m', '\x1B[39m'],
      'magenta'   : ['\x1B[35m', '\x1B[39m'],
      'red'       : ['\x1B[31m', '\x1B[39m'],
      'yellow'    : ['\x1B[33m', '\x1B[39m'],
      //background colors
      //grayscale
      'whiteBG'     : ['\x1B[47m', '\x1B[49m'],
      'greyBG'      : ['\x1B[49;5;8m', '\x1B[49m'],
      'blackBG'     : ['\x1B[40m', '\x1B[49m'],
      //colors
      'blueBG'      : ['\x1B[44m', '\x1B[49m'],
      'cyanBG'      : ['\x1B[46m', '\x1B[49m'],
      'greenBG'     : ['\x1B[42m', '\x1B[49m'],
      'magentaBG'   : ['\x1B[45m', '\x1B[49m'],
      'redBG'       : ['\x1B[41m', '\x1B[49m'],
      'yellowBG'    : ['\x1B[43m', '\x1B[49m']
    };
  } else if (exports.mode === 'browser') {
    styles = {
      //styles
      'bold'      : ['<b>',  '</b>'],
      'italic'    : ['<i>',  '</i>'],
      'underline' : ['<u>',  '</u>'],
      'inverse'   : ['<span style="background-color:black;color:white;">',  '</span>'],
      'strikethrough' : ['<del>',  '</del>'],
      //text colors
      //grayscale
      'white'     : ['<span style="color:white;">',   '</span>'],
      'grey'      : ['<span style="color:gray;">',    '</span>'],
      'black'     : ['<span style="color:black;">',   '</span>'],
      //colors
      'blue'      : ['<span style="color:blue;">',    '</span>'],
      'cyan'      : ['<span style="color:cyan;">',    '</span>'],
      'green'     : ['<span style="color:green;">',   '</span>'],
      'magenta'   : ['<span style="color:magenta;">', '</span>'],
      'red'       : ['<span style="color:red;">',     '</span>'],
      'yellow'    : ['<span style="color:yellow;">',  '</span>'],
      //background colors
      //grayscale
      'whiteBG'     : ['<span style="background-color:white;">',   '</span>'],
      'greyBG'      : ['<span style="background-color:gray;">',    '</span>'],
      'blackBG'     : ['<span style="background-color:black;">',   '</span>'],
      //colors
      'blueBG'      : ['<span style="background-color:blue;">',    '</span>'],
      'cyanBG'      : ['<span style="background-color:cyan;">',    '</span>'],
      'greenBG'     : ['<span style="background-color:green;">',   '</span>'],
      'magentaBG'   : ['<span style="background-color:magenta;">', '</span>'],
      'redBG'       : ['<span style="background-color:red;">',     '</span>'],
      'yellowBG'    : ['<span style="background-color:yellow;">',  '</span>']
    };
  } else if (exports.mode === 'none') {
    return str + '';
  } else {
    console.log('unsupported mode, try "browser", "console" or "none"');
  }
  return styles[style][0] + str + styles[style][1];
}

function applyTheme(theme) {

  //
  // Remark: This is a list of methods that exist
  // on String that you should not overwrite.
  //
  var stringPrototypeBlacklist = [
    '__defineGetter__', '__defineSetter__', '__lookupGetter__', '__lookupSetter__', 'charAt', 'constructor',
    'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'toLocaleString', 'toString', 'valueOf', 'charCodeAt',
    'indexOf', 'lastIndexof', 'length', 'localeCompare', 'match', 'replace', 'search', 'slice', 'split', 'substring',
    'toLocaleLowerCase', 'toLocaleUpperCase', 'toLowerCase', 'toUpperCase', 'trim', 'trimLeft', 'trimRight'
  ];

  Object.keys(theme).forEach(function (prop) {
    if (stringPrototypeBlacklist.indexOf(prop) !== -1) {
      console.log('warn: '.red + ('String.prototype' + prop).magenta + ' is probably something you don\'t want to override. Ignoring style name');
    }
    else {
      if (typeof(theme[prop]) === 'string') {
        addProperty(prop, function () {
          return exports[theme[prop]](this);
        });
      }
      else {
        addProperty(prop, function () {
          var ret = this;
          for (var t = 0; t < theme[prop].length; t++) {
            ret = exports[theme[prop][t]](ret);
          }
          return ret;
        });
      }
    }
  });
}


//
// Iterate through all default styles and colors
//
var x = ['bold', 'underline', 'strikethrough', 'italic', 'inverse', 'grey', 'black', 'yellow', 'red', 'green', 'blue', 'white', 'cyan', 'magenta', 'greyBG', 'blackBG', 'yellowBG', 'redBG', 'greenBG', 'blueBG', 'whiteBG', 'cyanBG', 'magentaBG'];
x.forEach(function (style) {

  // __defineGetter__ at the least works in more browsers
  // http://robertnyman.com/javascript/javascript-getters-setters.html
  // Object.defineProperty only works in Chrome
  addProperty(style, function () {
    return stylize(this, style);
  });
});

function sequencer(map) {
  return function () {
    if (!isHeadless) {
      return this.replace(/( )/, '$1');
    }
    var exploded = this.split(""), i = 0;
    exploded = exploded.map(map);
    return exploded.join("");
  };
}

var rainbowMap = (function () {
  var rainbowColors = ['red', 'yellow', 'green', 'blue', 'magenta']; //RoY G BiV
  return function (letter, i, exploded) {
    if (letter === " ") {
      return letter;
    } else {
      return stylize(letter, rainbowColors[i++ % rainbowColors.length]);
    }
  };
})();

exports.themes = {};

exports.addSequencer = function (name, map) {
  addProperty(name, sequencer(map));
};

exports.addSequencer('rainbow', rainbowMap);
exports.addSequencer('zebra', function (letter, i, exploded) {
  return i % 2 === 0 ? letter : letter.inverse;
});

exports.setTheme = function (theme) {
  if (typeof theme === 'string') {
    try {
      exports.themes[theme] = require(theme);
      applyTheme(exports.themes[theme]);
      return exports.themes[theme];
    } catch (err) {
      console.log(err);
      return err;
    }
  } else {
    applyTheme(theme);
  }
};


addProperty('stripColors', function () {
  return ("" + this).replace(/\x1B\[\d+m/g, '');
});

// please no
function zalgo(text, options) {
  var soul = {
    "up" : [
      '̍', '̎', '̄', '̅',
      '̿', '̑', '̆', '̐',
      '͒', '͗', '͑', '̇',
      '̈', '̊', '͂', '̓',
      '̈', '͊', '͋', '͌',
      '̃', '̂', '̌', '͐',
      '̀', '́', '̋', '̏',
      '̒', '̓', '̔', '̽',
      '̉', 'ͣ', 'ͤ', 'ͥ',
      'ͦ', 'ͧ', 'ͨ', 'ͩ',
      'ͪ', 'ͫ', 'ͬ', 'ͭ',
      'ͮ', 'ͯ', '̾', '͛',
      '͆', '̚'
    ],
    "down" : [
      '̖', '̗', '̘', '̙',
      '̜', '̝', '̞', '̟',
      '̠', '̤', '̥', '̦',
      '̩', '̪', '̫', '̬',
      '̭', '̮', '̯', '̰',
      '̱', '̲', '̳', '̹',
      '̺', '̻', '̼', 'ͅ',
      '͇', '͈', '͉', '͍',
      '͎', '͓', '͔', '͕',
      '͖', '͙', '͚', '̣'
    ],
    "mid" : [
      '̕', '̛', '̀', '́',
      '͘', '̡', '̢', '̧',
      '̨', '̴', '̵', '̶',
      '͜', '͝', '͞',
      '͟', '͠', '͢', '̸',
      '̷', '͡', ' ҉'
    ]
  },
  all = [].concat(soul.up, soul.down, soul.mid),
  zalgo = {};

  function randomNumber(range) {
    var r = Math.floor(Math.random() * range);
    return r;
  }

  function is_char(character) {
    var bool = false;
    all.filter(function (i) {
      bool = (i === character);
    });
    return bool;
  }

  function heComes(text, options) {
    var result = '', counts, l;
    options = options || {};
    options["up"] = options["up"] || true;
    options["mid"] = options["mid"] || true;
    options["down"] = options["down"] || true;
    options["size"] = options["size"] || "maxi";
    text = text.split('');
    for (l in text) {
      if (is_char(l)) {
        continue;
      }
      result = result + text[l];
      counts = {"up" : 0, "down" : 0, "mid" : 0};
      switch (options.size) {
      case 'mini':
        counts.up = randomNumber(8);
        counts.min = randomNumber(2);
        counts.down = randomNumber(8);
        break;
      case 'maxi':
        counts.up = randomNumber(16) + 3;
        counts.min = randomNumber(4) + 1;
        counts.down = randomNumber(64) + 3;
        break;
      default:
        counts.up = randomNumber(8) + 1;
        counts.mid = randomNumber(6) / 2;
        counts.down = randomNumber(8) + 1;
        break;
      }

      var arr = ["up", "mid", "down"];
      for (var d in arr) {
        var index = arr[d];
        for (var i = 0 ; i <= counts[index]; i++) {
          if (options[index]) {
            result = result + soul[index][randomNumber(soul[index].length)];
          }
        }
      }
    }
    return result;
  }
  return heComes(text);
}


// don't summon zalgo
addProperty('zalgo', function () {
  return zalgo(this);
});

},{}],21:[function(require,module,exports){
var pSlice = Array.prototype.slice;
var Object_keys = typeof Object.keys === 'function'
    ? Object.keys
    : function (obj) {
        var keys = [];
        for (var key in obj) keys.push(key);
        return keys;
    }
;

var deepEqual = module.exports = function (actual, expected) {
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;

  } else if (actual instanceof Date && expected instanceof Date) {
    return actual.getTime() === expected.getTime();

  // 7.3. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if (typeof actual != 'object' && typeof expected != 'object') {
    return actual == expected;

  // 7.4. For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else {
    return objEquiv(actual, expected);
  }
}

function isUndefinedOrNull(value) {
  return value === null || value === undefined;
}

function isArguments(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
}

function objEquiv(a, b) {
  if (isUndefinedOrNull(a) || isUndefinedOrNull(b))
    return false;
  // an identical 'prototype' property.
  if (a.prototype !== b.prototype) return false;
  //~~~I've managed to break Object.keys through screwy arguments passing.
  //   Converting to array solves the problem.
  if (isArguments(a)) {
    if (!isArguments(b)) {
      return false;
    }
    a = pSlice.call(a);
    b = pSlice.call(b);
    return deepEqual(a, b);
  }
  try {
    var ka = Object_keys(a),
        kb = Object_keys(b),
        key, i;
  } catch (e) {//happens when one is a string literal and the other isn't
    return false;
  }
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length != kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] != kb[i])
      return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!deepEqual(a[key], b[key])) return false;
  }
  return true;
}

},{}],22:[function(require,module,exports){
var process=require("__browserify_process");// Generated by IcedCoffeeScript 1.6.3-g
(function() {
  var generator,
    __slice = [].slice;



  exports.generator = generator = function(intern, compiletime, runtime) {
    var C, Deferrals, Rendezvous, exceptionHandler, findDeferral, stackWalk;
    compiletime.transform = function(x, options) {
      return x.icedTransform(options);
    };
    compiletime["const"] = C = {
      k: "__iced_k",
      k_noop: "__iced_k_noop",
      param: "__iced_p_",
      ns: "iced",
      runtime: "runtime",
      Deferrals: "Deferrals",
      deferrals: "__iced_deferrals",
      fulfill: "_fulfill",
      b_while: "_break",
      t_while: "_while",
      c_while: "_continue",
      n_while: "_next",
      n_arg: "__iced_next_arg",
      context: "context",
      defer_method: "defer",
      slot: "__slot",
      assign_fn: "assign_fn",
      autocb: "autocb",
      retslot: "ret",
      trace: "__iced_trace",
      passed_deferral: "__iced_passed_deferral",
      findDeferral: "findDeferral",
      lineno: "lineno",
      parent: "parent",
      filename: "filename",
      funcname: "funcname",
      catchExceptions: 'catchExceptions',
      runtime_modes: ["node", "inline", "window", "none", "browserify"],
      trampoline: "trampoline"
    };
    intern.makeDeferReturn = function(obj, defer_args, id, trace_template, multi) {
      var k, ret, trace, v;
      trace = {};
      for (k in trace_template) {
        v = trace_template[k];
        trace[k] = v;
      }
      trace[C.lineno] = defer_args != null ? defer_args[C.lineno] : void 0;
      ret = function() {
        var inner_args, o, _ref;
        inner_args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        if (defer_args != null) {
          if ((_ref = defer_args.assign_fn) != null) {
            _ref.apply(null, inner_args);
          }
        }
        if (obj) {
          o = obj;
          if (!multi) {
            obj = null;
          }
          return o._fulfill(id, trace);
        } else {
          return intern._warn("overused deferral at " + (intern._trace_to_string(trace)));
        }
      };
      ret[C.trace] = trace;
      return ret;
    };
    intern.__c = 0;
    intern.tickCounter = function(mod) {
      intern.__c++;
      if ((intern.__c % mod) === 0) {
        intern.__c = 0;
        return true;
      } else {
        return false;
      }
    };
    intern.__active_trace = null;
    intern._trace_to_string = function(tr) {
      var fn;
      fn = tr[C.funcname] || "<anonymous>";
      return "" + fn + " (" + tr[C.filename] + ":" + (tr[C.lineno] + 1) + ")";
    };
    intern._warn = function(m) {
      return typeof console !== "undefined" && console !== null ? console.log("ICED warning: " + m) : void 0;
    };
    runtime.trampoline = function(fn) {
      if (!intern.tickCounter(500)) {
        return fn();
      } else if (typeof process !== "undefined" && process !== null) {
        return process.nextTick(fn);
      } else {
        return setTimeout(fn);
      }
    };
    runtime.Deferrals = Deferrals = (function() {
      function Deferrals(k, trace) {
        this.trace = trace;
        this.continuation = k;
        this.count = 1;
        this.ret = null;
      }

      Deferrals.prototype._call = function(trace) {
        var c;
        if (this.continuation) {
          intern.__active_trace = trace;
          c = this.continuation;
          this.continuation = null;
          return c(this.ret);
        } else {
          return intern._warn("Entered dead await at " + (intern._trace_to_string(trace)));
        }
      };

      Deferrals.prototype._fulfill = function(id, trace) {
        var _this = this;
        if (--this.count > 0) {

        } else {
          return runtime.trampoline((function() {
            return _this._call(trace);
          }));
        }
      };

      Deferrals.prototype.defer = function(args) {
        var self;
        this.count++;
        self = this;
        return intern.makeDeferReturn(self, args, null, this.trace);
      };

      Deferrals.prototype._defer = function(args) {
        return this["defer"](args);
      };

      return Deferrals;

    })();
    runtime.findDeferral = findDeferral = function(args) {
      var a, _i, _len;
      for (_i = 0, _len = args.length; _i < _len; _i++) {
        a = args[_i];
        if (a != null ? a[C.trace] : void 0) {
          return a;
        }
      }
      return null;
    };
    runtime.Rendezvous = Rendezvous = (function() {
      var RvId;

      function Rendezvous() {
        this.completed = [];
        this.waiters = [];
        this.defer_id = 0;
      }

      RvId = (function() {
        function RvId(rv, id, multi) {
          this.rv = rv;
          this.id = id;
          this.multi = multi;
        }

        RvId.prototype.defer = function(defer_args) {
          return this.rv._deferWithId(this.id, defer_args, this.multi);
        };

        return RvId;

      })();

      Rendezvous.prototype.wait = function(cb) {
        var x;
        if (this.completed.length) {
          x = this.completed.shift();
          return cb(x);
        } else {
          return this.waiters.push(cb);
        }
      };

      Rendezvous.prototype.defer = function(defer_args) {
        var id;
        id = this.defer_id++;
        return this.deferWithId(id, defer_args);
      };

      Rendezvous.prototype.id = function(i, multi) {
        if (multi == null) {
          multi = false;
        }
        return new RvId(this, i, multi);
      };

      Rendezvous.prototype._fulfill = function(id, trace) {
        var cb;
        if (this.waiters.length) {
          cb = this.waiters.shift();
          return cb(id);
        } else {
          return this.completed.push(id);
        }
      };

      Rendezvous.prototype._deferWithId = function(id, defer_args, multi) {
        this.count++;
        return intern.makeDeferReturn(this, defer_args, id, {}, multi);
      };

      return Rendezvous;

    })();
    runtime.stackWalk = stackWalk = function(cb) {
      var line, ret, tr, _ref;
      ret = [];
      tr = cb ? cb[C.trace] : intern.__active_trace;
      while (tr) {
        line = "   at " + (intern._trace_to_string(tr));
        ret.push(line);
        tr = tr != null ? (_ref = tr[C.parent]) != null ? _ref[C.trace] : void 0 : void 0;
      }
      return ret;
    };
    runtime.exceptionHandler = exceptionHandler = function(err, logger) {
      var stack;
      if (!logger) {
        logger = console.log;
      }
      logger(err.stack);
      stack = stackWalk();
      if (stack.length) {
        logger("Iced callback trace:");
        return logger(stack.join("\n"));
      }
    };
    return runtime.catchExceptions = function(logger) {
      return typeof process !== "undefined" && process !== null ? process.on('uncaughtException', function(err) {
        exceptionHandler(err, logger);
        return process.exit(1);
      }) : void 0;
    };
  };

  exports.runtime = {};

  generator(this, exports, exports.runtime);

}).call(this);

},{"__browserify_process":19}],23:[function(require,module,exports){
// Generated by IcedCoffeeScript 1.6.2d
(function() {
  var BaseError, Canceler, EscErr, EscOk, c_to_camel, ipush, make_error_klass, make_errors, make_esc, to_lower, util,
    __slice = [].slice;



  util = require('util');

  exports.BaseError = BaseError = function(msg, constructor) {
    Error.captureStackTrace(this, this.constructor);
    return this.message = msg || 'Error';
  };

  util.inherits(BaseError, Error);

  BaseError.prototype.name = "BaseError";

  to_lower = function(s) {
    return s[0].toUpperCase() + s.slice(1).toLowerCase();
  };

  c_to_camel = function(s) {
    var p;
    return ((function() {
      var _i, _len, _ref, _results;
      _ref = s.split(/_/);
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        p = _ref[_i];
        _results.push(to_lower(p));
      }
      return _results;
    })()).join('');
  };

  make_error_klass = function(k, code, default_msg) {
    var ctor;
    ctor = function(msg) {
      BaseError.call(this, msg || default_msg, this.constructor);
      this.istack = [];
      this.code = code;
      return this;
    };
    util.inherits(ctor, BaseError);
    ctor.prototype.name = k;
    ctor.prototype.inspect = function() {
      return "[" + k + ": " + this.message + " (code " + this.code + ")]";
    };
    return ctor;
  };

  exports.make_errors = make_errors = function(d) {
    var enam, errno, k, msg, out, val;
    out = {
      msg: {},
      name: {},
      code: {}
    };
    d.OK = "Success";
    errno = 100;
    for (k in d) {
      msg = d[k];
      if (k !== "OK") {
        enam = (c_to_camel(k)) + "Error";
        val = errno++;
        out[enam] = make_error_klass(enam, val, msg);
      } else {
        val = 0;
      }
      out[k] = val;
      out.msg[k] = out.msg[val] = msg;
      out.name[k] = out.name[val] = k;
      out.code[k] = val;
    }
    return out;
  };

  ipush = function(e, msg) {
    if (msg != null) {
      if (e.istack == null) {
        e.istack = [];
      }
      return e.istack.push(msg);
    }
  };

  exports.make_esc = make_esc = function(gcb, where) {
    return function(lcb) {
      return function() {
        var args, err;
        err = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
        if (err == null) {
          return lcb.apply(null, args);
        } else if (!gcb.__esc) {
          gcb.__esc = true;
          ipush(err, where);
          return gcb(err);
        }
      };
    };
  };

  exports.EscOk = EscOk = (function() {
    function EscOk(gcb, where) {
      this.gcb = gcb;
      this.where = where;
    }

    EscOk.prototype.bailout = function() {
      var t;
      if (this.gcb) {
        t = this.gcb;
        this.gcb = null;
        return t(false);
      }
    };

    EscOk.prototype.check_ok = function(cb) {
      var _this = this;
      return function() {
        var args, ok;
        ok = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
        if (!ok) {
          return _this.bailout();
        } else {
          return cb.apply(null, args);
        }
      };
    };

    EscOk.prototype.check_err = function(cb) {
      var _this = this;
      return function() {
        var args, err;
        err = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
        if (err != null) {
          ipush(err, _this.where);
          return _this.bailout();
        } else {
          return cb.apply(null, args);
        }
      };
    };

    EscOk.prototype.check_non_null = function(cb) {
      var _this = this;
      return function() {
        var args;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        if (args[0] == null) {
          return _this.bailout();
        } else {
          return cb.apply(null, args);
        }
      };
    };

    return EscOk;

  })();

  exports.EscErr = EscErr = (function() {
    function EscErr(gcb, where) {
      this.gcb = gcb;
      this.where = where;
    }

    EscErr.prototype.finish = function(err) {
      var t;
      if (this.gcb) {
        t = this.gcb;
        this.gcb = null;
        return t(err);
      }
    };

    EscErr.prototype.check_ok = function(cb, eclass, emsg) {
      if (eclass == null) {
        eclass = Error;
      }
      if (emsg == null) {
        emsg = null;
      }
      return function() {
        var args, err, ok;
        ok = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
        if (!ok) {
          err = new eclass(emsg);
          ipush(err, this.where);
          return this.finish(err);
        } else {
          return cb.apply(null, args);
        }
      };
    };

    EscErr.prototype.check_err = function(cb) {
      return function() {
        var args, err;
        err = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
        if (err != null) {
          ipush(err, this.where);
          return this.finish(err);
        } else {
          return cb.apply(null, args);
        }
      };
    };

    return EscErr;

  })();

  exports.Canceler = Canceler = (function() {
    function Canceler(klass) {
      this.klass = klass != null ? klass : Error;
      this._canceled = false;
    }

    Canceler.prototype.is_canceled = function() {
      return this._canceled;
    };

    Canceler.prototype.is_ok = function() {
      return !this._canceled;
    };

    Canceler.prototype.cancel = function() {
      return this._canceled = true;
    };

    Canceler.prototype.err = function() {
      if (this._canceled) {
        return new this.klass("Aborted");
      } else {
        return null;
      }
    };

    return Canceler;

  })();

}).call(this);

/*
//@ sourceMappingURL=index.map
*/

},{"util":14}],24:[function(require,module,exports){
var process=require("__browserify_process");// Generated by IcedCoffeeScript 1.6.2a
(function() {
  var $, BAD_X, BrowserRunner, CHECK, Case, File, Runner, ServerRunner, WAYPOINT, colors, deep_equal, fs, iced, path, urlmod, __iced_k, __iced_k_noop,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  iced = require('iced-coffee-script/lib/coffee-script/iced').runtime;
  __iced_k = __iced_k_noop = function() {};

  fs = require('fs');

  path = require('path');

  colors = require('colors');

  deep_equal = require('deep-equal');

  urlmod = require('url');

  CHECK = "\u2714";

  BAD_X = "\u2716";

  WAYPOINT = "\u2611";

  exports.File = File = (function() {
    function File(name, runner) {
      this.name = name;
      this.runner = runner;
    }

    File.prototype.new_case = function() {
      return new Case(this);
    };

    File.prototype.default_init = function(cb) {
      return cb(true);
    };

    File.prototype.default_destroy = function(cb) {
      return cb(true);
    };

    File.prototype.test_error_message = function(m) {
      return this.runner.test_error_message(m);
    };

    File.prototype.waypoint = function(m) {
      return this.runner.waypoint(m);
    };

    return File;

  })();

  exports.Case = Case = (function() {
    function Case(file) {
      this.file = file;
      this._ok = true;
    }

    Case.prototype.search = function(s, re, msg) {
      return this.assert((s != null) && s.search(re) >= 0, msg);
    };

    Case.prototype.assert = function(f, what) {
      if (!f) {
        this.error("Assertion failed: " + what);
        return this._ok = false;
      }
    };

    Case.prototype.equal = function(a, b, what) {
      var ja, jb, _ref;
      if (!deep_equal(a, b)) {
        _ref = [JSON.stringify(a), JSON.stringify(b)], ja = _ref[0], jb = _ref[1];
        this.error("In " + what + ": " + ja + " != " + jb);
        return this._ok = false;
      }
    };

    Case.prototype.error = function(e) {
      this.file.test_error_message(e);
      return this._ok = false;
    };

    Case.prototype.is_ok = function() {
      return this._ok;
    };

    Case.prototype.waypoint = function(m) {
      return this.file.waypoint(m);
    };

    return Case;

  })();

  Runner = (function() {
    function Runner() {
      this._files = [];
      this._launches = 0;
      this._tests = 0;
      this._successes = 0;
      this._rc = 0;
      this._n_files = 0;
      this._n_good_files = 0;
    }

    Runner.prototype.run_files = function(cb) {
      var f, ___iced_passed_deferral, __iced_deferrals, __iced_k,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      (function(__iced_k) {
        var _i, _len, _ref, _results, _while;
        _ref = _this._files;
        _len = _ref.length;
        _i = 0;
        _results = [];
        _while = function(__iced_k) {
          var _break, _continue, _next;
          _break = function() {
            return __iced_k(_results);
          };
          _continue = function() {
            return iced.trampoline(function() {
              ++_i;
              return _while(__iced_k);
            });
          };
          _next = function(__iced_next_arg) {
            _results.push(__iced_next_arg);
            return _continue();
          };
          if (!(_i < _len)) {
            return _break();
          } else {
            f = _ref[_i];
            (function(__iced_k) {
              __iced_deferrals = new iced.Deferrals(__iced_k, {
                parent: ___iced_passed_deferral,
                filename: "index.iced",
                funcname: "Runner.run_files"
              });
              _this.run_file(f, __iced_deferrals.defer({
                lineno: 84
              }));
              __iced_deferrals._fulfill();
            })(_next);
          }
        };
        _while(__iced_k);
      })(function() {
        return cb();
      });
    };

    Runner.prototype.new_file_obj = function(fn) {
      return new File(fn, this);
    };

    Runner.prototype.run_code = function(fn, code, cb) {
      var C, destroy, err, fo, k, ok, v, ___iced_passed_deferral, __iced_deferrals, __iced_k,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      fo = this.new_file_obj(fn);
      (function(__iced_k) {
        if (code.init != null) {
          (function(__iced_k) {
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              filename: "index.iced",
              funcname: "Runner.run_code"
            });
            code.init(fo.new_case(), __iced_deferrals.defer({
              assign_fn: (function() {
                return function() {
                  return err = arguments[0];
                };
              })(),
              lineno: 97
            }));
            __iced_deferrals._fulfill();
          })(__iced_k);
        } else {
          (function(__iced_k) {
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              filename: "index.iced",
              funcname: "Runner.run_code"
            });
            fo.default_init(__iced_deferrals.defer({
              assign_fn: (function() {
                return function() {
                  return ok = arguments[0];
                };
              })(),
              lineno: 99
            }));
            __iced_deferrals._fulfill();
          })(function() {
            return __iced_k(!ok ? err = "failed to run default init" : void 0);
          });
        }
      })(function() {
        destroy = code.destroy;
        delete code["init"];
        delete code["destroy"];
        _this._n_files++;
        (function(__iced_k) {
          if (err) {
            return __iced_k(_this.err("Failed to initialize file " + fn + ": " + err));
          } else {
            _this._n_good_files++;
            (function(__iced_k) {
              var _i, _k, _keys, _ref, _results, _while;
              _ref = code;
              _keys = (function() {
                var _results1;
                _results1 = [];
                for (_k in _ref) {
                  _results1.push(_k);
                }
                return _results1;
              })();
              _i = 0;
              _results = [];
              _while = function(__iced_k) {
                var _break, _continue, _next;
                _break = function() {
                  return __iced_k(_results);
                };
                _continue = function() {
                  return iced.trampoline(function() {
                    ++_i;
                    return _while(__iced_k);
                  });
                };
                _next = function(__iced_next_arg) {
                  _results.push(__iced_next_arg);
                  return _continue();
                };
                if (!(_i < _keys.length)) {
                  return _break();
                } else {
                  k = _keys[_i];
                  v = _ref[k];
                  _this._tests++;
                  C = fo.new_case();
                  (function(__iced_k) {
                    __iced_deferrals = new iced.Deferrals(__iced_k, {
                      parent: ___iced_passed_deferral,
                      filename: "index.iced",
                      funcname: "Runner.run_code"
                    });
                    v(C, __iced_deferrals.defer({
                      assign_fn: (function() {
                        return function() {
                          return err = arguments[0];
                        };
                      })(),
                      lineno: 114
                    }));
                    __iced_deferrals._fulfill();
                  })(function() {
                    return _next(err ? _this.err("In " + fn + "/" + k + ": " + err) : C.is_ok() ? (_this._successes++, _this.report_good_outcome("" + CHECK + " " + fn + ": " + k)) : _this.report_bad_outcome("" + BAD_X + " " + fn + ": " + k));
                  });
                }
              };
              _while(__iced_k);
            })(__iced_k);
          }
        })(function() {
          (function(__iced_k) {
            if (destroy != null) {
              (function(__iced_k) {
                __iced_deferrals = new iced.Deferrals(__iced_k, {
                  parent: ___iced_passed_deferral,
                  filename: "index.iced",
                  funcname: "Runner.run_code"
                });
                destroy(fo.new_case(), __iced_deferrals.defer({
                  lineno: 124
                }));
                __iced_deferrals._fulfill();
              })(__iced_k);
            } else {
              (function(__iced_k) {
                __iced_deferrals = new iced.Deferrals(__iced_k, {
                  parent: ___iced_passed_deferral,
                  filename: "index.iced",
                  funcname: "Runner.run_code"
                });
                fo.default_destroy(__iced_deferrals.defer({
                  lineno: 126
                }));
                __iced_deferrals._fulfill();
              })(__iced_k);
            }
          })(function() {
            return cb();
          });
        });
      });
    };

    Runner.prototype.report = function() {
      var opts;
      if (this._rc < 0) {
        this.err("" + BAD_X + " Failure due to test configuration issues");
      }
      if (this._tests !== this._successes) {
        this._rc = -1;
      }
      opts = this._rc === 0 ? {
        green: true
      } : {
        red: true
      };
      opts.bold = true;
      this.log("Tests: " + this._successes + "/" + this._tests + " passed", opts);
      if (this._n_files !== this._n_good_files) {
        this.err(" -> Only " + this._n_good_files + "/" + this._n_files + " files ran properly", {
          bold: true
        });
      }
      return this._rc;
    };

    Runner.prototype.err = function(e, opts) {
      if (opts == null) {
        opts = {};
      }
      opts.red = true;
      this.log(e, opts);
      return this._rc = -1;
    };

    Runner.prototype.waypoint = function(txt) {
      return this.log("  " + WAYPOINT + " " + txt, {
        green: true
      });
    };

    Runner.prototype.report_good_outcome = function(txt) {
      return this.log(txt, {
        green: true
      });
    };

    Runner.prototype.report_bad_outcome = function(txt) {
      return this.log(txt, {
        red: true,
        bold: true
      });
    };

    Runner.prototype.test_error_message = function(txt) {
      return this.log("- " + txt, {
        red: true
      });
    };

    Runner.prototype.init = function(cb) {
      return cb(true);
    };

    Runner.prototype.finish = function(cb) {
      return cb(true);
    };

    return Runner;

  })();

  exports.ServerRunner = ServerRunner = (function(_super) {
    __extends(ServerRunner, _super);

    function ServerRunner() {
      ServerRunner.__super__.constructor.call(this);
    }

    ServerRunner.prototype.run_file = function(f, cb) {
      var dat, e, m, ___iced_passed_deferral, __iced_deferrals, __iced_k,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      (function(__iced_k) {
        try {
          m = path.resolve(_this._dir, f);
          dat = require(m);
          if (dat.skip == null) {
            (function(__iced_k) {
              __iced_deferrals = new iced.Deferrals(__iced_k, {
                parent: ___iced_passed_deferral,
                filename: "index.iced",
                funcname: "ServerRunner.run_file"
              });
              _this.run_code(f, dat, __iced_deferrals.defer({
                lineno: 186
              }));
              __iced_deferrals._fulfill();
            })(__iced_k);
          } else {
            return __iced_k();
          }
        } catch (_error) {
          e = _error;
          return _this.err("In reading " + m + ": " + e + "\n" + e.stack);
        }
      })(function() {
        return cb();
      });
    };

    ServerRunner.prototype.log = function(msg, _arg) {
      var bold, green, red;
      green = _arg.green, red = _arg.red, bold = _arg.bold;
      if (green) {
        msg = msg.green;
      }
      if (bold) {
        msg = msg.bold;
      }
      if (red) {
        msg = msg.red;
      }
      return console.log(msg);
    };

    ServerRunner.prototype.load_files = function(_arg, cb) {
      var base, err, file, files, files_dir, k, mainfile, ok, re, whitelist, wld, ___iced_passed_deferral, __iced_deferrals, __iced_k, _i, _len,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      mainfile = _arg.mainfile, whitelist = _arg.whitelist, files_dir = _arg.files_dir;
      wld = null;
      if (whitelist != null) {
        wld = {};
        for (_i = 0, _len = whitelist.length; _i < _len; _i++) {
          k = whitelist[_i];
          wld[k] = true;
        }
      }
      this._dir = path.dirname(mainfile);
      if (files_dir != null) {
        this._dir = path.join(this._dir, files_dir);
      }
      base = path.basename(mainfile);
      (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: "index.iced",
          funcname: "ServerRunner.load_files"
        });
        fs.readdir(_this._dir, __iced_deferrals.defer({
          assign_fn: (function() {
            return function() {
              err = arguments[0];
              return files = arguments[1];
            };
          })(),
          lineno: 211
        }));
        __iced_deferrals._fulfill();
      })(function() {
        var _j, _len1;
        if (typeof err !== "undefined" && err !== null) {
          ok = false;
          _this.err("In reading " + _this._dir + ": " + err);
        } else {
          ok = true;
          re = /.*\.(iced|coffee)$/;
          for (_j = 0, _len1 = files.length; _j < _len1; _j++) {
            file = files[_j];
            if (file.match(re) && (file !== base) && ((wld == null) || wld[file])) {
              _this._files.push(file);
            }
          }
          _this._files.sort();
        }
        return cb(ok);
      });
    };

    ServerRunner.prototype.report_good_outcome = function(msg) {
      return console.log(msg.green);
    };

    ServerRunner.prototype.report_bad_outcome = function(msg) {
      return console.log(msg.bold.red);
    };

    ServerRunner.prototype.run = function(opts, cb) {
      var ok, ___iced_passed_deferral, __iced_deferrals, __iced_k,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: "index.iced",
          funcname: "ServerRunner.run"
        });
        _this.init(__iced_deferrals.defer({
          assign_fn: (function() {
            return function() {
              return ok = arguments[0];
            };
          })(),
          lineno: 231
        }));
        __iced_deferrals._fulfill();
      })(function() {
        (function(__iced_k) {
          if (ok) {
            (function(__iced_k) {
              __iced_deferrals = new iced.Deferrals(__iced_k, {
                parent: ___iced_passed_deferral,
                filename: "index.iced",
                funcname: "ServerRunner.run"
              });
              _this.load_files(opts, __iced_deferrals.defer({
                assign_fn: (function() {
                  return function() {
                    return ok = arguments[0];
                  };
                })(),
                lineno: 232
              }));
              __iced_deferrals._fulfill();
            })(__iced_k);
          } else {
            return __iced_k();
          }
        })(function() {
          (function(__iced_k) {
            if (ok) {
              (function(__iced_k) {
                __iced_deferrals = new iced.Deferrals(__iced_k, {
                  parent: ___iced_passed_deferral,
                  filename: "index.iced",
                  funcname: "ServerRunner.run"
                });
                _this.run_files(__iced_deferrals.defer({
                  lineno: 233
                }));
                __iced_deferrals._fulfill();
              })(__iced_k);
            } else {
              return __iced_k();
            }
          })(function() {
            _this.report();
            (function(__iced_k) {
              __iced_deferrals = new iced.Deferrals(__iced_k, {
                parent: ___iced_passed_deferral,
                filename: "index.iced",
                funcname: "ServerRunner.run"
              });
              _this.finish(__iced_deferrals.defer({
                assign_fn: (function() {
                  return function() {
                    return ok = arguments[0];
                  };
                })(),
                lineno: 235
              }));
              __iced_deferrals._fulfill();
            })(function() {
              return cb(_this._rc);
            });
          });
        });
      });
    };

    return ServerRunner;

  })(Runner);

  $ = function(m) {
    var _ref;
    return typeof window !== "undefined" && window !== null ? (_ref = window.document) != null ? _ref.getElementById(m) : void 0 : void 0;
  };

  exports.BrowserRunner = BrowserRunner = (function(_super) {
    __extends(BrowserRunner, _super);

    function BrowserRunner(divs) {
      this.divs = divs;
      BrowserRunner.__super__.constructor.call(this);
    }

    BrowserRunner.prototype.log = function(m, _arg) {
      var bold, green, k, red, style, style_tag, tag, v;
      red = _arg.red, green = _arg.green, bold = _arg.bold;
      style = {
        margin: "0px"
      };
      if (green) {
        style.color = "green";
      }
      if (red) {
        style.color = "red";
      }
      if (bold) {
        style["font-weight"] = "bold";
      }
      style_tag = ((function() {
        var _results;
        _results = [];
        for (k in style) {
          v = style[k];
          _results.push("" + k + ": " + v);
        }
        return _results;
      })()).join("; ");
      tag = "<p style=\"" + style_tag + "\">" + m + "</p>\n";
      return $(this.divs.log).innerHTML += tag;
    };

    BrowserRunner.prototype.run = function(modules, cb) {
      var k, ok, v, ___iced_passed_deferral, __iced_deferrals, __iced_k,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: "index.iced",
          funcname: "BrowserRunner.run"
        });
        _this.init(__iced_deferrals.defer({
          assign_fn: (function() {
            return function() {
              return ok = arguments[0];
            };
          })(),
          lineno: 264
        }));
        __iced_deferrals._fulfill();
      })(function() {
        (function(__iced_k) {
          var _i, _k, _keys, _ref, _results, _while;
          _ref = modules;
          _keys = (function() {
            var _results1;
            _results1 = [];
            for (_k in _ref) {
              _results1.push(_k);
            }
            return _results1;
          })();
          _i = 0;
          _results = [];
          _while = function(__iced_k) {
            var _break, _continue, _next;
            _break = function() {
              return __iced_k(_results);
            };
            _continue = function() {
              return iced.trampoline(function() {
                ++_i;
                return _while(__iced_k);
              });
            };
            _next = function(__iced_next_arg) {
              _results.push(__iced_next_arg);
              return _continue();
            };
            if (!(_i < _keys.length)) {
              return _break();
            } else {
              k = _keys[_i];
              v = _ref[k];
              if (!v.skip) {
                (function(__iced_k) {
                  __iced_deferrals = new iced.Deferrals(__iced_k, {
                    parent: ___iced_passed_deferral,
                    filename: "index.iced",
                    funcname: "BrowserRunner.run"
                  });
                  _this.run_code(k, v, __iced_deferrals.defer({
                    assign_fn: (function() {
                      return function() {
                        return ok = arguments[0];
                      };
                    })(),
                    lineno: 266
                  }));
                  __iced_deferrals._fulfill();
                })(_next);
              } else {
                return _continue();
              }
            }
          };
          _while(__iced_k);
        })(function() {
          _this.report();
          (function(__iced_k) {
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              filename: "index.iced",
              funcname: "BrowserRunner.run"
            });
            _this.finish(__iced_deferrals.defer({
              assign_fn: (function() {
                return function() {
                  return ok = arguments[0];
                };
              })(),
              lineno: 268
            }));
            __iced_deferrals._fulfill();
          })(function() {
            $(_this.divs.rc).innerHTML = _this._rc;
            return cb(_this._rc);
          });
        });
      });
    };

    return BrowserRunner;

  })(Runner);

  exports.run = function(_arg) {
    var files_dir, klass, mainfile, rc, runner, whitelist, ___iced_passed_deferral, __iced_deferrals, __iced_k,
      _this = this;
    __iced_k = __iced_k_noop;
    ___iced_passed_deferral = iced.findDeferral(arguments);
    mainfile = _arg.mainfile, klass = _arg.klass, whitelist = _arg.whitelist, files_dir = _arg.files_dir;
    if (klass == null) {
      klass = ServerRunner;
    }
    runner = new klass();
    (function(__iced_k) {
      __iced_deferrals = new iced.Deferrals(__iced_k, {
        parent: ___iced_passed_deferral,
        filename: "index.iced",
        funcname: "run"
      });
      runner.run({
        mainfile: mainfile,
        whitelist: whitelist,
        files_dir: files_dir
      }, __iced_deferrals.defer({
        assign_fn: (function() {
          return function() {
            return rc = arguments[0];
          };
        })(),
        lineno: 277
      }));
      __iced_deferrals._fulfill();
    })(function() {
      return process.exit(rc);
    });
  };

}).call(this);

/*
//@ sourceMappingURL=index.map
*/

},{"__browserify_process":19,"colors":20,"deep-equal":21,"fs":10,"iced-coffee-script/lib/coffee-script/iced":22,"path":11,"url":13}],25:[function(require,module,exports){
(function (){ 
	 // _compat first because it should come first in the output.
	 var compat;
	 if (typeof window !== "undefined" && window !== null) {
	 	compat = {
	 		local_storage_get : function (k) {
	 			return window.localStorage.getItem(k)
	 		},
	 		local_storage_set : function (k,v) {
	 			return window.localStorage.setItem(k,v);
	 		},
	 		get_random_byte : function () {
	 			var buf = new Uint8Array(1);
	 			window.crypto.getRandomValues(buf);
	 			return buf[0];
	 		},
	 		get_random_uint32 : function () {
	 			var buf = new Uint32Array(1);
	 			window.crypto.getRandomValues(buf);
	 			return buf[0];
	 		},
	 		html_encode : function (message) {
	 			if (message == null)
	 				return "";
	 			return $('<div/>').text(message).html();
	 		},
	 		print_debug : function (str) {
	 			str = compat.html_encode(str);
	 			compat.showMessages("<tt><p style=\"background-color: #ffffff; width: 652px; word-break: break-word; padding: 5px; border-bottom: 1px solid black;\">"+str.replace(/\n/g,"<br>")+"</p></tt>");
	 		},
	 		print_error : function (str) {
	 			str = openpgp_encoding_html_encode(str);
	 			compat.showMessages("<p style=\"font-size: 80%; background-color: #FF8888; margin:0; width: 652px; word-break: break-word; padding: 5px; border-bottom: 1px solid black;\"><span style=\"color: #888;\"><b>ERROR:</b></span>	"+str.replace(/\n/g,"<br>")+"</p>");
	 		},
	 		print_info : function (str) {
	 			str = openpgp_encoding_html_encode(str);
	 			compat.showMessages("<p style=\"font-size: 80%; background-color: #88FF88; margin:0; width: 652px; word-break: break-word; padding: 5px; border-bottom: 1px solid black;\"><span style=\"color: #888;\"><b>INFO:</b></span>	"+str.replace(/\n/g,"<br>")+"</p>");
	 		},
	 		print_warning : function (str) {
	 			str = openpgp_encoding_html_encode(str);
	 			compat.showMessages("<p style=\"font-size: 80%; background-color: #FFAA88; margin:0; width: 652px; word-break: break-word; padding: 5px; border-bottom: 1px solid black;\"><span style=\"color: #888;\"><b>WARNING:</b></span>	"+str.replace(/\n/g,"<br>")+"</p>");
	 		},
	 		showMessages : function (m) {
	 			// Not advised. Test classes should make this better, like by
	 			// dumping HTML into a <div>..</div> of some sort.
	 			console.log(m);
	 		},
	 		get_navigator : function () { return navigator; }
	 	};
	 };
	 
	 if (typeof window === "undefined" || window === null) {
	   	var crypto_mod = require('cry' + 'pto');
	   	var _store = {};
	 	compat = {
	 		local_storage_get : function (k) { return _store[k] || null; },
	 		local_storage_set : function (k,v) { return (_store[k] = v); },
	 		get_random_byte : function () {
	 			var buf = crypto_mod.rng(1);
	 			return buf.readUInt8(0);
	 		},
	 		get_random_uint32 : function () {
	 			var buf = crypto_mod.rng(1);
	 			return buf.readUint8(0);
	 		},
	 		html_encode : function (msg) { return msg; },
	 		print_debug : function (msg) { console.log("D " + msg); },
	 		print_error : function (msg) { console.log("E " + msg); },
	 		print_info : function (msg)  { console.log("I " + msg); },
	 		print_warning : function (msg) { console.log("W " + msg); },
	 		get_navigator : function () { return { appName : "node" }; }
	 
	 	};
	 };
	 
	 // GPG4Browsers - An OpenPGP implementation in javascript
	 // Copyright (C) 2011 Recurity Labs GmbH
	 // 
	 // This library is free software; you can redistribute it and/or
	 // modify it under the terms of the GNU Lesser General Public
	 // License as published by the Free Software Foundation; either
	 // version 2.1 of the License, or (at your option) any later version.
	 // 
	 // This library is distributed in the hope that it will be useful,
	 // but WITHOUT ANY WARRANTY; without even the implied warranty of
	 // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
	 // Lesser General Public License for more details.
	 // 
	 // You should have received a copy of the GNU Lesser General Public
	 // License along with this library; if not, write to the Free Software
	 // Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
	 //
	 // A Digital signature algorithm implementation
	 
	 function DSA() {
	 	// s1 = ((g**s) mod p) mod q
	 	// s1 = ((s**-1)*(sha-1(m)+(s1*x) mod q)
	 	function sign(hashalgo, m, g, p, q, x) {
	 		// If the output size of the chosen hash is larger than the number of
	 		// bits of q, the hash result is truncated to fit by taking the number
	 		// of leftmost bits equal to the number of bits of q.  This (possibly
	 		// truncated) hash function result is treated as a number and used
	 		// directly in the DSA signature algorithm.
	 		var hashed_data = util.getLeftNBits(openpgp_crypto_hashData(hashalgo,m),q.bitLength());
	 		var hash = new BigInteger(util.hexstrdump(hashed_data), 16);
	 		var k = openpgp_crypto_getRandomBigIntegerInRange(BigInteger.ONE.add(BigInteger.ONE), q.subtract(BigInteger.ONE));
	 		var s1 = (g.modPow(k,p)).mod(q); 
	 		var s2 = (k.modInverse(q).multiply(hash.add(x.multiply(s1)))).mod(q);
	 		var result = new Array();
	 		result[0] = s1.toMPI();
	 		result[1] = s2.toMPI();
	 		return result;
	 	}
	 	function select_hash_algorithm(q) {
	 		var usersetting = openpgp.config.config.prefer_hash_algorithm;
	 		/*
	 		 * 1024-bit key, 160-bit q, SHA-1, SHA-224, SHA-256, SHA-384, or SHA-512 hash
	 		 * 2048-bit key, 224-bit q, SHA-224, SHA-256, SHA-384, or SHA-512 hash
	 		 * 2048-bit key, 256-bit q, SHA-256, SHA-384, or SHA-512 hash
	 		 * 3072-bit key, 256-bit q, SHA-256, SHA-384, or SHA-512 hash
	 		 */
	 		switch (Math.round(q.bitLength() / 8)) {
	 		case 20: // 1024 bit
	 			if (usersetting != 2 &&
	 				usersetting > 11 &&
	 				usersetting != 10 &&
	 				usersetting < 8)
	 				return 2; // prefer sha1
	 			return usersetting;
	 		case 28: // 2048 bit
	 			if (usersetting > 11 &&
	 					usersetting < 8)
	 					return 11;
	 			return usersetting;
	 		case 32: // 4096 bit // prefer sha224
	 			if (usersetting > 10 &&
	 					usersetting < 8)
	 					return 8; // prefer sha256
	 			return usersetting;
	 		default:
	 			util.print_debug("DSA select hash algorithm: returning null for an unknown length of q");
	 			return null;
	 			
	 		}
	 	}
	 	this.select_hash_algorithm = select_hash_algorithm;
	 	
	 	function verify(hashalgo, s1,s2,m,p,q,g,y) {
	 		var hashed_data = util.getLeftNBits(openpgp_crypto_hashData(hashalgo,m),q.bitLength());
	 		var hash = new BigInteger(util.hexstrdump(hashed_data), 16); 
	 		if (BigInteger.ZERO.compareTo(s1) > 0 ||
	 				s1.compareTo(q) > 0 ||
	 				BigInteger.ZERO.compareTo(s2) > 0 ||
	 				s2.compareTo(q) > 0) {
	 			util.print_error("invalid DSA Signature");
	 			return null;
	 		}
	 		var w = s2.modInverse(q);
	 		var u1 = hash.multiply(w).mod(q);
	 		var u2 = s1.multiply(w).mod(q);
	 		return g.modPow(u1,p).multiply(y.modPow(u2,p)).mod(p).mod(q);
	 	}
	 	
	 	/*
	 	 * unused code. This can be used as a start to write a key generator
	 	 * function.
	 	
	 	function generateKey(bitcount) {
	 	    var qi = new BigInteger(bitcount, primeCenterie);
	 	    var pi = generateP(q, 512);
	 	    var gi = generateG(p, q, bitcount);
	 	    var xi;
	 	    do {
	 	        xi = new BigInteger(q.bitCount(), rand);
	 	    } while (x.compareTo(BigInteger.ZERO) != 1 && x.compareTo(q) != -1);
	 	    var yi = g.modPow(x, p);
	 	    return {x: xi, q: qi, p: pi, g: gi, y: yi};
	 	}
	 
	 	function generateP(q, bitlength, randomfn) {
	 	    if (bitlength % 64 != 0) {
	 	    	return false;
	 	    }
	 	    var pTemp;
	 	    var pTemp2;
	 	    do {
	 	        pTemp = randomfn(bitcount, true);
	 	        pTemp2 = pTemp.subtract(BigInteger.ONE);
	 	        pTemp = pTemp.subtract(pTemp2.remainder(q));
	 	    } while (!pTemp.isProbablePrime(primeCenterie) || pTemp.bitLength() != l);
	 	    return pTemp;
	 	}
	 	
	 	function generateG(p, q, bitlength, randomfn) {
	 	    var aux = p.subtract(BigInteger.ONE);
	 	    var pow = aux.divide(q);
	 	    var gTemp;
	 	    do {
	 	        gTemp = randomfn(bitlength);
	 	    } while (gTemp.compareTo(aux) != -1 && gTemp.compareTo(BigInteger.ONE) != 1);
	 	    return gTemp.modPow(pow, p);
	 	}
	 
	 	function generateK(q, bitlength, randomfn) {
	 	    var tempK;
	 	    do {
	 	        tempK = randomfn(bitlength, false);
	 	    } while (tempK.compareTo(q) != -1 && tempK.compareTo(BigInteger.ZERO) != 1);
	 	    return tempK;
	 	}
	 
	 	function generateR(q,p) {
	 	    k = generateK(q);
	 	    var r = g.modPow(k, p).mod(q);
	 	    return r;
	 	}
	 
	 	function generateS(hashfn,k,r,m,q,x) {
	         var hash = hashfn(m);
	         s = (k.modInverse(q).multiply(hash.add(x.multiply(r)))).mod(q);
	 	    return s;
	 	} */
	 	this.sign = sign;
	 	this.verify = verify;
	 	// this.generate = generateKey;
	 }
	 // GPG4Browsers - An OpenPGP implementation in javascript
	 // Copyright (C) 2011 Recurity Labs GmbH
	 // 
	 // This library is free software; you can redistribute it and/or
	 // modify it under the terms of the GNU Lesser General Public
	 // License as published by the Free Software Foundation; either
	 // version 2.1 of the License, or (at your option) any later version.
	 // 
	 // This library is distributed in the hope that it will be useful,
	 // but WITHOUT ANY WARRANTY; without even the implied warranty of
	 // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
	 // Lesser General Public License for more details.
	 // 
	 // You should have received a copy of the GNU Lesser General Public
	 // License along with this library; if not, write to the Free Software
	 // Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
	 //
	 // ElGamal implementation
	 
	 function Elgamal() {
	 	
	 	function encrypt(m,g,p,y) {
	 		//  choose k in {2,...,p-2}
	 		var two = BigInteger.ONE.add(BigInteger.ONE);
	 		var pMinus2 = p.subtract(two);
	 		var k = openpgp_crypto_getRandomBigIntegerInRange(two, pMinus2);
	 		var k = k.mod(pMinus2).add(BigInteger.ONE);
	 		var c = new Array();
	 		c[0] = g.modPow(k, p);
	 		c[1] = y.modPow(k, p).multiply(m).mod(p).toMPI();
	 		c[0] = c[0].toMPI();
	 		return c;
	 	}
	 	
	 	function decrypt(c1,c2,p,x) {
	 		util.print_debug("Elgamal Decrypt:\nc1:"+util.hexstrdump(c1.toMPI())+"\n"+
	 			  "c2:"+util.hexstrdump(c2.toMPI())+"\n"+
	 			  "p:"+util.hexstrdump(p.toMPI())+"\n"+
	 			  "x:"+util.hexstrdump(x.toMPI()));
	 		return (c1.modPow(x, p).modInverse(p)).multiply(c2).mod(p);
	 		//var c = c1.pow(x).modInverse(p); // c0^-a mod p
	 	    //return c.multiply(c2).mod(p);
	 	}
	 	
	 	// signing and signature verification using Elgamal is not required by OpenPGP.
	 	this.encrypt = encrypt;
	 	this.decrypt = decrypt;
	 }/*
	  * Copyright (c) 2003-2005  Tom Wu (tjw@cs.Stanford.EDU) 
	  * All Rights Reserved.
	  *
	  * Modified by Recurity Labs GmbH 
	  * 
	  * Permission is hereby granted, free of charge, to any person obtaining
	  * a copy of this software and associated documentation files (the
	  * "Software"), to deal in the Software without restriction, including
	  * without limitation the rights to use, copy, modify, merge, publish,
	  * distribute, sublicense, and/or sell copies of the Software, and to
	  * permit persons to whom the Software is furnished to do so, subject to
	  * the following conditions:
	  *
	  * The above copyright notice and this permission notice shall be
	  * included in all copies or substantial portions of the Software.
	  *
	  * THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND, 
	  * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY 
	  * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  
	  *
	  * IN NO EVENT SHALL TOM WU BE LIABLE FOR ANY SPECIAL, INCIDENTAL,
	  * INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND, OR ANY DAMAGES WHATSOEVER
	  * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER OR NOT ADVISED OF
	  * THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF LIABILITY, ARISING OUT
	  * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
	  *
	  * In addition, the following condition applies:
	  *
	  * All redistributions must retain an intact copy of this copyright notice
	  * and disclaimer.
	  */
	 
	 // Basic JavaScript BN library - subset useful for RSA encryption.
	 
	 // Bits per digit
	 var dbits;
	 
	 // JavaScript engine analysis
	 var canary = 0xdeadbeefcafe;
	 var j_lm = ((canary&0xffffff)==0xefcafe);
	 
	 // (public) Constructor
	 function BigInteger(a,b,c) {
	   if(a != null)
	     if("number" == typeof a) this.fromNumber(a,b,c);
	     else if(b == null && "string" != typeof a) this.fromString(a,256);
	     else this.fromString(a,b);
	 }
	 
	 // return new, unset BigInteger
	 function nbi() { return new BigInteger(null); }
	 
	 // am: Compute w_j += (x*this_i), propagate carries,
	 // c is initial carry, returns final carry.
	 // c < 3*dvalue, x < 2*dvalue, this_i < dvalue
	 // We need to select the fastest one that works in this environment.
	 
	 // am1: use a single mult and divide to get the high bits,
	 // max digit bits should be 26 because
	 // max internal value = 2*dvalue^2-2*dvalue (< 2^53)
	 function am1(i,x,w,j,c,n) {
	   while(--n >= 0) {
	     var v = x*this[i++]+w[j]+c;
	     c = Math.floor(v/0x4000000);
	     w[j++] = v&0x3ffffff;
	   }
	   return c;
	 }
	 // am2 avoids a big mult-and-extract completely.
	 // Max digit bits should be <= 30 because we do bitwise ops
	 // on values up to 2*hdvalue^2-hdvalue-1 (< 2^31)
	 function am2(i,x,w,j,c,n) {
	   var xl = x&0x7fff, xh = x>>15;
	   while(--n >= 0) {
	     var l = this[i]&0x7fff;
	     var h = this[i++]>>15;
	     var m = xh*l+h*xl;
	     l = xl*l+((m&0x7fff)<<15)+w[j]+(c&0x3fffffff);
	     c = (l>>>30)+(m>>>15)+xh*h+(c>>>30);
	     w[j++] = l&0x3fffffff;
	   }
	   return c;
	 }
	 // Alternately, set max digit bits to 28 since some
	 // browsers slow down when dealing with 32-bit numbers.
	 function am3(i,x,w,j,c,n) {
	   var xl = x&0x3fff, xh = x>>14;
	   while(--n >= 0) {
	     var l = this[i]&0x3fff;
	     var h = this[i++]>>14;
	     var m = xh*l+h*xl;
	     l = xl*l+((m&0x3fff)<<14)+w[j]+c;
	     c = (l>>28)+(m>>14)+xh*h;
	     w[j++] = l&0xfffffff;
	   }
	   return c;
	 }
	 
	 // Chrome seems to prefer this...
	 BigInteger.prototype.am = am3;
	 dbits = 28;
	 
	 BigInteger.prototype.DB = dbits;
	 BigInteger.prototype.DM = ((1<<dbits)-1);
	 BigInteger.prototype.DV = (1<<dbits);
	 
	 var BI_FP = 52;
	 BigInteger.prototype.FV = Math.pow(2,BI_FP);
	 BigInteger.prototype.F1 = BI_FP-dbits;
	 BigInteger.prototype.F2 = 2*dbits-BI_FP;
	 
	 // Digit conversions
	 var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";
	 var BI_RC = new Array();
	 var rr,vv;
	 rr = "0".charCodeAt(0);
	 for(vv = 0; vv <= 9; ++vv) BI_RC[rr++] = vv;
	 rr = "a".charCodeAt(0);
	 for(vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;
	 rr = "A".charCodeAt(0);
	 for(vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;
	 
	 function int2char(n) { return BI_RM.charAt(n); }
	 function intAt(s,i) {
	   var c = BI_RC[s.charCodeAt(i)];
	   return (c==null)?-1:c;
	 }
	 
	 // (protected) copy this to r
	 function bnpCopyTo(r) {
	   for(var i = this.t-1; i >= 0; --i) r[i] = this[i];
	   r.t = this.t;
	   r.s = this.s;
	 }
	 
	 // (protected) set from integer value x, -DV <= x < DV
	 function bnpFromInt(x) {
	   this.t = 1;
	   this.s = (x<0)?-1:0;
	   if(x > 0) this[0] = x;
	   else if(x < -1) this[0] = x+DV;
	   else this.t = 0;
	 }
	 
	 // return bigint initialized to value
	 function nbv(i) { var r = nbi(); r.fromInt(i); return r; }
	 
	 // (protected) set from string and radix
	 function bnpFromString(s,b) {
	   var k;
	   if(b == 16) k = 4;
	   else if(b == 8) k = 3;
	   else if(b == 256) k = 8; // byte array
	   else if(b == 2) k = 1;
	   else if(b == 32) k = 5;
	   else if(b == 4) k = 2;
	   else { this.fromRadix(s,b); return; }
	   this.t = 0;
	   this.s = 0;
	   var i = s.length, mi = false, sh = 0;
	   while(--i >= 0) {
	     var x = (k==8)?s[i]&0xff:intAt(s,i);
	     if(x < 0) {
	       if(s.charAt(i) == "-") mi = true;
	       continue;
	     }
	     mi = false;
	     if(sh == 0)
	       this[this.t++] = x;
	     else if(sh+k > this.DB) {
	       this[this.t-1] |= (x&((1<<(this.DB-sh))-1))<<sh;
	       this[this.t++] = (x>>(this.DB-sh));
	     }
	     else
	       this[this.t-1] |= x<<sh;
	     sh += k;
	     if(sh >= this.DB) sh -= this.DB;
	   }
	   if(k == 8 && (s[0]&0x80) != 0) {
	     this.s = -1;
	     if(sh > 0) this[this.t-1] |= ((1<<(this.DB-sh))-1)<<sh;
	   }
	   this.clamp();
	   if(mi) BigInteger.ZERO.subTo(this,this);
	 }
	 
	 // (protected) clamp off excess high words
	 function bnpClamp() {
	   var c = this.s&this.DM;
	   while(this.t > 0 && this[this.t-1] == c) --this.t;
	 }
	 
	 // (public) return string representation in given radix
	 function bnToString(b) {
	   if(this.s < 0) return "-"+this.negate().toString(b);
	   var k;
	   if(b == 16) k = 4;
	   else if(b == 8) k = 3;
	   else if(b == 2) k = 1;
	   else if(b == 32) k = 5;
	   else if(b == 4) k = 2;
	   else return this.toRadix(b);
	   var km = (1<<k)-1, d, m = false, r = "", i = this.t;
	   var p = this.DB-(i*this.DB)%k;
	   if(i-- > 0) {
	     if(p < this.DB && (d = this[i]>>p) > 0) { m = true; r = int2char(d); }
	     while(i >= 0) {
	       if(p < k) {
	         d = (this[i]&((1<<p)-1))<<(k-p);
	         d |= this[--i]>>(p+=this.DB-k);
	       }
	       else {
	         d = (this[i]>>(p-=k))&km;
	         if(p <= 0) { p += this.DB; --i; }
	       }
	       if(d > 0) m = true;
	       if(m) r += int2char(d);
	     }
	   }
	   return m?r:"0";
	 }
	 
	 // (public) -this
	 function bnNegate() { var r = nbi(); BigInteger.ZERO.subTo(this,r); return r; }
	 
	 // (public) |this|
	 function bnAbs() { return (this.s<0)?this.negate():this; }
	 
	 // (public) return + if this > a, - if this < a, 0 if equal
	 function bnCompareTo(a) {
	   var r = this.s-a.s;
	   if(r != 0) return r;
	   var i = this.t;
	   r = i-a.t;
	   if(r != 0) return r;
	   while(--i >= 0) if((r=this[i]-a[i]) != 0) return r;
	   return 0;
	 }
	 
	 // returns bit length of the integer x
	 function nbits(x) {
	   var r = 1, t;
	   if((t=x>>>16) != 0) { x = t; r += 16; }
	   if((t=x>>8) != 0) { x = t; r += 8; }
	   if((t=x>>4) != 0) { x = t; r += 4; }
	   if((t=x>>2) != 0) { x = t; r += 2; }
	   if((t=x>>1) != 0) { x = t; r += 1; }
	   return r;
	 }
	 
	 // (public) return the number of bits in "this"
	 function bnBitLength() {
	   if(this.t <= 0) return 0;
	   return this.DB*(this.t-1)+nbits(this[this.t-1]^(this.s&this.DM));
	 }
	 
	 // (protected) r = this << n*DB
	 function bnpDLShiftTo(n,r) {
	   var i;
	   for(i = this.t-1; i >= 0; --i) r[i+n] = this[i];
	   for(i = n-1; i >= 0; --i) r[i] = 0;
	   r.t = this.t+n;
	   r.s = this.s;
	 }
	 
	 // (protected) r = this >> n*DB
	 function bnpDRShiftTo(n,r) {
	   for(var i = n; i < this.t; ++i) r[i-n] = this[i];
	   r.t = Math.max(this.t-n,0);
	   r.s = this.s;
	 }
	 
	 // (protected) r = this << n
	 function bnpLShiftTo(n,r) {
	   var bs = n%this.DB;
	   var cbs = this.DB-bs;
	   var bm = (1<<cbs)-1;
	   var ds = Math.floor(n/this.DB), c = (this.s<<bs)&this.DM, i;
	   for(i = this.t-1; i >= 0; --i) {
	     r[i+ds+1] = (this[i]>>cbs)|c;
	     c = (this[i]&bm)<<bs;
	   }
	   for(i = ds-1; i >= 0; --i) r[i] = 0;
	   r[ds] = c;
	   r.t = this.t+ds+1;
	   r.s = this.s;
	   r.clamp();
	 }
	 
	 // (protected) r = this >> n
	 function bnpRShiftTo(n,r) {
	   r.s = this.s;
	   var ds = Math.floor(n/this.DB);
	   if(ds >= this.t) { r.t = 0; return; }
	   var bs = n%this.DB;
	   var cbs = this.DB-bs;
	   var bm = (1<<bs)-1;
	   r[0] = this[ds]>>bs;
	   for(var i = ds+1; i < this.t; ++i) {
	     r[i-ds-1] |= (this[i]&bm)<<cbs;
	     r[i-ds] = this[i]>>bs;
	   }
	   if(bs > 0) r[this.t-ds-1] |= (this.s&bm)<<cbs;
	   r.t = this.t-ds;
	   r.clamp();
	 }
	 
	 // (protected) r = this - a
	 function bnpSubTo(a,r) {
	   var i = 0, c = 0, m = Math.min(a.t,this.t);
	   while(i < m) {
	     c += this[i]-a[i];
	     r[i++] = c&this.DM;
	     c >>= this.DB;
	   }
	   if(a.t < this.t) {
	     c -= a.s;
	     while(i < this.t) {
	       c += this[i];
	       r[i++] = c&this.DM;
	       c >>= this.DB;
	     }
	     c += this.s;
	   }
	   else {
	     c += this.s;
	     while(i < a.t) {
	       c -= a[i];
	       r[i++] = c&this.DM;
	       c >>= this.DB;
	     }
	     c -= a.s;
	   }
	   r.s = (c<0)?-1:0;
	   if(c < -1) r[i++] = this.DV+c;
	   else if(c > 0) r[i++] = c;
	   r.t = i;
	   r.clamp();
	 }
	 
	 // (protected) r = this * a, r != this,a (HAC 14.12)
	 // "this" should be the larger one if appropriate.
	 function bnpMultiplyTo(a,r) {
	   var x = this.abs(), y = a.abs();
	   var i = x.t;
	   r.t = i+y.t;
	   while(--i >= 0) r[i] = 0;
	   for(i = 0; i < y.t; ++i) r[i+x.t] = x.am(0,y[i],r,i,0,x.t);
	   r.s = 0;
	   r.clamp();
	   if(this.s != a.s) BigInteger.ZERO.subTo(r,r);
	 }
	 
	 // (protected) r = this^2, r != this (HAC 14.16)
	 function bnpSquareTo(r) {
	   var x = this.abs();
	   var i = r.t = 2*x.t;
	   while(--i >= 0) r[i] = 0;
	   for(i = 0; i < x.t-1; ++i) {
	     var c = x.am(i,x[i],r,2*i,0,1);
	     if((r[i+x.t]+=x.am(i+1,2*x[i],r,2*i+1,c,x.t-i-1)) >= x.DV) {
	       r[i+x.t] -= x.DV;
	       r[i+x.t+1] = 1;
	     }
	   }
	   if(r.t > 0) r[r.t-1] += x.am(i,x[i],r,2*i,0,1);
	   r.s = 0;
	   r.clamp();
	 }
	 
	 // (protected) divide this by m, quotient and remainder to q, r (HAC 14.20)
	 // r != q, this != m.  q or r may be null.
	 function bnpDivRemTo(m,q,r) {
	   var pm = m.abs();
	   if(pm.t <= 0) return;
	   var pt = this.abs();
	   if(pt.t < pm.t) {
	     if(q != null) q.fromInt(0);
	     if(r != null) this.copyTo(r);
	     return;
	   }
	   if(r == null) r = nbi();
	   var y = nbi(), ts = this.s, ms = m.s;
	   var nsh = this.DB-nbits(pm[pm.t-1]);	// normalize modulus
	   if(nsh > 0) { pm.lShiftTo(nsh,y); pt.lShiftTo(nsh,r); }
	   else { pm.copyTo(y); pt.copyTo(r); }
	   var ys = y.t;
	   var y0 = y[ys-1];
	   if(y0 == 0) return;
	   var yt = y0*(1<<this.F1)+((ys>1)?y[ys-2]>>this.F2:0);
	   var d1 = this.FV/yt, d2 = (1<<this.F1)/yt, e = 1<<this.F2;
	   var i = r.t, j = i-ys, t = (q==null)?nbi():q;
	   y.dlShiftTo(j,t);
	   if(r.compareTo(t) >= 0) {
	     r[r.t++] = 1;
	     r.subTo(t,r);
	   }
	   BigInteger.ONE.dlShiftTo(ys,t);
	   t.subTo(y,y);	// "negative" y so we can replace sub with am later
	   while(y.t < ys) y[y.t++] = 0;
	   while(--j >= 0) {
	     // Estimate quotient digit
	     var qd = (r[--i]==y0)?this.DM:Math.floor(r[i]*d1+(r[i-1]+e)*d2);
	     if((r[i]+=y.am(0,qd,r,j,0,ys)) < qd) {	// Try it out
	       y.dlShiftTo(j,t);
	       r.subTo(t,r);
	       while(r[i] < --qd) r.subTo(t,r);
	     }
	   }
	   if(q != null) {
	     r.drShiftTo(ys,q);
	     if(ts != ms) BigInteger.ZERO.subTo(q,q);
	   }
	   r.t = ys;
	   r.clamp();
	   if(nsh > 0) r.rShiftTo(nsh,r);	// Denormalize remainder
	   if(ts < 0) BigInteger.ZERO.subTo(r,r);
	 }
	 
	 // (public) this mod a
	 function bnMod(a) {
	   var r = nbi();
	   this.abs().divRemTo(a,null,r);
	   if(this.s < 0 && r.compareTo(BigInteger.ZERO) > 0) a.subTo(r,r);
	   return r;
	 }
	 
	 // Modular reduction using "classic" algorithm
	 function Classic(m) { this.m = m; }
	 function cConvert(x) {
	   if(x.s < 0 || x.compareTo(this.m) >= 0) return x.mod(this.m);
	   else return x;
	 }
	 function cRevert(x) { return x; }
	 function cReduce(x) { x.divRemTo(this.m,null,x); }
	 function cMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }
	 function cSqrTo(x,r) { x.squareTo(r); this.reduce(r); }
	 
	 Classic.prototype.convert = cConvert;
	 Classic.prototype.revert = cRevert;
	 Classic.prototype.reduce = cReduce;
	 Classic.prototype.mulTo = cMulTo;
	 Classic.prototype.sqrTo = cSqrTo;
	 
	 // (protected) return "-1/this % 2^DB"; useful for Mont. reduction
	 // justification:
	 //         xy == 1 (mod m)
	 //         xy =  1+km
	 //   xy(2-xy) = (1+km)(1-km)
	 // x[y(2-xy)] = 1-k^2m^2
	 // x[y(2-xy)] == 1 (mod m^2)
	 // if y is 1/x mod m, then y(2-xy) is 1/x mod m^2
	 // should reduce x and y(2-xy) by m^2 at each step to keep size bounded.
	 // JS multiply "overflows" differently from C/C++, so care is needed here.
	 function bnpInvDigit() {
	   if(this.t < 1) return 0;
	   var x = this[0];
	   if((x&1) == 0) return 0;
	   var y = x&3;		// y == 1/x mod 2^2
	   y = (y*(2-(x&0xf)*y))&0xf;	// y == 1/x mod 2^4
	   y = (y*(2-(x&0xff)*y))&0xff;	// y == 1/x mod 2^8
	   y = (y*(2-(((x&0xffff)*y)&0xffff)))&0xffff;	// y == 1/x mod 2^16
	   // last step - calculate inverse mod DV directly;
	   // assumes 16 < DB <= 32 and assumes ability to handle 48-bit ints
	   y = (y*(2-x*y%this.DV))%this.DV;		// y == 1/x mod 2^dbits
	   // we really want the negative inverse, and -DV < y < DV
	   return (y>0)?this.DV-y:-y;
	 }
	 
	 // Montgomery reduction
	 function Montgomery(m) {
	   this.m = m;
	   this.mp = m.invDigit();
	   this.mpl = this.mp&0x7fff;
	   this.mph = this.mp>>15;
	   this.um = (1<<(m.DB-15))-1;
	   this.mt2 = 2*m.t;
	 }
	 
	 // xR mod m
	 function montConvert(x) {
	   var r = nbi();
	   x.abs().dlShiftTo(this.m.t,r);
	   r.divRemTo(this.m,null,r);
	   if(x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) this.m.subTo(r,r);
	   return r;
	 }
	 
	 // x/R mod m
	 function montRevert(x) {
	   var r = nbi();
	   x.copyTo(r);
	   this.reduce(r);
	   return r;
	 }
	 
	 // x = x/R mod m (HAC 14.32)
	 function montReduce(x) {
	   while(x.t <= this.mt2)	// pad x so am has enough room later
	     x[x.t++] = 0;
	   for(var i = 0; i < this.m.t; ++i) {
	     // faster way of calculating u0 = x[i]*mp mod DV
	     var j = x[i]&0x7fff;
	     var u0 = (j*this.mpl+(((j*this.mph+(x[i]>>15)*this.mpl)&this.um)<<15))&x.DM;
	     // use am to combine the multiply-shift-add into one call
	     j = i+this.m.t;
	     x[j] += this.m.am(0,u0,x,i,0,this.m.t);
	     // propagate carry
	     while(x[j] >= x.DV) { x[j] -= x.DV; x[++j]++; }
	   }
	   x.clamp();
	   x.drShiftTo(this.m.t,x);
	   if(x.compareTo(this.m) >= 0) x.subTo(this.m,x);
	 }
	 
	 // r = "x^2/R mod m"; x != r
	 function montSqrTo(x,r) { x.squareTo(r); this.reduce(r); }
	 
	 // r = "xy/R mod m"; x,y != r
	 function montMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }
	 
	 Montgomery.prototype.convert = montConvert;
	 Montgomery.prototype.revert = montRevert;
	 Montgomery.prototype.reduce = montReduce;
	 Montgomery.prototype.mulTo = montMulTo;
	 Montgomery.prototype.sqrTo = montSqrTo;
	 
	 // (protected) true iff this is even
	 function bnpIsEven() { return ((this.t>0)?(this[0]&1):this.s) == 0; }
	 
	 // (protected) this^e, e < 2^32, doing sqr and mul with "r" (HAC 14.79)
	 function bnpExp(e,z) {
	   if(e > 0xffffffff || e < 1) return BigInteger.ONE;
	   var r = nbi(), r2 = nbi(), g = z.convert(this), i = nbits(e)-1;
	   g.copyTo(r);
	   while(--i >= 0) {
	     z.sqrTo(r,r2);
	     if((e&(1<<i)) > 0) z.mulTo(r2,g,r);
	     else { var t = r; r = r2; r2 = t; }
	   }
	   return z.revert(r);
	 }
	 
	 // (public) this^e % m, 0 <= e < 2^32
	 function bnModPowInt(e,m) {
	   var z;
	   if(e < 256 || m.isEven()) z = new Classic(m); else z = new Montgomery(m);
	   return this.exp(e,z);
	 }
	 
	 // protected
	 BigInteger.prototype.copyTo = bnpCopyTo;
	 BigInteger.prototype.fromInt = bnpFromInt;
	 BigInteger.prototype.fromString = bnpFromString;
	 BigInteger.prototype.clamp = bnpClamp;
	 BigInteger.prototype.dlShiftTo = bnpDLShiftTo;
	 BigInteger.prototype.drShiftTo = bnpDRShiftTo;
	 BigInteger.prototype.lShiftTo = bnpLShiftTo;
	 BigInteger.prototype.rShiftTo = bnpRShiftTo;
	 BigInteger.prototype.subTo = bnpSubTo;
	 BigInteger.prototype.multiplyTo = bnpMultiplyTo;
	 BigInteger.prototype.squareTo = bnpSquareTo;
	 BigInteger.prototype.divRemTo = bnpDivRemTo;
	 BigInteger.prototype.invDigit = bnpInvDigit;
	 BigInteger.prototype.isEven = bnpIsEven;
	 BigInteger.prototype.exp = bnpExp;
	 
	 // public
	 BigInteger.prototype.toString = bnToString;
	 BigInteger.prototype.negate = bnNegate;
	 BigInteger.prototype.abs = bnAbs;
	 BigInteger.prototype.compareTo = bnCompareTo;
	 BigInteger.prototype.bitLength = bnBitLength;
	 BigInteger.prototype.mod = bnMod;
	 BigInteger.prototype.modPowInt = bnModPowInt;
	 
	 // "constants"
	 BigInteger.ZERO = nbv(0);
	 BigInteger.ONE = nbv(1);
	 
	 /*
	  * Copyright (c) 2003-2005  Tom Wu (tjw@cs.Stanford.EDU) 
	  * All Rights Reserved.
	  *
	  * Modified by Recurity Labs GmbH
	  *
	  * Permission is hereby granted, free of charge, to any person obtaining
	  * a copy of this software and associated documentation files (the
	  * "Software"), to deal in the Software without restriction, including
	  * without limitation the rights to use, copy, modify, merge, publish,
	  * distribute, sublicense, and/or sell copies of the Software, and to
	  * permit persons to whom the Software is furnished to do so, subject to
	  * the following conditions:
	  *
	  * The above copyright notice and this permission notice shall be
	  * included in all copies or substantial portions of the Software.
	  *
	  * THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND, 
	  * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY 
	  * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  
	  *
	  * IN NO EVENT SHALL TOM WU BE LIABLE FOR ANY SPECIAL, INCIDENTAL,
	  * INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND, OR ANY DAMAGES WHATSOEVER
	  * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER OR NOT ADVISED OF
	  * THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF LIABILITY, ARISING OUT
	  * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
	  *
	  * In addition, the following condition applies:
	  *
	  * All redistributions must retain an intact copy of this copyright notice
	  * and disclaimer.
	  */
	 // Extended JavaScript BN functions, required for RSA private ops.
	 
	 // Version 1.1: new BigInteger("0", 10) returns "proper" zero
	 // Version 1.2: square() API, isProbablePrime fix
	 
	 // (public)
	 function bnClone() { var r = nbi(); this.copyTo(r); return r; }
	 
	 // (public) return value as integer
	 function bnIntValue() {
	   if(this.s < 0) {
	     if(this.t == 1) return this[0]-this.DV;
	     else if(this.t == 0) return -1;
	   }
	   else if(this.t == 1) return this[0];
	   else if(this.t == 0) return 0;
	   // assumes 16 < DB < 32
	   return ((this[1]&((1<<(32-this.DB))-1))<<this.DB)|this[0];
	 }
	 
	 // (public) return value as byte
	 function bnByteValue() { return (this.t==0)?this.s:(this[0]<<24)>>24; }
	 
	 // (public) return value as short (assumes DB>=16)
	 function bnShortValue() { return (this.t==0)?this.s:(this[0]<<16)>>16; }
	 
	 // (protected) return x s.t. r^x < DV
	 function bnpChunkSize(r) { return Math.floor(Math.LN2*this.DB/Math.log(r)); }
	 
	 // (public) 0 if this == 0, 1 if this > 0
	 function bnSigNum() {
	   if(this.s < 0) return -1;
	   else if(this.t <= 0 || (this.t == 1 && this[0] <= 0)) return 0;
	   else return 1;
	 }
	 
	 // (protected) convert to radix string
	 function bnpToRadix(b) {
	   if(b == null) b = 10;
	   if(this.signum() == 0 || b < 2 || b > 36) return "0";
	   var cs = this.chunkSize(b);
	   var a = Math.pow(b,cs);
	   var d = nbv(a), y = nbi(), z = nbi(), r = "";
	   this.divRemTo(d,y,z);
	   while(y.signum() > 0) {
	     r = (a+z.intValue()).toString(b).substr(1) + r;
	     y.divRemTo(d,y,z);
	   }
	   return z.intValue().toString(b) + r;
	 }
	 
	 // (protected) convert from radix string
	 function bnpFromRadix(s,b) {
	   this.fromInt(0);
	   if(b == null) b = 10;
	   var cs = this.chunkSize(b);
	   var d = Math.pow(b,cs), mi = false, j = 0, w = 0;
	   for(var i = 0; i < s.length; ++i) {
	     var x = intAt(s,i);
	     if(x < 0) {
	       if(s.charAt(i) == "-" && this.signum() == 0) mi = true;
	       continue;
	     }
	     w = b*w+x;
	     if(++j >= cs) {
	       this.dMultiply(d);
	       this.dAddOffset(w,0);
	       j = 0;
	       w = 0;
	     }
	   }
	   if(j > 0) {
	     this.dMultiply(Math.pow(b,j));
	     this.dAddOffset(w,0);
	   }
	   if(mi) BigInteger.ZERO.subTo(this,this);
	 }
	 
	 // (protected) alternate constructor
	 function bnpFromNumber(a,b,c) {
	   if("number" == typeof b) {
	     // new BigInteger(int,int,RNG)
	     if(a < 2) this.fromInt(1);
	     else {
	       this.fromNumber(a,c);
	       if(!this.testBit(a-1))	// force MSB set
	         this.bitwiseTo(BigInteger.ONE.shiftLeft(a-1),op_or,this);
	       if(this.isEven()) this.dAddOffset(1,0); // force odd
	       while(!this.isProbablePrime(b)) {
	         this.dAddOffset(2,0);
	         if(this.bitLength() > a) this.subTo(BigInteger.ONE.shiftLeft(a-1),this);
	       }
	     }
	   }
	   else {
	     // new BigInteger(int,RNG)
	     var x = new Array(), t = a&7;
	     x.length = (a>>3)+1;
	     b.nextBytes(x);
	     if(t > 0) x[0] &= ((1<<t)-1); else x[0] = 0;
	     this.fromString(x,256);
	   }
	 }
	 
	 // (public) convert to bigendian byte array
	 function bnToByteArray() {
	   var i = this.t, r = new Array();
	   r[0] = this.s;
	   var p = this.DB-(i*this.DB)%8, d, k = 0;
	   if(i-- > 0) {
	     if(p < this.DB && (d = this[i]>>p) != (this.s&this.DM)>>p)
	       r[k++] = d|(this.s<<(this.DB-p));
	     while(i >= 0) {
	       if(p < 8) {
	         d = (this[i]&((1<<p)-1))<<(8-p);
	         d |= this[--i]>>(p+=this.DB-8);
	       }
	       else {
	         d = (this[i]>>(p-=8))&0xff;
	         if(p <= 0) { p += this.DB; --i; }
	       }
	       //if((d&0x80) != 0) d |= -256;
	       //if(k == 0 && (this.s&0x80) != (d&0x80)) ++k;
	       if(k > 0 || d != this.s) r[k++] = d;
	     }
	   }
	   return r;
	 }
	 
	 function bnEquals(a) { return(this.compareTo(a)==0); }
	 function bnMin(a) { return(this.compareTo(a)<0)?this:a; }
	 function bnMax(a) { return(this.compareTo(a)>0)?this:a; }
	 
	 // (protected) r = this op a (bitwise)
	 function bnpBitwiseTo(a,op,r) {
	   var i, f, m = Math.min(a.t,this.t);
	   for(i = 0; i < m; ++i) r[i] = op(this[i],a[i]);
	   if(a.t < this.t) {
	     f = a.s&this.DM;
	     for(i = m; i < this.t; ++i) r[i] = op(this[i],f);
	     r.t = this.t;
	   }
	   else {
	     f = this.s&this.DM;
	     for(i = m; i < a.t; ++i) r[i] = op(f,a[i]);
	     r.t = a.t;
	   }
	   r.s = op(this.s,a.s);
	   r.clamp();
	 }
	 
	 // (public) this & a
	 function op_and(x,y) { return x&y; }
	 function bnAnd(a) { var r = nbi(); this.bitwiseTo(a,op_and,r); return r; }
	 
	 // (public) this | a
	 function op_or(x,y) { return x|y; }
	 function bnOr(a) { var r = nbi(); this.bitwiseTo(a,op_or,r); return r; }
	 
	 // (public) this ^ a
	 function op_xor(x,y) { return x^y; }
	 function bnXor(a) { var r = nbi(); this.bitwiseTo(a,op_xor,r); return r; }
	 
	 // (public) this & ~a
	 function op_andnot(x,y) { return x&~y; }
	 function bnAndNot(a) { var r = nbi(); this.bitwiseTo(a,op_andnot,r); return r; }
	 
	 // (public) ~this
	 function bnNot() {
	   var r = nbi();
	   for(var i = 0; i < this.t; ++i) r[i] = this.DM&~this[i];
	   r.t = this.t;
	   r.s = ~this.s;
	   return r;
	 }
	 
	 // (public) this << n
	 function bnShiftLeft(n) {
	   var r = nbi();
	   if(n < 0) this.rShiftTo(-n,r); else this.lShiftTo(n,r);
	   return r;
	 }
	 
	 // (public) this >> n
	 function bnShiftRight(n) {
	   var r = nbi();
	   if(n < 0) this.lShiftTo(-n,r); else this.rShiftTo(n,r);
	   return r;
	 }
	 
	 // return index of lowest 1-bit in x, x < 2^31
	 function lbit(x) {
	   if(x == 0) return -1;
	   var r = 0;
	   if((x&0xffff) == 0) { x >>= 16; r += 16; }
	   if((x&0xff) == 0) { x >>= 8; r += 8; }
	   if((x&0xf) == 0) { x >>= 4; r += 4; }
	   if((x&3) == 0) { x >>= 2; r += 2; }
	   if((x&1) == 0) ++r;
	   return r;
	 }
	 
	 // (public) returns index of lowest 1-bit (or -1 if none)
	 function bnGetLowestSetBit() {
	   for(var i = 0; i < this.t; ++i)
	     if(this[i] != 0) return i*this.DB+lbit(this[i]);
	   if(this.s < 0) return this.t*this.DB;
	   return -1;
	 }
	 
	 // return number of 1 bits in x
	 function cbit(x) {
	   var r = 0;
	   while(x != 0) { x &= x-1; ++r; }
	   return r;
	 }
	 
	 // (public) return number of set bits
	 function bnBitCount() {
	   var r = 0, x = this.s&this.DM;
	   for(var i = 0; i < this.t; ++i) r += cbit(this[i]^x);
	   return r;
	 }
	 
	 // (public) true iff nth bit is set
	 function bnTestBit(n) {
	   var j = Math.floor(n/this.DB);
	   if(j >= this.t) return(this.s!=0);
	   return((this[j]&(1<<(n%this.DB)))!=0);
	 }
	 
	 // (protected) this op (1<<n)
	 function bnpChangeBit(n,op) {
	   var r = BigInteger.ONE.shiftLeft(n);
	   this.bitwiseTo(r,op,r);
	   return r;
	 }
	 
	 // (public) this | (1<<n)
	 function bnSetBit(n) { return this.changeBit(n,op_or); }
	 
	 // (public) this & ~(1<<n)
	 function bnClearBit(n) { return this.changeBit(n,op_andnot); }
	 
	 // (public) this ^ (1<<n)
	 function bnFlipBit(n) { return this.changeBit(n,op_xor); }
	 
	 // (protected) r = this + a
	 function bnpAddTo(a,r) {
	   var i = 0, c = 0, m = Math.min(a.t,this.t);
	   while(i < m) {
	     c += this[i]+a[i];
	     r[i++] = c&this.DM;
	     c >>= this.DB;
	   }
	   if(a.t < this.t) {
	     c += a.s;
	     while(i < this.t) {
	       c += this[i];
	       r[i++] = c&this.DM;
	       c >>= this.DB;
	     }
	     c += this.s;
	   }
	   else {
	     c += this.s;
	     while(i < a.t) {
	       c += a[i];
	       r[i++] = c&this.DM;
	       c >>= this.DB;
	     }
	     c += a.s;
	   }
	   r.s = (c<0)?-1:0;
	   if(c > 0) r[i++] = c;
	   else if(c < -1) r[i++] = this.DV+c;
	   r.t = i;
	   r.clamp();
	 }
	 
	 // (public) this + a
	 function bnAdd(a) { var r = nbi(); this.addTo(a,r); return r; }
	 
	 // (public) this - a
	 function bnSubtract(a) { var r = nbi(); this.subTo(a,r); return r; }
	 
	 // (public) this * a
	 function bnMultiply(a) { var r = nbi(); this.multiplyTo(a,r); return r; }
	 
	 // (public) this^2
	 function bnSquare() { var r = nbi(); this.squareTo(r); return r; }
	 
	 // (public) this / a
	 function bnDivide(a) { var r = nbi(); this.divRemTo(a,r,null); return r; }
	 
	 // (public) this % a
	 function bnRemainder(a) { var r = nbi(); this.divRemTo(a,null,r); return r; }
	 
	 // (public) [this/a,this%a]
	 function bnDivideAndRemainder(a) {
	   var q = nbi(), r = nbi();
	   this.divRemTo(a,q,r);
	   return new Array(q,r);
	 }
	 
	 // (protected) this *= n, this >= 0, 1 < n < DV
	 function bnpDMultiply(n) {
	   this[this.t] = this.am(0,n-1,this,0,0,this.t);
	   ++this.t;
	   this.clamp();
	 }
	 
	 // (protected) this += n << w words, this >= 0
	 function bnpDAddOffset(n,w) {
	   if(n == 0) return;
	   while(this.t <= w) this[this.t++] = 0;
	   this[w] += n;
	   while(this[w] >= this.DV) {
	     this[w] -= this.DV;
	     if(++w >= this.t) this[this.t++] = 0;
	     ++this[w];
	   }
	 }
	 
	 // A "null" reducer
	 function NullExp() {}
	 function nNop(x) { return x; }
	 function nMulTo(x,y,r) { x.multiplyTo(y,r); }
	 function nSqrTo(x,r) { x.squareTo(r); }
	 
	 NullExp.prototype.convert = nNop;
	 NullExp.prototype.revert = nNop;
	 NullExp.prototype.mulTo = nMulTo;
	 NullExp.prototype.sqrTo = nSqrTo;
	 
	 // (public) this^e
	 function bnPow(e) { return this.exp(e,new NullExp()); }
	 
	 // (protected) r = lower n words of "this * a", a.t <= n
	 // "this" should be the larger one if appropriate.
	 function bnpMultiplyLowerTo(a,n,r) {
	   var i = Math.min(this.t+a.t,n);
	   r.s = 0; // assumes a,this >= 0
	   r.t = i;
	   while(i > 0) r[--i] = 0;
	   var j;
	   for(j = r.t-this.t; i < j; ++i) r[i+this.t] = this.am(0,a[i],r,i,0,this.t);
	   for(j = Math.min(a.t,n); i < j; ++i) this.am(0,a[i],r,i,0,n-i);
	   r.clamp();
	 }
	 
	 // (protected) r = "this * a" without lower n words, n > 0
	 // "this" should be the larger one if appropriate.
	 function bnpMultiplyUpperTo(a,n,r) {
	   --n;
	   var i = r.t = this.t+a.t-n;
	   r.s = 0; // assumes a,this >= 0
	   while(--i >= 0) r[i] = 0;
	   for(i = Math.max(n-this.t,0); i < a.t; ++i)
	     r[this.t+i-n] = this.am(n-i,a[i],r,0,0,this.t+i-n);
	   r.clamp();
	   r.drShiftTo(1,r);
	 }
	 
	 // Barrett modular reduction
	 function Barrett(m) {
	   // setup Barrett
	   this.r2 = nbi();
	   this.q3 = nbi();
	   BigInteger.ONE.dlShiftTo(2*m.t,this.r2);
	   this.mu = this.r2.divide(m);
	   this.m = m;
	 }
	 
	 function barrettConvert(x) {
	   if(x.s < 0 || x.t > 2*this.m.t) return x.mod(this.m);
	   else if(x.compareTo(this.m) < 0) return x;
	   else { var r = nbi(); x.copyTo(r); this.reduce(r); return r; }
	 }
	 
	 function barrettRevert(x) { return x; }
	 
	 // x = x mod m (HAC 14.42)
	 function barrettReduce(x) {
	   x.drShiftTo(this.m.t-1,this.r2);
	   if(x.t > this.m.t+1) { x.t = this.m.t+1; x.clamp(); }
	   this.mu.multiplyUpperTo(this.r2,this.m.t+1,this.q3);
	   this.m.multiplyLowerTo(this.q3,this.m.t+1,this.r2);
	   while(x.compareTo(this.r2) < 0) x.dAddOffset(1,this.m.t+1);
	   x.subTo(this.r2,x);
	   while(x.compareTo(this.m) >= 0) x.subTo(this.m,x);
	 }
	 
	 // r = x^2 mod m; x != r
	 function barrettSqrTo(x,r) { x.squareTo(r); this.reduce(r); }
	 
	 // r = x*y mod m; x,y != r
	 function barrettMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }
	 
	 Barrett.prototype.convert = barrettConvert;
	 Barrett.prototype.revert = barrettRevert;
	 Barrett.prototype.reduce = barrettReduce;
	 Barrett.prototype.mulTo = barrettMulTo;
	 Barrett.prototype.sqrTo = barrettSqrTo;
	 
	 // (public) this^e % m (HAC 14.85)
	 function bnModPow(e,m) {
	   var i = e.bitLength(), k, r = nbv(1), z;
	   if(i <= 0) return r;
	   else if(i < 18) k = 1;
	   else if(i < 48) k = 3;
	   else if(i < 144) k = 4;
	   else if(i < 768) k = 5;
	   else k = 6;
	   if(i < 8)
	     z = new Classic(m);
	   else if(m.isEven())
	     z = new Barrett(m);
	   else
	     z = new Montgomery(m);
	 
	   // precomputation
	   var g = new Array(), n = 3, k1 = k-1, km = (1<<k)-1;
	   g[1] = z.convert(this);
	   if(k > 1) {
	     var g2 = nbi();
	     z.sqrTo(g[1],g2);
	     while(n <= km) {
	       g[n] = nbi();
	       z.mulTo(g2,g[n-2],g[n]);
	       n += 2;
	     }
	   }
	 
	   var j = e.t-1, w, is1 = true, r2 = nbi(), t;
	   i = nbits(e[j])-1;
	   while(j >= 0) {
	     if(i >= k1) w = (e[j]>>(i-k1))&km;
	     else {
	       w = (e[j]&((1<<(i+1))-1))<<(k1-i);
	       if(j > 0) w |= e[j-1]>>(this.DB+i-k1);
	     }
	 
	     n = k;
	     while((w&1) == 0) { w >>= 1; --n; }
	     if((i -= n) < 0) { i += this.DB; --j; }
	     if(is1) {	// ret == 1, don't bother squaring or multiplying it
	       g[w].copyTo(r);
	       is1 = false;
	     }
	     else {
	       while(n > 1) { z.sqrTo(r,r2); z.sqrTo(r2,r); n -= 2; }
	       if(n > 0) z.sqrTo(r,r2); else { t = r; r = r2; r2 = t; }
	       z.mulTo(r2,g[w],r);
	     }
	 
	     while(j >= 0 && (e[j]&(1<<i)) == 0) {
	       z.sqrTo(r,r2); t = r; r = r2; r2 = t;
	       if(--i < 0) { i = this.DB-1; --j; }
	     }
	   }
	   return z.revert(r);
	 }
	 
	 // (public) gcd(this,a) (HAC 14.54)
	 function bnGCD(a) {
	   var x = (this.s<0)?this.negate():this.clone();
	   var y = (a.s<0)?a.negate():a.clone();
	   if(x.compareTo(y) < 0) { var t = x; x = y; y = t; }
	   var i = x.getLowestSetBit(), g = y.getLowestSetBit();
	   if(g < 0) return x;
	   if(i < g) g = i;
	   if(g > 0) {
	     x.rShiftTo(g,x);
	     y.rShiftTo(g,y);
	   }
	   while(x.signum() > 0) {
	     if((i = x.getLowestSetBit()) > 0) x.rShiftTo(i,x);
	     if((i = y.getLowestSetBit()) > 0) y.rShiftTo(i,y);
	     if(x.compareTo(y) >= 0) {
	       x.subTo(y,x);
	       x.rShiftTo(1,x);
	     }
	     else {
	       y.subTo(x,y);
	       y.rShiftTo(1,y);
	     }
	   }
	   if(g > 0) y.lShiftTo(g,y);
	   return y;
	 }
	 
	 // (protected) this % n, n < 2^26
	 function bnpModInt(n) {
	   if(n <= 0) return 0;
	   var d = this.DV%n, r = (this.s<0)?n-1:0;
	   if(this.t > 0)
	     if(d == 0) r = this[0]%n;
	     else for(var i = this.t-1; i >= 0; --i) r = (d*r+this[i])%n;
	   return r;
	 }
	 
	 // (public) 1/this % m (HAC 14.61)
	 function bnModInverse(m) {
	   var ac = m.isEven();
	   if((this.isEven() && ac) || m.signum() == 0) return BigInteger.ZERO;
	   var u = m.clone(), v = this.clone();
	   var a = nbv(1), b = nbv(0), c = nbv(0), d = nbv(1);
	   while(u.signum() != 0) {
	     while(u.isEven()) {
	       u.rShiftTo(1,u);
	       if(ac) {
	         if(!a.isEven() || !b.isEven()) { a.addTo(this,a); b.subTo(m,b); }
	         a.rShiftTo(1,a);
	       }
	       else if(!b.isEven()) b.subTo(m,b);
	       b.rShiftTo(1,b);
	     }
	     while(v.isEven()) {
	       v.rShiftTo(1,v);
	       if(ac) {
	         if(!c.isEven() || !d.isEven()) { c.addTo(this,c); d.subTo(m,d); }
	         c.rShiftTo(1,c);
	       }
	       else if(!d.isEven()) d.subTo(m,d);
	       d.rShiftTo(1,d);
	     }
	     if(u.compareTo(v) >= 0) {
	       u.subTo(v,u);
	       if(ac) a.subTo(c,a);
	       b.subTo(d,b);
	     }
	     else {
	       v.subTo(u,v);
	       if(ac) c.subTo(a,c);
	       d.subTo(b,d);
	     }
	   }
	   if(v.compareTo(BigInteger.ONE) != 0) return BigInteger.ZERO;
	   if(d.compareTo(m) >= 0) return d.subtract(m);
	   if(d.signum() < 0) d.addTo(m,d); else return d;
	   if(d.signum() < 0) return d.add(m); else return d;
	 }
	 
	 var lowprimes = [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997];
	 var lplim = (1<<26)/lowprimes[lowprimes.length-1];
	 
	 // (public) test primality with certainty >= 1-.5^t
	 function bnIsProbablePrime(t) {
	   var i, x = this.abs();
	   if(x.t == 1 && x[0] <= lowprimes[lowprimes.length-1]) {
	     for(i = 0; i < lowprimes.length; ++i)
	       if(x[0] == lowprimes[i]) return true;
	     return false;
	   }
	   if(x.isEven()) return false;
	   i = 1;
	   while(i < lowprimes.length) {
	     var m = lowprimes[i], j = i+1;
	     while(j < lowprimes.length && m < lplim) m *= lowprimes[j++];
	     m = x.modInt(m);
	     while(i < j) if(m%lowprimes[i++] == 0) return false;
	   }
	   return x.millerRabin(t);
	 }
	 
	 /* added by Recurity Labs */
	 
	 function nbits(x) {
	 	var n = 1, t;
	 	if ((t = x >>> 16) != 0) {
	 		x = t;
	 		n += 16;
	 	}
	 	if ((t = x >> 8) != 0) {
	 		x = t;
	 		n += 8;
	 	}
	 	if ((t = x >> 4) != 0) {
	 		x = t;
	 		n += 4;
	 	}
	 	if ((t = x >> 2) != 0) {
	 		x = t;
	 		n += 2;
	 	}
	 	if ((t = x >> 1) != 0) {
	 		x = t;
	 		n += 1;
	 	}
	 	return n;
	 }
	 
	 function bnToMPI () {
	 	var ba = this.toByteArray();
	 	var size = (ba.length-1)*8+nbits(ba[0]);
	 	var result = "";
	 	result += String.fromCharCode((size & 0xFF00) >> 8);
	 	result += String.fromCharCode(size & 0xFF);
	 	result += util.bin2str(ba);
	 	return result;
	 }
	 /* END of addition */
	 
	 // (protected) true if probably prime (HAC 4.24, Miller-Rabin)
	 function bnpMillerRabin(t) {
	   var n1 = this.subtract(BigInteger.ONE);
	   var k = n1.getLowestSetBit();
	   if(k <= 0) return false;
	   var r = n1.shiftRight(k);
	   t = (t+1)>>1;
	   if(t > lowprimes.length) t = lowprimes.length;
	   var a = nbi();
	   for(var i = 0; i < t; ++i) {
	     //Pick bases at random, instead of starting at 2
	     a.fromInt(lowprimes[Math.floor(Math.random()*lowprimes.length)]);
	     var y = a.modPow(r,this);
	     if(y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0) {
	       var j = 1;
	       while(j++ < k && y.compareTo(n1) != 0) {
	         y = y.modPowInt(2,this);
	         if(y.compareTo(BigInteger.ONE) == 0) return false;
	       }
	       if(y.compareTo(n1) != 0) return false;
	     }
	   }
	   return true;
	 }
	 
	 // protected
	 BigInteger.prototype.chunkSize = bnpChunkSize;
	 BigInteger.prototype.toRadix = bnpToRadix;
	 BigInteger.prototype.fromRadix = bnpFromRadix;
	 BigInteger.prototype.fromNumber = bnpFromNumber;
	 BigInteger.prototype.bitwiseTo = bnpBitwiseTo;
	 BigInteger.prototype.changeBit = bnpChangeBit;
	 BigInteger.prototype.addTo = bnpAddTo;
	 BigInteger.prototype.dMultiply = bnpDMultiply;
	 BigInteger.prototype.dAddOffset = bnpDAddOffset;
	 BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;
	 BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;
	 BigInteger.prototype.modInt = bnpModInt;
	 BigInteger.prototype.millerRabin = bnpMillerRabin;
	 
	 // public
	 BigInteger.prototype.clone = bnClone;
	 BigInteger.prototype.intValue = bnIntValue;
	 BigInteger.prototype.byteValue = bnByteValue;
	 BigInteger.prototype.shortValue = bnShortValue;
	 BigInteger.prototype.signum = bnSigNum;
	 BigInteger.prototype.toByteArray = bnToByteArray;
	 BigInteger.prototype.equals = bnEquals;
	 BigInteger.prototype.min = bnMin;
	 BigInteger.prototype.max = bnMax;
	 BigInteger.prototype.and = bnAnd;
	 BigInteger.prototype.or = bnOr;
	 BigInteger.prototype.xor = bnXor;
	 BigInteger.prototype.andNot = bnAndNot;
	 BigInteger.prototype.not = bnNot;
	 BigInteger.prototype.shiftLeft = bnShiftLeft;
	 BigInteger.prototype.shiftRight = bnShiftRight;
	 BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;
	 BigInteger.prototype.bitCount = bnBitCount;
	 BigInteger.prototype.testBit = bnTestBit;
	 BigInteger.prototype.setBit = bnSetBit;
	 BigInteger.prototype.clearBit = bnClearBit;
	 BigInteger.prototype.flipBit = bnFlipBit;
	 BigInteger.prototype.add = bnAdd;
	 BigInteger.prototype.subtract = bnSubtract;
	 BigInteger.prototype.multiply = bnMultiply;
	 BigInteger.prototype.divide = bnDivide;
	 BigInteger.prototype.remainder = bnRemainder;
	 BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;
	 BigInteger.prototype.modPow = bnModPow;
	 BigInteger.prototype.modInverse = bnModInverse;
	 BigInteger.prototype.pow = bnPow;
	 BigInteger.prototype.gcd = bnGCD;
	 BigInteger.prototype.isProbablePrime = bnIsProbablePrime;
	 BigInteger.prototype.toMPI = bnToMPI;
	 
	 // JSBN-specific extension
	 BigInteger.prototype.square = bnSquare;
	 // GPG4Browsers - An OpenPGP implementation in javascript
	 // Copyright (C) 2011 Recurity Labs GmbH
	 // 
	 // This library is free software; you can redistribute it and/or
	 // modify it under the terms of the GNU Lesser General Public
	 // License as published by the Free Software Foundation; either
	 // version 2.1 of the License, or (at your option) any later version.
	 // 
	 // This library is distributed in the hope that it will be useful,
	 // but WITHOUT ANY WARRANTY; without even the implied warranty of
	 // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
	 // Lesser General Public License for more details.
	 // 
	 // You should have received a copy of the GNU Lesser General Public
	 // License along with this library; if not, write to the Free Software
	 // Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
	 //
	 // RSA implementation
	 
	 function SecureRandom(){
	     function nextBytes(byteArray){
	         for(var n = 0; n < byteArray.length;n++){
	             byteArray[n] = openpgp_crypto_getSecureRandomOctet();
	         }
	     }
	     this.nextBytes = nextBytes;
	 }
	 
	 function RSA() {
	 	/**
	 	 * This function uses jsbn Big Num library to decrypt RSA
	 	 * @param m
	 	 *            message
	 	 * @param d
	 	 *            RSA d as BigInteger
	 	 * @param p
	 	 *            RSA p as BigInteger
	 	 * @param q
	 	 *            RSA q as BigInteger
	 	 * @param u
	 	 *            RSA u as BigInteger
	 	 * @return {BigInteger} The decrypted value of the message
	 	 */
	 	function decrypt(m, d, p, q, u) {
	 		var xp = m.mod(p).modPow(d.mod(p.subtract(BigInteger.ONE)), p);
	 		var xq = m.mod(q).modPow(d.mod(q.subtract(BigInteger.ONE)), q);
	 		util.print_debug("rsa.js decrypt\nxpn:"+util.hexstrdump(xp.toMPI())+"\nxqn:"+util.hexstrdump(xq.toMPI()));
	 
	 		var t = xq.subtract(xp);
	 		if (t[0] == 0) {
	 			t = xp.subtract(xq);
	 			t = t.multiply(u).mod(q);
	 			t = q.subtract(t);
	 		} else {
	 			t = t.multiply(u).mod(q);
	 		}
	 		return t.multiply(p).add(xp);
	 	}
	 	
	 	/**
	 	 * encrypt message
	 	 * @param m message as BigInteger
	 	 * @param e public MPI part as BigInteger
	 	 * @param n public MPI part as BigInteger
	 	 * @return BigInteger
	 	 */
	 	function encrypt(m,e,n) {
	 		return m.modPowInt(e, n);
	 	}
	 	
	 	/* Sign and Verify */
	 	function sign(m,d,n) {
	 		return m.modPow(d, n);
	 	}
	 		
	 	function verify(x,e,n) {
	 		return x.modPowInt(e, n);
	 	}
	 	
	 	// "empty" RSA key constructor
	     function keyObject() {
	         this.n = null;
	         this.e = 0;
	         this.ee = null;
	         this.d = null;
	         this.p = null;
	         this.q = null;
	         this.dmp1 = null;
	         this.dmq1 = null;
	         this.u = null;
	     }
	 	
	 	// Generate a new random private key B bits long, using public expt E
	     function generate(B,E) {
	         var key = new keyObject();
	         var rng = new SecureRandom();
	         var qs = B>>1;
	         key.e = parseInt(E,16);
	         key.ee = new BigInteger(E,16);
	         for(;;) {
	             for(;;) {
	                 key.p = new BigInteger(B-qs,1,rng);
	                 if(key.p.subtract(BigInteger.ONE).gcd(key.ee).compareTo(BigInteger.ONE) == 0 && key.p.isProbablePrime(10)) break;
	             }
	             for(;;) {
	                 key.q = new BigInteger(qs,1,rng);
	                 if(key.q.subtract(BigInteger.ONE).gcd(key.ee).compareTo(BigInteger.ONE) == 0 && key.q.isProbablePrime(10)) break;
	             }
	             if(key.p.compareTo(key.q) <= 0) {
	                 var t = key.p;
	                 key.p = key.q;
	                 key.q = t;
	             }
	             var p1 = key.p.subtract(BigInteger.ONE);
	             var q1 = key.q.subtract(BigInteger.ONE);
	             var phi = p1.multiply(q1);
	             if(phi.gcd(key.ee).compareTo(BigInteger.ONE) == 0) {
	                 key.n = key.p.multiply(key.q);
	                 key.d = key.ee.modInverse(phi);
	                 key.dmp1 = key.d.mod(p1);
	                 key.dmq1 = key.d.mod(q1);
	                 key.u = key.p.modInverse(key.q);
	                 break;
	             }
	         }
	         return key;
	     }
	 		
	 	this.encrypt = encrypt;
	 	this.decrypt = decrypt;
	 	this.verify = verify;
	 	this.sign = sign;
	 	this.generate = generate;
	 	this.keyObject = keyObject;
	 }
	 /**
	  * A fast MD5 JavaScript implementation
	  * Copyright (c) 2012 Joseph Myers
	  * http://www.myersdaily.org/joseph/javascript/md5-text.html
	  *
	  * Permission to use, copy, modify, and distribute this software
	  * and its documentation for any purposes and without
	  * fee is hereby granted provided that this copyright notice
	  * appears in all copies.
	  *
	  * Of course, this soft is provided "as is" without express or implied
	  * warranty of any kind.
	  */
	 
	 function MD5(entree) {
	 	var hex = md5(entree);
	 	var bin = util.hex2bin(hex);
	 	return bin;
	 }
	 
	 function md5cycle(x, k) {
	 var a = x[0], b = x[1], c = x[2], d = x[3];
	 
	 a = ff(a, b, c, d, k[0], 7, -680876936);
	 d = ff(d, a, b, c, k[1], 12, -389564586);
	 c = ff(c, d, a, b, k[2], 17,  606105819);
	 b = ff(b, c, d, a, k[3], 22, -1044525330);
	 a = ff(a, b, c, d, k[4], 7, -176418897);
	 d = ff(d, a, b, c, k[5], 12,  1200080426);
	 c = ff(c, d, a, b, k[6], 17, -1473231341);
	 b = ff(b, c, d, a, k[7], 22, -45705983);
	 a = ff(a, b, c, d, k[8], 7,  1770035416);
	 d = ff(d, a, b, c, k[9], 12, -1958414417);
	 c = ff(c, d, a, b, k[10], 17, -42063);
	 b = ff(b, c, d, a, k[11], 22, -1990404162);
	 a = ff(a, b, c, d, k[12], 7,  1804603682);
	 d = ff(d, a, b, c, k[13], 12, -40341101);
	 c = ff(c, d, a, b, k[14], 17, -1502002290);
	 b = ff(b, c, d, a, k[15], 22,  1236535329);
	 
	 a = gg(a, b, c, d, k[1], 5, -165796510);
	 d = gg(d, a, b, c, k[6], 9, -1069501632);
	 c = gg(c, d, a, b, k[11], 14,  643717713);
	 b = gg(b, c, d, a, k[0], 20, -373897302);
	 a = gg(a, b, c, d, k[5], 5, -701558691);
	 d = gg(d, a, b, c, k[10], 9,  38016083);
	 c = gg(c, d, a, b, k[15], 14, -660478335);
	 b = gg(b, c, d, a, k[4], 20, -405537848);
	 a = gg(a, b, c, d, k[9], 5,  568446438);
	 d = gg(d, a, b, c, k[14], 9, -1019803690);
	 c = gg(c, d, a, b, k[3], 14, -187363961);
	 b = gg(b, c, d, a, k[8], 20,  1163531501);
	 a = gg(a, b, c, d, k[13], 5, -1444681467);
	 d = gg(d, a, b, c, k[2], 9, -51403784);
	 c = gg(c, d, a, b, k[7], 14,  1735328473);
	 b = gg(b, c, d, a, k[12], 20, -1926607734);
	 
	 a = hh(a, b, c, d, k[5], 4, -378558);
	 d = hh(d, a, b, c, k[8], 11, -2022574463);
	 c = hh(c, d, a, b, k[11], 16,  1839030562);
	 b = hh(b, c, d, a, k[14], 23, -35309556);
	 a = hh(a, b, c, d, k[1], 4, -1530992060);
	 d = hh(d, a, b, c, k[4], 11,  1272893353);
	 c = hh(c, d, a, b, k[7], 16, -155497632);
	 b = hh(b, c, d, a, k[10], 23, -1094730640);
	 a = hh(a, b, c, d, k[13], 4,  681279174);
	 d = hh(d, a, b, c, k[0], 11, -358537222);
	 c = hh(c, d, a, b, k[3], 16, -722521979);
	 b = hh(b, c, d, a, k[6], 23,  76029189);
	 a = hh(a, b, c, d, k[9], 4, -640364487);
	 d = hh(d, a, b, c, k[12], 11, -421815835);
	 c = hh(c, d, a, b, k[15], 16,  530742520);
	 b = hh(b, c, d, a, k[2], 23, -995338651);
	 
	 a = ii(a, b, c, d, k[0], 6, -198630844);
	 d = ii(d, a, b, c, k[7], 10,  1126891415);
	 c = ii(c, d, a, b, k[14], 15, -1416354905);
	 b = ii(b, c, d, a, k[5], 21, -57434055);
	 a = ii(a, b, c, d, k[12], 6,  1700485571);
	 d = ii(d, a, b, c, k[3], 10, -1894986606);
	 c = ii(c, d, a, b, k[10], 15, -1051523);
	 b = ii(b, c, d, a, k[1], 21, -2054922799);
	 a = ii(a, b, c, d, k[8], 6,  1873313359);
	 d = ii(d, a, b, c, k[15], 10, -30611744);
	 c = ii(c, d, a, b, k[6], 15, -1560198380);
	 b = ii(b, c, d, a, k[13], 21,  1309151649);
	 a = ii(a, b, c, d, k[4], 6, -145523070);
	 d = ii(d, a, b, c, k[11], 10, -1120210379);
	 c = ii(c, d, a, b, k[2], 15,  718787259);
	 b = ii(b, c, d, a, k[9], 21, -343485551);
	 
	 x[0] = add32(a, x[0]);
	 x[1] = add32(b, x[1]);
	 x[2] = add32(c, x[2]);
	 x[3] = add32(d, x[3]);
	 
	 }
	 
	 function cmn(q, a, b, x, s, t) {
	 a = add32(add32(a, q), add32(x, t));
	 return add32((a << s) | (a >>> (32 - s)), b);
	 }
	 
	 function ff(a, b, c, d, x, s, t) {
	 return cmn((b & c) | ((~b) & d), a, b, x, s, t);
	 }
	 
	 function gg(a, b, c, d, x, s, t) {
	 return cmn((b & d) | (c & (~d)), a, b, x, s, t);
	 }
	 
	 function hh(a, b, c, d, x, s, t) {
	 return cmn(b ^ c ^ d, a, b, x, s, t);
	 }
	 
	 function ii(a, b, c, d, x, s, t) {
	 return cmn(c ^ (b | (~d)), a, b, x, s, t);
	 }
	 
	 function md51(s) {
	 txt = '';
	 var n = s.length,
	 state = [1732584193, -271733879, -1732584194, 271733878], i;
	 for (i=64; i<=s.length; i+=64) {
	 md5cycle(state, md5blk(s.substring(i-64, i)));
	 }
	 s = s.substring(i-64);
	 var tail = [0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0];
	 for (i=0; i<s.length; i++)
	 tail[i>>2] |= s.charCodeAt(i) << ((i%4) << 3);
	 tail[i>>2] |= 0x80 << ((i%4) << 3);
	 if (i > 55) {
	 md5cycle(state, tail);
	 for (i=0; i<16; i++) tail[i] = 0;
	 }
	 tail[14] = n*8;
	 md5cycle(state, tail);
	 return state;
	 }
	 
	 /* there needs to be support for Unicode here,
	  * unless we pretend that we can redefine the MD-5
	  * algorithm for multi-byte characters (perhaps
	  * by adding every four 16-bit characters and
	  * shortening the sum to 32 bits). Otherwise
	  * I suggest performing MD-5 as if every character
	  * was two bytes--e.g., 0040 0025 = @%--but then
	  * how will an ordinary MD-5 sum be matched?
	  * There is no way to standardize text to something
	  * like UTF-8 before transformation; speed cost is
	  * utterly prohibitive. The JavaScript standard
	  * itself needs to look at this: it should start
	  * providing access to strings as preformed UTF-8
	  * 8-bit unsigned value arrays.
	  */
	 function md5blk(s) { /* I figured global was faster.   */
	 var md5blks = [], i; /* Andy King said do it this way. */
	 for (i=0; i<64; i+=4) {
	 md5blks[i>>2] = s.charCodeAt(i)
	 + (s.charCodeAt(i+1) << 8)
	 + (s.charCodeAt(i+2) << 16)
	 + (s.charCodeAt(i+3) << 24);
	 }
	 return md5blks;
	 }
	 
	 var hex_chr = '0123456789abcdef'.split('');
	 
	 function rhex(n)
	 {
	 var s='', j=0;
	 for(; j<4; j++)
	 s += hex_chr[(n >> (j * 8 + 4)) & 0x0F]
	 + hex_chr[(n >> (j * 8)) & 0x0F];
	 return s;
	 }
	 
	 function hex(x) {
	 for (var i=0; i<x.length; i++)
	 x[i] = rhex(x[i]);
	 return x.join('');
	 }
	 
	 function md5(s) {
	 return hex(md51(s));
	 }
	 
	 /* this function is much faster,
	 so if possible we use it. Some IEs
	 are the only ones I know of that
	 need the idiotic second function,
	 generated by an if clause.  */
	 
	 function add32(a, b) {
	 return (a + b) & 0xFFFFFFFF;
	 }
	 
	 if (md5('hello') != '5d41402abc4b2a76b9719d911017c592') {
	 function add32(x, y) {
	 var lsw = (x & 0xFFFF) + (y & 0xFFFF),
	 msw = (x >> 16) + (y >> 16) + (lsw >> 16);
	 return (msw << 16) | (lsw & 0xFFFF);
	 }
	 }
	 /*
	  * CryptoMX Tools
	  * Copyright (C) 2004 - 2006 Derek Buitenhuis
	  *
	  * This program is free software; you can redistribute it and/or
	  * modify it under the terms of the GNU General Public License
	  * as published by the Free Software Foundation; either version 2
	  * of the License, or (at your option) any later version.
	  *
	  * This program is distributed in the hope that it will be useful,
	  * but WITHOUT ANY WARRANTY; without even the implied warranty of
	  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	  * GNU General Public License for more details.
	  *
	  * You should have received a copy of the GNU General Public License
	  * along with this program; if not, write to the Free Software
	  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
	  */
	 
	 /* Modified by Recurity Labs GmbH
	  */
	 
	 var RMDsize   = 160;
	 var X = new Array();
	 
	 function ROL(x, n)
	 {
	   return new Number ((x << n) | ( x >>> (32 - n)));
	 }
	 
	 function F(x, y, z)
	 {
	   return new Number(x ^ y ^ z);
	 }
	 
	 function G(x, y, z)
	 {
	   return new Number((x & y) | (~x & z));
	 }
	 
	 function H(x, y, z)
	 {
	   return new Number((x | ~y) ^ z);
	 }
	 
	 function I(x, y, z)
	 {
	   return new Number((x & z) | (y & ~z));
	 }
	 
	 function J(x, y, z)
	 {
	   return new Number(x ^ (y | ~z));
	 }
	 
	 function mixOneRound(a, b, c, d, e, x, s, roundNumber)
	 {
	   switch (roundNumber)
	   {
	     case 0 : a += F(b, c, d) + x + 0x00000000; break;
	     case 1 : a += G(b, c, d) + x + 0x5a827999; break;
	     case 2 : a += H(b, c, d) + x + 0x6ed9eba1; break;
	     case 3 : a += I(b, c, d) + x + 0x8f1bbcdc; break;
	     case 4 : a += J(b, c, d) + x + 0xa953fd4e; break;
	     case 5 : a += J(b, c, d) + x + 0x50a28be6; break;
	     case 6 : a += I(b, c, d) + x + 0x5c4dd124; break;
	     case 7 : a += H(b, c, d) + x + 0x6d703ef3; break;
	     case 8 : a += G(b, c, d) + x + 0x7a6d76e9; break;
	     case 9 : a += F(b, c, d) + x + 0x00000000; break;
	     
	     default : document.write("Bogus round number"); break;
	   }  
	   
	   a = ROL(a, s) + e;
	   c = ROL(c, 10);
	 
	   a &= 0xffffffff;
	   b &= 0xffffffff;
	   c &= 0xffffffff;
	   d &= 0xffffffff;
	   e &= 0xffffffff;
	 
	   var retBlock = new Array();
	   retBlock[0] = a;
	   retBlock[1] = b;
	   retBlock[2] = c;
	   retBlock[3] = d;
	   retBlock[4] = e;
	   retBlock[5] = x;
	   retBlock[6] = s;
	 
	   return retBlock;
	 }
	 
	 function MDinit (MDbuf)
	 {
	   MDbuf[0] = 0x67452301;
	   MDbuf[1] = 0xefcdab89;
	   MDbuf[2] = 0x98badcfe;
	   MDbuf[3] = 0x10325476;
	   MDbuf[4] = 0xc3d2e1f0;
	 }
	 
	 var ROLs = [
	   [11, 14, 15, 12,  5,  8,  7,  9, 11, 13, 14, 15,  6,  7,  9,  8],
	   [ 7,  6,  8, 13, 11,  9,  7, 15,  7, 12, 15,  9, 11,  7, 13, 12],
	   [11, 13,  6,  7, 14,  9, 13, 15, 14,  8, 13,  6,  5, 12,  7,  5],
	   [11, 12, 14, 15, 14, 15,  9,  8,  9, 14,  5,  6,  8,  6,  5, 12],
	   [ 9, 15,  5, 11,  6,  8, 13, 12,  5, 12, 13, 14, 11,  8,  5,  6],
	   [ 8,  9,  9, 11, 13, 15, 15,  5,  7,  7,  8, 11, 14, 14, 12,  6],
	   [ 9, 13, 15,  7, 12,  8,  9, 11,  7,  7, 12,  7,  6, 15, 13, 11],
	   [ 9,  7, 15, 11,  8,  6,  6, 14, 12, 13,  5, 14, 13, 13,  7,  5],
	   [15,  5,  8, 11, 14, 14,  6, 14,  6,  9, 12,  9, 12,  5, 15,  8],
	   [ 8,  5, 12,  9, 12,  5, 14,  6,  8, 13,  6,  5, 15, 13, 11, 11]
	 ];
	 
	 var indexes = [
	   [ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15],
	   [ 7,  4, 13,  1, 10,  6, 15,  3, 12,  0,  9,  5,  2, 14, 11,  8],
	   [ 3, 10, 14,  4,  9, 15,  8,  1,  2,  7,  0,  6, 13, 11,  5, 12],
	   [ 1,  9, 11, 10,  0,  8, 12,  4, 13,  3,  7, 15, 14,  5,  6,  2],
	   [ 4,  0,  5,  9,  7, 12,  2, 10, 14,  1,  3,  8, 11,  6, 15, 13],
	   [ 5, 14,  7,  0,  9,  2, 11,  4, 13,  6, 15,  8,  1, 10,  3, 12],
	   [ 6, 11,  3,  7,  0, 13,  5, 10, 14, 15,  8, 12,  4,  9,  1,  2],
	   [15,  5,  1,  3,  7, 14,  6,  9, 11,  8, 12,  2, 10,  0,  4, 13],
	   [ 8,  6,  4,  1,  3, 11, 15,  0,  5, 12,  2, 13,  9,  7, 10, 14],
	   [12, 15, 10,  4,  1,  5,  8,  7,  6,  2, 13, 14,  0,  3,  9, 11]
	 ];
	 
	 function compress (MDbuf, X)
	 {
	   blockA = new Array();
	   blockB = new Array();
	 
	   var retBlock;
	 
	   for (var i=0; i < 5; i++)
	   {
	     blockA[i] = new Number(MDbuf[i]);
	     blockB[i] = new Number(MDbuf[i]);
	   }
	 
	   var step = 0;
	   for (var j = 0; j < 5; j++)
	   {
	     for (var i = 0; i < 16; i++)
	     {
	       retBlock = mixOneRound(
	         blockA[(step+0) % 5],
	         blockA[(step+1) % 5],   
	         blockA[(step+2) % 5],   
	         blockA[(step+3) % 5],   
	         blockA[(step+4) % 5],  
	         X[indexes[j][i]], 
	         ROLs[j][i],
	         j
	       );
	 
	       blockA[(step+0) % 5] = retBlock[0];
	       blockA[(step+1) % 5] = retBlock[1];
	       blockA[(step+2) % 5] = retBlock[2];
	       blockA[(step+3) % 5] = retBlock[3];
	       blockA[(step+4) % 5] = retBlock[4];
	 
	       step += 4;
	     }
	   }
	 
	   step = 0;
	   for (var j = 5; j < 10; j++)
	   {
	     for (var i = 0; i < 16; i++)
	     {  
	       retBlock = mixOneRound(
	         blockB[(step+0) % 5], 
	         blockB[(step+1) % 5], 
	         blockB[(step+2) % 5], 
	         blockB[(step+3) % 5], 
	         blockB[(step+4) % 5],  
	         X[indexes[j][i]], 
	         ROLs[j][i],
	         j
	       );
	 
	       blockB[(step+0) % 5] = retBlock[0];
	       blockB[(step+1) % 5] = retBlock[1];
	       blockB[(step+2) % 5] = retBlock[2];
	       blockB[(step+3) % 5] = retBlock[3];
	       blockB[(step+4) % 5] = retBlock[4];
	 
	       step += 4;
	     }
	   }
	 
	   blockB[3] += blockA[2] + MDbuf[1];
	   MDbuf[1]  = MDbuf[2] + blockA[3] + blockB[4];
	   MDbuf[2]  = MDbuf[3] + blockA[4] + blockB[0];
	   MDbuf[3]  = MDbuf[4] + blockA[0] + blockB[1];
	   MDbuf[4]  = MDbuf[0] + blockA[1] + blockB[2];
	   MDbuf[0]  = blockB[3];
	 }
	 
	 function zeroX(X)
	 {
	   for (var i = 0; i < 16; i++) { X[i] = 0; }
	 }
	 
	 function MDfinish (MDbuf, strptr, lswlen, mswlen)
	 {
	   var X = new Array(16);
	   zeroX(X);
	 
	   var j = 0;
	   for (var i=0; i < (lswlen & 63); i++)
	   {
	     X[i >>> 2] ^= (strptr.charCodeAt(j++) & 255) << (8 * (i & 3));
	   }
	 
	   X[(lswlen >>> 2) & 15] ^= 1 << (8 * (lswlen & 3) + 7);
	 
	   if ((lswlen & 63) > 55)
	   {
	     compress(MDbuf, X);
	     var X = new Array(16);
	     zeroX(X);
	   }
	 
	   X[14] = lswlen << 3;
	   X[15] = (lswlen >>> 29) | (mswlen << 3);
	 
	   compress(MDbuf, X);
	 }
	 
	 function BYTES_TO_DWORD(fourChars)
	 {
	   var tmp  = (fourChars.charCodeAt(3) & 255) << 24;
	   tmp   |= (fourChars.charCodeAt(2) & 255) << 16;
	   tmp   |= (fourChars.charCodeAt(1) & 255) << 8;
	   tmp   |= (fourChars.charCodeAt(0) & 255);  
	 
	   return tmp;
	 }
	 
	 function RMD(message)
	 {
	   var MDbuf   = new Array(RMDsize / 32);
	   var hashcode   = new Array(RMDsize / 8);
	   var length;  
	   var nbytes;
	 
	   MDinit(MDbuf);
	   length = message.length;
	 
	   var X = new Array(16);
	   zeroX(X);
	 
	   var j=0;
	   for (var nbytes=length; nbytes > 63; nbytes -= 64)
	   {
	     for (var i=0; i < 16; i++)
	     {
	       X[i] = BYTES_TO_DWORD(message.substr(j, 4));
	       j += 4;
	     }
	     compress(MDbuf, X);
	   }
	 
	   MDfinish(MDbuf, message.substr(j), length, 0);
	 
	   for (var i=0; i < RMDsize / 8; i += 4)
	   {
	     hashcode[i]   =  MDbuf[i >>> 2]   & 255;
	     hashcode[i+1] = (MDbuf[i >>> 2] >>> 8)   & 255;
	     hashcode[i+2] = (MDbuf[i >>> 2] >>> 16) & 255;
	     hashcode[i+3] = (MDbuf[i >>> 2] >>> 24) & 255;
	   }
	 
	   return hashcode;
	 }
	 
	 
	 function RMDstring(message)
	 {
	   var hashcode = RMD(message);
	   var retString = "";
	 
	   for (var i=0; i < RMDsize/8; i++)
	   {
	     retString += String.fromCharCode(hashcode[i]);
	   }  
	 
	   return retString;  
	 }/* A JavaScript implementation of the SHA family of hashes, as defined in FIPS 
	  * PUB 180-2 as well as the corresponding HMAC implementation as defined in
	  * FIPS PUB 198a
	  *
	  * Version 1.3 Copyright Brian Turek 2008-2010
	  * Distributed under the BSD License
	  * See http://jssha.sourceforge.net/ for more information
	  *
	  * Several functions taken from Paul Johnson
	  */
	 
	 /* Modified by Recurity Labs GmbH
	  * 
	  * This code has been slightly modified direct string output:
	  * - bin2bstr has been added
	  * - following wrappers of this library have been added:
	  *   - str_sha1
	  *   - str_sha256
	  *   - str_sha224
	  *   - str_sha384
	  *   - str_sha512
	  */
	 
	 var jsSHA = (function () {
	 	
	 	/*
	 	 * Configurable variables. Defaults typically work
	 	 */
	 	/* Number of Bits Per character (8 for ASCII, 16 for Unicode) */
	 	var charSize = 8, 
	 	/* base-64 pad character. "=" for strict RFC compliance */
	 	b64pad = "", 
	 	/* hex output format. 0 - lowercase; 1 - uppercase */
	 	hexCase = 0, 
	 
	 	/*
	 	 * Int_64 is a object for 2 32-bit numbers emulating a 64-bit number
	 	 *
	 	 * @constructor
	 	 * @param {Number} msint_32 The most significant 32-bits of a 64-bit number
	 	 * @param {Number} lsint_32 The least significant 32-bits of a 64-bit number
	 	 */
	 	Int_64 = function (msint_32, lsint_32)
	 	{
	 		this.highOrder = msint_32;
	 		this.lowOrder = lsint_32;
	 	},
	 
	 	/*
	 	 * Convert a string to an array of big-endian words
	 	 * If charSize is ASCII, characters >255 have their hi-byte silently
	 	 * ignored.
	 	 *
	 	 * @param {String} str String to be converted to binary representation
	 	 * @return Integer array representation of the parameter
	 	 */
	 	str2binb = function (str)
	 	{
	 		var bin = [], mask = (1 << charSize) - 1,
	 			length = str.length * charSize, i;
	 
	 		for (i = 0; i < length; i += charSize)
	 		{
	 			bin[i >> 5] |= (str.charCodeAt(i / charSize) & mask) <<
	 				(32 - charSize - (i % 32));
	 		}
	 
	 		return bin;
	 	},
	 
	 	/*
	 	 * Convert a hex string to an array of big-endian words
	 	 *
	 	 * @param {String} str String to be converted to binary representation
	 	 * @return Integer array representation of the parameter
	 	 */
	 	hex2binb = function (str)
	 	{
	 		var bin = [], length = str.length, i, num;
	 
	 		for (i = 0; i < length; i += 2)
	 		{
	 			num = parseInt(str.substr(i, 2), 16);
	 			if (!isNaN(num))
	 			{
	 				bin[i >> 3] |= num << (24 - (4 * (i % 8)));
	 			}
	 			else
	 			{
	 				return "INVALID HEX STRING";
	 			}
	 		}
	 
	 		return bin;
	 	},
	 
	 	/*
	 	 * Convert an array of big-endian words to a hex string.
	 	 *
	 	 * @private
	 	 * @param {Array} binarray Array of integers to be converted to hexidecimal
	 	 *	 representation
	 	 * @return Hexidecimal representation of the parameter in String form
	 	 */
	 	binb2hex = function (binarray)
	 	{
	 		var hex_tab = (hexCase) ? "0123456789ABCDEF" : "0123456789abcdef",
	 			str = "", length = binarray.length * 4, i, srcByte;
	 
	 		for (i = 0; i < length; i += 1)
	 		{
	 			srcByte = binarray[i >> 2] >> ((3 - (i % 4)) * 8);
	 			str += hex_tab.charAt((srcByte >> 4) & 0xF) +
	 				hex_tab.charAt(srcByte & 0xF);
	 		}
	 
	 		return str;
	 	},
	 
	 	/*
	 	 * Convert an array of big-endian words to a base-64 string
	 	 *
	 	 * @private
	 	 * @param {Array} binarray Array of integers to be converted to base-64
	 	 *	 representation
	 	 * @return Base-64 encoded representation of the parameter in String form
	 	 */
	 	binb2b64 = function (binarray)
	 	{
	 		var tab = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz" +
	 			"0123456789+/", str = "", length = binarray.length * 4, i, j,
	 			triplet;
	 
	 		for (i = 0; i < length; i += 3)
	 		{
	 			triplet = (((binarray[i >> 2] >> 8 * (3 - i % 4)) & 0xFF) << 16) |
	 				(((binarray[i + 1 >> 2] >> 8 * (3 - (i + 1) % 4)) & 0xFF) << 8) |
	 				((binarray[i + 2 >> 2] >> 8 * (3 - (i + 2) % 4)) & 0xFF);
	 			for (j = 0; j < 4; j += 1)
	 			{
	 				if (i * 8 + j * 6 <= binarray.length * 32)
	 				{
	 					str += tab.charAt((triplet >> 6 * (3 - j)) & 0x3F);
	 				}
	 				else
	 				{
	 					str += b64pad;
	 				}
	 			}
	 		}
	 		return str;
	 	},
	 
	 	/*
	 	 * Convert an array of big-endian words to a string
	 	 */
	 	binb2str = function (bin)
	 	{
	 	  var str = "";
	 	  var mask = (1 << 8) - 1;
	 	  for(var i = 0; i < bin.length * 32; i += 8)
	 	    str += String.fromCharCode((bin[i>>5] >>> (24 - i%32)) & mask);
	 	  return str;
	 	},
	 	/*
	 	 * The 32-bit implementation of circular rotate left
	 	 *
	 	 * @private
	 	 * @param {Number} x The 32-bit integer argument
	 	 * @param {Number} n The number of bits to shift
	 	 * @return The x shifted circularly by n bits
	 	 */
	 	rotl_32 = function (x, n)
	 	{
	 		return (x << n) | (x >>> (32 - n));
	 	},
	 
	 	/*
	 	 * The 32-bit implementation of circular rotate right
	 	 *
	 	 * @private
	 	 * @param {Number} x The 32-bit integer argument
	 	 * @param {Number} n The number of bits to shift
	 	 * @return The x shifted circularly by n bits
	 	 */
	 	rotr_32 = function (x, n)
	 	{
	 		return (x >>> n) | (x << (32 - n));
	 	},
	 
	 	/*
	 	 * The 64-bit implementation of circular rotate right
	 	 *
	 	 * @private
	 	 * @param {Int_64} x The 64-bit integer argument
	 	 * @param {Number} n The number of bits to shift
	 	 * @return The x shifted circularly by n bits
	 	 */
	 	rotr_64 = function (x, n)
	 	{
	 		if (n <= 32)
	 		{
	 			return new Int_64(
	 					(x.highOrder >>> n) | (x.lowOrder << (32 - n)),
	 					(x.lowOrder >>> n) | (x.highOrder << (32 - n))
	 				);
	 		}
	 		else
	 		{
	 			return new Int_64(
	 					(x.lowOrder >>> n) | (x.highOrder << (32 - n)),
	 					(x.highOrder >>> n) | (x.lowOrder << (32 - n))
	 				);
	 		}
	 	},
	 
	 	/*
	 	 * The 32-bit implementation of shift right
	 	 *
	 	 * @private
	 	 * @param {Number} x The 32-bit integer argument
	 	 * @param {Number} n The number of bits to shift
	 	 * @return The x shifted by n bits
	 	 */
	 	shr_32 = function (x, n)
	 	{
	 		return x >>> n;
	 	},
	 
	 	/*
	 	 * The 64-bit implementation of shift right
	 	 *
	 	 * @private
	 	 * @param {Int_64} x The 64-bit integer argument
	 	 * @param {Number} n The number of bits to shift
	 	 * @return The x shifted by n bits
	 	 */
	 	shr_64 = function (x, n)
	 	{
	 		if (n <= 32)
	 		{
	 			return new Int_64(
	 					x.highOrder >>> n,
	 					x.lowOrder >>> n | (x.highOrder << (32 - n))
	 				);
	 		}
	 		else
	 		{
	 			return new Int_64(
	 					0,
	 					x.highOrder << (32 - n)
	 				);
	 		}
	 	},
	 
	 	/*
	 	 * The 32-bit implementation of the NIST specified Parity function
	 	 *
	 	 * @private
	 	 * @param {Number} x The first 32-bit integer argument
	 	 * @param {Number} y The second 32-bit integer argument
	 	 * @param {Number} z The third 32-bit integer argument
	 	 * @return The NIST specified output of the function
	 	 */
	 	parity_32 = function (x, y, z)
	 	{
	 		return x ^ y ^ z;
	 	},
	 
	 	/*
	 	 * The 32-bit implementation of the NIST specified Ch function
	 	 *
	 	 * @private
	 	 * @param {Number} x The first 32-bit integer argument
	 	 * @param {Number} y The second 32-bit integer argument
	 	 * @param {Number} z The third 32-bit integer argument
	 	 * @return The NIST specified output of the function
	 	 */
	 	ch_32 = function (x, y, z)
	 	{
	 		return (x & y) ^ (~x & z);
	 	},
	 
	 	/*
	 	 * The 64-bit implementation of the NIST specified Ch function
	 	 *
	 	 * @private
	 	 * @param {Int_64} x The first 64-bit integer argument
	 	 * @param {Int_64} y The second 64-bit integer argument
	 	 * @param {Int_64} z The third 64-bit integer argument
	 	 * @return The NIST specified output of the function
	 	 */
	 	ch_64 = function (x, y, z)
	 	{
	 		return new Int_64(
	 				(x.highOrder & y.highOrder) ^ (~x.highOrder & z.highOrder),
	 				(x.lowOrder & y.lowOrder) ^ (~x.lowOrder & z.lowOrder)
	 			);
	 	},
	 
	 	/*
	 	 * The 32-bit implementation of the NIST specified Maj function
	 	 *
	 	 * @private
	 	 * @param {Number} x The first 32-bit integer argument
	 	 * @param {Number} y The second 32-bit integer argument
	 	 * @param {Number} z The third 32-bit integer argument
	 	 * @return The NIST specified output of the function
	 	 */
	 	maj_32 = function (x, y, z)
	 	{
	 		return (x & y) ^ (x & z) ^ (y & z);
	 	},
	 
	 	/*
	 	 * The 64-bit implementation of the NIST specified Maj function
	 	 *
	 	 * @private
	 	 * @param {Int_64} x The first 64-bit integer argument
	 	 * @param {Int_64} y The second 64-bit integer argument
	 	 * @param {Int_64} z The third 64-bit integer argument
	 	 * @return The NIST specified output of the function
	 	 */
	 	maj_64 = function (x, y, z)
	 	{
	 		return new Int_64(
	 				(x.highOrder & y.highOrder) ^
	 				(x.highOrder & z.highOrder) ^
	 				(y.highOrder & z.highOrder),
	 				(x.lowOrder & y.lowOrder) ^
	 				(x.lowOrder & z.lowOrder) ^
	 				(y.lowOrder & z.lowOrder)
	 			);
	 	},
	 
	 	/*
	 	 * The 32-bit implementation of the NIST specified Sigma0 function
	 	 *
	 	 * @private
	 	 * @param {Number} x The 32-bit integer argument
	 	 * @return The NIST specified output of the function
	 	 */
	 	sigma0_32 = function (x)
	 	{
	 		return rotr_32(x, 2) ^ rotr_32(x, 13) ^ rotr_32(x, 22);
	 	},
	 
	 	/*
	 	 * The 64-bit implementation of the NIST specified Sigma0 function
	 	 *
	 	 * @private
	 	 * @param {Int_64} x The 64-bit integer argument
	 	 * @return The NIST specified output of the function
	 	 */
	 	sigma0_64 = function (x)
	 	{
	 		var rotr28 = rotr_64(x, 28), rotr34 = rotr_64(x, 34),
	 			rotr39 = rotr_64(x, 39);
	 
	 		return new Int_64(
	 				rotr28.highOrder ^ rotr34.highOrder ^ rotr39.highOrder,
	 				rotr28.lowOrder ^ rotr34.lowOrder ^ rotr39.lowOrder);
	 	},
	 
	 	/*
	 	 * The 32-bit implementation of the NIST specified Sigma1 function
	 	 *
	 	 * @private
	 	 * @param {Number} x The 32-bit integer argument
	 	 * @return The NIST specified output of the function
	 	 */
	 	sigma1_32 = function (x)
	 	{
	 		return rotr_32(x, 6) ^ rotr_32(x, 11) ^ rotr_32(x, 25);
	 	},
	 
	 	/*
	 	 * The 64-bit implementation of the NIST specified Sigma1 function
	 	 *
	 	 * @private
	 	 * @param {Int_64} x The 64-bit integer argument
	 	 * @return The NIST specified output of the function
	 	 */
	 	sigma1_64 = function (x)
	 	{
	 		var rotr14 = rotr_64(x, 14), rotr18 = rotr_64(x, 18),
	 			rotr41 = rotr_64(x, 41);
	 
	 		return new Int_64(
	 				rotr14.highOrder ^ rotr18.highOrder ^ rotr41.highOrder,
	 				rotr14.lowOrder ^ rotr18.lowOrder ^ rotr41.lowOrder);
	 	},
	 
	 	/*
	 	 * The 32-bit implementation of the NIST specified Gamma0 function
	 	 *
	 	 * @private
	 	 * @param {Number} x The 32-bit integer argument
	 	 * @return The NIST specified output of the function
	 	 */
	 	gamma0_32 = function (x)
	 	{
	 		return rotr_32(x, 7) ^ rotr_32(x, 18) ^ shr_32(x, 3);
	 	},
	 
	 	/*
	 	 * The 64-bit implementation of the NIST specified Gamma0 function
	 	 *
	 	 * @private
	 	 * @param {Int_64} x The 64-bit integer argument
	 	 * @return The NIST specified output of the function
	 	 */
	 	gamma0_64 = function (x)
	 	{
	 		var rotr1 = rotr_64(x, 1), rotr8 = rotr_64(x, 8), shr7 = shr_64(x, 7);
	 
	 		return new Int_64(
	 				rotr1.highOrder ^ rotr8.highOrder ^ shr7.highOrder,
	 				rotr1.lowOrder ^ rotr8.lowOrder ^ shr7.lowOrder
	 			);
	 	},
	 
	 	/*
	 	 * The 32-bit implementation of the NIST specified Gamma1 function
	 	 *
	 	 * @private
	 	 * @param {Number} x The 32-bit integer argument
	 	 * @return The NIST specified output of the function
	 	 */
	 	gamma1_32 = function (x)
	 	{
	 		return rotr_32(x, 17) ^ rotr_32(x, 19) ^ shr_32(x, 10);
	 	},
	 
	 	/*
	 	 * The 64-bit implementation of the NIST specified Gamma1 function
	 	 *
	 	 * @private
	 	 * @param {Int_64} x The 64-bit integer argument
	 	 * @return The NIST specified output of the function
	 	 */
	 	gamma1_64 = function (x)
	 	{
	 		var rotr19 = rotr_64(x, 19), rotr61 = rotr_64(x, 61),
	 			shr6 = shr_64(x, 6);
	 
	 		return new Int_64(
	 				rotr19.highOrder ^ rotr61.highOrder ^ shr6.highOrder,
	 				rotr19.lowOrder ^ rotr61.lowOrder ^ shr6.lowOrder
	 			);
	 	},
	 
	 	/*
	 	 * Add two 32-bit integers, wrapping at 2^32. This uses 16-bit operations
	 	 * internally to work around bugs in some JS interpreters.
	 	 *
	 	 * @private
	 	 * @param {Number} x The first 32-bit integer argument to be added
	 	 * @param {Number} y The second 32-bit integer argument to be added
	 	 * @return The sum of x + y
	 	 */
	 	safeAdd_32_2 = function (x, y)
	 	{
	 		var lsw = (x & 0xFFFF) + (y & 0xFFFF),
	 			msw = (x >>> 16) + (y >>> 16) + (lsw >>> 16);
	 
	 		return ((msw & 0xFFFF) << 16) | (lsw & 0xFFFF);
	 	},
	 
	 	/*
	 	 * Add four 32-bit integers, wrapping at 2^32. This uses 16-bit operations
	 	 * internally to work around bugs in some JS interpreters.
	 	 *
	 	 * @private
	 	 * @param {Number} a The first 32-bit integer argument to be added
	 	 * @param {Number} b The second 32-bit integer argument to be added
	 	 * @param {Number} c The third 32-bit integer argument to be added
	 	 * @param {Number} d The fourth 32-bit integer argument to be added
	 	 * @return The sum of a + b + c + d
	 	 */
	 	safeAdd_32_4 = function (a, b, c, d)
	 	{
	 		var lsw = (a & 0xFFFF) + (b & 0xFFFF) + (c & 0xFFFF) + (d & 0xFFFF),
	 			msw = (a >>> 16) + (b >>> 16) + (c >>> 16) + (d >>> 16) +
	 				(lsw >>> 16);
	 
	 		return ((msw & 0xFFFF) << 16) | (lsw & 0xFFFF);
	 	},
	 
	 	/*
	 	 * Add five 32-bit integers, wrapping at 2^32. This uses 16-bit operations
	 	 * internally to work around bugs in some JS interpreters.
	 	 *
	 	 * @private
	 	 * @param {Number} a The first 32-bit integer argument to be added
	 	 * @param {Number} b The second 32-bit integer argument to be added
	 	 * @param {Number} c The third 32-bit integer argument to be added
	 	 * @param {Number} d The fourth 32-bit integer argument to be added
	 	 * @param {Number} e The fifth 32-bit integer argument to be added
	 	 * @return The sum of a + b + c + d + e
	 	 */
	 	safeAdd_32_5 = function (a, b, c, d, e)
	 	{
	 		var lsw = (a & 0xFFFF) + (b & 0xFFFF) + (c & 0xFFFF) + (d & 0xFFFF) +
	 				(e & 0xFFFF),
	 			msw = (a >>> 16) + (b >>> 16) + (c >>> 16) + (d >>> 16) +
	 				(e >>> 16) + (lsw >>> 16);
	 
	 		return ((msw & 0xFFFF) << 16) | (lsw & 0xFFFF);
	 	},
	 
	 	/*
	 	 * Add two 64-bit integers, wrapping at 2^64. This uses 16-bit operations
	 	 * internally to work around bugs in some JS interpreters.
	 	 *
	 	 * @private
	 	 * @param {Int_64} x The first 64-bit integer argument to be added
	 	 * @param {Int_64} y The second 64-bit integer argument to be added
	 	 * @return The sum of x + y
	 	 */
	 	safeAdd_64_2 = function (x, y)
	 	{
	 		var lsw, msw, lowOrder, highOrder;
	 
	 		lsw = (x.lowOrder & 0xFFFF) + (y.lowOrder & 0xFFFF);
	 		msw = (x.lowOrder >>> 16) + (y.lowOrder >>> 16) + (lsw >>> 16);
	 		lowOrder = ((msw & 0xFFFF) << 16) | (lsw & 0xFFFF);
	 
	 		lsw = (x.highOrder & 0xFFFF) + (y.highOrder & 0xFFFF) + (msw >>> 16);
	 		msw = (x.highOrder >>> 16) + (y.highOrder >>> 16) + (lsw >>> 16);
	 		highOrder = ((msw & 0xFFFF) << 16) | (lsw & 0xFFFF);
	 
	 		return new Int_64(highOrder, lowOrder);
	 	},
	 
	 	/*
	 	 * Add four 64-bit integers, wrapping at 2^64. This uses 16-bit operations
	 	 * internally to work around bugs in some JS interpreters.
	 	 *
	 	 * @private
	 	 * @param {Int_64} a The first 64-bit integer argument to be added
	 	 * @param {Int_64} b The second 64-bit integer argument to be added
	 	 * @param {Int_64} c The third 64-bit integer argument to be added
	 	 * @param {Int_64} d The fouth 64-bit integer argument to be added
	 	 * @return The sum of a + b + c + d
	 	 */
	 	safeAdd_64_4 = function (a, b, c, d)
	 	{
	 		var lsw, msw, lowOrder, highOrder;
	 
	 		lsw = (a.lowOrder & 0xFFFF) + (b.lowOrder & 0xFFFF) +
	 			(c.lowOrder & 0xFFFF) + (d.lowOrder & 0xFFFF);
	 		msw = (a.lowOrder >>> 16) + (b.lowOrder >>> 16) +
	 			(c.lowOrder >>> 16) + (d.lowOrder >>> 16) + (lsw >>> 16);
	 		lowOrder = ((msw & 0xFFFF) << 16) | (lsw & 0xFFFF);
	 
	 		lsw = (a.highOrder & 0xFFFF) + (b.highOrder & 0xFFFF) +
	 			(c.highOrder & 0xFFFF) + (d.highOrder & 0xFFFF) + (msw >>> 16);
	 		msw = (a.highOrder >>> 16) + (b.highOrder >>> 16) +
	 			(c.highOrder >>> 16) + (d.highOrder >>> 16) + (lsw >>> 16);
	 		highOrder = ((msw & 0xFFFF) << 16) | (lsw & 0xFFFF);
	 
	 		return new Int_64(highOrder, lowOrder);
	 	},
	 
	 	/*
	 	 * Add five 64-bit integers, wrapping at 2^64. This uses 16-bit operations
	 	 * internally to work around bugs in some JS interpreters.
	 	 *
	 	 * @private
	 	 * @param {Int_64} a The first 64-bit integer argument to be added
	 	 * @param {Int_64} b The second 64-bit integer argument to be added
	 	 * @param {Int_64} c The third 64-bit integer argument to be added
	 	 * @param {Int_64} d The fouth 64-bit integer argument to be added
	 	 * @param {Int_64} e The fouth 64-bit integer argument to be added
	 	 * @return The sum of a + b + c + d + e
	 	 */
	 	safeAdd_64_5 = function (a, b, c, d, e)
	 	{
	 		var lsw, msw, lowOrder, highOrder;
	 
	 		lsw = (a.lowOrder & 0xFFFF) + (b.lowOrder & 0xFFFF) +
	 			(c.lowOrder & 0xFFFF) + (d.lowOrder & 0xFFFF) +
	 			(e.lowOrder & 0xFFFF);
	 		msw = (a.lowOrder >>> 16) + (b.lowOrder >>> 16) +
	 			(c.lowOrder >>> 16) + (d.lowOrder >>> 16) + (e.lowOrder >>> 16) +
	 			(lsw >>> 16);
	 		lowOrder = ((msw & 0xFFFF) << 16) | (lsw & 0xFFFF);
	 
	 		lsw = (a.highOrder & 0xFFFF) + (b.highOrder & 0xFFFF) +
	 			(c.highOrder & 0xFFFF) + (d.highOrder & 0xFFFF) +
	 			(e.highOrder & 0xFFFF) + (msw >>> 16);
	 		msw = (a.highOrder >>> 16) + (b.highOrder >>> 16) +
	 			(c.highOrder >>> 16) + (d.highOrder >>> 16) +
	 			(e.highOrder >>> 16) + (lsw >>> 16);
	 		highOrder = ((msw & 0xFFFF) << 16) | (lsw & 0xFFFF);
	 
	 		return new Int_64(highOrder, lowOrder);
	 	},
	 
	 	/*
	 	 * Calculates the SHA-1 hash of the string set at instantiation
	 	 *
	 	 * @private
	 	 * @param {Array} message The binary array representation of the string to
	 	 *	 hash
	 	 * @param {Number} messageLen The number of bits in the message
	 	 * @return The array of integers representing the SHA-1 hash of message
	 	 */
	 	coreSHA1 = function (message, messageLen)
	 	{
	 		var W = [], a, b, c, d, e, T, ch = ch_32, parity = parity_32,
	 			maj = maj_32, rotl = rotl_32, safeAdd_2 = safeAdd_32_2, i, t,
	 			safeAdd_5 = safeAdd_32_5, appendedMessageLength,
	 			H = [
	 				0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0
	 			],
	 			K = [
	 				0x5a827999, 0x5a827999, 0x5a827999, 0x5a827999,
	 				0x5a827999, 0x5a827999, 0x5a827999, 0x5a827999,
	 				0x5a827999, 0x5a827999, 0x5a827999, 0x5a827999,
	 				0x5a827999, 0x5a827999, 0x5a827999, 0x5a827999,
	 				0x5a827999, 0x5a827999, 0x5a827999, 0x5a827999,
	 				0x6ed9eba1, 0x6ed9eba1, 0x6ed9eba1, 0x6ed9eba1,
	 				0x6ed9eba1, 0x6ed9eba1, 0x6ed9eba1, 0x6ed9eba1,
	 				0x6ed9eba1, 0x6ed9eba1, 0x6ed9eba1, 0x6ed9eba1,
	 				0x6ed9eba1, 0x6ed9eba1, 0x6ed9eba1, 0x6ed9eba1,
	 				0x6ed9eba1, 0x6ed9eba1, 0x6ed9eba1, 0x6ed9eba1,
	 				0x8f1bbcdc, 0x8f1bbcdc, 0x8f1bbcdc, 0x8f1bbcdc,
	 				0x8f1bbcdc, 0x8f1bbcdc, 0x8f1bbcdc, 0x8f1bbcdc,
	 				0x8f1bbcdc, 0x8f1bbcdc, 0x8f1bbcdc, 0x8f1bbcdc,
	 				0x8f1bbcdc, 0x8f1bbcdc, 0x8f1bbcdc, 0x8f1bbcdc,
	 				0x8f1bbcdc, 0x8f1bbcdc, 0x8f1bbcdc, 0x8f1bbcdc,
	 				0xca62c1d6, 0xca62c1d6, 0xca62c1d6, 0xca62c1d6,
	 				0xca62c1d6, 0xca62c1d6, 0xca62c1d6, 0xca62c1d6,
	 				0xca62c1d6, 0xca62c1d6, 0xca62c1d6, 0xca62c1d6,
	 				0xca62c1d6, 0xca62c1d6, 0xca62c1d6, 0xca62c1d6,
	 				0xca62c1d6, 0xca62c1d6, 0xca62c1d6, 0xca62c1d6
	 			];
	 
	 		/* Append '1' at the end of the binary string */
	 		message[messageLen >> 5] |= 0x80 << (24 - (messageLen % 32));
	 		/* Append length of binary string in the position such that the new
	 		length is a multiple of 512.  Logic does not work for even multiples
	 		of 512 but there can never be even multiples of 512 */
	 		message[(((messageLen + 65) >> 9) << 4) + 15] = messageLen;
	 
	 		appendedMessageLength = message.length;
	 
	 		for (i = 0; i < appendedMessageLength; i += 16)
	 		{
	 			a = H[0];
	 			b = H[1];
	 			c = H[2];
	 			d = H[3];
	 			e = H[4];
	 
	 			for (t = 0; t < 80; t += 1)
	 			{
	 				if (t < 16)
	 				{
	 					W[t] = message[t + i];
	 				}
	 				else
	 				{
	 					W[t] = rotl(W[t - 3] ^ W[t - 8] ^ W[t - 14] ^ W[t - 16], 1);
	 				}
	 
	 				if (t < 20)
	 				{
	 					T = safeAdd_5(rotl(a, 5), ch(b, c, d), e, K[t], W[t]);
	 				}
	 				else if (t < 40)
	 				{
	 					T = safeAdd_5(rotl(a, 5), parity(b, c, d), e, K[t], W[t]);
	 				}
	 				else if (t < 60)
	 				{
	 					T = safeAdd_5(rotl(a, 5), maj(b, c, d), e, K[t], W[t]);
	 				} else {
	 					T = safeAdd_5(rotl(a, 5), parity(b, c, d), e, K[t], W[t]);
	 				}
	 
	 				e = d;
	 				d = c;
	 				c = rotl(b, 30);
	 				b = a;
	 				a = T;
	 			}
	 
	 			H[0] = safeAdd_2(a, H[0]);
	 			H[1] = safeAdd_2(b, H[1]);
	 			H[2] = safeAdd_2(c, H[2]);
	 			H[3] = safeAdd_2(d, H[3]);
	 			H[4] = safeAdd_2(e, H[4]);
	 		}
	 
	 		return H;
	 	},
	 
	 	/*
	 	 * Calculates the desired SHA-2 hash of the string set at instantiation
	 	 *
	 	 * @private
	 	 * @param {Array} The binary array representation of the string to hash
	 	 * @param {Number} The number of bits in message
	 	 * @param {String} variant The desired SHA-2 variant
	 	 * @return The array of integers representing the SHA-2 hash of message
	 	 */
	 	coreSHA2 = function (message, messageLen, variant)
	 	{
	 		var a, b, c, d, e, f, g, h, T1, T2, H, numRounds, lengthPosition, i, t,
	 			binaryStringInc, binaryStringMult, safeAdd_2, safeAdd_4, safeAdd_5,
	 			gamma0, gamma1, sigma0, sigma1, ch, maj, Int, K, W = [],
	 			appendedMessageLength;
	 
	 		/* Set up the various function handles and variable for the specific 
	 		 * variant */
	 		if (variant === "SHA-224" || variant === "SHA-256")
	 		{
	 			/* 32-bit variant */
	 			numRounds = 64;
	 			lengthPosition = (((messageLen + 65) >> 9) << 4) + 15;
	 			binaryStringInc = 16;
	 			binaryStringMult = 1;
	 			Int = Number;
	 			safeAdd_2 = safeAdd_32_2;
	 			safeAdd_4 = safeAdd_32_4;
	 			safeAdd_5 = safeAdd_32_5;
	 			gamma0 = gamma0_32;
	 			gamma1 = gamma1_32;
	 			sigma0 = sigma0_32;
	 			sigma1 = sigma1_32;
	 			maj = maj_32;
	 			ch = ch_32;
	 			K = [
	 					0x428A2F98, 0x71374491, 0xB5C0FBCF, 0xE9B5DBA5,
	 					0x3956C25B, 0x59F111F1, 0x923F82A4, 0xAB1C5ED5,
	 					0xD807AA98, 0x12835B01, 0x243185BE, 0x550C7DC3,
	 					0x72BE5D74, 0x80DEB1FE, 0x9BDC06A7, 0xC19BF174,
	 					0xE49B69C1, 0xEFBE4786, 0x0FC19DC6, 0x240CA1CC,
	 					0x2DE92C6F, 0x4A7484AA, 0x5CB0A9DC, 0x76F988DA,
	 					0x983E5152, 0xA831C66D, 0xB00327C8, 0xBF597FC7,
	 					0xC6E00BF3, 0xD5A79147, 0x06CA6351, 0x14292967,
	 					0x27B70A85, 0x2E1B2138, 0x4D2C6DFC, 0x53380D13,
	 					0x650A7354, 0x766A0ABB, 0x81C2C92E, 0x92722C85,
	 					0xA2BFE8A1, 0xA81A664B, 0xC24B8B70, 0xC76C51A3,
	 					0xD192E819, 0xD6990624, 0xF40E3585, 0x106AA070,
	 					0x19A4C116, 0x1E376C08, 0x2748774C, 0x34B0BCB5,
	 					0x391C0CB3, 0x4ED8AA4A, 0x5B9CCA4F, 0x682E6FF3,
	 					0x748F82EE, 0x78A5636F, 0x84C87814, 0x8CC70208,
	 					0x90BEFFFA, 0xA4506CEB, 0xBEF9A3F7, 0xC67178F2
	 				];
	 
	 			if (variant === "SHA-224")
	 			{
	 				H = [
	 						0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939,
	 						0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4
	 					];
	 			}
	 			else
	 			{
	 				H = [
	 						0x6A09E667, 0xBB67AE85, 0x3C6EF372, 0xA54FF53A,
	 						0x510E527F, 0x9B05688C, 0x1F83D9AB, 0x5BE0CD19
	 					];
	 			}
	 		}
	 		else if (variant === "SHA-384" || variant === "SHA-512")
	 		{
	 			/* 64-bit variant */
	 			numRounds = 80;
	 			lengthPosition = (((messageLen + 128) >> 10) << 5) + 31;
	 			binaryStringInc = 32;
	 			binaryStringMult = 2;
	 			Int = Int_64;
	 			safeAdd_2 = safeAdd_64_2;
	 			safeAdd_4 = safeAdd_64_4;
	 			safeAdd_5 = safeAdd_64_5;
	 			gamma0 = gamma0_64;
	 			gamma1 = gamma1_64;
	 			sigma0 = sigma0_64;
	 			sigma1 = sigma1_64;
	 			maj = maj_64;
	 			ch = ch_64;
	 
	 			K = [
	 				new Int(0x428a2f98, 0xd728ae22), new Int(0x71374491, 0x23ef65cd),
	 				new Int(0xb5c0fbcf, 0xec4d3b2f), new Int(0xe9b5dba5, 0x8189dbbc),
	 				new Int(0x3956c25b, 0xf348b538), new Int(0x59f111f1, 0xb605d019),
	 				new Int(0x923f82a4, 0xaf194f9b), new Int(0xab1c5ed5, 0xda6d8118),
	 				new Int(0xd807aa98, 0xa3030242), new Int(0x12835b01, 0x45706fbe),
	 				new Int(0x243185be, 0x4ee4b28c), new Int(0x550c7dc3, 0xd5ffb4e2),
	 				new Int(0x72be5d74, 0xf27b896f), new Int(0x80deb1fe, 0x3b1696b1),
	 				new Int(0x9bdc06a7, 0x25c71235), new Int(0xc19bf174, 0xcf692694),
	 				new Int(0xe49b69c1, 0x9ef14ad2), new Int(0xefbe4786, 0x384f25e3),
	 				new Int(0x0fc19dc6, 0x8b8cd5b5), new Int(0x240ca1cc, 0x77ac9c65),
	 				new Int(0x2de92c6f, 0x592b0275), new Int(0x4a7484aa, 0x6ea6e483),
	 				new Int(0x5cb0a9dc, 0xbd41fbd4), new Int(0x76f988da, 0x831153b5),
	 				new Int(0x983e5152, 0xee66dfab), new Int(0xa831c66d, 0x2db43210),
	 				new Int(0xb00327c8, 0x98fb213f), new Int(0xbf597fc7, 0xbeef0ee4),
	 				new Int(0xc6e00bf3, 0x3da88fc2), new Int(0xd5a79147, 0x930aa725),
	 				new Int(0x06ca6351, 0xe003826f), new Int(0x14292967, 0x0a0e6e70),
	 				new Int(0x27b70a85, 0x46d22ffc), new Int(0x2e1b2138, 0x5c26c926),
	 				new Int(0x4d2c6dfc, 0x5ac42aed), new Int(0x53380d13, 0x9d95b3df),
	 				new Int(0x650a7354, 0x8baf63de), new Int(0x766a0abb, 0x3c77b2a8),
	 				new Int(0x81c2c92e, 0x47edaee6), new Int(0x92722c85, 0x1482353b),
	 				new Int(0xa2bfe8a1, 0x4cf10364), new Int(0xa81a664b, 0xbc423001),
	 				new Int(0xc24b8b70, 0xd0f89791), new Int(0xc76c51a3, 0x0654be30),
	 				new Int(0xd192e819, 0xd6ef5218), new Int(0xd6990624, 0x5565a910),
	 				new Int(0xf40e3585, 0x5771202a), new Int(0x106aa070, 0x32bbd1b8),
	 				new Int(0x19a4c116, 0xb8d2d0c8), new Int(0x1e376c08, 0x5141ab53),
	 				new Int(0x2748774c, 0xdf8eeb99), new Int(0x34b0bcb5, 0xe19b48a8),
	 				new Int(0x391c0cb3, 0xc5c95a63), new Int(0x4ed8aa4a, 0xe3418acb),
	 				new Int(0x5b9cca4f, 0x7763e373), new Int(0x682e6ff3, 0xd6b2b8a3),
	 				new Int(0x748f82ee, 0x5defb2fc), new Int(0x78a5636f, 0x43172f60),
	 				new Int(0x84c87814, 0xa1f0ab72), new Int(0x8cc70208, 0x1a6439ec),
	 				new Int(0x90befffa, 0x23631e28), new Int(0xa4506ceb, 0xde82bde9),
	 				new Int(0xbef9a3f7, 0xb2c67915), new Int(0xc67178f2, 0xe372532b),
	 				new Int(0xca273ece, 0xea26619c), new Int(0xd186b8c7, 0x21c0c207),
	 				new Int(0xeada7dd6, 0xcde0eb1e), new Int(0xf57d4f7f, 0xee6ed178),
	 				new Int(0x06f067aa, 0x72176fba), new Int(0x0a637dc5, 0xa2c898a6),
	 				new Int(0x113f9804, 0xbef90dae), new Int(0x1b710b35, 0x131c471b),
	 				new Int(0x28db77f5, 0x23047d84), new Int(0x32caab7b, 0x40c72493),
	 				new Int(0x3c9ebe0a, 0x15c9bebc), new Int(0x431d67c4, 0x9c100d4c),
	 				new Int(0x4cc5d4be, 0xcb3e42b6), new Int(0x597f299c, 0xfc657e2a),
	 				new Int(0x5fcb6fab, 0x3ad6faec), new Int(0x6c44198c, 0x4a475817)
	 			];
	 
	 			if (variant === "SHA-384")
	 			{
	 				H = [
	 					new Int(0xcbbb9d5d, 0xc1059ed8), new Int(0x0629a292a, 0x367cd507),
	 					new Int(0x9159015a, 0x3070dd17), new Int(0x0152fecd8, 0xf70e5939),
	 					new Int(0x67332667, 0xffc00b31), new Int(0x98eb44a87, 0x68581511),
	 					new Int(0xdb0c2e0d, 0x64f98fa7), new Int(0x047b5481d, 0xbefa4fa4)
	 				];
	 			}
	 			else
	 			{
	 				H = [
	 					new Int(0x6a09e667, 0xf3bcc908), new Int(0xbb67ae85, 0x84caa73b),
	 					new Int(0x3c6ef372, 0xfe94f82b), new Int(0xa54ff53a, 0x5f1d36f1),
	 					new Int(0x510e527f, 0xade682d1), new Int(0x9b05688c, 0x2b3e6c1f),
	 					new Int(0x1f83d9ab, 0xfb41bd6b), new Int(0x5be0cd19, 0x137e2179)
	 				];
	 			}
	 		}
	 
	 		/* Append '1' at the end of the binary string */
	 		message[messageLen >> 5] |= 0x80 << (24 - messageLen % 32);
	 		/* Append length of binary string in the position such that the new
	 		 * length is correct */
	 		message[lengthPosition] = messageLen;
	 
	 		appendedMessageLength = message.length;
	 
	 		for (i = 0; i < appendedMessageLength; i += binaryStringInc)
	 		{
	 			a = H[0];
	 			b = H[1];
	 			c = H[2];
	 			d = H[3];
	 			e = H[4];
	 			f = H[5];
	 			g = H[6];
	 			h = H[7];
	 
	 			for (t = 0; t < numRounds; t += 1)
	 			{
	 				if (t < 16)
	 				{
	 					/* Bit of a hack - for 32-bit, the second term is ignored */
	 					W[t] = new Int(message[t * binaryStringMult + i],
	 							message[t * binaryStringMult + i + 1]);
	 				}
	 				else
	 				{
	 					W[t] = safeAdd_4(
	 							gamma1(W[t - 2]), W[t - 7],
	 							gamma0(W[t - 15]), W[t - 16]
	 						);
	 				}
	 
	 				T1 = safeAdd_5(h, sigma1(e), ch(e, f, g), K[t], W[t]);
	 				T2 = safeAdd_2(sigma0(a), maj(a, b, c));
	 				h = g;
	 				g = f;
	 				f = e;
	 				e = safeAdd_2(d, T1);
	 				d = c;
	 				c = b;
	 				b = a;
	 				a = safeAdd_2(T1, T2);
	 			}
	 
	 			H[0] = safeAdd_2(a, H[0]);
	 			H[1] = safeAdd_2(b, H[1]);
	 			H[2] = safeAdd_2(c, H[2]);
	 			H[3] = safeAdd_2(d, H[3]);
	 			H[4] = safeAdd_2(e, H[4]);
	 			H[5] = safeAdd_2(f, H[5]);
	 			H[6] = safeAdd_2(g, H[6]);
	 			H[7] = safeAdd_2(h, H[7]);
	 		}
	 
	 		switch (variant)
	 		{
	 		case "SHA-224":
	 			return	[
	 				H[0], H[1], H[2], H[3],
	 				H[4], H[5], H[6]
	 			];
	 		case "SHA-256":
	 			return H;
	 		case "SHA-384":
	 			return [
	 				H[0].highOrder, H[0].lowOrder,
	 				H[1].highOrder, H[1].lowOrder,
	 				H[2].highOrder, H[2].lowOrder,
	 				H[3].highOrder, H[3].lowOrder,
	 				H[4].highOrder, H[4].lowOrder,
	 				H[5].highOrder, H[5].lowOrder
	 			];
	 		case "SHA-512":
	 			return [
	 				H[0].highOrder, H[0].lowOrder,
	 				H[1].highOrder, H[1].lowOrder,
	 				H[2].highOrder, H[2].lowOrder,
	 				H[3].highOrder, H[3].lowOrder,
	 				H[4].highOrder, H[4].lowOrder,
	 				H[5].highOrder, H[5].lowOrder,
	 				H[6].highOrder, H[6].lowOrder,
	 				H[7].highOrder, H[7].lowOrder
	 			];
	 		default:
	 			/* This should never be reached */
	 			return []; 
	 		}
	 	},
	 
	 	/*
	 	 * jsSHA is the workhorse of the library.  Instantiate it with the string to
	 	 * be hashed as the parameter
	 	 *
	 	 * @constructor
	 	 * @param {String} srcString The string to be hashed
	 	 * @param {String} inputFormat The format of srcString, ASCII or HEX
	 	 */
	 	jsSHA = function (srcString, inputFormat)
	 	{
	 
	 		this.sha1 = null;
	 		this.sha224 = null;
	 		this.sha256 = null;
	 		this.sha384 = null;
	 		this.sha512 = null;
	 
	 		this.strBinLen = null;
	 		this.strToHash = null;
	 
	 		/* Convert the input string into the correct type */
	 		if ("HEX" === inputFormat)
	 		{
	 			if (0 !== (srcString.length % 2))
	 			{
	 				return "TEXT MUST BE IN BYTE INCREMENTS";
	 			}
	 			this.strBinLen = srcString.length * 4;
	 			this.strToHash = hex2binb(srcString);
	 		}
	 		else if (("ASCII" === inputFormat) ||
	 			 ('undefined' === typeof(inputFormat)))
	 		{
	 			this.strBinLen = srcString.length * charSize;
	 			this.strToHash = str2binb(srcString);
	 		}
	 		else
	 		{
	 			return "UNKNOWN TEXT INPUT TYPE";
	 		}
	 	};
	 
	 	jsSHA.prototype = {
	 		/*
	 		 * Returns the desired SHA hash of the string specified at instantiation
	 		 * using the specified parameters
	 		 *
	 		 * @param {String} variant The desired SHA variant (SHA-1, SHA-224,
	 		 *	 SHA-256, SHA-384, or SHA-512)
	 		 * @param {String} format The desired output formatting (B64 or HEX)
	 		 * @return The string representation of the hash in the format specified
	 		 */
	 		getHash : function (variant, format)
	 		{
	 			var formatFunc = null, message = this.strToHash.slice();
	 
	 			switch (format)
	 			{
	 			case "HEX":
	 				formatFunc = binb2hex;
	 				break;
	 			case "B64":
	 				formatFunc = binb2b64;
	 				break;
	 			case "ASCII":
	 				formatFunc = binb2str;
	 				break;
	 			default:
	 				return "FORMAT NOT RECOGNIZED";
	 			}
	 
	 			switch (variant)
	 			{
	 			case "SHA-1":
	 				if (null === this.sha1)
	 				{
	 					this.sha1 = coreSHA1(message, this.strBinLen);
	 				}
	 				return formatFunc(this.sha1);
	 			case "SHA-224":
	 				if (null === this.sha224)
	 				{
	 					this.sha224 = coreSHA2(message, this.strBinLen, variant);
	 				}
	 				return formatFunc(this.sha224);
	 			case "SHA-256":
	 				if (null === this.sha256)
	 				{
	 					this.sha256 = coreSHA2(message, this.strBinLen, variant);
	 				}
	 				return formatFunc(this.sha256);
	 			case "SHA-384":
	 				if (null === this.sha384)
	 				{
	 					this.sha384 = coreSHA2(message, this.strBinLen, variant);
	 				}
	 				return formatFunc(this.sha384);
	 			case "SHA-512":
	 				if (null === this.sha512)
	 				{
	 					this.sha512 = coreSHA2(message, this.strBinLen, variant);
	 				}
	 				return formatFunc(this.sha512);
	 			default:
	 				return "HASH NOT RECOGNIZED";
	 			}
	 		},
	 
	 		/*
	 		 * Returns the desired HMAC of the string specified at instantiation
	 		 * using the key and variant param.
	 		 *
	 		 * @param {String} key The key used to calculate the HMAC
	 		 * @param {String} inputFormat The format of key, ASCII or HEX
	 		 * @param {String} variant The desired SHA variant (SHA-1, SHA-224,
	 		 *	 SHA-256, SHA-384, or SHA-512)
	 		 * @param {String} outputFormat The desired output formatting
	 		 *	 (B64 or HEX)
	 		 * @return The string representation of the hash in the format specified
	 		 */
	 		getHMAC : function (key, inputFormat, variant, outputFormat)
	 		{
	 			var formatFunc, keyToUse, blockByteSize, blockBitSize, i,
	 				retVal, lastArrayIndex, keyBinLen, hashBitSize,
	 				keyWithIPad = [], keyWithOPad = [];
	 
	 			/* Validate the output format selection */
	 			switch (outputFormat)
	 			{
	 			case "HEX":
	 				formatFunc = binb2hex;
	 				break;
	 			case "B64":
	 				formatFunc = binb2b64;
	 				break;
	 			case "ASCII":
	 				formatFunc = binb2str;
	 				break;
	 			default:
	 				return "FORMAT NOT RECOGNIZED";
	 			}
	 
	 			/* Validate the hash variant selection and set needed variables */
	 			switch (variant)
	 			{
	 			case "SHA-1":
	 				blockByteSize = 64;
	 				hashBitSize = 160;
	 				break;
	 			case "SHA-224":
	 				blockByteSize = 64;
	 				hashBitSize = 224;
	 				break;
	 			case "SHA-256":
	 				blockByteSize = 64;
	 				hashBitSize = 256;
	 				break;
	 			case "SHA-384":
	 				blockByteSize = 128;
	 				hashBitSize = 384;
	 				break;
	 			case "SHA-512":
	 				blockByteSize = 128;
	 				hashBitSize = 512;
	 				break;
	 			default:
	 				return "HASH NOT RECOGNIZED";
	 			}
	 
	 			/* Validate input format selection */
	 			if ("HEX" === inputFormat)
	 			{
	 				/* Nibbles must come in pairs */
	 				if (0 !== (key.length % 2))
	 				{
	 					return "KEY MUST BE IN BYTE INCREMENTS";
	 				}
	 				keyToUse = hex2binb(key);
	 				keyBinLen = key.length * 4;
	 			}
	 			else if ("ASCII" === inputFormat)
	 			{
	 				keyToUse = str2binb(key);
	 				keyBinLen = key.length * charSize;
	 			}
	 			else
	 			{
	 				return "UNKNOWN KEY INPUT TYPE";
	 			}
	 
	 			/* These are used multiple times, calculate and store them */
	 			blockBitSize = blockByteSize * 8;
	 			lastArrayIndex = (blockByteSize / 4) - 1;
	 
	 			/* Figure out what to do with the key based on its size relative to
	 			 * the hash's block size */
	 			if (blockByteSize < (keyBinLen / 8))
	 			{
	 				if ("SHA-1" === variant)
	 				{
	 					keyToUse = coreSHA1(keyToUse, keyBinLen);
	 				}
	 				else
	 				{
	 					keyToUse = coreSHA2(keyToUse, keyBinLen, variant);
	 				}
	 				/* For all variants, the block size is bigger than the output
	 				 * size so there will never be a useful byte at the end of the
	 				 * string */
	 				keyToUse[lastArrayIndex] &= 0xFFFFFF00;
	 			}
	 			else if (blockByteSize > (keyBinLen / 8))
	 			{
	 				/* If the blockByteSize is greater than the key length, there
	 				 * will always be at LEAST one "useless" byte at the end of the
	 				 * string */
	 				keyToUse[lastArrayIndex] &= 0xFFFFFF00;
	 			}
	 
	 			/* Create ipad and opad */
	 			for (i = 0; i <= lastArrayIndex; i += 1)
	 			{
	 				keyWithIPad[i] = keyToUse[i] ^ 0x36363636;
	 				keyWithOPad[i] = keyToUse[i] ^ 0x5C5C5C5C;
	 			}
	 
	 			/* Calculate the HMAC */
	 			if ("SHA-1" === variant)
	 			{
	 				retVal = coreSHA1(
	 							keyWithIPad.concat(this.strToHash),
	 							blockBitSize + this.strBinLen);
	 				retVal = coreSHA1(
	 							keyWithOPad.concat(retVal),
	 							blockBitSize + hashBitSize);
	 			}
	 			else
	 			{
	 				retVal = coreSHA2(
	 							keyWithIPad.concat(this.strToHash),
	 							blockBitSize + this.strBinLen, variant);
	 				retVal = coreSHA2(
	 							keyWithOPad.concat(retVal),
	 							blockBitSize + hashBitSize, variant);
	 			}
	 
	 			return (formatFunc(retVal));
	 		}
	 	};
	 
	 	return jsSHA;
	 }());
	 
	 function str_sha1(str) {
	 	var shaObj = new jsSHA(str, "ASCII");
	 	return shaObj.getHash("SHA-1", "ASCII");
	 }
	 
	 function str_sha224(str) {
	 	var shaObj = new jsSHA(str, "ASCII");
	 	return shaObj.getHash("SHA-224", "ASCII");
	 }
	 
	 function str_sha256(str) {
	 	var shaObj = new jsSHA(str, "ASCII");
	 	return shaObj.getHash("SHA-256", "ASCII");
	 }
	 
	 
	 function str_sha384(str) {
	 	var shaObj = new jsSHA(str, "ASCII");
	 	return shaObj.getHash("SHA-384", "ASCII");
	 
	 }
	 
	 function str_sha512(str) {
	 	var shaObj = new jsSHA(str, "ASCII");
	 	return shaObj.getHash("SHA-512", "ASCII");
	 }
	 // Modified by Recurity Labs GmbH 
	 
	 // modified version of http://www.hanewin.net/encrypt/PGdecode.js:
	 
	 /* OpenPGP encryption using RSA/AES
	  * Copyright 2005-2006 Herbert Hanewinkel, www.haneWIN.de
	  * version 2.0, check www.haneWIN.de for the latest version
	 
	  * This software is provided as-is, without express or implied warranty.  
	  * Permission to use, copy, modify, distribute or sell this software, with or
	  * without fee, for any purpose and by any individual or organization, is hereby
	  * granted, provided that the above copyright notice and this paragraph appear 
	  * in all copies. Distribution as a part of an application or binary must
	  * include the above copyright notice in the documentation and/or other
	  * materials provided with the application or distribution.
	  */
	 
	 /**
	  * An array of bytes, that is integers with values from 0 to 255
	  * @typedef {(Array|Uint8Array)} openpgp_byte_array
	  */
	 
	 /**
	  * Block cipher function
	  * @callback openpgp_cipher_block_fn
	  * @param {openpgp_byte_array} block A block to perform operations on
	  * @param {openpgp_byte_array} key to use in encryption/decryption
	  * @return {openpgp_byte_array} Encrypted/decrypted block
	  */
	 
	 
	 // --------------------------------------
	 /**
	  * This function encrypts a given with the specified prefixrandom 
	  * using the specified blockcipher to encrypt a message
	  * @param {String} prefixrandom random bytes of block_size length provided 
	  *  as a string to be used in prefixing the data
	  * @param {openpgp_cipher_block_fn} blockcipherfn the algorithm encrypt function to encrypt
	  *  data in one block_size encryption. 
	  * @param {Integer} block_size the block size in bytes of the algorithm used
	  * @param {String} plaintext data to be encrypted provided as a string
	  * @param {openpgp_byte_array} key key to be used to encrypt the data. This will be passed to the 
	  *  blockcipherfn
	  * @param {Boolean} resync a boolean value specifying if a resync of the 
	  *  IV should be used or not. The encrypteddatapacket uses the 
	  *  "old" style with a resync. Encryption within an 
	  *  encryptedintegrityprotecteddata packet is not resyncing the IV.
	  * @return {String} a string with the encrypted data
	  */
	 function openpgp_cfb_encrypt(prefixrandom, blockcipherencryptfn, plaintext, block_size, key, resync) {
	 	var FR = new Array(block_size);
	 	var FRE = new Array(block_size);
	 
	 	prefixrandom = prefixrandom + prefixrandom.charAt(block_size-2) +prefixrandom.charAt(block_size-1);
	 	util.print_debug("prefixrandom:"+util.hexstrdump(prefixrandom));
	 	var ciphertext = "";
	 	// 1.  The feedback register (FR) is set to the IV, which is all zeros.
	 	for (var i = 0; i < block_size; i++) FR[i] = 0;
	 	
	 	// 2.  FR is encrypted to produce FRE (FR Encrypted).  This is the
	     //     encryption of an all-zero value.
	 	FRE = blockcipherencryptfn(FR, key);
	 	// 3.  FRE is xored with the first BS octets of random data prefixed to
	     //     the plaintext to produce C[1] through C[BS], the first BS octets
	     //     of ciphertext.
	 	for (var i = 0; i < block_size; i++) ciphertext += String.fromCharCode(FRE[i] ^ prefixrandom.charCodeAt(i));
	 	
	 	// 4.  FR is loaded with C[1] through C[BS].
	 	for (var i = 0; i < block_size; i++) FR[i] = ciphertext.charCodeAt(i);
	 	
	 	// 5.  FR is encrypted to produce FRE, the encryption of the first BS
	     // 	   octets of ciphertext.
	 	FRE = blockcipherencryptfn(FR, key);
	 
	 	// 6.  The left two octets of FRE get xored with the next two octets of
	 	//     data that were prefixed to the plaintext.  This produces C[BS+1]
	 	//     and C[BS+2], the next two octets of ciphertext.
	 	ciphertext += String.fromCharCode(FRE[0] ^ prefixrandom.charCodeAt(block_size));
	 	ciphertext += String.fromCharCode(FRE[1] ^ prefixrandom.charCodeAt(block_size+1));
	 
	 	if (resync) {
	 		// 7.  (The resync step) FR is loaded with C3-C10.
	 		for (var i = 0; i < block_size; i++) FR[i] = ciphertext.charCodeAt(i+2);
	 	} else {
	 		for (var i = 0; i < block_size; i++) FR[i] = ciphertext.charCodeAt(i);
	 	}
	 	// 8.  FR is encrypted to produce FRE.
	 	FRE = blockcipherencryptfn(FR, key);
	 	
	 	if (resync) {
	 		// 9.  FRE is xored with the first 8 octets of the given plaintext, now
	 	    //	   that we have finished encrypting the 10 octets of prefixed data.
	 	    // 	   This produces C11-C18, the next 8 octets of ciphertext.
	 		for (var i = 0; i < block_size; i++)
	 			ciphertext += String.fromCharCode(FRE[i] ^ plaintext.charCodeAt(i));
	 		for(n=block_size+2; n < plaintext.length; n+=block_size) {
	 			// 10. FR is loaded with C11-C18
	 			for (var i = 0; i < block_size; i++) FR[i] = ciphertext.charCodeAt(n+i);
	 		
	 			// 11. FR is encrypted to produce FRE.
	 			FRE = blockcipherencryptfn(FR, key);
	 		
	 			// 12. FRE is xored with the next 8 octets of plaintext, to produce the
	 			// next 8 octets of ciphertext.  These are loaded into FR and the
	 			// process is repeated until the plaintext is used up.
	 			for (var i = 0; i < block_size; i++) ciphertext += String.fromCharCode(FRE[i] ^ plaintext.charCodeAt((n-2)+i));
	 		}
	 	}
	 	else {
	 		plaintext = "  "+plaintext;
	 		// 9.  FRE is xored with the first 8 octets of the given plaintext, now
	 	    //	   that we have finished encrypting the 10 octets of prefixed data.
	 	    // 	   This produces C11-C18, the next 8 octets of ciphertext.
	 		for (var i = 2; i < block_size; i++) ciphertext += String.fromCharCode(FRE[i] ^ plaintext.charCodeAt(i));
	 		var tempCiphertext = ciphertext.substring(0,2*block_size).split('');
	 		var tempCiphertextString = ciphertext.substring(block_size);
	 		for(n=block_size; n<plaintext.length; n+=block_size) {
	 			// 10. FR is loaded with C11-C18
	 			for (var i = 0; i < block_size; i++) FR[i] = tempCiphertextString.charCodeAt(i);
	 			tempCiphertextString='';
	 			
	 			// 11. FR is encrypted to produce FRE.
	 			FRE = blockcipherencryptfn(FR, key);
	 			
	 			// 12. FRE is xored with the next 8 octets of plaintext, to produce the
	 			//     next 8 octets of ciphertext.  These are loaded into FR and the
	 			//     process is repeated until the plaintext is used up.
	 			for (var i = 0; i < block_size; i++){ tempCiphertext.push(String.fromCharCode(FRE[i] ^ plaintext.charCodeAt(n+i)));
	 			tempCiphertextString += String.fromCharCode(FRE[i] ^ plaintext.charCodeAt(n+i));
	 			}
	 		}
	 		ciphertext = tempCiphertext.join('');
	 		
	 	}
	 	return ciphertext;
	 }
	 
	 /**
	  * Decrypts the prefixed data for the Modification Detection Code (MDC) computation
	  * @param {openpgp_block_cipher_fn} blockcipherencryptfn Cipher function to use
	  * @param {Integer} block_size Blocksize of the algorithm
	  * @param {openpgp_byte_array} key The key for encryption
	  * @param {String} ciphertext The encrypted data
	  * @return {String} plaintext Data of D(ciphertext) with blocksize length +2
	  */
	 function openpgp_cfb_mdc(blockcipherencryptfn, block_size, key, ciphertext) {
	 	var iblock = new Array(block_size);
	 	var ablock = new Array(block_size);
	 	var i;
	 
	 	// initialisation vector
	 	for(i=0; i < block_size; i++) iblock[i] = 0;
	 
	 	iblock = blockcipherencryptfn(iblock, key);
	 	for(i = 0; i < block_size; i++)
	 	{
	 		ablock[i] = ciphertext.charCodeAt(i);
	 		iblock[i] ^= ablock[i];
	 	}
	 
	 	ablock = blockcipherencryptfn(ablock, key);
	 
	 	return util.bin2str(iblock)+
	 		String.fromCharCode(ablock[0]^ciphertext.charCodeAt(block_size))+
	 		String.fromCharCode(ablock[1]^ciphertext.charCodeAt(block_size+1));
	 }
	 /**
	  * This function decrypts a given plaintext using the specified
	  * blockcipher to decrypt a message
	  * @param {openpgp_cipher_block_fn} blockcipherfn The algorithm _encrypt_ function to encrypt
	  *  data in one block_size encryption.
	  * @param {Integer} block_size the block size in bytes of the algorithm used
	  * @param {String} plaintext ciphertext to be decrypted provided as a string
	  * @param {openpgp_byte_array} key key to be used to decrypt the ciphertext. This will be passed to the 
	  *  blockcipherfn
	  * @param {Boolean} resync a boolean value specifying if a resync of the 
	  *  IV should be used or not. The encrypteddatapacket uses the 
	  *  "old" style with a resync. Decryption within an 
	  *  encryptedintegrityprotecteddata packet is not resyncing the IV.
	  * @return {String} a string with the plaintext data
	  */
	 
	 function openpgp_cfb_decrypt(blockcipherencryptfn, block_size, key, ciphertext, resync)
	 {
	 	util.print_debug("resync:"+resync);
	 	var iblock = new Array(block_size);
	 	var ablock = new Array(block_size);
	 	var i, n = '';
	 	var text = [];
	 
	 	// initialisation vector
	 	for(i=0; i < block_size; i++) iblock[i] = 0;
	 
	 	iblock = blockcipherencryptfn(iblock, key);
	 	for(i = 0; i < block_size; i++)
	 	{
	 		ablock[i] = ciphertext.charCodeAt(i);
	 		iblock[i] ^= ablock[i];
	 	}
	 
	 	ablock = blockcipherencryptfn(ablock, key);
	 
	 	util.print_debug("openpgp_cfb_decrypt:\niblock:"+util.hexidump(iblock)+"\nablock:"+util.hexidump(ablock)+"\n");
	 	util.print_debug((ablock[0]^ciphertext.charCodeAt(block_size)).toString(16)+(ablock[1]^ciphertext.charCodeAt(block_size+1)).toString(16));
	 	
	 	// test check octets
	 	if(iblock[block_size-2]!=(ablock[0]^ciphertext.charCodeAt(block_size))
	 	|| iblock[block_size-1]!=(ablock[1]^ciphertext.charCodeAt(block_size+1)))
	 	{
	 		util.print_eror("error duding decryption. Symmectric encrypted data not valid.");
	 		return text.join('');
	 	}
	 	
	 	/*  RFC4880: Tag 18 and Resync:
	 	 *  [...] Unlike the Symmetrically Encrypted Data Packet, no
	    	 *  special CFB resynchronization is done after encrypting this prefix
	      *  data.  See "OpenPGP CFB Mode" below for more details.
	 
	 	 */
	 	
	 	if (resync) {
	 	    for(i=0; i<block_size; i++) iblock[i] = ciphertext.charCodeAt(i+2);
	 		for(n=block_size+2; n<ciphertext.length; n+=block_size)
	 		{
	 			ablock = blockcipherencryptfn(iblock, key);
	 
	 			for(i = 0; i<block_size && i+n < ciphertext.length; i++)
	 			{
	 				iblock[i] = ciphertext.charCodeAt(n+i);
	 				text.push(String.fromCharCode(ablock[i]^iblock[i])); 
	 			}
	 		}
	 	} else {
	 		for(i=0; i<block_size; i++) iblock[i] = ciphertext.charCodeAt(i);
	 		for(n=block_size; n<ciphertext.length; n+=block_size)
	 		{
	 			ablock = blockcipherencryptfn(iblock, key);
	 			for(i = 0; i<block_size && i+n < ciphertext.length; i++)
	 			{
	 				iblock[i] = ciphertext.charCodeAt(n+i);
	 				text.push(String.fromCharCode(ablock[i]^iblock[i])); 
	 			}
	 		}
	 		
	 	}
	 	
	 	return text.join('');
	 }
	 
	 
	 function normal_cfb_encrypt(blockcipherencryptfn, block_size, key, plaintext, iv) {
	 	var blocki ="";
	 	var blockc = "";
	 	var pos = 0;
	 	var cyphertext = [];
	 	var tempBlock = [];
	 	blockc = iv.substring(0,block_size);
	 	while (plaintext.length > block_size*pos) {
	 		var encblock = blockcipherencryptfn(blockc, key);
	 		blocki = plaintext.substring((pos*block_size),(pos*block_size)+block_size);
	 		for (var i=0; i < blocki.length; i++)
	 		    tempBlock.push(String.fromCharCode(blocki.charCodeAt(i) ^ encblock[i]));
	 		blockc = tempBlock.join('');
	 		tempBlock = [];
	 		cyphertext.push(blockc);
	 		pos++;
	 	}
	 	return cyphertext.join('');
	 }
	 
	 function normal_cfb_decrypt(blockcipherencryptfn, block_size, key, ciphertext, iv) { 
	 	var blockp ="";
	 	var pos = 0;
	 	var plaintext = [];
	 	var offset = 0;
	 	if (iv == null)
	 		for (var i = 0; i < block_size; i++) blockp += String.fromCharCode(0);
	 	else
	 		blockp = iv.substring(0,block_size);
	 	while (ciphertext.length > (block_size*pos)) {
	 		var decblock = blockcipherencryptfn(blockp, key);
	 		blockp = ciphertext.substring((pos*(block_size))+offset,(pos*(block_size))+(block_size)+offset);
	 		for (var i=0; i < blockp.length; i++) {
	 			plaintext.push(String.fromCharCode(blockp.charCodeAt(i) ^ decblock[i]));
	 		}
	 		pos++;
	 	}
	 	
	 	return plaintext.join('');
	 }
	 // GPG4Browsers - An OpenPGP implementation in javascript
	 // Copyright (C) 2011 Recurity Labs GmbH
	 // 
	 // This library is free software; you can redistribute it and/or
	 // modify it under the terms of the GNU Lesser General Public
	 // License as published by the Free Software Foundation; either
	 // version 2.1 of the License, or (at your option) any later version.
	 // 
	 // This library is distributed in the hope that it will be useful,
	 // but WITHOUT ANY WARRANTY; without even the implied warranty of
	 // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
	 // Lesser General Public License for more details.
	 // 
	 // You should have received a copy of the GNU Lesser General Public
	 // License along with this library; if not, write to the Free Software
	 // Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA 
	 
	 // The GPG4Browsers crypto interface
	 
	 /**
	  * Encrypts data using the specified public key multiprecision integers 
	  * and the specified algorithm.
	  * @param {Integer} algo Algorithm to be used (See RFC4880 9.1)
	  * @param {openpgp_type_mpi[]} publicMPIs Algorithm dependent multiprecision integers
	  * @param {openpgp_type_mpi} data Data to be encrypted as MPI
	  * @return {(openpgp_type_mpi|openpgp_type_mpi[])} if RSA an openpgp_type_mpi; 
	  * if elgamal encryption an array of two openpgp_type_mpi is returned; otherwise null
	  */
	 function openpgp_crypto_asymetricEncrypt(algo, publicMPIs, data) {
	 	switch(algo) {
	 	case 1: // RSA (Encrypt or Sign) [HAC]
	 	case 2: // RSA Encrypt-Only [HAC]
	 	case 3: // RSA Sign-Only [HAC]
	 		var rsa = new RSA();
	 		var n = publicMPIs[0].toBigInteger();
	 		var e = publicMPIs[1].toBigInteger();
	 		var m = data.toBigInteger();
	 		return rsa.encrypt(m,e,n).toMPI();
	 	case 16: // Elgamal (Encrypt-Only) [ELGAMAL] [HAC]
	 		var elgamal = new Elgamal();
	 		var p = publicMPIs[0].toBigInteger();
	 		var g = publicMPIs[1].toBigInteger();
	 		var y = publicMPIs[2].toBigInteger();
	 		var m = data.toBigInteger();
	 		return elgamal.encrypt(m,g,p,y);
	 	default:
	 		return null;
	 	}
	 }
	 
	 /**
	  * Decrypts data using the specified public key multiprecision integers of the private key,
	  * the specified secretMPIs of the private key and the specified algorithm.
	  * @param {Integer} algo Algorithm to be used (See RFC4880 9.1)
	  * @param {openpgp_type_mpi[]} publicMPIs Algorithm dependent multiprecision integers 
	  * of the public key part of the private key
	  * @param {openpgp_type_mpi[]} secretMPIs Algorithm dependent multiprecision integers 
	  * of the private key used
	  * @param {openpgp_type_mpi} data Data to be encrypted as MPI
	  * @return {BigInteger} returns a big integer containing the decrypted data; otherwise null
	  */
	 
	 function openpgp_crypto_asymetricDecrypt(algo, publicMPIs, secretMPIs, dataMPIs) {
	 	switch(algo) {
	 	case 1: // RSA (Encrypt or Sign) [HAC]  
	 	case 2: // RSA Encrypt-Only [HAC]
	 	case 3: // RSA Sign-Only [HAC]
	 		var rsa = new RSA();
	 		var d = secretMPIs[0].toBigInteger();
	 		var p = secretMPIs[1].toBigInteger();
	 		var q = secretMPIs[2].toBigInteger();
	 		var u = secretMPIs[3].toBigInteger();
	 		var m = dataMPIs[0].toBigInteger();
	 		return rsa.decrypt(m, d, p, q, u);
	 	case 16: // Elgamal (Encrypt-Only) [ELGAMAL] [HAC]
	 		var elgamal = new Elgamal();
	 		var x = secretMPIs[0].toBigInteger();
	 		var c1 = dataMPIs[0].toBigInteger();
	 		var c2 = dataMPIs[1].toBigInteger();
	 		var p = publicMPIs[0].toBigInteger();
	 		return elgamal.decrypt(c1,c2,p,x);
	 	default:
	 		return null;
	 	}
	 	
	 }
	 
	 /**
	  * generate random byte prefix as string for the specified algorithm
	  * @param {Integer} algo Algorithm to use (see RFC4880 9.2)
	  * @return {String} Random bytes with length equal to the block
	  * size of the cipher
	  */
	 function openpgp_crypto_getPrefixRandom(algo) {
	 	switch(algo) {
	 	case 2:
	 	case 3:
	 	case 4:
	 		return openpgp_crypto_getRandomBytes(8);
	 	case 7:
	 	case 8:
	 	case 9:
	 	case 10:
	 		return openpgp_crypto_getRandomBytes(16);
	 	default:
	 		return null;
	 	}
	 }
	 
	 /**
	  * retrieve the MDC prefixed bytes by decrypting them
	  * @param {Integer} algo Algorithm to use (see RFC4880 9.2)
	  * @param {String} key Key as string. length is depending on the algorithm used
	  * @param {String} data Encrypted data where the prefix is decrypted from
	  * @return {String} Plain text data of the prefixed data
	  */
	 function openpgp_crypto_MDCSystemBytes(algo, key, data) {
	 	util.print_debug_hexstr_dump("openpgp_crypto_symmetricDecrypt:\nencrypteddata:",data);
	 	switch(algo) {
	 	case 0: // Plaintext or unencrypted data
	 		return data;
	 	case 2: // TripleDES (DES-EDE, [SCHNEIER] [HAC] - 168 bit key derived from 192)
	 		return openpgp_cfb_mdc(desede, 8, key, data, openpgp_cfb);
	 	case 3: // CAST5 (128 bit key, as per [RFC2144])
	 		return openpgp_cfb_mdc(cast5_encrypt, 8, key, data);
	 	case 4: // Blowfish (128 bit key, 16 rounds) [BLOWFISH]
	 		return openpgp_cfb_mdc(BFencrypt, 8, key, data);
	 	case 7: // AES with 128-bit key [AES]
	 	case 8: // AES with 192-bit key
	 	case 9: // AES with 256-bit key
	 		return openpgp_cfb_mdc(AESencrypt, 16, keyExpansion(key), data);
	 	case 10: 
	 		return openpgp_cfb_mdc(TFencrypt, 16, key, data);
	 	case 1: // IDEA [IDEA]
	 		util.print_error(""+ (algo == 1 ? "IDEA Algorithm not implemented" : "Twofish Algorithm not implemented"));
	 		return null;
	 	default:
	 	}
	 	return null;
	 }
	 /**
	  * Generating a session key for the specified symmetric algorithm
	  * @param {Integer} algo Algorithm to use (see RFC4880 9.2)
	  * @return {String} Random bytes as a string to be used as a key
	  */
	 function openpgp_crypto_generateSessionKey(algo) {
	 	switch (algo) {
	 	case 2: // TripleDES (DES-EDE, [SCHNEIER] [HAC] - 168 bit key derived from 192)
	 	case 8: // AES with 192-bit key
	 		return openpgp_crypto_getRandomBytes(24); 
	 	case 3: // CAST5 (128 bit key, as per [RFC2144])
	 	case 4: // Blowfish (128 bit key, 16 rounds) [BLOWFISH]
	 	case 7: // AES with 128-bit key [AES]
	 		util.print_debug("length = 16:\n"+util.hexstrdump(openpgp_crypto_getRandomBytes(16)));
	 		return openpgp_crypto_getRandomBytes(16);
	 	case 9: // AES with 256-bit key
	 	case 10:// Twofish with 256-bit key [TWOFISH]
	 		return openpgp_crypto_getRandomBytes(32);
	 	}
	 	return null;
	 }
	 
	 /**
	  * 
	  * @param {Integer} algo public Key algorithm
	  * @param {Integer} hash_algo Hash algorithm
	  * @param {openpgp_type_mpi[]} msg_MPIs Signature multiprecision integers
	  * @param {openpgp_type_mpi[]} publickey_MPIs Public key multiprecision integers 
	  * @param {String} data Data on where the signature was computed on.
	  * @return {Boolean} true if signature (sig_data was equal to data over hash)
	  */
	 function openpgp_crypto_verifySignature(algo, hash_algo, msg_MPIs, publickey_MPIs, data) {
	 	var calc_hash = openpgp_crypto_hashData(hash_algo, data);
	 	switch(algo) {
	 	case 1: // RSA (Encrypt or Sign) [HAC]  
	 	case 2: // RSA Encrypt-Only [HAC]
	 	case 3: // RSA Sign-Only [HAC]
	 		var rsa = new RSA();
	 		var n = publickey_MPIs[0].toBigInteger();
	 		var e = publickey_MPIs[1].toBigInteger();
	 		var x = msg_MPIs[0].toBigInteger();
	 		var dopublic = rsa.verify(x,e,n);
	 		var hash  = openpgp_encoding_emsa_pkcs1_decode(hash_algo,dopublic.toMPI().substring(2));
	 		if (hash == -1) {
	 			util.print_error("PKCS1 padding in message or key incorrect. Aborting...");
	 			return false;
	 		}
	 		return hash == calc_hash;
	 		
	 	case 16: // Elgamal (Encrypt-Only) [ELGAMAL] [HAC]
	 		util.print_error("signing with Elgamal is not defined in the OpenPGP standard.");
	 		return null;
	 	case 17: // DSA (Digital Signature Algorithm) [FIPS186] [HAC]
	 		var dsa = new DSA();
	 		var s1 = msg_MPIs[0].toBigInteger();
	 		var s2 = msg_MPIs[1].toBigInteger();
	 		var p = publickey_MPIs[0].toBigInteger();
	 		var q = publickey_MPIs[1].toBigInteger();
	 		var g = publickey_MPIs[2].toBigInteger();
	 		var y = publickey_MPIs[3].toBigInteger();
	 		var m = data;
	 		var dopublic = dsa.verify(hash_algo,s1,s2,m,p,q,g,y);
	 		return dopublic.compareTo(s1) == 0;
	 	default:
	 		return null;
	 	}
	 	
	 }
	    
	 /**
	  * Create a signature on data using the specified algorithm
	  * @param {Integer} hash_algo hash Algorithm to use (See RFC4880 9.4)
	  * @param {Integer} algo Asymmetric cipher algorithm to use (See RFC4880 9.1)
	  * @param {openpgp_type_mpi[]} publicMPIs Public key multiprecision integers 
	  * of the private key 
	  * @param {openpgp_type_mpi[]} secretMPIs Private key multiprecision 
	  * integers which is used to sign the data
	  * @param {String} data Data to be signed
	  * @return {(String|openpgp_type_mpi)}
	  */
	 function openpgp_crypto_signData(hash_algo, algo, publicMPIs, secretMPIs, data) {
	 	
	 	switch(algo) {
	 	case 1: // RSA (Encrypt or Sign) [HAC]  
	 	case 2: // RSA Encrypt-Only [HAC]
	 	case 3: // RSA Sign-Only [HAC]
	 		var rsa = new RSA();
	 		var d = secretMPIs[0].toBigInteger();
	 		var n = publicMPIs[0].toBigInteger();
	 		var m = openpgp_encoding_emsa_pkcs1_encode(hash_algo, data,publicMPIs[0].mpiByteLength);
	 		util.print_debug("signing using RSA");
	 		return rsa.sign(m, d, n).toMPI();
	 	case 17: // DSA (Digital Signature Algorithm) [FIPS186] [HAC]
	 		var dsa = new DSA();
	 		util.print_debug("DSA Sign: q size in Bytes:"+publicMPIs[1].getByteLength());
	 		var p = publicMPIs[0].toBigInteger();
	 		var q = publicMPIs[1].toBigInteger();
	 		var g = publicMPIs[2].toBigInteger();
	 		var y = publicMPIs[3].toBigInteger();
	 		var x = secretMPIs[0].toBigInteger();
	 		var m = data;
	 		var result = dsa.sign(hash_algo,m, g, p, q, x);
	 		util.print_debug("signing using DSA\n result:"+util.hexstrdump(result[0])+"|"+util.hexstrdump(result[1]));
	 		return result[0]+result[1];
	 	case 16: // Elgamal (Encrypt-Only) [ELGAMAL] [HAC]
	 			util.print_debug("signing with Elgamal is not defined in the OpenPGP standard.");
	 			return null;
	 	default:
	 		return null;
	 	}	
	 }
	 
	 /**
	  * Create a hash on the specified data using the specified algorithm
	  * @param {Integer} algo Hash algorithm type (see RFC4880 9.4)
	  * @param {String} data Data to be hashed
	  * @return {String} hash value
	  */
	 function openpgp_crypto_hashData(algo, data) {
	 	var hash = null;
	 	switch(algo) {
	 	case 1: // - MD5 [HAC]
	 		hash = MD5(data);
	 		break;
	 	case 2: // - SHA-1 [FIPS180]
	 		hash = str_sha1(data);
	 		break;
	 	case 3: // - RIPE-MD/160 [HAC]
	 		hash = RMDstring(data);
	 		break;
	 	case 8: // - SHA256 [FIPS180]
	 		hash = str_sha256(data);
	 		break;
	 	case 9: // - SHA384 [FIPS180]
	 		hash = str_sha384(data);
	 		break;
	 	case 10:// - SHA512 [FIPS180]
	 		hash = str_sha512(data);
	 		break;
	 	case 11:// - SHA224 [FIPS180]
	 		hash = str_sha224(data);
	 	default:
	 		break;
	 	}
	 	return hash;
	 }
	 
	 /**
	  * Returns the hash size in bytes of the specified hash algorithm type
	  * @param {Integer} algo Hash algorithm type (See RFC4880 9.4)
	  * @return {Integer} Size in bytes of the resulting hash
	  */
	 function openpgp_crypto_getHashByteLength(algo) {
	 	var hash = null;
	 	switch(algo) {
	 	case 1: // - MD5 [HAC]
	 		return 16;
	 	case 2: // - SHA-1 [FIPS180]
	 	case 3: // - RIPE-MD/160 [HAC]
	 		return 20;
	 	case 8: // - SHA256 [FIPS180]
	 		return 32;
	 	case 9: // - SHA384 [FIPS180]
	 		return 48
	 	case 10:// - SHA512 [FIPS180]
	 		return 64;
	 	case 11:// - SHA224 [FIPS180]
	 		return 28;
	 	}
	 	return null;
	 }
	 
	 /**
	  * Retrieve secure random byte string of the specified length
	  * @param {Integer} length Length in bytes to generate
	  * @return {String} Random byte string
	  */
	 function openpgp_crypto_getRandomBytes(length) {
	 	var result = '';
	 	for (var i = 0; i < length; i++) {
	 		result += String.fromCharCode(openpgp_crypto_getSecureRandomOctet());
	 	}
	 	return result;
	 }
	 
	 /**
	  * Return a pseudo-random number in the specified range
	  * @param {Integer} from Min of the random number
	  * @param {Integer} to Max of the random number (max 32bit)
	  * @return {Integer} A pseudo random number
	  */
	 function openpgp_crypto_getPseudoRandom(from, to) {
	 	return Math.round(Math.random()*(to-from))+from;
	 }
	 
	 /**
	  * Return a secure random number in the specified range
	  * @param {Integer} from Min of the random number
	  * @param {Integer} to Max of the random number (max 32bit)
	  * @return {Integer} A secure random number
	  */
	 function openpgp_crypto_getSecureRandom(from, to) {
	 	var val = compat.get_random_uint32();
	 	var bits = ((to-from)).toString(2).length;
	 	while ((val & (Math.pow(2, bits) -1)) > (to-from))
	 		val = compat.get_random_uint32();
	 	return from+(Math.abs(val & (Math.pow(2, bits) -1)));
	 }
	 
	 function openpgp_crypto_getSecureRandomOctet() {
	 	return compat.get_random_byte();
	 }
	 
	 /**
	  * Create a secure random big integer of bits length
	  * @param {Integer} bits Bit length of the MPI to create
	  * @return {BigInteger} Resulting big integer
	  */
	 function openpgp_crypto_getRandomBigInteger(bits) {
	 	if (bits < 0)
	 	   return null;
	 	var numBytes = Math.floor((bits+7)/8);
	 
	 	var randomBits = openpgp_crypto_getRandomBytes(numBytes);
	 	if (bits % 8 > 0) {
	 		
	 		randomBits = String.fromCharCode(
	 						(Math.pow(2,bits % 8)-1) &
	 						randomBits.charCodeAt(0)) +
	 			randomBits.substring(1);
	 	}
	 	return new openpgp_type_mpi().create(randomBits).toBigInteger();
	 }
	 
	 function openpgp_crypto_getRandomBigIntegerInRange(min, max) {
	 	if (max.compareTo(min) <= 0)
	 		return;
	 	var range = max.subtract(min);
	 	var r = openpgp_crypto_getRandomBigInteger(range.bitLength());
	 	while (r > range) {
	 		r = openpgp_crypto_getRandomBigInteger(range.bitLength());
	 	}
	 	return min.add(r);
	 }
	 
	 
	 //This is a test method to ensure that encryption/decryption with a given 1024bit RSAKey object functions as intended
	 function openpgp_crypto_testRSA(key){
	 	debugger;
	     var rsa = new RSA();
	 	var mpi = new openpgp_type_mpi();
	 	mpi.create(openpgp_encoding_eme_pkcs1_encode('ABABABAB', 128));
	 	var msg = rsa.encrypt(mpi.toBigInteger(),key.ee,key.n);
	 	var result = rsa.decrypt(msg, key.d, key.p, key.q, key.u);
	 }
	 
	 /**
	  * @typedef {Object} openpgp_keypair
	  * @property {openpgp_packet_keymaterial} privateKey 
	  * @property {openpgp_packet_keymaterial} publicKey
	  */
	 
	 /**
	  * Calls the necessary crypto functions to generate a keypair. 
	  * Called directly by openpgp.js
	  * @param {Integer} keyType Follows OpenPGP algorithm convention.
	  * @param {Integer} numBits Number of bits to make the key to be generated
	  * @return {openpgp_keypair}
	  */
	 function openpgp_crypto_generateKeyPair(keyType, numBits, passphrase, s2kHash, symmetricEncryptionAlgorithm){
	 	var privKeyPacket;
	 	var publicKeyPacket;
	 	var d = new Date();
	 	d = d.getTime()/1000;
	 	var timePacket = String.fromCharCode(Math.floor(d/0x1000000%0x100)) + String.fromCharCode(Math.floor(d/0x10000%0x100)) + String.fromCharCode(Math.floor(d/0x100%0x100)) + String.fromCharCode(Math.floor(d%0x100));
	 	switch(keyType){
	 	case 1:
	 	    var rsa = new RSA();
	 	    var key = rsa.generate(numBits,"10001");
	 	    privKeyPacket = new openpgp_packet_keymaterial().write_private_key(keyType, key, passphrase, s2kHash, symmetricEncryptionAlgorithm, timePacket);
	 	    publicKeyPacket =  new openpgp_packet_keymaterial().write_public_key(keyType, key, timePacket);
	 	    break;
	 	default:
	 		util.print_error("Unknown keytype "+keyType)
	 	}
	 	return {privateKey: privKeyPacket, publicKey: publicKeyPacket};
	 }
	 // GPG4Browsers - An OpenPGP implementation in javascript
	 // Copyright (C) 2011 Recurity Labs GmbH
	 // 
	 // This library is free software; you can redistribute it and/or
	 // modify it under the terms of the GNU Lesser General Public
	 // License as published by the Free Software Foundation; either
	 // version 2.1 of the License, or (at your option) any later version.
	 // 
	 // This library is distributed in the hope that it will be useful,
	 // but WITHOUT ANY WARRANTY; without even the implied warranty of
	 // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
	 // Lesser General Public License for more details.
	 // 
	 // You should have received a copy of the GNU Lesser General Public
	 // License along with this library; if not, write to the Free Software
	 // Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA 
	 
	 // The GPG4Browsers symmetric crypto interface
	 
	 /**
	  * Symmetrically encrypts data using prefixedrandom, a key with length 
	  * depending on the algorithm in openpgp_cfb mode with or without resync
	  * (MDC style)
	  * @param {String} prefixrandom Secure random bytes as string in 
	  * length equal to the block size of the algorithm used (use 
	  * openpgp_crypto_getPrefixRandom(algo) to retrieve that string
	  * @param {Integer} algo Algorithm to use (see RFC4880 9.2)
	  * @param {String} key Key as string. length is depending on the algorithm used
	  * @param {String} data Data to encrypt
	  * @param {Boolean} openpgp_cfb
	  * @return {String} Encrypted data
	  */
	 function openpgp_crypto_symmetricEncrypt(prefixrandom, algo, key, data, openpgp_cfb) {
	 	switch(algo) {
	 		case 0: // Plaintext or unencrypted data
	 			return data; // blockcipherencryptfn, plaintext, block_size, key
	 		case 2: // TripleDES (DES-EDE, [SCHNEIER] [HAC] - 168 bit key derived from 192)
	 			return openpgp_cfb_encrypt(prefixrandom, desede, data,8,key, openpgp_cfb).substring(0, data.length + 10);
	 		case 3: // CAST5 (128 bit key, as per [RFC2144])
	 			return openpgp_cfb_encrypt(prefixrandom, cast5_encrypt, data,8,key, openpgp_cfb).substring(0, data.length + 10);
	 		case 4: // Blowfish (128 bit key, 16 rounds) [BLOWFISH]
	 			return openpgp_cfb_encrypt(prefixrandom, BFencrypt, data,8,key, openpgp_cfb).substring(0, data.length + 10);
	 		case 7: // AES with 128-bit key [AES]
	 		case 8: // AES with 192-bit key
	 		case 9: // AES with 256-bit key
	 			return openpgp_cfb_encrypt(prefixrandom, AESencrypt, data, 16, keyExpansion(key), openpgp_cfb).substring(0, data.length + 18);
	 		case 10: // Twofish with 256-bit key [TWOFISH]
	 			return openpgp_cfb_encrypt(prefixrandom, TFencrypt, data,16, key, openpgp_cfb).substring(0, data.length + 18);
	 		case 1: // IDEA [IDEA]
	 			util.print_error("IDEA Algorithm not implemented");
	 			return null;
	 		default:
	 			return null;
	 	}
	 }
	 
	 /**
	  * Symmetrically decrypts data using a key with length depending on the
	  * algorithm in openpgp_cfb mode with or without resync (MDC style)
	  * @param {Integer} algo Algorithm to use (see RFC4880 9.2)
	  * @param {String} key Key as string. length is depending on the algorithm used
	  * @param {String} data Data to be decrypted
	  * @param {Boolean} openpgp_cfb If true use the resync (for encrypteddata); 
	  * otherwise use without the resync (for MDC encrypted data)
	  * @return {String} Plaintext data
	  */
	 function openpgp_crypto_symmetricDecrypt(algo, key, data, openpgp_cfb) {
	 	util.print_debug_hexstr_dump("openpgp_crypto_symmetricDecrypt:\nalgo:"+algo+"\nencrypteddata:",data);
	 	var n = 0;
	 	if (!openpgp_cfb)
	 		n = 2;
	 	switch(algo) {
	 	case 0: // Plaintext or unencrypted data
	 		return data;
	 	case 2: // TripleDES (DES-EDE, [SCHNEIER] [HAC] - 168 bit key derived from 192)
	 		return openpgp_cfb_decrypt(desede, 8, key, data, openpgp_cfb).substring(n, (data.length+n)-10);
	 	case 3: // CAST5 (128 bit key, as per [RFC2144])
	 		return openpgp_cfb_decrypt(cast5_encrypt, 8, key, data, openpgp_cfb).substring(n, (data.length+n)-10);
	 	case 4: // Blowfish (128 bit key, 16 rounds) [BLOWFISH]
	 		return openpgp_cfb_decrypt(BFencrypt, 8, key, data, openpgp_cfb).substring(n, (data.length+n)-10);
	 	case 7: // AES with 128-bit key [AES]
	 	case 8: // AES with 192-bit key
	 	case 9: // AES with 256-bit key
	 		return openpgp_cfb_decrypt(AESencrypt, 16, keyExpansion(key), data, openpgp_cfb).substring(n, (data.length+n)-18);
	 	case 10: // Twofish with 256-bit key [TWOFISH]
	 		var result = openpgp_cfb_decrypt(TFencrypt, 16, key, data, openpgp_cfb).substring(n, (data.length+n)-18);
	 		return result;
	 	case 1: // IDEA [IDEA]
	 		util.print_error(""+ (algo == 1 ? "IDEA Algorithm not implemented" : "Twofish Algorithm not implemented"));
	 		return null;
	 	default:
	 	}
	 	return null;
	 }
	 
	 /* Rijndael (AES) Encryption
	  * Copyright 2005 Herbert Hanewinkel, www.haneWIN.de
	  * version 1.1, check www.haneWIN.de for the latest version
	 
	  * This software is provided as-is, without express or implied warranty.  
	  * Permission to use, copy, modify, distribute or sell this software, with or
	  * without fee, for any purpose and by any individual or organization, is hereby
	  * granted, provided that the above copyright notice and this paragraph appear 
	  * in all copies. Distribution as a part of an application or binary must
	  * include the above copyright notice in the documentation and/or other
	  * materials provided with the application or distribution.
	  */
	 
	 // The round constants used in subkey expansion
	 var Rcon = [ 
	 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 
	 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 
	 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91 ];
	 
	 // Precomputed lookup table for the SBox
	 var S = [
	  99, 124, 119, 123, 242, 107, 111, 197,  48,   1, 103,  43, 254, 215, 171, 
	 118, 202, 130, 201, 125, 250,  89,  71, 240, 173, 212, 162, 175, 156, 164, 
	 114, 192, 183, 253, 147,  38,  54,  63, 247, 204,  52, 165, 229, 241, 113, 
	 216,  49,  21,   4, 199,  35, 195,  24, 150,   5, 154,   7,  18, 128, 226, 
	 235,  39, 178, 117,   9, 131,  44,  26,  27, 110,  90, 160,  82,  59, 214, 
	 179,  41, 227,  47, 132,  83, 209,   0, 237,  32, 252, 177,  91, 106, 203, 
	 190,  57,  74,  76,  88, 207, 208, 239, 170, 251,  67,  77,  51, 133,  69, 
	 249,   2, 127,  80,  60, 159, 168,  81, 163,  64, 143, 146, 157,  56, 245, 
	 188, 182, 218,  33,  16, 255, 243, 210, 205,  12,  19, 236,  95, 151,  68,  
	 23,  196, 167, 126,  61, 100,  93,  25, 115,  96, 129,  79, 220,  34,  42, 
	 144, 136,  70, 238, 184,  20, 222,  94,  11, 219, 224,  50,  58,  10,  73,
	   6,  36,  92, 194, 211, 172,  98, 145, 149, 228, 121, 231, 200,  55, 109, 
	 141, 213,  78, 169, 108,  86, 244, 234, 101, 122, 174,   8, 186, 120,  37,  
	  46,  28, 166, 180, 198, 232, 221, 116,  31,  75, 189, 139, 138, 112,  62, 
	 181, 102,  72,   3, 246,  14,  97,  53,  87, 185, 134, 193,  29, 158, 225,
	 248, 152,  17, 105, 217, 142, 148, 155,  30, 135, 233, 206,  85,  40, 223,
	 140, 161, 137,  13, 191, 230,  66, 104,  65, 153,  45,  15, 176,  84, 187,  
	  22 ];
	 
	 var T1 = [
	 0xa56363c6, 0x847c7cf8, 0x997777ee, 0x8d7b7bf6,
	 0x0df2f2ff, 0xbd6b6bd6, 0xb16f6fde, 0x54c5c591,
	 0x50303060, 0x03010102, 0xa96767ce, 0x7d2b2b56,
	 0x19fefee7, 0x62d7d7b5, 0xe6abab4d, 0x9a7676ec,
	 0x45caca8f, 0x9d82821f, 0x40c9c989, 0x877d7dfa,
	 0x15fafaef, 0xeb5959b2, 0xc947478e, 0x0bf0f0fb,
	 0xecadad41, 0x67d4d4b3, 0xfda2a25f, 0xeaafaf45,
	 0xbf9c9c23, 0xf7a4a453, 0x967272e4, 0x5bc0c09b,
	 0xc2b7b775, 0x1cfdfde1, 0xae93933d, 0x6a26264c,
	 0x5a36366c, 0x413f3f7e, 0x02f7f7f5, 0x4fcccc83,
	 0x5c343468, 0xf4a5a551, 0x34e5e5d1, 0x08f1f1f9,
	 0x937171e2, 0x73d8d8ab, 0x53313162, 0x3f15152a,
	 0x0c040408, 0x52c7c795, 0x65232346, 0x5ec3c39d,
	 0x28181830, 0xa1969637, 0x0f05050a, 0xb59a9a2f,
	 0x0907070e, 0x36121224, 0x9b80801b, 0x3de2e2df,
	 0x26ebebcd, 0x6927274e, 0xcdb2b27f, 0x9f7575ea,
	 0x1b090912, 0x9e83831d, 0x742c2c58, 0x2e1a1a34,
	 0x2d1b1b36, 0xb26e6edc, 0xee5a5ab4, 0xfba0a05b,
	 0xf65252a4, 0x4d3b3b76, 0x61d6d6b7, 0xceb3b37d,
	 0x7b292952, 0x3ee3e3dd, 0x712f2f5e, 0x97848413,
	 0xf55353a6, 0x68d1d1b9, 0x00000000, 0x2cededc1,
	 0x60202040, 0x1ffcfce3, 0xc8b1b179, 0xed5b5bb6,
	 0xbe6a6ad4, 0x46cbcb8d, 0xd9bebe67, 0x4b393972,
	 0xde4a4a94, 0xd44c4c98, 0xe85858b0, 0x4acfcf85,
	 0x6bd0d0bb, 0x2aefefc5, 0xe5aaaa4f, 0x16fbfbed,
	 0xc5434386, 0xd74d4d9a, 0x55333366, 0x94858511,
	 0xcf45458a, 0x10f9f9e9, 0x06020204, 0x817f7ffe,
	 0xf05050a0, 0x443c3c78, 0xba9f9f25, 0xe3a8a84b,
	 0xf35151a2, 0xfea3a35d, 0xc0404080, 0x8a8f8f05,
	 0xad92923f, 0xbc9d9d21, 0x48383870, 0x04f5f5f1,
	 0xdfbcbc63, 0xc1b6b677, 0x75dadaaf, 0x63212142,
	 0x30101020, 0x1affffe5, 0x0ef3f3fd, 0x6dd2d2bf,
	 0x4ccdcd81, 0x140c0c18, 0x35131326, 0x2fececc3,
	 0xe15f5fbe, 0xa2979735, 0xcc444488, 0x3917172e,
	 0x57c4c493, 0xf2a7a755, 0x827e7efc, 0x473d3d7a,
	 0xac6464c8, 0xe75d5dba, 0x2b191932, 0x957373e6,
	 0xa06060c0, 0x98818119, 0xd14f4f9e, 0x7fdcdca3,
	 0x66222244, 0x7e2a2a54, 0xab90903b, 0x8388880b,
	 0xca46468c, 0x29eeeec7, 0xd3b8b86b, 0x3c141428,
	 0x79dedea7, 0xe25e5ebc, 0x1d0b0b16, 0x76dbdbad,
	 0x3be0e0db, 0x56323264, 0x4e3a3a74, 0x1e0a0a14,
	 0xdb494992, 0x0a06060c, 0x6c242448, 0xe45c5cb8,
	 0x5dc2c29f, 0x6ed3d3bd, 0xefacac43, 0xa66262c4,
	 0xa8919139, 0xa4959531, 0x37e4e4d3, 0x8b7979f2,
	 0x32e7e7d5, 0x43c8c88b, 0x5937376e, 0xb76d6dda,
	 0x8c8d8d01, 0x64d5d5b1, 0xd24e4e9c, 0xe0a9a949,
	 0xb46c6cd8, 0xfa5656ac, 0x07f4f4f3, 0x25eaeacf,
	 0xaf6565ca, 0x8e7a7af4, 0xe9aeae47, 0x18080810,
	 0xd5baba6f, 0x887878f0, 0x6f25254a, 0x722e2e5c,
	 0x241c1c38, 0xf1a6a657, 0xc7b4b473, 0x51c6c697,
	 0x23e8e8cb, 0x7cdddda1, 0x9c7474e8, 0x211f1f3e,
	 0xdd4b4b96, 0xdcbdbd61, 0x868b8b0d, 0x858a8a0f,
	 0x907070e0, 0x423e3e7c, 0xc4b5b571, 0xaa6666cc,
	 0xd8484890, 0x05030306, 0x01f6f6f7, 0x120e0e1c,
	 0xa36161c2, 0x5f35356a, 0xf95757ae, 0xd0b9b969,
	 0x91868617, 0x58c1c199, 0x271d1d3a, 0xb99e9e27,
	 0x38e1e1d9, 0x13f8f8eb, 0xb398982b, 0x33111122,
	 0xbb6969d2, 0x70d9d9a9, 0x898e8e07, 0xa7949433,
	 0xb69b9b2d, 0x221e1e3c, 0x92878715, 0x20e9e9c9,
	 0x49cece87, 0xff5555aa, 0x78282850, 0x7adfdfa5,
	 0x8f8c8c03, 0xf8a1a159, 0x80898909, 0x170d0d1a,
	 0xdabfbf65, 0x31e6e6d7, 0xc6424284, 0xb86868d0,
	 0xc3414182, 0xb0999929, 0x772d2d5a, 0x110f0f1e,
	 0xcbb0b07b, 0xfc5454a8, 0xd6bbbb6d, 0x3a16162c ];
	 
	 var T2 = [
	 0x6363c6a5, 0x7c7cf884, 0x7777ee99, 0x7b7bf68d,
	 0xf2f2ff0d, 0x6b6bd6bd, 0x6f6fdeb1, 0xc5c59154,
	 0x30306050, 0x01010203, 0x6767cea9, 0x2b2b567d,
	 0xfefee719, 0xd7d7b562, 0xabab4de6, 0x7676ec9a,
	 0xcaca8f45, 0x82821f9d, 0xc9c98940, 0x7d7dfa87,
	 0xfafaef15, 0x5959b2eb, 0x47478ec9, 0xf0f0fb0b,
	 0xadad41ec, 0xd4d4b367, 0xa2a25ffd, 0xafaf45ea,
	 0x9c9c23bf, 0xa4a453f7, 0x7272e496, 0xc0c09b5b,
	 0xb7b775c2, 0xfdfde11c, 0x93933dae, 0x26264c6a,
	 0x36366c5a, 0x3f3f7e41, 0xf7f7f502, 0xcccc834f,
	 0x3434685c, 0xa5a551f4, 0xe5e5d134, 0xf1f1f908,
	 0x7171e293, 0xd8d8ab73, 0x31316253, 0x15152a3f,
	 0x0404080c, 0xc7c79552, 0x23234665, 0xc3c39d5e,
	 0x18183028, 0x969637a1, 0x05050a0f, 0x9a9a2fb5,
	 0x07070e09, 0x12122436, 0x80801b9b, 0xe2e2df3d,
	 0xebebcd26, 0x27274e69, 0xb2b27fcd, 0x7575ea9f,
	 0x0909121b, 0x83831d9e, 0x2c2c5874, 0x1a1a342e,
	 0x1b1b362d, 0x6e6edcb2, 0x5a5ab4ee, 0xa0a05bfb,
	 0x5252a4f6, 0x3b3b764d, 0xd6d6b761, 0xb3b37dce,
	 0x2929527b, 0xe3e3dd3e, 0x2f2f5e71, 0x84841397,
	 0x5353a6f5, 0xd1d1b968, 0x00000000, 0xededc12c,
	 0x20204060, 0xfcfce31f, 0xb1b179c8, 0x5b5bb6ed,
	 0x6a6ad4be, 0xcbcb8d46, 0xbebe67d9, 0x3939724b,
	 0x4a4a94de, 0x4c4c98d4, 0x5858b0e8, 0xcfcf854a,
	 0xd0d0bb6b, 0xefefc52a, 0xaaaa4fe5, 0xfbfbed16,
	 0x434386c5, 0x4d4d9ad7, 0x33336655, 0x85851194,
	 0x45458acf, 0xf9f9e910, 0x02020406, 0x7f7ffe81,
	 0x5050a0f0, 0x3c3c7844, 0x9f9f25ba, 0xa8a84be3,
	 0x5151a2f3, 0xa3a35dfe, 0x404080c0, 0x8f8f058a,
	 0x92923fad, 0x9d9d21bc, 0x38387048, 0xf5f5f104,
	 0xbcbc63df, 0xb6b677c1, 0xdadaaf75, 0x21214263,
	 0x10102030, 0xffffe51a, 0xf3f3fd0e, 0xd2d2bf6d,
	 0xcdcd814c, 0x0c0c1814, 0x13132635, 0xececc32f,
	 0x5f5fbee1, 0x979735a2, 0x444488cc, 0x17172e39,
	 0xc4c49357, 0xa7a755f2, 0x7e7efc82, 0x3d3d7a47,
	 0x6464c8ac, 0x5d5dbae7, 0x1919322b, 0x7373e695,
	 0x6060c0a0, 0x81811998, 0x4f4f9ed1, 0xdcdca37f,
	 0x22224466, 0x2a2a547e, 0x90903bab, 0x88880b83,
	 0x46468cca, 0xeeeec729, 0xb8b86bd3, 0x1414283c,
	 0xdedea779, 0x5e5ebce2, 0x0b0b161d, 0xdbdbad76,
	 0xe0e0db3b, 0x32326456, 0x3a3a744e, 0x0a0a141e,
	 0x494992db, 0x06060c0a, 0x2424486c, 0x5c5cb8e4,
	 0xc2c29f5d, 0xd3d3bd6e, 0xacac43ef, 0x6262c4a6,
	 0x919139a8, 0x959531a4, 0xe4e4d337, 0x7979f28b,
	 0xe7e7d532, 0xc8c88b43, 0x37376e59, 0x6d6ddab7,
	 0x8d8d018c, 0xd5d5b164, 0x4e4e9cd2, 0xa9a949e0,
	 0x6c6cd8b4, 0x5656acfa, 0xf4f4f307, 0xeaeacf25,
	 0x6565caaf, 0x7a7af48e, 0xaeae47e9, 0x08081018,
	 0xbaba6fd5, 0x7878f088, 0x25254a6f, 0x2e2e5c72,
	 0x1c1c3824, 0xa6a657f1, 0xb4b473c7, 0xc6c69751,
	 0xe8e8cb23, 0xdddda17c, 0x7474e89c, 0x1f1f3e21,
	 0x4b4b96dd, 0xbdbd61dc, 0x8b8b0d86, 0x8a8a0f85,
	 0x7070e090, 0x3e3e7c42, 0xb5b571c4, 0x6666ccaa,
	 0x484890d8, 0x03030605, 0xf6f6f701, 0x0e0e1c12,
	 0x6161c2a3, 0x35356a5f, 0x5757aef9, 0xb9b969d0,
	 0x86861791, 0xc1c19958, 0x1d1d3a27, 0x9e9e27b9,
	 0xe1e1d938, 0xf8f8eb13, 0x98982bb3, 0x11112233,
	 0x6969d2bb, 0xd9d9a970, 0x8e8e0789, 0x949433a7,
	 0x9b9b2db6, 0x1e1e3c22, 0x87871592, 0xe9e9c920,
	 0xcece8749, 0x5555aaff, 0x28285078, 0xdfdfa57a,
	 0x8c8c038f, 0xa1a159f8, 0x89890980, 0x0d0d1a17,
	 0xbfbf65da, 0xe6e6d731, 0x424284c6, 0x6868d0b8,
	 0x414182c3, 0x999929b0, 0x2d2d5a77, 0x0f0f1e11,
	 0xb0b07bcb, 0x5454a8fc, 0xbbbb6dd6, 0x16162c3a ];
	 
	 var T3 = [
	 0x63c6a563, 0x7cf8847c, 0x77ee9977, 0x7bf68d7b,
	 0xf2ff0df2, 0x6bd6bd6b, 0x6fdeb16f, 0xc59154c5,
	 0x30605030, 0x01020301, 0x67cea967, 0x2b567d2b,
	 0xfee719fe, 0xd7b562d7, 0xab4de6ab, 0x76ec9a76,
	 0xca8f45ca, 0x821f9d82, 0xc98940c9, 0x7dfa877d,
	 0xfaef15fa, 0x59b2eb59, 0x478ec947, 0xf0fb0bf0,
	 0xad41ecad, 0xd4b367d4, 0xa25ffda2, 0xaf45eaaf,
	 0x9c23bf9c, 0xa453f7a4, 0x72e49672, 0xc09b5bc0,
	 0xb775c2b7, 0xfde11cfd, 0x933dae93, 0x264c6a26,
	 0x366c5a36, 0x3f7e413f, 0xf7f502f7, 0xcc834fcc,
	 0x34685c34, 0xa551f4a5, 0xe5d134e5, 0xf1f908f1,
	 0x71e29371, 0xd8ab73d8, 0x31625331, 0x152a3f15,
	 0x04080c04, 0xc79552c7, 0x23466523, 0xc39d5ec3,
	 0x18302818, 0x9637a196, 0x050a0f05, 0x9a2fb59a,
	 0x070e0907, 0x12243612, 0x801b9b80, 0xe2df3de2,
	 0xebcd26eb, 0x274e6927, 0xb27fcdb2, 0x75ea9f75,
	 0x09121b09, 0x831d9e83, 0x2c58742c, 0x1a342e1a,
	 0x1b362d1b, 0x6edcb26e, 0x5ab4ee5a, 0xa05bfba0,
	 0x52a4f652, 0x3b764d3b, 0xd6b761d6, 0xb37dceb3,
	 0x29527b29, 0xe3dd3ee3, 0x2f5e712f, 0x84139784,
	 0x53a6f553, 0xd1b968d1, 0x00000000, 0xedc12ced,
	 0x20406020, 0xfce31ffc, 0xb179c8b1, 0x5bb6ed5b,
	 0x6ad4be6a, 0xcb8d46cb, 0xbe67d9be, 0x39724b39,
	 0x4a94de4a, 0x4c98d44c, 0x58b0e858, 0xcf854acf,
	 0xd0bb6bd0, 0xefc52aef, 0xaa4fe5aa, 0xfbed16fb,
	 0x4386c543, 0x4d9ad74d, 0x33665533, 0x85119485,
	 0x458acf45, 0xf9e910f9, 0x02040602, 0x7ffe817f,
	 0x50a0f050, 0x3c78443c, 0x9f25ba9f, 0xa84be3a8,
	 0x51a2f351, 0xa35dfea3, 0x4080c040, 0x8f058a8f,
	 0x923fad92, 0x9d21bc9d, 0x38704838, 0xf5f104f5,
	 0xbc63dfbc, 0xb677c1b6, 0xdaaf75da, 0x21426321,
	 0x10203010, 0xffe51aff, 0xf3fd0ef3, 0xd2bf6dd2,
	 0xcd814ccd, 0x0c18140c, 0x13263513, 0xecc32fec,
	 0x5fbee15f, 0x9735a297, 0x4488cc44, 0x172e3917,
	 0xc49357c4, 0xa755f2a7, 0x7efc827e, 0x3d7a473d,
	 0x64c8ac64, 0x5dbae75d, 0x19322b19, 0x73e69573,
	 0x60c0a060, 0x81199881, 0x4f9ed14f, 0xdca37fdc,
	 0x22446622, 0x2a547e2a, 0x903bab90, 0x880b8388,
	 0x468cca46, 0xeec729ee, 0xb86bd3b8, 0x14283c14,
	 0xdea779de, 0x5ebce25e, 0x0b161d0b, 0xdbad76db,
	 0xe0db3be0, 0x32645632, 0x3a744e3a, 0x0a141e0a,
	 0x4992db49, 0x060c0a06, 0x24486c24, 0x5cb8e45c,
	 0xc29f5dc2, 0xd3bd6ed3, 0xac43efac, 0x62c4a662,
	 0x9139a891, 0x9531a495, 0xe4d337e4, 0x79f28b79,
	 0xe7d532e7, 0xc88b43c8, 0x376e5937, 0x6ddab76d,
	 0x8d018c8d, 0xd5b164d5, 0x4e9cd24e, 0xa949e0a9,
	 0x6cd8b46c, 0x56acfa56, 0xf4f307f4, 0xeacf25ea,
	 0x65caaf65, 0x7af48e7a, 0xae47e9ae, 0x08101808,
	 0xba6fd5ba, 0x78f08878, 0x254a6f25, 0x2e5c722e,
	 0x1c38241c, 0xa657f1a6, 0xb473c7b4, 0xc69751c6,
	 0xe8cb23e8, 0xdda17cdd, 0x74e89c74, 0x1f3e211f,
	 0x4b96dd4b, 0xbd61dcbd, 0x8b0d868b, 0x8a0f858a,
	 0x70e09070, 0x3e7c423e, 0xb571c4b5, 0x66ccaa66,
	 0x4890d848, 0x03060503, 0xf6f701f6, 0x0e1c120e,
	 0x61c2a361, 0x356a5f35, 0x57aef957, 0xb969d0b9,
	 0x86179186, 0xc19958c1, 0x1d3a271d, 0x9e27b99e,
	 0xe1d938e1, 0xf8eb13f8, 0x982bb398, 0x11223311,
	 0x69d2bb69, 0xd9a970d9, 0x8e07898e, 0x9433a794,
	 0x9b2db69b, 0x1e3c221e, 0x87159287, 0xe9c920e9,
	 0xce8749ce, 0x55aaff55, 0x28507828, 0xdfa57adf,
	 0x8c038f8c, 0xa159f8a1, 0x89098089, 0x0d1a170d,
	 0xbf65dabf, 0xe6d731e6, 0x4284c642, 0x68d0b868,
	 0x4182c341, 0x9929b099, 0x2d5a772d, 0x0f1e110f,
	 0xb07bcbb0, 0x54a8fc54, 0xbb6dd6bb, 0x162c3a16 ];
	 
	 var T4 = [
	 0xc6a56363, 0xf8847c7c, 0xee997777, 0xf68d7b7b,
	 0xff0df2f2, 0xd6bd6b6b, 0xdeb16f6f, 0x9154c5c5,
	 0x60503030, 0x02030101, 0xcea96767, 0x567d2b2b,
	 0xe719fefe, 0xb562d7d7, 0x4de6abab, 0xec9a7676,
	 0x8f45caca, 0x1f9d8282, 0x8940c9c9, 0xfa877d7d,
	 0xef15fafa, 0xb2eb5959, 0x8ec94747, 0xfb0bf0f0,
	 0x41ecadad, 0xb367d4d4, 0x5ffda2a2, 0x45eaafaf,
	 0x23bf9c9c, 0x53f7a4a4, 0xe4967272, 0x9b5bc0c0,
	 0x75c2b7b7, 0xe11cfdfd, 0x3dae9393, 0x4c6a2626,
	 0x6c5a3636, 0x7e413f3f, 0xf502f7f7, 0x834fcccc,
	 0x685c3434, 0x51f4a5a5, 0xd134e5e5, 0xf908f1f1,
	 0xe2937171, 0xab73d8d8, 0x62533131, 0x2a3f1515,
	 0x080c0404, 0x9552c7c7, 0x46652323, 0x9d5ec3c3,
	 0x30281818, 0x37a19696, 0x0a0f0505, 0x2fb59a9a,
	 0x0e090707, 0x24361212, 0x1b9b8080, 0xdf3de2e2,
	 0xcd26ebeb, 0x4e692727, 0x7fcdb2b2, 0xea9f7575,
	 0x121b0909, 0x1d9e8383, 0x58742c2c, 0x342e1a1a,
	 0x362d1b1b, 0xdcb26e6e, 0xb4ee5a5a, 0x5bfba0a0,
	 0xa4f65252, 0x764d3b3b, 0xb761d6d6, 0x7dceb3b3,
	 0x527b2929, 0xdd3ee3e3, 0x5e712f2f, 0x13978484,
	 0xa6f55353, 0xb968d1d1, 0x00000000, 0xc12ceded,
	 0x40602020, 0xe31ffcfc, 0x79c8b1b1, 0xb6ed5b5b,
	 0xd4be6a6a, 0x8d46cbcb, 0x67d9bebe, 0x724b3939,
	 0x94de4a4a, 0x98d44c4c, 0xb0e85858, 0x854acfcf,
	 0xbb6bd0d0, 0xc52aefef, 0x4fe5aaaa, 0xed16fbfb,
	 0x86c54343, 0x9ad74d4d, 0x66553333, 0x11948585,
	 0x8acf4545, 0xe910f9f9, 0x04060202, 0xfe817f7f,
	 0xa0f05050, 0x78443c3c, 0x25ba9f9f, 0x4be3a8a8,
	 0xa2f35151, 0x5dfea3a3, 0x80c04040, 0x058a8f8f,
	 0x3fad9292, 0x21bc9d9d, 0x70483838, 0xf104f5f5,
	 0x63dfbcbc, 0x77c1b6b6, 0xaf75dada, 0x42632121,
	 0x20301010, 0xe51affff, 0xfd0ef3f3, 0xbf6dd2d2,
	 0x814ccdcd, 0x18140c0c, 0x26351313, 0xc32fecec,
	 0xbee15f5f, 0x35a29797, 0x88cc4444, 0x2e391717,
	 0x9357c4c4, 0x55f2a7a7, 0xfc827e7e, 0x7a473d3d,
	 0xc8ac6464, 0xbae75d5d, 0x322b1919, 0xe6957373,
	 0xc0a06060, 0x19988181, 0x9ed14f4f, 0xa37fdcdc,
	 0x44662222, 0x547e2a2a, 0x3bab9090, 0x0b838888,
	 0x8cca4646, 0xc729eeee, 0x6bd3b8b8, 0x283c1414,
	 0xa779dede, 0xbce25e5e, 0x161d0b0b, 0xad76dbdb,
	 0xdb3be0e0, 0x64563232, 0x744e3a3a, 0x141e0a0a,
	 0x92db4949, 0x0c0a0606, 0x486c2424, 0xb8e45c5c,
	 0x9f5dc2c2, 0xbd6ed3d3, 0x43efacac, 0xc4a66262,
	 0x39a89191, 0x31a49595, 0xd337e4e4, 0xf28b7979,
	 0xd532e7e7, 0x8b43c8c8, 0x6e593737, 0xdab76d6d,
	 0x018c8d8d, 0xb164d5d5, 0x9cd24e4e, 0x49e0a9a9,
	 0xd8b46c6c, 0xacfa5656, 0xf307f4f4, 0xcf25eaea,
	 0xcaaf6565, 0xf48e7a7a, 0x47e9aeae, 0x10180808,
	 0x6fd5baba, 0xf0887878, 0x4a6f2525, 0x5c722e2e,
	 0x38241c1c, 0x57f1a6a6, 0x73c7b4b4, 0x9751c6c6,
	 0xcb23e8e8, 0xa17cdddd, 0xe89c7474, 0x3e211f1f,
	 0x96dd4b4b, 0x61dcbdbd, 0x0d868b8b, 0x0f858a8a,
	 0xe0907070, 0x7c423e3e, 0x71c4b5b5, 0xccaa6666,
	 0x90d84848, 0x06050303, 0xf701f6f6, 0x1c120e0e,
	 0xc2a36161, 0x6a5f3535, 0xaef95757, 0x69d0b9b9,
	 0x17918686, 0x9958c1c1, 0x3a271d1d, 0x27b99e9e,
	 0xd938e1e1, 0xeb13f8f8, 0x2bb39898, 0x22331111,
	 0xd2bb6969, 0xa970d9d9, 0x07898e8e, 0x33a79494,
	 0x2db69b9b, 0x3c221e1e, 0x15928787, 0xc920e9e9,
	 0x8749cece, 0xaaff5555, 0x50782828, 0xa57adfdf,
	 0x038f8c8c, 0x59f8a1a1, 0x09808989, 0x1a170d0d,
	 0x65dabfbf, 0xd731e6e6, 0x84c64242, 0xd0b86868,
	 0x82c34141, 0x29b09999, 0x5a772d2d, 0x1e110f0f,
	 0x7bcbb0b0, 0xa8fc5454, 0x6dd6bbbb, 0x2c3a1616 ];
	 
	 function B0(x) { return (x&255); }
	 function B1(x) { return ((x>>8)&255); }
	 function B2(x) { return ((x>>16)&255); }
	 function B3(x) { return ((x>>24)&255); }
	 
	 function F1(x0, x1, x2, x3)
	 {
	   return B1(T1[x0&255]) | (B1(T1[(x1>>8)&255])<<8)
	       | (B1(T1[(x2>>16)&255])<<16) | (B1(T1[x3>>>24])<<24);
	 }
	 
	 function packBytes(octets)
	 {
	   var i, j;
	   var len=octets.length;
	   var b=new Array(len/4);
	 
	   if (!octets || len % 4) return;
	 
	   for (i=0, j=0; j<len; j+= 4)
	      b[i++] = octets[j] | (octets[j+1]<<8) | (octets[j+2]<<16) | (octets[j+3]<<24);
	 
	   return b;  
	 }
	 
	 function unpackBytes(packed)
	 {
	   var j;
	   var i=0, l = packed.length;
	   var r = new Array(l*4);
	 
	   for (j=0; j<l; j++)
	   {
	     r[i++] = B0(packed[j]);
	     r[i++] = B1(packed[j]);
	     r[i++] = B2(packed[j]);
	     r[i++] = B3(packed[j]);
	   }
	   return r;
	 }
	 
	 // ------------------------------------------------
	 
	 var maxkc=8;
	 var maxrk=14;
	 
	 function keyExpansion(key)
	 {
	   var kc, i, j, r, t;
	   var rounds;
	   var keySched=new Array(maxrk+1);
	   var keylen=key.length;
	   var k=new Array(maxkc);
	   var tk=new Array(maxkc);
	   var rconpointer=0;
	 
	   if(keylen==16)
	   {
	    rounds=10;
	    kc=4;
	   }
	   else if(keylen==24)
	   {
	    rounds=12;
	    kc=6;
	   }
	   else if(keylen==32)
	   {
	    rounds=14;
	    kc=8;
	   }
	   else
	   {
	 	util.print_error('aes.js: Invalid key-length for AES key:'+keylen);
	    return;
	   }
	 
	   for(i=0; i<maxrk+1; i++) keySched[i]=new Array(4);
	 
	   for(i=0,j=0; j<keylen; j++,i+=4)
	     k[j] = key.charCodeAt(i) | (key.charCodeAt(i+1)<<8)
	                      | (key.charCodeAt(i+2)<<16) | (key.charCodeAt(i+3)<<24);
	 
	   for(j=kc-1; j>=0; j--) tk[j] = k[j];
	 
	   r=0;
	   t=0;
	   for(j=0; (j<kc)&&(r<rounds+1); )
	   {
	     for(; (j<kc)&&(t<4); j++,t++)
	     {
	       keySched[r][t]=tk[j];
	     }
	     if(t==4)
	     {
	       r++;
	       t=0;
	     }
	   }
	 
	   while(r<rounds+1)
	   {
	     var temp = tk[kc-1];
	 
	     tk[0] ^= S[B1(temp)] | (S[B2(temp)]<<8) | (S[B3(temp)]<<16) | (S[B0(temp)]<<24);
	     tk[0] ^= Rcon[rconpointer++];
	 
	     if(kc != 8)
	     {
	       for(j=1; j<kc; j++) tk[j] ^= tk[j-1];
	     }
	     else
	     {
	       for(j=1; j<kc/2; j++) tk[j] ^= tk[j-1];
	  
	       temp = tk[kc/2-1];
	       tk[kc/2] ^= S[B0(temp)] | (S[B1(temp)]<<8) | (S[B2(temp)]<<16) | (S[B3(temp)]<<24);
	 
	       for(j=kc/2+1; j<kc; j++) tk[j] ^= tk[j-1];
	     }
	 
	     for(j=0; (j<kc)&&(r<rounds+1); )
	     {
	       for(; (j<kc)&&(t<4); j++,t++)
	       {
	         keySched[r][t]=tk[j];
	       }
	       if(t==4)
	       {
	         r++;
	         t=0;
	       }
	     }
	   }
	   this.rounds = rounds;
	   this.rk = keySched;
	   return this;
	 }
	 
	 function AESencrypt(block, ctx)
	 {
	   var r;
	   var t0,t1,t2,t3;
	 
	   var b = packBytes(block);
	   var rounds = ctx.rounds;
	   var b0 = b[0];
	   var b1 = b[1];
	   var b2 = b[2];
	   var b3 = b[3];
	 
	   for(r=0; r<rounds-1; r++)
	   {
	     t0 = b0 ^ ctx.rk[r][0];
	     t1 = b1 ^ ctx.rk[r][1];
	     t2 = b2 ^ ctx.rk[r][2];
	     t3 = b3 ^ ctx.rk[r][3];
	 
	     b0 = T1[t0&255] ^ T2[(t1>>8)&255] ^ T3[(t2>>16)&255] ^ T4[t3>>>24];
	     b1 = T1[t1&255] ^ T2[(t2>>8)&255] ^ T3[(t3>>16)&255] ^ T4[t0>>>24];
	     b2 = T1[t2&255] ^ T2[(t3>>8)&255] ^ T3[(t0>>16)&255] ^ T4[t1>>>24];
	     b3 = T1[t3&255] ^ T2[(t0>>8)&255] ^ T3[(t1>>16)&255] ^ T4[t2>>>24];
	   }
	 
	   // last round is special
	   r = rounds-1;
	 
	   t0 = b0 ^ ctx.rk[r][0];
	   t1 = b1 ^ ctx.rk[r][1];
	   t2 = b2 ^ ctx.rk[r][2];
	   t3 = b3 ^ ctx.rk[r][3];
	 
	   b[0] = F1(t0, t1, t2, t3) ^ ctx.rk[rounds][0];
	   b[1] = F1(t1, t2, t3, t0) ^ ctx.rk[rounds][1];
	   b[2] = F1(t2, t3, t0, t1) ^ ctx.rk[rounds][2];
	   b[3] = F1(t3, t0, t1, t2) ^ ctx.rk[rounds][3];
	 
	   return unpackBytes(b);
	 }
	 /* Modified by Recurity Labs GmbH 
	  * 
	  * Originally written by nklein software (nklein.com)
	  */
	 
	 /* 
	  * Javascript implementation based on Bruce Schneier's reference implementation.
	  *
	  *
	  * The constructor doesn't do much of anything.  It's just here
	  * so we can start defining properties and methods and such.
	  */
	 function Blowfish() {
	 };
	 
	 /*
	  * Declare the block size so that protocols know what size
	  * Initialization Vector (IV) they will need.
	  */
	 Blowfish.prototype.BLOCKSIZE = 8;
	 
	 /*
	  * These are the default SBOXES.
	  */
	 Blowfish.prototype.SBOXES = [
	     [
	 	0xd1310ba6, 0x98dfb5ac, 0x2ffd72db, 0xd01adfb7, 0xb8e1afed, 0x6a267e96,
	 	0xba7c9045, 0xf12c7f99, 0x24a19947, 0xb3916cf7, 0x0801f2e2, 0x858efc16,
	 	0x636920d8, 0x71574e69, 0xa458fea3, 0xf4933d7e, 0x0d95748f, 0x728eb658,
	 	0x718bcd58, 0x82154aee, 0x7b54a41d, 0xc25a59b5, 0x9c30d539, 0x2af26013,
	 	0xc5d1b023, 0x286085f0, 0xca417918, 0xb8db38ef, 0x8e79dcb0, 0x603a180e,
	 	0x6c9e0e8b, 0xb01e8a3e, 0xd71577c1, 0xbd314b27, 0x78af2fda, 0x55605c60,
	 	0xe65525f3, 0xaa55ab94, 0x57489862, 0x63e81440, 0x55ca396a, 0x2aab10b6,
	 	0xb4cc5c34, 0x1141e8ce, 0xa15486af, 0x7c72e993, 0xb3ee1411, 0x636fbc2a,
	 	0x2ba9c55d, 0x741831f6, 0xce5c3e16, 0x9b87931e, 0xafd6ba33, 0x6c24cf5c,
	 	0x7a325381, 0x28958677, 0x3b8f4898, 0x6b4bb9af, 0xc4bfe81b, 0x66282193,
	 	0x61d809cc, 0xfb21a991, 0x487cac60, 0x5dec8032, 0xef845d5d, 0xe98575b1,
	 	0xdc262302, 0xeb651b88, 0x23893e81, 0xd396acc5, 0x0f6d6ff3, 0x83f44239,
	 	0x2e0b4482, 0xa4842004, 0x69c8f04a, 0x9e1f9b5e, 0x21c66842, 0xf6e96c9a,
	 	0x670c9c61, 0xabd388f0, 0x6a51a0d2, 0xd8542f68, 0x960fa728, 0xab5133a3,
	 	0x6eef0b6c, 0x137a3be4, 0xba3bf050, 0x7efb2a98, 0xa1f1651d, 0x39af0176,
	 	0x66ca593e, 0x82430e88, 0x8cee8619, 0x456f9fb4, 0x7d84a5c3, 0x3b8b5ebe,
	 	0xe06f75d8, 0x85c12073, 0x401a449f, 0x56c16aa6, 0x4ed3aa62, 0x363f7706,
	 	0x1bfedf72, 0x429b023d, 0x37d0d724, 0xd00a1248, 0xdb0fead3, 0x49f1c09b,
	 	0x075372c9, 0x80991b7b, 0x25d479d8, 0xf6e8def7, 0xe3fe501a, 0xb6794c3b,
	 	0x976ce0bd, 0x04c006ba, 0xc1a94fb6, 0x409f60c4, 0x5e5c9ec2, 0x196a2463,
	 	0x68fb6faf, 0x3e6c53b5, 0x1339b2eb, 0x3b52ec6f, 0x6dfc511f, 0x9b30952c,
	 	0xcc814544, 0xaf5ebd09, 0xbee3d004, 0xde334afd, 0x660f2807, 0x192e4bb3,
	 	0xc0cba857, 0x45c8740f, 0xd20b5f39, 0xb9d3fbdb, 0x5579c0bd, 0x1a60320a,
	 	0xd6a100c6, 0x402c7279, 0x679f25fe, 0xfb1fa3cc, 0x8ea5e9f8, 0xdb3222f8,
	 	0x3c7516df, 0xfd616b15, 0x2f501ec8, 0xad0552ab, 0x323db5fa, 0xfd238760,
	 	0x53317b48, 0x3e00df82, 0x9e5c57bb, 0xca6f8ca0, 0x1a87562e, 0xdf1769db,
	 	0xd542a8f6, 0x287effc3, 0xac6732c6, 0x8c4f5573, 0x695b27b0, 0xbbca58c8,
	 	0xe1ffa35d, 0xb8f011a0, 0x10fa3d98, 0xfd2183b8, 0x4afcb56c, 0x2dd1d35b,
	 	0x9a53e479, 0xb6f84565, 0xd28e49bc, 0x4bfb9790, 0xe1ddf2da, 0xa4cb7e33,
	 	0x62fb1341, 0xcee4c6e8, 0xef20cada, 0x36774c01, 0xd07e9efe, 0x2bf11fb4,
	 	0x95dbda4d, 0xae909198, 0xeaad8e71, 0x6b93d5a0, 0xd08ed1d0, 0xafc725e0,
	 	0x8e3c5b2f, 0x8e7594b7, 0x8ff6e2fb, 0xf2122b64, 0x8888b812, 0x900df01c,
	 	0x4fad5ea0, 0x688fc31c, 0xd1cff191, 0xb3a8c1ad, 0x2f2f2218, 0xbe0e1777,
	 	0xea752dfe, 0x8b021fa1, 0xe5a0cc0f, 0xb56f74e8, 0x18acf3d6, 0xce89e299,
	 	0xb4a84fe0, 0xfd13e0b7, 0x7cc43b81, 0xd2ada8d9, 0x165fa266, 0x80957705,
	 	0x93cc7314, 0x211a1477, 0xe6ad2065, 0x77b5fa86, 0xc75442f5, 0xfb9d35cf,
	 	0xebcdaf0c, 0x7b3e89a0, 0xd6411bd3, 0xae1e7e49, 0x00250e2d, 0x2071b35e,
	 	0x226800bb, 0x57b8e0af, 0x2464369b, 0xf009b91e, 0x5563911d, 0x59dfa6aa,
	 	0x78c14389, 0xd95a537f, 0x207d5ba2, 0x02e5b9c5, 0x83260376, 0x6295cfa9,
	 	0x11c81968, 0x4e734a41, 0xb3472dca, 0x7b14a94a, 0x1b510052, 0x9a532915,
	 	0xd60f573f, 0xbc9bc6e4, 0x2b60a476, 0x81e67400, 0x08ba6fb5, 0x571be91f,
	 	0xf296ec6b, 0x2a0dd915, 0xb6636521, 0xe7b9f9b6, 0xff34052e, 0xc5855664,
	 	0x53b02d5d, 0xa99f8fa1, 0x08ba4799, 0x6e85076a
	     ], [
	 	0x4b7a70e9, 0xb5b32944, 0xdb75092e, 0xc4192623, 0xad6ea6b0, 0x49a7df7d,
	 	0x9cee60b8, 0x8fedb266, 0xecaa8c71, 0x699a17ff, 0x5664526c, 0xc2b19ee1,
	 	0x193602a5, 0x75094c29, 0xa0591340, 0xe4183a3e, 0x3f54989a, 0x5b429d65,
	 	0x6b8fe4d6, 0x99f73fd6, 0xa1d29c07, 0xefe830f5, 0x4d2d38e6, 0xf0255dc1,
	 	0x4cdd2086, 0x8470eb26, 0x6382e9c6, 0x021ecc5e, 0x09686b3f, 0x3ebaefc9,
	 	0x3c971814, 0x6b6a70a1, 0x687f3584, 0x52a0e286, 0xb79c5305, 0xaa500737,
	 	0x3e07841c, 0x7fdeae5c, 0x8e7d44ec, 0x5716f2b8, 0xb03ada37, 0xf0500c0d,
	 	0xf01c1f04, 0x0200b3ff, 0xae0cf51a, 0x3cb574b2, 0x25837a58, 0xdc0921bd,
	 	0xd19113f9, 0x7ca92ff6, 0x94324773, 0x22f54701, 0x3ae5e581, 0x37c2dadc,
	 	0xc8b57634, 0x9af3dda7, 0xa9446146, 0x0fd0030e, 0xecc8c73e, 0xa4751e41,
	 	0xe238cd99, 0x3bea0e2f, 0x3280bba1, 0x183eb331, 0x4e548b38, 0x4f6db908,
	 	0x6f420d03, 0xf60a04bf, 0x2cb81290, 0x24977c79, 0x5679b072, 0xbcaf89af,
	 	0xde9a771f, 0xd9930810, 0xb38bae12, 0xdccf3f2e, 0x5512721f, 0x2e6b7124,
	 	0x501adde6, 0x9f84cd87, 0x7a584718, 0x7408da17, 0xbc9f9abc, 0xe94b7d8c,
	 	0xec7aec3a, 0xdb851dfa, 0x63094366, 0xc464c3d2, 0xef1c1847, 0x3215d908,
	 	0xdd433b37, 0x24c2ba16, 0x12a14d43, 0x2a65c451, 0x50940002, 0x133ae4dd,
	 	0x71dff89e, 0x10314e55, 0x81ac77d6, 0x5f11199b, 0x043556f1, 0xd7a3c76b,
	 	0x3c11183b, 0x5924a509, 0xf28fe6ed, 0x97f1fbfa, 0x9ebabf2c, 0x1e153c6e,
	 	0x86e34570, 0xeae96fb1, 0x860e5e0a, 0x5a3e2ab3, 0x771fe71c, 0x4e3d06fa,
	 	0x2965dcb9, 0x99e71d0f, 0x803e89d6, 0x5266c825, 0x2e4cc978, 0x9c10b36a,
	 	0xc6150eba, 0x94e2ea78, 0xa5fc3c53, 0x1e0a2df4, 0xf2f74ea7, 0x361d2b3d,
	 	0x1939260f, 0x19c27960, 0x5223a708, 0xf71312b6, 0xebadfe6e, 0xeac31f66,
	 	0xe3bc4595, 0xa67bc883, 0xb17f37d1, 0x018cff28, 0xc332ddef, 0xbe6c5aa5,
	 	0x65582185, 0x68ab9802, 0xeecea50f, 0xdb2f953b, 0x2aef7dad, 0x5b6e2f84,
	 	0x1521b628, 0x29076170, 0xecdd4775, 0x619f1510, 0x13cca830, 0xeb61bd96,
	 	0x0334fe1e, 0xaa0363cf, 0xb5735c90, 0x4c70a239, 0xd59e9e0b, 0xcbaade14,
	 	0xeecc86bc, 0x60622ca7, 0x9cab5cab, 0xb2f3846e, 0x648b1eaf, 0x19bdf0ca,
	 	0xa02369b9, 0x655abb50, 0x40685a32, 0x3c2ab4b3, 0x319ee9d5, 0xc021b8f7,
	 	0x9b540b19, 0x875fa099, 0x95f7997e, 0x623d7da8, 0xf837889a, 0x97e32d77,
	 	0x11ed935f, 0x16681281, 0x0e358829, 0xc7e61fd6, 0x96dedfa1, 0x7858ba99,
	 	0x57f584a5, 0x1b227263, 0x9b83c3ff, 0x1ac24696, 0xcdb30aeb, 0x532e3054,
	 	0x8fd948e4, 0x6dbc3128, 0x58ebf2ef, 0x34c6ffea, 0xfe28ed61, 0xee7c3c73,
	 	0x5d4a14d9, 0xe864b7e3, 0x42105d14, 0x203e13e0, 0x45eee2b6, 0xa3aaabea,
	 	0xdb6c4f15, 0xfacb4fd0, 0xc742f442, 0xef6abbb5, 0x654f3b1d, 0x41cd2105,
	 	0xd81e799e, 0x86854dc7, 0xe44b476a, 0x3d816250, 0xcf62a1f2, 0x5b8d2646,
	 	0xfc8883a0, 0xc1c7b6a3, 0x7f1524c3, 0x69cb7492, 0x47848a0b, 0x5692b285,
	 	0x095bbf00, 0xad19489d, 0x1462b174, 0x23820e00, 0x58428d2a, 0x0c55f5ea,
	 	0x1dadf43e, 0x233f7061, 0x3372f092, 0x8d937e41, 0xd65fecf1, 0x6c223bdb,
	 	0x7cde3759, 0xcbee7460, 0x4085f2a7, 0xce77326e, 0xa6078084, 0x19f8509e,
	 	0xe8efd855, 0x61d99735, 0xa969a7aa, 0xc50c06c2, 0x5a04abfc, 0x800bcadc,
	 	0x9e447a2e, 0xc3453484, 0xfdd56705, 0x0e1e9ec9, 0xdb73dbd3, 0x105588cd,
	 	0x675fda79, 0xe3674340, 0xc5c43465, 0x713e38d8, 0x3d28f89e, 0xf16dff20,
	 	0x153e21e7, 0x8fb03d4a, 0xe6e39f2b, 0xdb83adf7
	     ], [
	 	0xe93d5a68, 0x948140f7, 0xf64c261c, 0x94692934, 0x411520f7, 0x7602d4f7,
	 	0xbcf46b2e, 0xd4a20068, 0xd4082471, 0x3320f46a, 0x43b7d4b7, 0x500061af,
	 	0x1e39f62e, 0x97244546, 0x14214f74, 0xbf8b8840, 0x4d95fc1d, 0x96b591af,
	 	0x70f4ddd3, 0x66a02f45, 0xbfbc09ec, 0x03bd9785, 0x7fac6dd0, 0x31cb8504,
	 	0x96eb27b3, 0x55fd3941, 0xda2547e6, 0xabca0a9a, 0x28507825, 0x530429f4,
	 	0x0a2c86da, 0xe9b66dfb, 0x68dc1462, 0xd7486900, 0x680ec0a4, 0x27a18dee,
	 	0x4f3ffea2, 0xe887ad8c, 0xb58ce006, 0x7af4d6b6, 0xaace1e7c, 0xd3375fec,
	 	0xce78a399, 0x406b2a42, 0x20fe9e35, 0xd9f385b9, 0xee39d7ab, 0x3b124e8b,
	 	0x1dc9faf7, 0x4b6d1856, 0x26a36631, 0xeae397b2, 0x3a6efa74, 0xdd5b4332,
	 	0x6841e7f7, 0xca7820fb, 0xfb0af54e, 0xd8feb397, 0x454056ac, 0xba489527,
	 	0x55533a3a, 0x20838d87, 0xfe6ba9b7, 0xd096954b, 0x55a867bc, 0xa1159a58,
	 	0xcca92963, 0x99e1db33, 0xa62a4a56, 0x3f3125f9, 0x5ef47e1c, 0x9029317c,
	 	0xfdf8e802, 0x04272f70, 0x80bb155c, 0x05282ce3, 0x95c11548, 0xe4c66d22,
	 	0x48c1133f, 0xc70f86dc, 0x07f9c9ee, 0x41041f0f, 0x404779a4, 0x5d886e17,
	 	0x325f51eb, 0xd59bc0d1, 0xf2bcc18f, 0x41113564, 0x257b7834, 0x602a9c60,
	 	0xdff8e8a3, 0x1f636c1b, 0x0e12b4c2, 0x02e1329e, 0xaf664fd1, 0xcad18115,
	 	0x6b2395e0, 0x333e92e1, 0x3b240b62, 0xeebeb922, 0x85b2a20e, 0xe6ba0d99,
	 	0xde720c8c, 0x2da2f728, 0xd0127845, 0x95b794fd, 0x647d0862, 0xe7ccf5f0,
	 	0x5449a36f, 0x877d48fa, 0xc39dfd27, 0xf33e8d1e, 0x0a476341, 0x992eff74,
	 	0x3a6f6eab, 0xf4f8fd37, 0xa812dc60, 0xa1ebddf8, 0x991be14c, 0xdb6e6b0d,
	 	0xc67b5510, 0x6d672c37, 0x2765d43b, 0xdcd0e804, 0xf1290dc7, 0xcc00ffa3,
	 	0xb5390f92, 0x690fed0b, 0x667b9ffb, 0xcedb7d9c, 0xa091cf0b, 0xd9155ea3,
	 	0xbb132f88, 0x515bad24, 0x7b9479bf, 0x763bd6eb, 0x37392eb3, 0xcc115979,
	 	0x8026e297, 0xf42e312d, 0x6842ada7, 0xc66a2b3b, 0x12754ccc, 0x782ef11c,
	 	0x6a124237, 0xb79251e7, 0x06a1bbe6, 0x4bfb6350, 0x1a6b1018, 0x11caedfa,
	 	0x3d25bdd8, 0xe2e1c3c9, 0x44421659, 0x0a121386, 0xd90cec6e, 0xd5abea2a,
	 	0x64af674e, 0xda86a85f, 0xbebfe988, 0x64e4c3fe, 0x9dbc8057, 0xf0f7c086,
	 	0x60787bf8, 0x6003604d, 0xd1fd8346, 0xf6381fb0, 0x7745ae04, 0xd736fccc,
	 	0x83426b33, 0xf01eab71, 0xb0804187, 0x3c005e5f, 0x77a057be, 0xbde8ae24,
	 	0x55464299, 0xbf582e61, 0x4e58f48f, 0xf2ddfda2, 0xf474ef38, 0x8789bdc2,
	 	0x5366f9c3, 0xc8b38e74, 0xb475f255, 0x46fcd9b9, 0x7aeb2661, 0x8b1ddf84,
	 	0x846a0e79, 0x915f95e2, 0x466e598e, 0x20b45770, 0x8cd55591, 0xc902de4c,
	 	0xb90bace1, 0xbb8205d0, 0x11a86248, 0x7574a99e, 0xb77f19b6, 0xe0a9dc09,
	 	0x662d09a1, 0xc4324633, 0xe85a1f02, 0x09f0be8c, 0x4a99a025, 0x1d6efe10,
	 	0x1ab93d1d, 0x0ba5a4df, 0xa186f20f, 0x2868f169, 0xdcb7da83, 0x573906fe,
	 	0xa1e2ce9b, 0x4fcd7f52, 0x50115e01, 0xa70683fa, 0xa002b5c4, 0x0de6d027,
	 	0x9af88c27, 0x773f8641, 0xc3604c06, 0x61a806b5, 0xf0177a28, 0xc0f586e0,
	 	0x006058aa, 0x30dc7d62, 0x11e69ed7, 0x2338ea63, 0x53c2dd94, 0xc2c21634,
	 	0xbbcbee56, 0x90bcb6de, 0xebfc7da1, 0xce591d76, 0x6f05e409, 0x4b7c0188,
	 	0x39720a3d, 0x7c927c24, 0x86e3725f, 0x724d9db9, 0x1ac15bb4, 0xd39eb8fc,
	 	0xed545578, 0x08fca5b5, 0xd83d7cd3, 0x4dad0fc4, 0x1e50ef5e, 0xb161e6f8,
	 	0xa28514d9, 0x6c51133c, 0x6fd5c7e7, 0x56e14ec4, 0x362abfce, 0xddc6c837,
	 	0xd79a3234, 0x92638212, 0x670efa8e, 0x406000e0
	     ], [
	 	0x3a39ce37, 0xd3faf5cf, 0xabc27737, 0x5ac52d1b, 0x5cb0679e, 0x4fa33742,
	 	0xd3822740, 0x99bc9bbe, 0xd5118e9d, 0xbf0f7315, 0xd62d1c7e, 0xc700c47b,
	 	0xb78c1b6b, 0x21a19045, 0xb26eb1be, 0x6a366eb4, 0x5748ab2f, 0xbc946e79,
	 	0xc6a376d2, 0x6549c2c8, 0x530ff8ee, 0x468dde7d, 0xd5730a1d, 0x4cd04dc6,
	 	0x2939bbdb, 0xa9ba4650, 0xac9526e8, 0xbe5ee304, 0xa1fad5f0, 0x6a2d519a,
	 	0x63ef8ce2, 0x9a86ee22, 0xc089c2b8, 0x43242ef6, 0xa51e03aa, 0x9cf2d0a4,
	 	0x83c061ba, 0x9be96a4d, 0x8fe51550, 0xba645bd6, 0x2826a2f9, 0xa73a3ae1,
	 	0x4ba99586, 0xef5562e9, 0xc72fefd3, 0xf752f7da, 0x3f046f69, 0x77fa0a59,
	 	0x80e4a915, 0x87b08601, 0x9b09e6ad, 0x3b3ee593, 0xe990fd5a, 0x9e34d797,
	 	0x2cf0b7d9, 0x022b8b51, 0x96d5ac3a, 0x017da67d, 0xd1cf3ed6, 0x7c7d2d28,
	 	0x1f9f25cf, 0xadf2b89b, 0x5ad6b472, 0x5a88f54c, 0xe029ac71, 0xe019a5e6,
	 	0x47b0acfd, 0xed93fa9b, 0xe8d3c48d, 0x283b57cc, 0xf8d56629, 0x79132e28,
	 	0x785f0191, 0xed756055, 0xf7960e44, 0xe3d35e8c, 0x15056dd4, 0x88f46dba,
	 	0x03a16125, 0x0564f0bd, 0xc3eb9e15, 0x3c9057a2, 0x97271aec, 0xa93a072a,
	 	0x1b3f6d9b, 0x1e6321f5, 0xf59c66fb, 0x26dcf319, 0x7533d928, 0xb155fdf5,
	 	0x03563482, 0x8aba3cbb, 0x28517711, 0xc20ad9f8, 0xabcc5167, 0xccad925f,
	 	0x4de81751, 0x3830dc8e, 0x379d5862, 0x9320f991, 0xea7a90c2, 0xfb3e7bce,
	 	0x5121ce64, 0x774fbe32, 0xa8b6e37e, 0xc3293d46, 0x48de5369, 0x6413e680,
	 	0xa2ae0810, 0xdd6db224, 0x69852dfd, 0x09072166, 0xb39a460a, 0x6445c0dd,
	 	0x586cdecf, 0x1c20c8ae, 0x5bbef7dd, 0x1b588d40, 0xccd2017f, 0x6bb4e3bb,
	 	0xdda26a7e, 0x3a59ff45, 0x3e350a44, 0xbcb4cdd5, 0x72eacea8, 0xfa6484bb,
	 	0x8d6612ae, 0xbf3c6f47, 0xd29be463, 0x542f5d9e, 0xaec2771b, 0xf64e6370,
	 	0x740e0d8d, 0xe75b1357, 0xf8721671, 0xaf537d5d, 0x4040cb08, 0x4eb4e2cc,
	 	0x34d2466a, 0x0115af84, 0xe1b00428, 0x95983a1d, 0x06b89fb4, 0xce6ea048,
	 	0x6f3f3b82, 0x3520ab82, 0x011a1d4b, 0x277227f8, 0x611560b1, 0xe7933fdc,
	 	0xbb3a792b, 0x344525bd, 0xa08839e1, 0x51ce794b, 0x2f32c9b7, 0xa01fbac9,
	 	0xe01cc87e, 0xbcc7d1f6, 0xcf0111c3, 0xa1e8aac7, 0x1a908749, 0xd44fbd9a,
	 	0xd0dadecb, 0xd50ada38, 0x0339c32a, 0xc6913667, 0x8df9317c, 0xe0b12b4f,
	 	0xf79e59b7, 0x43f5bb3a, 0xf2d519ff, 0x27d9459c, 0xbf97222c, 0x15e6fc2a,
	 	0x0f91fc71, 0x9b941525, 0xfae59361, 0xceb69ceb, 0xc2a86459, 0x12baa8d1,
	 	0xb6c1075e, 0xe3056a0c, 0x10d25065, 0xcb03a442, 0xe0ec6e0e, 0x1698db3b,
	 	0x4c98a0be, 0x3278e964, 0x9f1f9532, 0xe0d392df, 0xd3a0342b, 0x8971f21e,
	 	0x1b0a7441, 0x4ba3348c, 0xc5be7120, 0xc37632d8, 0xdf359f8d, 0x9b992f2e,
	 	0xe60b6f47, 0x0fe3f11d, 0xe54cda54, 0x1edad891, 0xce6279cf, 0xcd3e7e6f,
	 	0x1618b166, 0xfd2c1d05, 0x848fd2c5, 0xf6fb2299, 0xf523f357, 0xa6327623,
	 	0x93a83531, 0x56cccd02, 0xacf08162, 0x5a75ebb5, 0x6e163697, 0x88d273cc,
	 	0xde966292, 0x81b949d0, 0x4c50901b, 0x71c65614, 0xe6c6c7bd, 0x327a140a,
	 	0x45e1d006, 0xc3f27b9a, 0xc9aa53fd, 0x62a80f00, 0xbb25bfe2, 0x35bdd2f6,
	 	0x71126905, 0xb2040222, 0xb6cbcf7c, 0xcd769c2b, 0x53113ec0, 0x1640e3d3,
	 	0x38abbd60, 0x2547adf0, 0xba38209c, 0xf746ce76, 0x77afa1c5, 0x20756060,
	 	0x85cbfe4e, 0x8ae88dd8, 0x7aaaf9b0, 0x4cf9aa7e, 0x1948c25c, 0x02fb8a8c,
	 	0x01c36ae4, 0xd6ebe1f9, 0x90d4f869, 0xa65cdea0, 0x3f09252d, 0xc208e69f,
	 	0xb74e6132, 0xce77e25b, 0x578fdfe3, 0x3ac372e6
	     ]
	 ];
	 
	 //*
	 //* This is the default PARRAY
	 //*
	 Blowfish.prototype.PARRAY = [
	     0x243f6a88, 0x85a308d3, 0x13198a2e, 0x03707344, 0xa4093822, 0x299f31d0,
	     0x082efa98, 0xec4e6c89, 0x452821e6, 0x38d01377, 0xbe5466cf, 0x34e90c6c,
	     0xc0ac29b7, 0xc97c50dd, 0x3f84d5b5, 0xb5470917, 0x9216d5d9, 0x8979fb1b
	 ];
	 
	 //*
	 //* This is the number of rounds the cipher will go
	 //*
	 Blowfish.prototype.NN = 16;
	 
	 //*
	 //* This function is needed to get rid of problems
	 //* with the high-bit getting set.  If we don't do
	 //* this, then sometimes ( aa & 0x00FFFFFFFF ) is not
	 //* equal to ( bb & 0x00FFFFFFFF ) even when they
	 //* agree bit-for-bit for the first 32 bits.
	 //*
	 Blowfish.prototype._clean = function( xx ) {
	     if ( xx < 0 ) {
	 	var yy = xx & 0x7FFFFFFF;
	 	xx = yy + 0x80000000;
	     }
	     return xx;
	 };
	 
	 //*
	 //* This is the mixing function that uses the sboxes
	 //*
	 Blowfish.prototype._F = function ( xx ) {
	     var aa;
	     var bb;
	     var cc;
	     var dd;
	     var yy;
	 
	     dd = xx & 0x00FF;
	     xx >>>= 8;
	     cc = xx & 0x00FF;
	     xx >>>= 8;
	     bb = xx & 0x00FF;
	     xx >>>= 8;
	     aa = xx & 0x00FF;
	 
	     yy = this.sboxes[ 0 ][ aa ] + this.sboxes[ 1 ][ bb ];
	     yy = yy ^ this.sboxes[ 2 ][ cc ];
	     yy = yy + this.sboxes[ 3 ][ dd ];
	 
	     return yy;
	 };
	 
	 //*
	 //* This method takes an array with two values, left and right
	 //* and does NN rounds of Blowfish on them.
	 //*
	 Blowfish.prototype._encrypt_block = function ( vals ) {
	     var dataL = vals[ 0 ];
	     var dataR = vals[ 1 ];
	 
	     var ii;
	 
	     for ( ii=0; ii < this.NN; ++ii ) {
	 	dataL = dataL ^ this.parray[ ii ];
	 	dataR = this._F( dataL ) ^ dataR;
	 
	 	var tmp = dataL;
	 	dataL = dataR;
	 	dataR = tmp;
	     }
	 
	     dataL = dataL ^ this.parray[ this.NN + 0 ];
	     dataR = dataR ^ this.parray[ this.NN + 1 ];
	 
	     vals[ 0 ] = this._clean( dataR );
	     vals[ 1 ] = this._clean( dataL );
	 };
	 
	 //*
	 //* This method takes a vector of numbers and turns them
	 //* into long words so that they can be processed by the
	 //* real algorithm.
	 //*
	 //* Maybe I should make the real algorithm above take a vector
	 //* instead.  That will involve more looping, but it won't require
	 //* the F() method to deconstruct the vector.
	 //*
	 Blowfish.prototype.encrypt_block = function ( vector ) {
	     var ii;
	     var vals = [ 0, 0 ];
	     var off  = this.BLOCKSIZE/2;
	     for ( ii = 0; ii < this.BLOCKSIZE/2; ++ii ) {
	 	vals[0] = ( vals[0] << 8 ) | ( vector[ ii + 0   ] & 0x00FF );
	 	vals[1] = ( vals[1] << 8 ) | ( vector[ ii + off ] & 0x00FF );
	     }
	 
	     this._encrypt_block( vals );
	 
	     var ret = [ ];
	     for ( ii = 0; ii < this.BLOCKSIZE/2; ++ii ) {
	 	ret[ ii + 0   ] = ( vals[ 0 ] >>> (24 - 8*(ii)) & 0x00FF );
	 	ret[ ii + off ] = ( vals[ 1 ] >>> (24 - 8*(ii)) & 0x00FF );
	 	// vals[ 0 ] = ( vals[ 0 ] >>> 8 );
	 	// vals[ 1 ] = ( vals[ 1 ] >>> 8 );
	     }
	 
	     return ret;
	 };
	 
	 //*
	 //* This method takes an array with two values, left and right
	 //* and undoes NN rounds of Blowfish on them.
	 //*
	 Blowfish.prototype._decrypt_block = function ( vals ) {
	     var dataL = vals[ 0 ];
	     var dataR = vals[ 1 ];
	 
	     var ii;
	 
	     for ( ii=this.NN+1; ii > 1; --ii ) {
	 	dataL = dataL ^ this.parray[ ii ];
	 	dataR = this._F( dataL ) ^ dataR;
	 
	 	var tmp = dataL;
	 	dataL = dataR;
	 	dataR = tmp;
	     }
	 
	     dataL = dataL ^ this.parray[ 1 ];
	     dataR = dataR ^ this.parray[ 0 ];
	 
	     vals[ 0 ] = this._clean( dataR );
	     vals[ 1 ] = this._clean( dataL );
	 };
	 
	 //*
	 //* This method takes a key array and initializes the
	 //* sboxes and parray for this encryption.
	 //*
	 Blowfish.prototype.init = function ( key ) {
	     var ii;
	     var jj = 0;
	 
	     this.parray = [];
	     for ( ii=0; ii < this.NN + 2; ++ii ) {
	 	var data = 0x00000000;
	 	var kk;
	 	for ( kk=0; kk < 4; ++kk ) {
	 	    data = ( data << 8 ) | ( key[ jj ] & 0x00FF );
	 	    if ( ++jj >= key.length ) {
	 		jj = 0;
	 	    }
	 	}
	 	this.parray[ ii ] = this.PARRAY[ ii ] ^ data;
	     }
	 
	     this.sboxes = [];
	     for ( ii=0; ii < 4; ++ii ) {
	 	this.sboxes[ ii ] = [];
	 	for ( jj=0; jj < 256; ++jj ) {
	 	    this.sboxes[ ii ][ jj ] = this.SBOXES[ ii ][ jj ];
	 	}
	     }
	 
	     var vals = [ 0x00000000, 0x00000000 ];
	 
	     for ( ii=0; ii < this.NN+2; ii += 2 ) {
	 	this._encrypt_block( vals );
	 	this.parray[ ii + 0 ] = vals[ 0 ];
	 	this.parray[ ii + 1 ] = vals[ 1 ];
	     }
	 
	     for ( ii=0; ii < 4; ++ii ) {
	 	for ( jj=0; jj < 256; jj += 2 ) {
	 	    this._encrypt_block( vals );
	 	    this.sboxes[ ii ][ jj + 0 ] = vals[ 0 ];
	 	    this.sboxes[ ii ][ jj + 1 ] = vals[ 1 ];
	 	}
	     }
	 };
	 
	 // added by Recurity Labs
	 function BFencrypt(block,key) {
	 	var bf = new Blowfish();
	 	bf.init(util.str2bin(key));
	 	return bf.encrypt_block(block);
	 }
	 
	 // Use of this source code is governed by a BSD-style
	 // license that can be found in the LICENSE file.
	 
	 // Copyright 2010 pjacobs@xeekr.com . All rights reserved.
	 
	 // Modified by Recurity Labs GmbH
	 
	 // fixed/modified by Herbert Hanewinkel, www.haneWIN.de
	 // check www.haneWIN.de for the latest version
	 
	 // cast5.js is a Javascript implementation of CAST-128, as defined in RFC 2144.
	 // CAST-128 is a common OpenPGP cipher.
	 
	 
	 // CAST5 constructor
	 
	 function cast5_encrypt(block, key) {
	 	var cast5 = new openpgp_symenc_cast5();
	 	cast5.setKey(util.str2bin(key));
	 	return cast5.encrypt(block);
	 }
	 
	 function openpgp_symenc_cast5() {
	 	this.BlockSize= 8;
	 	this.KeySize = 16;
	 
	 	this.setKey = function (key) {
	 		 this.masking = new Array(16);
	 		 this.rotate = new Array(16);
	 
	 		 this.reset();
	 
	 		 if (key.length == this.KeySize)
	 		 {
	 		   this.keySchedule(key);
	 		 }
	 		 else
	 		 {
	 		   util.print_error('cast5.js: CAST-128: keys must be 16 bytes');
	 		   return false;
	 		 }
	 		 return true;
	 	};
	 	
	 	this.reset = function() {
	 		 for (var i = 0; i < 16; i++)
	 		 {
	 		  this.masking[i] = 0;
	 		  this.rotate[i] = 0;
	 		 }
	 	};
	 
	 	this.getBlockSize = function() {
	 		 return BlockSize;
	 	};
	 
	 	this.encrypt = function(src) {
	 		 var dst = new Array(src.length);
	 
	 		 for(var i = 0; i < src.length; i+=8)
	 		 {
	 		  var l = src[i]<<24 | src[i+1]<<16 | src[i+2]<<8 | src[i+3];
	 		  var r = src[i+4]<<24 | src[i+5]<<16 | src[i+6]<<8 | src[i+7];
	 		  var t;
	 
	 		  t = r; r = l^f1(r, this.masking[0], this.rotate[0]); l = t;
	 		  t = r; r = l^f2(r, this.masking[1], this.rotate[1]); l = t;
	 		  t = r; r = l^f3(r, this.masking[2], this.rotate[2]); l = t;
	 		  t = r; r = l^f1(r, this.masking[3], this.rotate[3]); l = t;
	 
	 		  t = r; r = l^f2(r, this.masking[4], this.rotate[4]); l = t;
	 		  t = r; r = l^f3(r, this.masking[5], this.rotate[5]); l = t;
	 		  t = r; r = l^f1(r, this.masking[6], this.rotate[6]); l = t;
	 		  t = r; r = l^f2(r, this.masking[7], this.rotate[7]); l = t;
	 
	 		  t = r; r = l^f3(r, this.masking[8], this.rotate[8]); l = t;
	 		  t = r; r = l^f1(r, this.masking[9], this.rotate[9]); l = t;
	 		  t = r; r = l^f2(r, this.masking[10], this.rotate[10]); l = t;
	 		  t = r; r = l^f3(r, this.masking[11], this.rotate[11]); l = t;
	 
	 		  t = r; r = l^f1(r, this.masking[12], this.rotate[12]); l = t;
	 		  t = r; r = l^f2(r, this.masking[13], this.rotate[13]); l = t;
	 		  t = r; r = l^f3(r, this.masking[14], this.rotate[14]); l = t;
	 		  t = r; r = l^f1(r, this.masking[15], this.rotate[15]); l = t;
	 
	 		  dst[i]   = (r >>> 24)&255;
	 		  dst[i+1] = (r >>> 16)&255;
	 		  dst[i+2] = (r >>> 8)&255;
	 		  dst[i+3] = r&255;
	 		  dst[i+4] = (l >>> 24)&255;
	 		  dst[i+5] = (l >>> 16)&255;
	 		  dst[i+6] = (l >>> 8)&255;
	 		  dst[i+7] = l&255;
	 		 }
	 
	 		 return dst;
	 	};
	 	
	 	this.decrypt = function(src) {
	 		 var dst = new Array(src.length);
	 
	 		 for(var i = 0; i < src.length; i+=8)
	 		 {
	 		  var l = src[i]<<24 | src[i+1]<<16 | src[i+2]<<8 | src[i+3];
	 		  var r = src[i+4]<<24 | src[i+5]<<16 | src[i+6]<<8 | src[i+7];
	 		  var t;
	 
	 		  t = r; r = l^f1(r, this.masking[15], this.rotate[15]); l = t;
	 		  t = r; r = l^f3(r, this.masking[14], this.rotate[14]); l = t;
	 		  t = r; r = l^f2(r, this.masking[13], this.rotate[13]); l = t;
	 		  t = r; r = l^f1(r, this.masking[12], this.rotate[12]); l = t;
	 
	 		  t = r; r = l^f3(r, this.masking[11], this.rotate[11]); l = t;
	 		  t = r; r = l^f2(r, this.masking[10], this.rotate[10]); l = t;
	 		  t = r; r = l^f1(r, this.masking[9], this.rotate[9]); l = t;
	 		  t = r; r = l^f3(r, this.masking[8], this.rotate[8]); l = t;
	 
	 		  t = r; r = l^f2(r, this.masking[7], this.rotate[7]); l = t;
	 		  t = r; r = l^f1(r, this.masking[6], this.rotate[6]); l = t;
	 		  t = r; r = l^f3(r, this.masking[5], this.rotate[5]); l = t;
	 		  t = r; r = l^f2(r, this.masking[4], this.rotate[4]); l = t;
	 
	 		  t = r; r = l^f1(r, this.masking[3], this.rotate[3]); l = t;
	 		  t = r; r = l^f3(r, this.masking[2], this.rotate[2]); l = t;
	 		  t = r; r = l^f2(r, this.masking[1], this.rotate[1]); l = t;
	 		  t = r; r = l^f1(r, this.masking[0], this.rotate[0]); l = t;
	 
	 		  dst[i]   = (r >>> 24)&255;
	 		  dst[i+1] = (r >>> 16)&255;
	 		  dst[i+2] = (r >>> 8)&255;
	 		  dst[i+3] = r&255;
	 		  dst[i+4] = (l >>> 24)&255;
	 		  dst[i+5] = (l >> 16)&255;
	 		  dst[i+6] = (l >> 8)&255;
	 		  dst[i+7] = l&255;
	 		 }
	 
	 		 return dst;
	 		};
	 		var scheduleA = new Array(4);
	 
	 		scheduleA[0] = new Array(4);
	 		scheduleA[0][0] = new Array(4, 0, 0xd, 0xf, 0xc, 0xe, 0x8);
	 		scheduleA[0][1] = new Array(5, 2, 16 + 0, 16 + 2, 16 + 1, 16 + 3, 0xa);
	 		scheduleA[0][2] = new Array(6, 3, 16 + 7, 16 + 6, 16 + 5, 16 + 4, 9);
	 		scheduleA[0][3] = new Array(7, 1, 16 + 0xa, 16 + 9, 16 + 0xb, 16 + 8, 0xb);
	 
	 		scheduleA[1] = new Array(4);
	 		scheduleA[1][0] = new Array(0, 6, 16 + 5, 16 + 7, 16 + 4, 16 + 6, 16 + 0);
	 		scheduleA[1][1] = new Array(1, 4, 0, 2, 1, 3, 16 + 2);
	 		scheduleA[1][2] = new Array(2, 5, 7, 6, 5, 4, 16 + 1);
	 		scheduleA[1][3] = new Array(3, 7, 0xa, 9, 0xb, 8, 16 + 3);
	 
	 		scheduleA[2] = new Array(4);
	 		scheduleA[2][0] = new Array(4, 0, 0xd, 0xf, 0xc, 0xe, 8);
	 		scheduleA[2][1] = new Array(5, 2, 16 + 0, 16 + 2, 16 + 1, 16 + 3, 0xa);
	 		scheduleA[2][2] = new Array(6, 3, 16 + 7, 16 + 6, 16 + 5, 16 + 4, 9);
	 		scheduleA[2][3] = new Array(7, 1, 16 + 0xa, 16 + 9, 16 + 0xb, 16 + 8, 0xb);
	 
	 
	 		scheduleA[3] = new Array(4);
	 		scheduleA[3][0] = new Array(0, 6, 16 + 5, 16 + 7, 16 + 4, 16 + 6, 16 + 0);
	 		scheduleA[3][1] = new Array(1, 4, 0, 2, 1, 3, 16 + 2);
	 		scheduleA[3][2] = new Array(2, 5, 7, 6, 5, 4, 16 + 1);
	 		scheduleA[3][3] = new Array(3, 7, 0xa, 9, 0xb, 8, 16 + 3);
	 
	 		var scheduleB = new Array(4);
	 
	 		scheduleB[0] = new Array(4);
	 		scheduleB[0][0] = new Array(16 + 8, 16 + 9, 16 + 7, 16 + 6, 16 + 2);
	 		scheduleB[0][1] = new Array(16 + 0xa, 16 + 0xb, 16 + 5, 16 + 4, 16 + 6);
	 		scheduleB[0][2] = new Array(16 + 0xc, 16 + 0xd, 16 + 3, 16 + 2, 16 + 9);
	 		scheduleB[0][3] = new Array(16 + 0xe, 16 + 0xf, 16 + 1, 16 + 0, 16 + 0xc);
	 
	 		scheduleB[1] = new Array(4);
	 		scheduleB[1][0] = new Array(3, 2, 0xc, 0xd, 8);
	 		scheduleB[1][1] = new Array(1, 0, 0xe, 0xf, 0xd);
	 		scheduleB[1][2] = new Array(7, 6, 8, 9, 3);
	 		scheduleB[1][3] = new Array(5, 4, 0xa, 0xb, 7);
	 
	 
	 		scheduleB[2] = new Array(4);
	 		scheduleB[2][0] = new Array(16 + 3, 16 + 2, 16 + 0xc, 16 + 0xd, 16 + 9);
	 		scheduleB[2][1] = new Array(16 + 1, 16 + 0, 16 + 0xe, 16 + 0xf, 16 + 0xc);
	 		scheduleB[2][2] = new Array(16 + 7, 16 + 6, 16 + 8, 16 + 9, 16 + 2);
	 		scheduleB[2][3] = new Array(16 + 5, 16 + 4, 16 + 0xa, 16 + 0xb, 16 + 6);
	 
	 
	 		scheduleB[3] = new Array(4);
	 		scheduleB[3][0] = new Array(8, 9, 7, 6, 3);
	 		scheduleB[3][1] = new Array(0xa, 0xb, 5, 4, 7);
	 		scheduleB[3][2] = new Array(0xc, 0xd, 3, 2, 8);
	 		scheduleB[3][3] = new Array(0xe, 0xf, 1, 0, 0xd);
	 
	 		// changed 'in' to 'inn' (in javascript 'in' is a reserved word)
	 		this.keySchedule = function(inn)
	 		{
	 		 var t = new Array(8);
	 		 var k = new Array(32);
	 
	 		 for (var i = 0; i < 4; i++)
	 		 {
	 		  var j = i * 4;
	 		  t[i] = inn[j]<<24 | inn[j+1]<<16 | inn[j+2]<<8 | inn[j+3];
	 		 }
	 
	 		 var x = [6, 7, 4, 5];
	 		 var ki = 0;
	 
	 		 for (var half = 0; half < 2; half++)
	 		 {
	 		  for (var round = 0; round < 4; round++)
	 		  {
	 		   for (var j = 0; j < 4; j++)
	 		   {
	 		    var a = scheduleA[round][j];
	 		    var w = t[a[1]];
	 
	 		    w ^= sBox[4][(t[a[2]>>>2]>>>(24-8*(a[2]&3)))&0xff];
	 		    w ^= sBox[5][(t[a[3]>>>2]>>>(24-8*(a[3]&3)))&0xff];
	 		    w ^= sBox[6][(t[a[4]>>>2]>>>(24-8*(a[4]&3)))&0xff];
	 		    w ^= sBox[7][(t[a[5]>>>2]>>>(24-8*(a[5]&3)))&0xff];
	 		    w ^= sBox[x[j]][(t[a[6]>>>2]>>>(24-8*(a[6]&3)))&0xff];
	 		    t[a[0]] = w;
	 		   }
	 
	 		   for (var j = 0; j < 4; j++)
	 		   {
	 		    var b = scheduleB[round][j];
	 		    var w = sBox[4][(t[b[0]>>>2]>>>(24-8*(b[0]&3)))&0xff];
	 
	 		    w ^= sBox[5][(t[b[1]>>>2]>>>(24-8*(b[1]&3)))&0xff];
	 		    w ^= sBox[6][(t[b[2]>>>2]>>>(24-8*(b[2]&3)))&0xff];
	 		    w ^= sBox[7][(t[b[3]>>>2]>>>(24-8*(b[3]&3)))&0xff];
	 		    w ^= sBox[4+j][(t[b[4]>>>2]>>>(24-8*(b[4]&3)))&0xff];
	 		    k[ki] = w;
	 		    ki++;
	 		   }
	 		  }
	 		 }
	 
	 		 for (var i = 0; i < 16; i++)
	 		 {
	 		  this.masking[i] = k[i];
	 		  this.rotate[i]  = k[16+i] & 0x1f;
	 		 }
	 		};
	 
	 		// These are the three 'f' functions. See RFC 2144, section 2.2.
	 
	 		function f1(d, m, r)
	 		{
	 		 var t = m + d;
	 		 var I = (t << r) | (t >>> (32 - r));
	 		 return ((sBox[0][I>>>24] ^ sBox[1][(I>>>16)&255]) - sBox[2][(I>>>8)&255]) + sBox[3][I&255];
	 		}
	 
	 		function f2(d, m, r)
	 		{
	 		 var t = m ^ d;
	 		 var I = (t << r) | (t >>> (32 - r));
	 		 return ((sBox[0][I>>>24] - sBox[1][(I>>>16)&255]) + sBox[2][(I>>>8)&255]) ^ sBox[3][I&255];
	 		}
	 
	 		function f3(d, m, r)
	 		{
	 		 var t = m - d;
	 		 var I = (t << r) | (t >>> (32 - r));
	 		 return ((sBox[0][I>>>24] + sBox[1][(I>>>16)&255]) ^ sBox[2][(I>>>8)&255]) - sBox[3][I&255];
	 		}
	 
	 		var sBox = new Array(8);
	 		sBox[0] = new Array(
	 		  0x30fb40d4, 0x9fa0ff0b, 0x6beccd2f, 0x3f258c7a, 0x1e213f2f, 0x9c004dd3, 0x6003e540, 0xcf9fc949,
	 		  0xbfd4af27, 0x88bbbdb5, 0xe2034090, 0x98d09675, 0x6e63a0e0, 0x15c361d2, 0xc2e7661d, 0x22d4ff8e,
	 		  0x28683b6f, 0xc07fd059, 0xff2379c8, 0x775f50e2, 0x43c340d3, 0xdf2f8656, 0x887ca41a, 0xa2d2bd2d,
	 		  0xa1c9e0d6, 0x346c4819, 0x61b76d87, 0x22540f2f, 0x2abe32e1, 0xaa54166b, 0x22568e3a, 0xa2d341d0,
	 		  0x66db40c8, 0xa784392f, 0x004dff2f, 0x2db9d2de, 0x97943fac, 0x4a97c1d8, 0x527644b7, 0xb5f437a7,
	 		  0xb82cbaef, 0xd751d159, 0x6ff7f0ed, 0x5a097a1f, 0x827b68d0, 0x90ecf52e, 0x22b0c054, 0xbc8e5935,
	 		  0x4b6d2f7f, 0x50bb64a2, 0xd2664910, 0xbee5812d, 0xb7332290, 0xe93b159f, 0xb48ee411, 0x4bff345d,
	 		  0xfd45c240, 0xad31973f, 0xc4f6d02e, 0x55fc8165, 0xd5b1caad, 0xa1ac2dae, 0xa2d4b76d, 0xc19b0c50,
	 		  0x882240f2, 0x0c6e4f38, 0xa4e4bfd7, 0x4f5ba272, 0x564c1d2f, 0xc59c5319, 0xb949e354, 0xb04669fe,
	 		  0xb1b6ab8a, 0xc71358dd, 0x6385c545, 0x110f935d, 0x57538ad5, 0x6a390493, 0xe63d37e0, 0x2a54f6b3,
	 		  0x3a787d5f, 0x6276a0b5, 0x19a6fcdf, 0x7a42206a, 0x29f9d4d5, 0xf61b1891, 0xbb72275e, 0xaa508167,
	 		  0x38901091, 0xc6b505eb, 0x84c7cb8c, 0x2ad75a0f, 0x874a1427, 0xa2d1936b, 0x2ad286af, 0xaa56d291,
	 		  0xd7894360, 0x425c750d, 0x93b39e26, 0x187184c9, 0x6c00b32d, 0x73e2bb14, 0xa0bebc3c, 0x54623779,
	 		  0x64459eab, 0x3f328b82, 0x7718cf82, 0x59a2cea6, 0x04ee002e, 0x89fe78e6, 0x3fab0950, 0x325ff6c2,
	 		  0x81383f05, 0x6963c5c8, 0x76cb5ad6, 0xd49974c9, 0xca180dcf, 0x380782d5, 0xc7fa5cf6, 0x8ac31511,
	 		  0x35e79e13, 0x47da91d0, 0xf40f9086, 0xa7e2419e, 0x31366241, 0x051ef495, 0xaa573b04, 0x4a805d8d,
	 		  0x548300d0, 0x00322a3c, 0xbf64cddf, 0xba57a68e, 0x75c6372b, 0x50afd341, 0xa7c13275, 0x915a0bf5,
	 		  0x6b54bfab, 0x2b0b1426, 0xab4cc9d7, 0x449ccd82, 0xf7fbf265, 0xab85c5f3, 0x1b55db94, 0xaad4e324,
	 		  0xcfa4bd3f, 0x2deaa3e2, 0x9e204d02, 0xc8bd25ac, 0xeadf55b3, 0xd5bd9e98, 0xe31231b2, 0x2ad5ad6c,
	 		  0x954329de, 0xadbe4528, 0xd8710f69, 0xaa51c90f, 0xaa786bf6, 0x22513f1e, 0xaa51a79b, 0x2ad344cc,
	 		  0x7b5a41f0, 0xd37cfbad, 0x1b069505, 0x41ece491, 0xb4c332e6, 0x032268d4, 0xc9600acc, 0xce387e6d,
	 		  0xbf6bb16c, 0x6a70fb78, 0x0d03d9c9, 0xd4df39de, 0xe01063da, 0x4736f464, 0x5ad328d8, 0xb347cc96,
	 		  0x75bb0fc3, 0x98511bfb, 0x4ffbcc35, 0xb58bcf6a, 0xe11f0abc, 0xbfc5fe4a, 0xa70aec10, 0xac39570a,
	 		  0x3f04442f, 0x6188b153, 0xe0397a2e, 0x5727cb79, 0x9ceb418f, 0x1cacd68d, 0x2ad37c96, 0x0175cb9d,
	 		  0xc69dff09, 0xc75b65f0, 0xd9db40d8, 0xec0e7779, 0x4744ead4, 0xb11c3274, 0xdd24cb9e, 0x7e1c54bd,
	 		  0xf01144f9, 0xd2240eb1, 0x9675b3fd, 0xa3ac3755, 0xd47c27af, 0x51c85f4d, 0x56907596, 0xa5bb15e6,
	 		  0x580304f0, 0xca042cf1, 0x011a37ea, 0x8dbfaadb, 0x35ba3e4a, 0x3526ffa0, 0xc37b4d09, 0xbc306ed9,
	 		  0x98a52666, 0x5648f725, 0xff5e569d, 0x0ced63d0, 0x7c63b2cf, 0x700b45e1, 0xd5ea50f1, 0x85a92872,
	 		  0xaf1fbda7, 0xd4234870, 0xa7870bf3, 0x2d3b4d79, 0x42e04198, 0x0cd0ede7, 0x26470db8, 0xf881814c,
	 		  0x474d6ad7, 0x7c0c5e5c, 0xd1231959, 0x381b7298, 0xf5d2f4db, 0xab838653, 0x6e2f1e23, 0x83719c9e,
	 		  0xbd91e046, 0x9a56456e, 0xdc39200c, 0x20c8c571, 0x962bda1c, 0xe1e696ff, 0xb141ab08, 0x7cca89b9,
	 		  0x1a69e783, 0x02cc4843, 0xa2f7c579, 0x429ef47d, 0x427b169c, 0x5ac9f049, 0xdd8f0f00, 0x5c8165bf);
	 
	 		sBox[1] = new Array(
	 		  0x1f201094, 0xef0ba75b, 0x69e3cf7e, 0x393f4380, 0xfe61cf7a, 0xeec5207a, 0x55889c94, 0x72fc0651,
	 		  0xada7ef79, 0x4e1d7235, 0xd55a63ce, 0xde0436ba, 0x99c430ef, 0x5f0c0794, 0x18dcdb7d, 0xa1d6eff3,
	 		  0xa0b52f7b, 0x59e83605, 0xee15b094, 0xe9ffd909, 0xdc440086, 0xef944459, 0xba83ccb3, 0xe0c3cdfb,
	 		  0xd1da4181, 0x3b092ab1, 0xf997f1c1, 0xa5e6cf7b, 0x01420ddb, 0xe4e7ef5b, 0x25a1ff41, 0xe180f806,
	 		  0x1fc41080, 0x179bee7a, 0xd37ac6a9, 0xfe5830a4, 0x98de8b7f, 0x77e83f4e, 0x79929269, 0x24fa9f7b,
	 		  0xe113c85b, 0xacc40083, 0xd7503525, 0xf7ea615f, 0x62143154, 0x0d554b63, 0x5d681121, 0xc866c359,
	 		  0x3d63cf73, 0xcee234c0, 0xd4d87e87, 0x5c672b21, 0x071f6181, 0x39f7627f, 0x361e3084, 0xe4eb573b,
	 		  0x602f64a4, 0xd63acd9c, 0x1bbc4635, 0x9e81032d, 0x2701f50c, 0x99847ab4, 0xa0e3df79, 0xba6cf38c,
	 		  0x10843094, 0x2537a95e, 0xf46f6ffe, 0xa1ff3b1f, 0x208cfb6a, 0x8f458c74, 0xd9e0a227, 0x4ec73a34,
	 		  0xfc884f69, 0x3e4de8df, 0xef0e0088, 0x3559648d, 0x8a45388c, 0x1d804366, 0x721d9bfd, 0xa58684bb,
	 		  0xe8256333, 0x844e8212, 0x128d8098, 0xfed33fb4, 0xce280ae1, 0x27e19ba5, 0xd5a6c252, 0xe49754bd,
	 		  0xc5d655dd, 0xeb667064, 0x77840b4d, 0xa1b6a801, 0x84db26a9, 0xe0b56714, 0x21f043b7, 0xe5d05860,
	 		  0x54f03084, 0x066ff472, 0xa31aa153, 0xdadc4755, 0xb5625dbf, 0x68561be6, 0x83ca6b94, 0x2d6ed23b,
	 		  0xeccf01db, 0xa6d3d0ba, 0xb6803d5c, 0xaf77a709, 0x33b4a34c, 0x397bc8d6, 0x5ee22b95, 0x5f0e5304,
	 		  0x81ed6f61, 0x20e74364, 0xb45e1378, 0xde18639b, 0x881ca122, 0xb96726d1, 0x8049a7e8, 0x22b7da7b,
	 		  0x5e552d25, 0x5272d237, 0x79d2951c, 0xc60d894c, 0x488cb402, 0x1ba4fe5b, 0xa4b09f6b, 0x1ca815cf,
	 		  0xa20c3005, 0x8871df63, 0xb9de2fcb, 0x0cc6c9e9, 0x0beeff53, 0xe3214517, 0xb4542835, 0x9f63293c,
	 		  0xee41e729, 0x6e1d2d7c, 0x50045286, 0x1e6685f3, 0xf33401c6, 0x30a22c95, 0x31a70850, 0x60930f13,
	 		  0x73f98417, 0xa1269859, 0xec645c44, 0x52c877a9, 0xcdff33a6, 0xa02b1741, 0x7cbad9a2, 0x2180036f,
	 		  0x50d99c08, 0xcb3f4861, 0xc26bd765, 0x64a3f6ab, 0x80342676, 0x25a75e7b, 0xe4e6d1fc, 0x20c710e6,
	 		  0xcdf0b680, 0x17844d3b, 0x31eef84d, 0x7e0824e4, 0x2ccb49eb, 0x846a3bae, 0x8ff77888, 0xee5d60f6,
	 		  0x7af75673, 0x2fdd5cdb, 0xa11631c1, 0x30f66f43, 0xb3faec54, 0x157fd7fa, 0xef8579cc, 0xd152de58,
	 		  0xdb2ffd5e, 0x8f32ce19, 0x306af97a, 0x02f03ef8, 0x99319ad5, 0xc242fa0f, 0xa7e3ebb0, 0xc68e4906,
	 		  0xb8da230c, 0x80823028, 0xdcdef3c8, 0xd35fb171, 0x088a1bc8, 0xbec0c560, 0x61a3c9e8, 0xbca8f54d,
	 		  0xc72feffa, 0x22822e99, 0x82c570b4, 0xd8d94e89, 0x8b1c34bc, 0x301e16e6, 0x273be979, 0xb0ffeaa6,
	 		  0x61d9b8c6, 0x00b24869, 0xb7ffce3f, 0x08dc283b, 0x43daf65a, 0xf7e19798, 0x7619b72f, 0x8f1c9ba4,
	 		  0xdc8637a0, 0x16a7d3b1, 0x9fc393b7, 0xa7136eeb, 0xc6bcc63e, 0x1a513742, 0xef6828bc, 0x520365d6,
	 		  0x2d6a77ab, 0x3527ed4b, 0x821fd216, 0x095c6e2e, 0xdb92f2fb, 0x5eea29cb, 0x145892f5, 0x91584f7f,
	 		  0x5483697b, 0x2667a8cc, 0x85196048, 0x8c4bacea, 0x833860d4, 0x0d23e0f9, 0x6c387e8a, 0x0ae6d249,
	 		  0xb284600c, 0xd835731d, 0xdcb1c647, 0xac4c56ea, 0x3ebd81b3, 0x230eabb0, 0x6438bc87, 0xf0b5b1fa,
	 		  0x8f5ea2b3, 0xfc184642, 0x0a036b7a, 0x4fb089bd, 0x649da589, 0xa345415e, 0x5c038323, 0x3e5d3bb9,
	 		  0x43d79572, 0x7e6dd07c, 0x06dfdf1e, 0x6c6cc4ef, 0x7160a539, 0x73bfbe70, 0x83877605, 0x4523ecf1);
	 
	 		sBox[2] = new Array(
	 		  0x8defc240, 0x25fa5d9f, 0xeb903dbf, 0xe810c907, 0x47607fff, 0x369fe44b, 0x8c1fc644, 0xaececa90,
	 		  0xbeb1f9bf, 0xeefbcaea, 0xe8cf1950, 0x51df07ae, 0x920e8806, 0xf0ad0548, 0xe13c8d83, 0x927010d5,
	 		  0x11107d9f, 0x07647db9, 0xb2e3e4d4, 0x3d4f285e, 0xb9afa820, 0xfade82e0, 0xa067268b, 0x8272792e,
	 		  0x553fb2c0, 0x489ae22b, 0xd4ef9794, 0x125e3fbc, 0x21fffcee, 0x825b1bfd, 0x9255c5ed, 0x1257a240,
	 		  0x4e1a8302, 0xbae07fff, 0x528246e7, 0x8e57140e, 0x3373f7bf, 0x8c9f8188, 0xa6fc4ee8, 0xc982b5a5,
	 		  0xa8c01db7, 0x579fc264, 0x67094f31, 0xf2bd3f5f, 0x40fff7c1, 0x1fb78dfc, 0x8e6bd2c1, 0x437be59b,
	 		  0x99b03dbf, 0xb5dbc64b, 0x638dc0e6, 0x55819d99, 0xa197c81c, 0x4a012d6e, 0xc5884a28, 0xccc36f71,
	 		  0xb843c213, 0x6c0743f1, 0x8309893c, 0x0feddd5f, 0x2f7fe850, 0xd7c07f7e, 0x02507fbf, 0x5afb9a04,
	 		  0xa747d2d0, 0x1651192e, 0xaf70bf3e, 0x58c31380, 0x5f98302e, 0x727cc3c4, 0x0a0fb402, 0x0f7fef82,
	 		  0x8c96fdad, 0x5d2c2aae, 0x8ee99a49, 0x50da88b8, 0x8427f4a0, 0x1eac5790, 0x796fb449, 0x8252dc15,
	 		  0xefbd7d9b, 0xa672597d, 0xada840d8, 0x45f54504, 0xfa5d7403, 0xe83ec305, 0x4f91751a, 0x925669c2,
	 		  0x23efe941, 0xa903f12e, 0x60270df2, 0x0276e4b6, 0x94fd6574, 0x927985b2, 0x8276dbcb, 0x02778176,
	 		  0xf8af918d, 0x4e48f79e, 0x8f616ddf, 0xe29d840e, 0x842f7d83, 0x340ce5c8, 0x96bbb682, 0x93b4b148,
	 		  0xef303cab, 0x984faf28, 0x779faf9b, 0x92dc560d, 0x224d1e20, 0x8437aa88, 0x7d29dc96, 0x2756d3dc,
	 		  0x8b907cee, 0xb51fd240, 0xe7c07ce3, 0xe566b4a1, 0xc3e9615e, 0x3cf8209d, 0x6094d1e3, 0xcd9ca341,
	 		  0x5c76460e, 0x00ea983b, 0xd4d67881, 0xfd47572c, 0xf76cedd9, 0xbda8229c, 0x127dadaa, 0x438a074e,
	 		  0x1f97c090, 0x081bdb8a, 0x93a07ebe, 0xb938ca15, 0x97b03cff, 0x3dc2c0f8, 0x8d1ab2ec, 0x64380e51,
	 		  0x68cc7bfb, 0xd90f2788, 0x12490181, 0x5de5ffd4, 0xdd7ef86a, 0x76a2e214, 0xb9a40368, 0x925d958f,
	 		  0x4b39fffa, 0xba39aee9, 0xa4ffd30b, 0xfaf7933b, 0x6d498623, 0x193cbcfa, 0x27627545, 0x825cf47a,
	 		  0x61bd8ba0, 0xd11e42d1, 0xcead04f4, 0x127ea392, 0x10428db7, 0x8272a972, 0x9270c4a8, 0x127de50b,
	 		  0x285ba1c8, 0x3c62f44f, 0x35c0eaa5, 0xe805d231, 0x428929fb, 0xb4fcdf82, 0x4fb66a53, 0x0e7dc15b,
	 		  0x1f081fab, 0x108618ae, 0xfcfd086d, 0xf9ff2889, 0x694bcc11, 0x236a5cae, 0x12deca4d, 0x2c3f8cc5,
	 		  0xd2d02dfe, 0xf8ef5896, 0xe4cf52da, 0x95155b67, 0x494a488c, 0xb9b6a80c, 0x5c8f82bc, 0x89d36b45,
	 		  0x3a609437, 0xec00c9a9, 0x44715253, 0x0a874b49, 0xd773bc40, 0x7c34671c, 0x02717ef6, 0x4feb5536,
	 		  0xa2d02fff, 0xd2bf60c4, 0xd43f03c0, 0x50b4ef6d, 0x07478cd1, 0x006e1888, 0xa2e53f55, 0xb9e6d4bc,
	 		  0xa2048016, 0x97573833, 0xd7207d67, 0xde0f8f3d, 0x72f87b33, 0xabcc4f33, 0x7688c55d, 0x7b00a6b0,
	 		  0x947b0001, 0x570075d2, 0xf9bb88f8, 0x8942019e, 0x4264a5ff, 0x856302e0, 0x72dbd92b, 0xee971b69,
	 		  0x6ea22fde, 0x5f08ae2b, 0xaf7a616d, 0xe5c98767, 0xcf1febd2, 0x61efc8c2, 0xf1ac2571, 0xcc8239c2,
	 		  0x67214cb8, 0xb1e583d1, 0xb7dc3e62, 0x7f10bdce, 0xf90a5c38, 0x0ff0443d, 0x606e6dc6, 0x60543a49,
	 		  0x5727c148, 0x2be98a1d, 0x8ab41738, 0x20e1be24, 0xaf96da0f, 0x68458425, 0x99833be5, 0x600d457d,
	 		  0x282f9350, 0x8334b362, 0xd91d1120, 0x2b6d8da0, 0x642b1e31, 0x9c305a00, 0x52bce688, 0x1b03588a,
	 		  0xf7baefd5, 0x4142ed9c, 0xa4315c11, 0x83323ec5, 0xdfef4636, 0xa133c501, 0xe9d3531c, 0xee353783);
	 
	 		sBox[3] = new Array(
	 		  0x9db30420, 0x1fb6e9de, 0xa7be7bef, 0xd273a298, 0x4a4f7bdb, 0x64ad8c57, 0x85510443, 0xfa020ed1,
	 		  0x7e287aff, 0xe60fb663, 0x095f35a1, 0x79ebf120, 0xfd059d43, 0x6497b7b1, 0xf3641f63, 0x241e4adf,
	 		  0x28147f5f, 0x4fa2b8cd, 0xc9430040, 0x0cc32220, 0xfdd30b30, 0xc0a5374f, 0x1d2d00d9, 0x24147b15,
	 		  0xee4d111a, 0x0fca5167, 0x71ff904c, 0x2d195ffe, 0x1a05645f, 0x0c13fefe, 0x081b08ca, 0x05170121,
	 		  0x80530100, 0xe83e5efe, 0xac9af4f8, 0x7fe72701, 0xd2b8ee5f, 0x06df4261, 0xbb9e9b8a, 0x7293ea25,
	 		  0xce84ffdf, 0xf5718801, 0x3dd64b04, 0xa26f263b, 0x7ed48400, 0x547eebe6, 0x446d4ca0, 0x6cf3d6f5,
	 		  0x2649abdf, 0xaea0c7f5, 0x36338cc1, 0x503f7e93, 0xd3772061, 0x11b638e1, 0x72500e03, 0xf80eb2bb,
	 		  0xabe0502e, 0xec8d77de, 0x57971e81, 0xe14f6746, 0xc9335400, 0x6920318f, 0x081dbb99, 0xffc304a5,
	 		  0x4d351805, 0x7f3d5ce3, 0xa6c866c6, 0x5d5bcca9, 0xdaec6fea, 0x9f926f91, 0x9f46222f, 0x3991467d,
	 		  0xa5bf6d8e, 0x1143c44f, 0x43958302, 0xd0214eeb, 0x022083b8, 0x3fb6180c, 0x18f8931e, 0x281658e6,
	 		  0x26486e3e, 0x8bd78a70, 0x7477e4c1, 0xb506e07c, 0xf32d0a25, 0x79098b02, 0xe4eabb81, 0x28123b23,
	 		  0x69dead38, 0x1574ca16, 0xdf871b62, 0x211c40b7, 0xa51a9ef9, 0x0014377b, 0x041e8ac8, 0x09114003,
	 		  0xbd59e4d2, 0xe3d156d5, 0x4fe876d5, 0x2f91a340, 0x557be8de, 0x00eae4a7, 0x0ce5c2ec, 0x4db4bba6,
	 		  0xe756bdff, 0xdd3369ac, 0xec17b035, 0x06572327, 0x99afc8b0, 0x56c8c391, 0x6b65811c, 0x5e146119,
	 		  0x6e85cb75, 0xbe07c002, 0xc2325577, 0x893ff4ec, 0x5bbfc92d, 0xd0ec3b25, 0xb7801ab7, 0x8d6d3b24,
	 		  0x20c763ef, 0xc366a5fc, 0x9c382880, 0x0ace3205, 0xaac9548a, 0xeca1d7c7, 0x041afa32, 0x1d16625a,
	 		  0x6701902c, 0x9b757a54, 0x31d477f7, 0x9126b031, 0x36cc6fdb, 0xc70b8b46, 0xd9e66a48, 0x56e55a79,
	 		  0x026a4ceb, 0x52437eff, 0x2f8f76b4, 0x0df980a5, 0x8674cde3, 0xedda04eb, 0x17a9be04, 0x2c18f4df,
	 		  0xb7747f9d, 0xab2af7b4, 0xefc34d20, 0x2e096b7c, 0x1741a254, 0xe5b6a035, 0x213d42f6, 0x2c1c7c26,
	 		  0x61c2f50f, 0x6552daf9, 0xd2c231f8, 0x25130f69, 0xd8167fa2, 0x0418f2c8, 0x001a96a6, 0x0d1526ab,
	 		  0x63315c21, 0x5e0a72ec, 0x49bafefd, 0x187908d9, 0x8d0dbd86, 0x311170a7, 0x3e9b640c, 0xcc3e10d7,
	 		  0xd5cad3b6, 0x0caec388, 0xf73001e1, 0x6c728aff, 0x71eae2a1, 0x1f9af36e, 0xcfcbd12f, 0xc1de8417,
	 		  0xac07be6b, 0xcb44a1d8, 0x8b9b0f56, 0x013988c3, 0xb1c52fca, 0xb4be31cd, 0xd8782806, 0x12a3a4e2,
	 		  0x6f7de532, 0x58fd7eb6, 0xd01ee900, 0x24adffc2, 0xf4990fc5, 0x9711aac5, 0x001d7b95, 0x82e5e7d2,
	 		  0x109873f6, 0x00613096, 0xc32d9521, 0xada121ff, 0x29908415, 0x7fbb977f, 0xaf9eb3db, 0x29c9ed2a,
	 		  0x5ce2a465, 0xa730f32c, 0xd0aa3fe8, 0x8a5cc091, 0xd49e2ce7, 0x0ce454a9, 0xd60acd86, 0x015f1919,
	 		  0x77079103, 0xdea03af6, 0x78a8565e, 0xdee356df, 0x21f05cbe, 0x8b75e387, 0xb3c50651, 0xb8a5c3ef,
	 		  0xd8eeb6d2, 0xe523be77, 0xc2154529, 0x2f69efdf, 0xafe67afb, 0xf470c4b2, 0xf3e0eb5b, 0xd6cc9876,
	 		  0x39e4460c, 0x1fda8538, 0x1987832f, 0xca007367, 0xa99144f8, 0x296b299e, 0x492fc295, 0x9266beab,
	 		  0xb5676e69, 0x9bd3ddda, 0xdf7e052f, 0xdb25701c, 0x1b5e51ee, 0xf65324e6, 0x6afce36c, 0x0316cc04,
	 		  0x8644213e, 0xb7dc59d0, 0x7965291f, 0xccd6fd43, 0x41823979, 0x932bcdf6, 0xb657c34d, 0x4edfd282,
	 		  0x7ae5290c, 0x3cb9536b, 0x851e20fe, 0x9833557e, 0x13ecf0b0, 0xd3ffb372, 0x3f85c5c1, 0x0aef7ed2);
	 
	 		sBox[4] = new Array(
	 		  0x7ec90c04, 0x2c6e74b9, 0x9b0e66df, 0xa6337911, 0xb86a7fff, 0x1dd358f5, 0x44dd9d44, 0x1731167f,
	 		  0x08fbf1fa, 0xe7f511cc, 0xd2051b00, 0x735aba00, 0x2ab722d8, 0x386381cb, 0xacf6243a, 0x69befd7a,
	 		  0xe6a2e77f, 0xf0c720cd, 0xc4494816, 0xccf5c180, 0x38851640, 0x15b0a848, 0xe68b18cb, 0x4caadeff,
	 		  0x5f480a01, 0x0412b2aa, 0x259814fc, 0x41d0efe2, 0x4e40b48d, 0x248eb6fb, 0x8dba1cfe, 0x41a99b02,
	 		  0x1a550a04, 0xba8f65cb, 0x7251f4e7, 0x95a51725, 0xc106ecd7, 0x97a5980a, 0xc539b9aa, 0x4d79fe6a,
	 		  0xf2f3f763, 0x68af8040, 0xed0c9e56, 0x11b4958b, 0xe1eb5a88, 0x8709e6b0, 0xd7e07156, 0x4e29fea7,
	 		  0x6366e52d, 0x02d1c000, 0xc4ac8e05, 0x9377f571, 0x0c05372a, 0x578535f2, 0x2261be02, 0xd642a0c9,
	 		  0xdf13a280, 0x74b55bd2, 0x682199c0, 0xd421e5ec, 0x53fb3ce8, 0xc8adedb3, 0x28a87fc9, 0x3d959981,
	 		  0x5c1ff900, 0xfe38d399, 0x0c4eff0b, 0x062407ea, 0xaa2f4fb1, 0x4fb96976, 0x90c79505, 0xb0a8a774,
	 		  0xef55a1ff, 0xe59ca2c2, 0xa6b62d27, 0xe66a4263, 0xdf65001f, 0x0ec50966, 0xdfdd55bc, 0x29de0655,
	 		  0x911e739a, 0x17af8975, 0x32c7911c, 0x89f89468, 0x0d01e980, 0x524755f4, 0x03b63cc9, 0x0cc844b2,
	 		  0xbcf3f0aa, 0x87ac36e9, 0xe53a7426, 0x01b3d82b, 0x1a9e7449, 0x64ee2d7e, 0xcddbb1da, 0x01c94910,
	 		  0xb868bf80, 0x0d26f3fd, 0x9342ede7, 0x04a5c284, 0x636737b6, 0x50f5b616, 0xf24766e3, 0x8eca36c1,
	 		  0x136e05db, 0xfef18391, 0xfb887a37, 0xd6e7f7d4, 0xc7fb7dc9, 0x3063fcdf, 0xb6f589de, 0xec2941da,
	 		  0x26e46695, 0xb7566419, 0xf654efc5, 0xd08d58b7, 0x48925401, 0xc1bacb7f, 0xe5ff550f, 0xb6083049,
	 		  0x5bb5d0e8, 0x87d72e5a, 0xab6a6ee1, 0x223a66ce, 0xc62bf3cd, 0x9e0885f9, 0x68cb3e47, 0x086c010f,
	 		  0xa21de820, 0xd18b69de, 0xf3f65777, 0xfa02c3f6, 0x407edac3, 0xcbb3d550, 0x1793084d, 0xb0d70eba,
	 		  0x0ab378d5, 0xd951fb0c, 0xded7da56, 0x4124bbe4, 0x94ca0b56, 0x0f5755d1, 0xe0e1e56e, 0x6184b5be,
	 		  0x580a249f, 0x94f74bc0, 0xe327888e, 0x9f7b5561, 0xc3dc0280, 0x05687715, 0x646c6bd7, 0x44904db3,
	 		  0x66b4f0a3, 0xc0f1648a, 0x697ed5af, 0x49e92ff6, 0x309e374f, 0x2cb6356a, 0x85808573, 0x4991f840,
	 		  0x76f0ae02, 0x083be84d, 0x28421c9a, 0x44489406, 0x736e4cb8, 0xc1092910, 0x8bc95fc6, 0x7d869cf4,
	 		  0x134f616f, 0x2e77118d, 0xb31b2be1, 0xaa90b472, 0x3ca5d717, 0x7d161bba, 0x9cad9010, 0xaf462ba2,
	 		  0x9fe459d2, 0x45d34559, 0xd9f2da13, 0xdbc65487, 0xf3e4f94e, 0x176d486f, 0x097c13ea, 0x631da5c7,
	 		  0x445f7382, 0x175683f4, 0xcdc66a97, 0x70be0288, 0xb3cdcf72, 0x6e5dd2f3, 0x20936079, 0x459b80a5,
	 		  0xbe60e2db, 0xa9c23101, 0xeba5315c, 0x224e42f2, 0x1c5c1572, 0xf6721b2c, 0x1ad2fff3, 0x8c25404e,
	 		  0x324ed72f, 0x4067b7fd, 0x0523138e, 0x5ca3bc78, 0xdc0fd66e, 0x75922283, 0x784d6b17, 0x58ebb16e,
	 		  0x44094f85, 0x3f481d87, 0xfcfeae7b, 0x77b5ff76, 0x8c2302bf, 0xaaf47556, 0x5f46b02a, 0x2b092801,
	 		  0x3d38f5f7, 0x0ca81f36, 0x52af4a8a, 0x66d5e7c0, 0xdf3b0874, 0x95055110, 0x1b5ad7a8, 0xf61ed5ad,
	 		  0x6cf6e479, 0x20758184, 0xd0cefa65, 0x88f7be58, 0x4a046826, 0x0ff6f8f3, 0xa09c7f70, 0x5346aba0,
	 		  0x5ce96c28, 0xe176eda3, 0x6bac307f, 0x376829d2, 0x85360fa9, 0x17e3fe2a, 0x24b79767, 0xf5a96b20,
	 		  0xd6cd2595, 0x68ff1ebf, 0x7555442c, 0xf19f06be, 0xf9e0659a, 0xeeb9491d, 0x34010718, 0xbb30cab8,
	 		  0xe822fe15, 0x88570983, 0x750e6249, 0xda627e55, 0x5e76ffa8, 0xb1534546, 0x6d47de08, 0xefe9e7d4);
	 
	 		sBox[5] = new Array(
	 		  0xf6fa8f9d, 0x2cac6ce1, 0x4ca34867, 0xe2337f7c, 0x95db08e7, 0x016843b4, 0xeced5cbc, 0x325553ac,
	 		  0xbf9f0960, 0xdfa1e2ed, 0x83f0579d, 0x63ed86b9, 0x1ab6a6b8, 0xde5ebe39, 0xf38ff732, 0x8989b138,
	 		  0x33f14961, 0xc01937bd, 0xf506c6da, 0xe4625e7e, 0xa308ea99, 0x4e23e33c, 0x79cbd7cc, 0x48a14367,
	 		  0xa3149619, 0xfec94bd5, 0xa114174a, 0xeaa01866, 0xa084db2d, 0x09a8486f, 0xa888614a, 0x2900af98,
	 		  0x01665991, 0xe1992863, 0xc8f30c60, 0x2e78ef3c, 0xd0d51932, 0xcf0fec14, 0xf7ca07d2, 0xd0a82072,
	 		  0xfd41197e, 0x9305a6b0, 0xe86be3da, 0x74bed3cd, 0x372da53c, 0x4c7f4448, 0xdab5d440, 0x6dba0ec3,
	 		  0x083919a7, 0x9fbaeed9, 0x49dbcfb0, 0x4e670c53, 0x5c3d9c01, 0x64bdb941, 0x2c0e636a, 0xba7dd9cd,
	 		  0xea6f7388, 0xe70bc762, 0x35f29adb, 0x5c4cdd8d, 0xf0d48d8c, 0xb88153e2, 0x08a19866, 0x1ae2eac8,
	 		  0x284caf89, 0xaa928223, 0x9334be53, 0x3b3a21bf, 0x16434be3, 0x9aea3906, 0xefe8c36e, 0xf890cdd9,
	 		  0x80226dae, 0xc340a4a3, 0xdf7e9c09, 0xa694a807, 0x5b7c5ecc, 0x221db3a6, 0x9a69a02f, 0x68818a54,
	 		  0xceb2296f, 0x53c0843a, 0xfe893655, 0x25bfe68a, 0xb4628abc, 0xcf222ebf, 0x25ac6f48, 0xa9a99387,
	 		  0x53bddb65, 0xe76ffbe7, 0xe967fd78, 0x0ba93563, 0x8e342bc1, 0xe8a11be9, 0x4980740d, 0xc8087dfc,
	 		  0x8de4bf99, 0xa11101a0, 0x7fd37975, 0xda5a26c0, 0xe81f994f, 0x9528cd89, 0xfd339fed, 0xb87834bf,
	 		  0x5f04456d, 0x22258698, 0xc9c4c83b, 0x2dc156be, 0x4f628daa, 0x57f55ec5, 0xe2220abe, 0xd2916ebf,
	 		  0x4ec75b95, 0x24f2c3c0, 0x42d15d99, 0xcd0d7fa0, 0x7b6e27ff, 0xa8dc8af0, 0x7345c106, 0xf41e232f,
	 		  0x35162386, 0xe6ea8926, 0x3333b094, 0x157ec6f2, 0x372b74af, 0x692573e4, 0xe9a9d848, 0xf3160289,
	 		  0x3a62ef1d, 0xa787e238, 0xf3a5f676, 0x74364853, 0x20951063, 0x4576698d, 0xb6fad407, 0x592af950,
	 		  0x36f73523, 0x4cfb6e87, 0x7da4cec0, 0x6c152daa, 0xcb0396a8, 0xc50dfe5d, 0xfcd707ab, 0x0921c42f,
	 		  0x89dff0bb, 0x5fe2be78, 0x448f4f33, 0x754613c9, 0x2b05d08d, 0x48b9d585, 0xdc049441, 0xc8098f9b,
	 		  0x7dede786, 0xc39a3373, 0x42410005, 0x6a091751, 0x0ef3c8a6, 0x890072d6, 0x28207682, 0xa9a9f7be,
	 		  0xbf32679d, 0xd45b5b75, 0xb353fd00, 0xcbb0e358, 0x830f220a, 0x1f8fb214, 0xd372cf08, 0xcc3c4a13,
	 		  0x8cf63166, 0x061c87be, 0x88c98f88, 0x6062e397, 0x47cf8e7a, 0xb6c85283, 0x3cc2acfb, 0x3fc06976,
	 		  0x4e8f0252, 0x64d8314d, 0xda3870e3, 0x1e665459, 0xc10908f0, 0x513021a5, 0x6c5b68b7, 0x822f8aa0,
	 		  0x3007cd3e, 0x74719eef, 0xdc872681, 0x073340d4, 0x7e432fd9, 0x0c5ec241, 0x8809286c, 0xf592d891,
	 		  0x08a930f6, 0x957ef305, 0xb7fbffbd, 0xc266e96f, 0x6fe4ac98, 0xb173ecc0, 0xbc60b42a, 0x953498da,
	 		  0xfba1ae12, 0x2d4bd736, 0x0f25faab, 0xa4f3fceb, 0xe2969123, 0x257f0c3d, 0x9348af49, 0x361400bc,
	 		  0xe8816f4a, 0x3814f200, 0xa3f94043, 0x9c7a54c2, 0xbc704f57, 0xda41e7f9, 0xc25ad33a, 0x54f4a084,
	 		  0xb17f5505, 0x59357cbe, 0xedbd15c8, 0x7f97c5ab, 0xba5ac7b5, 0xb6f6deaf, 0x3a479c3a, 0x5302da25,
	 		  0x653d7e6a, 0x54268d49, 0x51a477ea, 0x5017d55b, 0xd7d25d88, 0x44136c76, 0x0404a8c8, 0xb8e5a121,
	 		  0xb81a928a, 0x60ed5869, 0x97c55b96, 0xeaec991b, 0x29935913, 0x01fdb7f1, 0x088e8dfa, 0x9ab6f6f5,
	 		  0x3b4cbf9f, 0x4a5de3ab, 0xe6051d35, 0xa0e1d855, 0xd36b4cf1, 0xf544edeb, 0xb0e93524, 0xbebb8fbd,
	 		  0xa2d762cf, 0x49c92f54, 0x38b5f331, 0x7128a454, 0x48392905, 0xa65b1db8, 0x851c97bd, 0xd675cf2f);
	 
	 		sBox[6] = new Array(
	 		  0x85e04019, 0x332bf567, 0x662dbfff, 0xcfc65693, 0x2a8d7f6f, 0xab9bc912, 0xde6008a1, 0x2028da1f,
	 		  0x0227bce7, 0x4d642916, 0x18fac300, 0x50f18b82, 0x2cb2cb11, 0xb232e75c, 0x4b3695f2, 0xb28707de,
	 		  0xa05fbcf6, 0xcd4181e9, 0xe150210c, 0xe24ef1bd, 0xb168c381, 0xfde4e789, 0x5c79b0d8, 0x1e8bfd43,
	 		  0x4d495001, 0x38be4341, 0x913cee1d, 0x92a79c3f, 0x089766be, 0xbaeeadf4, 0x1286becf, 0xb6eacb19,
	 		  0x2660c200, 0x7565bde4, 0x64241f7a, 0x8248dca9, 0xc3b3ad66, 0x28136086, 0x0bd8dfa8, 0x356d1cf2,
	 		  0x107789be, 0xb3b2e9ce, 0x0502aa8f, 0x0bc0351e, 0x166bf52a, 0xeb12ff82, 0xe3486911, 0xd34d7516,
	 		  0x4e7b3aff, 0x5f43671b, 0x9cf6e037, 0x4981ac83, 0x334266ce, 0x8c9341b7, 0xd0d854c0, 0xcb3a6c88,
	 		  0x47bc2829, 0x4725ba37, 0xa66ad22b, 0x7ad61f1e, 0x0c5cbafa, 0x4437f107, 0xb6e79962, 0x42d2d816,
	 		  0x0a961288, 0xe1a5c06e, 0x13749e67, 0x72fc081a, 0xb1d139f7, 0xf9583745, 0xcf19df58, 0xbec3f756,
	 		  0xc06eba30, 0x07211b24, 0x45c28829, 0xc95e317f, 0xbc8ec511, 0x38bc46e9, 0xc6e6fa14, 0xbae8584a,
	 		  0xad4ebc46, 0x468f508b, 0x7829435f, 0xf124183b, 0x821dba9f, 0xaff60ff4, 0xea2c4e6d, 0x16e39264,
	 		  0x92544a8b, 0x009b4fc3, 0xaba68ced, 0x9ac96f78, 0x06a5b79a, 0xb2856e6e, 0x1aec3ca9, 0xbe838688,
	 		  0x0e0804e9, 0x55f1be56, 0xe7e5363b, 0xb3a1f25d, 0xf7debb85, 0x61fe033c, 0x16746233, 0x3c034c28,
	 		  0xda6d0c74, 0x79aac56c, 0x3ce4e1ad, 0x51f0c802, 0x98f8f35a, 0x1626a49f, 0xeed82b29, 0x1d382fe3,
	 		  0x0c4fb99a, 0xbb325778, 0x3ec6d97b, 0x6e77a6a9, 0xcb658b5c, 0xd45230c7, 0x2bd1408b, 0x60c03eb7,
	 		  0xb9068d78, 0xa33754f4, 0xf430c87d, 0xc8a71302, 0xb96d8c32, 0xebd4e7be, 0xbe8b9d2d, 0x7979fb06,
	 		  0xe7225308, 0x8b75cf77, 0x11ef8da4, 0xe083c858, 0x8d6b786f, 0x5a6317a6, 0xfa5cf7a0, 0x5dda0033,
	 		  0xf28ebfb0, 0xf5b9c310, 0xa0eac280, 0x08b9767a, 0xa3d9d2b0, 0x79d34217, 0x021a718d, 0x9ac6336a,
	 		  0x2711fd60, 0x438050e3, 0x069908a8, 0x3d7fedc4, 0x826d2bef, 0x4eeb8476, 0x488dcf25, 0x36c9d566,
	 		  0x28e74e41, 0xc2610aca, 0x3d49a9cf, 0xbae3b9df, 0xb65f8de6, 0x92aeaf64, 0x3ac7d5e6, 0x9ea80509,
	 		  0xf22b017d, 0xa4173f70, 0xdd1e16c3, 0x15e0d7f9, 0x50b1b887, 0x2b9f4fd5, 0x625aba82, 0x6a017962,
	 		  0x2ec01b9c, 0x15488aa9, 0xd716e740, 0x40055a2c, 0x93d29a22, 0xe32dbf9a, 0x058745b9, 0x3453dc1e,
	 		  0xd699296e, 0x496cff6f, 0x1c9f4986, 0xdfe2ed07, 0xb87242d1, 0x19de7eae, 0x053e561a, 0x15ad6f8c,
	 		  0x66626c1c, 0x7154c24c, 0xea082b2a, 0x93eb2939, 0x17dcb0f0, 0x58d4f2ae, 0x9ea294fb, 0x52cf564c,
	 		  0x9883fe66, 0x2ec40581, 0x763953c3, 0x01d6692e, 0xd3a0c108, 0xa1e7160e, 0xe4f2dfa6, 0x693ed285,
	 		  0x74904698, 0x4c2b0edd, 0x4f757656, 0x5d393378, 0xa132234f, 0x3d321c5d, 0xc3f5e194, 0x4b269301,
	 		  0xc79f022f, 0x3c997e7e, 0x5e4f9504, 0x3ffafbbd, 0x76f7ad0e, 0x296693f4, 0x3d1fce6f, 0xc61e45be,
	 		  0xd3b5ab34, 0xf72bf9b7, 0x1b0434c0, 0x4e72b567, 0x5592a33d, 0xb5229301, 0xcfd2a87f, 0x60aeb767,
	 		  0x1814386b, 0x30bcc33d, 0x38a0c07d, 0xfd1606f2, 0xc363519b, 0x589dd390, 0x5479f8e6, 0x1cb8d647,
	 		  0x97fd61a9, 0xea7759f4, 0x2d57539d, 0x569a58cf, 0xe84e63ad, 0x462e1b78, 0x6580f87e, 0xf3817914,
	 		  0x91da55f4, 0x40a230f3, 0xd1988f35, 0xb6e318d2, 0x3ffa50bc, 0x3d40f021, 0xc3c0bdae, 0x4958c24c,
	 		  0x518f36b2, 0x84b1d370, 0x0fedce83, 0x878ddada, 0xf2a279c7, 0x94e01be8, 0x90716f4b, 0x954b8aa3);
	 
	 		sBox[7] = new Array(
	 		  0xe216300d, 0xbbddfffc, 0xa7ebdabd, 0x35648095, 0x7789f8b7, 0xe6c1121b, 0x0e241600, 0x052ce8b5,
	 		  0x11a9cfb0, 0xe5952f11, 0xece7990a, 0x9386d174, 0x2a42931c, 0x76e38111, 0xb12def3a, 0x37ddddfc,
	 		  0xde9adeb1, 0x0a0cc32c, 0xbe197029, 0x84a00940, 0xbb243a0f, 0xb4d137cf, 0xb44e79f0, 0x049eedfd,
	 		  0x0b15a15d, 0x480d3168, 0x8bbbde5a, 0x669ded42, 0xc7ece831, 0x3f8f95e7, 0x72df191b, 0x7580330d,
	 		  0x94074251, 0x5c7dcdfa, 0xabbe6d63, 0xaa402164, 0xb301d40a, 0x02e7d1ca, 0x53571dae, 0x7a3182a2,
	 		  0x12a8ddec, 0xfdaa335d, 0x176f43e8, 0x71fb46d4, 0x38129022, 0xce949ad4, 0xb84769ad, 0x965bd862,
	 		  0x82f3d055, 0x66fb9767, 0x15b80b4e, 0x1d5b47a0, 0x4cfde06f, 0xc28ec4b8, 0x57e8726e, 0x647a78fc,
	 		  0x99865d44, 0x608bd593, 0x6c200e03, 0x39dc5ff6, 0x5d0b00a3, 0xae63aff2, 0x7e8bd632, 0x70108c0c,
	 		  0xbbd35049, 0x2998df04, 0x980cf42a, 0x9b6df491, 0x9e7edd53, 0x06918548, 0x58cb7e07, 0x3b74ef2e,
	 		  0x522fffb1, 0xd24708cc, 0x1c7e27cd, 0xa4eb215b, 0x3cf1d2e2, 0x19b47a38, 0x424f7618, 0x35856039,
	 		  0x9d17dee7, 0x27eb35e6, 0xc9aff67b, 0x36baf5b8, 0x09c467cd, 0xc18910b1, 0xe11dbf7b, 0x06cd1af8,
	 		  0x7170c608, 0x2d5e3354, 0xd4de495a, 0x64c6d006, 0xbcc0c62c, 0x3dd00db3, 0x708f8f34, 0x77d51b42,
	 		  0x264f620f, 0x24b8d2bf, 0x15c1b79e, 0x46a52564, 0xf8d7e54e, 0x3e378160, 0x7895cda5, 0x859c15a5,
	 		  0xe6459788, 0xc37bc75f, 0xdb07ba0c, 0x0676a3ab, 0x7f229b1e, 0x31842e7b, 0x24259fd7, 0xf8bef472,
	 		  0x835ffcb8, 0x6df4c1f2, 0x96f5b195, 0xfd0af0fc, 0xb0fe134c, 0xe2506d3d, 0x4f9b12ea, 0xf215f225,
	 		  0xa223736f, 0x9fb4c428, 0x25d04979, 0x34c713f8, 0xc4618187, 0xea7a6e98, 0x7cd16efc, 0x1436876c,
	 		  0xf1544107, 0xbedeee14, 0x56e9af27, 0xa04aa441, 0x3cf7c899, 0x92ecbae6, 0xdd67016d, 0x151682eb,
	 		  0xa842eedf, 0xfdba60b4, 0xf1907b75, 0x20e3030f, 0x24d8c29e, 0xe139673b, 0xefa63fb8, 0x71873054,
	 		  0xb6f2cf3b, 0x9f326442, 0xcb15a4cc, 0xb01a4504, 0xf1e47d8d, 0x844a1be5, 0xbae7dfdc, 0x42cbda70,
	 		  0xcd7dae0a, 0x57e85b7a, 0xd53f5af6, 0x20cf4d8c, 0xcea4d428, 0x79d130a4, 0x3486ebfb, 0x33d3cddc,
	 		  0x77853b53, 0x37effcb5, 0xc5068778, 0xe580b3e6, 0x4e68b8f4, 0xc5c8b37e, 0x0d809ea2, 0x398feb7c,
	 		  0x132a4f94, 0x43b7950e, 0x2fee7d1c, 0x223613bd, 0xdd06caa2, 0x37df932b, 0xc4248289, 0xacf3ebc3,
	 		  0x5715f6b7, 0xef3478dd, 0xf267616f, 0xc148cbe4, 0x9052815e, 0x5e410fab, 0xb48a2465, 0x2eda7fa4,
	 		  0xe87b40e4, 0xe98ea084, 0x5889e9e1, 0xefd390fc, 0xdd07d35b, 0xdb485694, 0x38d7e5b2, 0x57720101,
	 		  0x730edebc, 0x5b643113, 0x94917e4f, 0x503c2fba, 0x646f1282, 0x7523d24a, 0xe0779695, 0xf9c17a8f,
	 		  0x7a5b2121, 0xd187b896, 0x29263a4d, 0xba510cdf, 0x81f47c9f, 0xad1163ed, 0xea7b5965, 0x1a00726e,
	 		  0x11403092, 0x00da6d77, 0x4a0cdd61, 0xad1f4603, 0x605bdfb0, 0x9eedc364, 0x22ebe6a8, 0xcee7d28a,
	 		  0xa0e736a0, 0x5564a6b9, 0x10853209, 0xc7eb8f37, 0x2de705ca, 0x8951570f, 0xdf09822b, 0xbd691a6c,
	 		  0xaa12e4f2, 0x87451c0f, 0xe0f6a27a, 0x3ada4819, 0x4cf1764f, 0x0d771c2b, 0x67cdb156, 0x350d8384,
	 		  0x5938fa0f, 0x42399ef3, 0x36997b07, 0x0e84093d, 0x4aa93e61, 0x8360d87b, 0x1fa98b0c, 0x1149382c,
	 		  0xe97625a5, 0x0614d1b7, 0x0e25244b, 0x0c768347, 0x589e8d82, 0x0d2059d1, 0xa466bb1e, 0xf8da0a82,
	 		  0x04f19130, 0xba6e4ec0, 0x99265164, 0x1ee7230d, 0x50b2ad80, 0xeaee6801, 0x8db2a283, 0xea8bf59e);
	 
	 };
	 
	 //Paul Tero, July 2001
	 //http://www.tero.co.uk/des/
	 //
	 //Optimised for performance with large blocks by Michael Hayworth, November 2001
	 //http://www.netdealing.com
	 //
	 // Modified by Recurity Labs GmbH
	 
	 //THIS SOFTWARE IS PROVIDED "AS IS" AND
	 //ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	 //IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
	 //ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
	 //FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
	 //DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
	 //OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
	 //HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
	 //LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
	 //OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
	 //SUCH DAMAGE.
	 
	 //des
	 //this takes the key, the message, and whether to encrypt or decrypt
	 
	 // added by Recurity Labs
	 function desede(block,key) {
	 	var key1 = key.substring(0,8);
	 	var key2 = key.substring(8,16);
	 	var key3 = key.substring(16,24);
	 	return util.str2bin(des(des_createKeys(key3),des(des_createKeys(key2),des(des_createKeys(key1),util.bin2str(block), true, 0,null,null), false, 0,null,null), true, 0,null,null));
	 }
	 
	 
	 function des (keys, message, encrypt, mode, iv, padding) {
	   //declaring this locally speeds things up a bit
	   var spfunction1 = new Array (0x1010400,0,0x10000,0x1010404,0x1010004,0x10404,0x4,0x10000,0x400,0x1010400,0x1010404,0x400,0x1000404,0x1010004,0x1000000,0x4,0x404,0x1000400,0x1000400,0x10400,0x10400,0x1010000,0x1010000,0x1000404,0x10004,0x1000004,0x1000004,0x10004,0,0x404,0x10404,0x1000000,0x10000,0x1010404,0x4,0x1010000,0x1010400,0x1000000,0x1000000,0x400,0x1010004,0x10000,0x10400,0x1000004,0x400,0x4,0x1000404,0x10404,0x1010404,0x10004,0x1010000,0x1000404,0x1000004,0x404,0x10404,0x1010400,0x404,0x1000400,0x1000400,0,0x10004,0x10400,0,0x1010004);
	   var spfunction2 = new Array (-0x7fef7fe0,-0x7fff8000,0x8000,0x108020,0x100000,0x20,-0x7fefffe0,-0x7fff7fe0,-0x7fffffe0,-0x7fef7fe0,-0x7fef8000,-0x80000000,-0x7fff8000,0x100000,0x20,-0x7fefffe0,0x108000,0x100020,-0x7fff7fe0,0,-0x80000000,0x8000,0x108020,-0x7ff00000,0x100020,-0x7fffffe0,0,0x108000,0x8020,-0x7fef8000,-0x7ff00000,0x8020,0,0x108020,-0x7fefffe0,0x100000,-0x7fff7fe0,-0x7ff00000,-0x7fef8000,0x8000,-0x7ff00000,-0x7fff8000,0x20,-0x7fef7fe0,0x108020,0x20,0x8000,-0x80000000,0x8020,-0x7fef8000,0x100000,-0x7fffffe0,0x100020,-0x7fff7fe0,-0x7fffffe0,0x100020,0x108000,0,-0x7fff8000,0x8020,-0x80000000,-0x7fefffe0,-0x7fef7fe0,0x108000);
	   var spfunction3 = new Array (0x208,0x8020200,0,0x8020008,0x8000200,0,0x20208,0x8000200,0x20008,0x8000008,0x8000008,0x20000,0x8020208,0x20008,0x8020000,0x208,0x8000000,0x8,0x8020200,0x200,0x20200,0x8020000,0x8020008,0x20208,0x8000208,0x20200,0x20000,0x8000208,0x8,0x8020208,0x200,0x8000000,0x8020200,0x8000000,0x20008,0x208,0x20000,0x8020200,0x8000200,0,0x200,0x20008,0x8020208,0x8000200,0x8000008,0x200,0,0x8020008,0x8000208,0x20000,0x8000000,0x8020208,0x8,0x20208,0x20200,0x8000008,0x8020000,0x8000208,0x208,0x8020000,0x20208,0x8,0x8020008,0x20200);
	   var spfunction4 = new Array (0x802001,0x2081,0x2081,0x80,0x802080,0x800081,0x800001,0x2001,0,0x802000,0x802000,0x802081,0x81,0,0x800080,0x800001,0x1,0x2000,0x800000,0x802001,0x80,0x800000,0x2001,0x2080,0x800081,0x1,0x2080,0x800080,0x2000,0x802080,0x802081,0x81,0x800080,0x800001,0x802000,0x802081,0x81,0,0,0x802000,0x2080,0x800080,0x800081,0x1,0x802001,0x2081,0x2081,0x80,0x802081,0x81,0x1,0x2000,0x800001,0x2001,0x802080,0x800081,0x2001,0x2080,0x800000,0x802001,0x80,0x800000,0x2000,0x802080);
	   var spfunction5 = new Array (0x100,0x2080100,0x2080000,0x42000100,0x80000,0x100,0x40000000,0x2080000,0x40080100,0x80000,0x2000100,0x40080100,0x42000100,0x42080000,0x80100,0x40000000,0x2000000,0x40080000,0x40080000,0,0x40000100,0x42080100,0x42080100,0x2000100,0x42080000,0x40000100,0,0x42000000,0x2080100,0x2000000,0x42000000,0x80100,0x80000,0x42000100,0x100,0x2000000,0x40000000,0x2080000,0x42000100,0x40080100,0x2000100,0x40000000,0x42080000,0x2080100,0x40080100,0x100,0x2000000,0x42080000,0x42080100,0x80100,0x42000000,0x42080100,0x2080000,0,0x40080000,0x42000000,0x80100,0x2000100,0x40000100,0x80000,0,0x40080000,0x2080100,0x40000100);
	   var spfunction6 = new Array (0x20000010,0x20400000,0x4000,0x20404010,0x20400000,0x10,0x20404010,0x400000,0x20004000,0x404010,0x400000,0x20000010,0x400010,0x20004000,0x20000000,0x4010,0,0x400010,0x20004010,0x4000,0x404000,0x20004010,0x10,0x20400010,0x20400010,0,0x404010,0x20404000,0x4010,0x404000,0x20404000,0x20000000,0x20004000,0x10,0x20400010,0x404000,0x20404010,0x400000,0x4010,0x20000010,0x400000,0x20004000,0x20000000,0x4010,0x20000010,0x20404010,0x404000,0x20400000,0x404010,0x20404000,0,0x20400010,0x10,0x4000,0x20400000,0x404010,0x4000,0x400010,0x20004010,0,0x20404000,0x20000000,0x400010,0x20004010);
	   var spfunction7 = new Array (0x200000,0x4200002,0x4000802,0,0x800,0x4000802,0x200802,0x4200800,0x4200802,0x200000,0,0x4000002,0x2,0x4000000,0x4200002,0x802,0x4000800,0x200802,0x200002,0x4000800,0x4000002,0x4200000,0x4200800,0x200002,0x4200000,0x800,0x802,0x4200802,0x200800,0x2,0x4000000,0x200800,0x4000000,0x200800,0x200000,0x4000802,0x4000802,0x4200002,0x4200002,0x2,0x200002,0x4000000,0x4000800,0x200000,0x4200800,0x802,0x200802,0x4200800,0x802,0x4000002,0x4200802,0x4200000,0x200800,0,0x2,0x4200802,0,0x200802,0x4200000,0x800,0x4000002,0x4000800,0x800,0x200002);
	   var spfunction8 = new Array (0x10001040,0x1000,0x40000,0x10041040,0x10000000,0x10001040,0x40,0x10000000,0x40040,0x10040000,0x10041040,0x41000,0x10041000,0x41040,0x1000,0x40,0x10040000,0x10000040,0x10001000,0x1040,0x41000,0x40040,0x10040040,0x10041000,0x1040,0,0,0x10040040,0x10000040,0x10001000,0x41040,0x40000,0x41040,0x40000,0x10041000,0x1000,0x40,0x10040040,0x1000,0x41040,0x10001000,0x40,0x10000040,0x10040000,0x10040040,0x10000000,0x40000,0x10001040,0,0x10041040,0x40040,0x10000040,0x10040000,0x10001000,0x10001040,0,0x10041040,0x41000,0x41000,0x1040,0x1040,0x40040,0x10000000,0x10041000);
	 
	   //create the 16 or 48 subkeys we will need
	   var m=0, i, j, temp, temp2, right1, right2, left, right, looping;
	   var cbcleft, cbcleft2, cbcright, cbcright2
	   var endloop, loopinc;
	   var len = message.length;
	   var chunk = 0;
	   //set up the loops for single and triple des
	   var iterations = keys.length == 32 ? 3 : 9; //single or triple des
	   if (iterations == 3) {looping = encrypt ? new Array (0, 32, 2) : new Array (30, -2, -2);}
	   else {looping = encrypt ? new Array (0, 32, 2, 62, 30, -2, 64, 96, 2) : new Array (94, 62, -2, 32, 64, 2, 30, -2, -2);}
	 
	   //pad the message depending on the padding parameter
	   //only add padding if encrypting - note that you need to use the same padding option for both encrypt and decrypt
	   if (encrypt) {
	     message = des_addPadding(message, padding);
	     len = message.length;
	   }
	 
	     //store the result here
	   result = "";
	   tempresult = "";
	 
	   if (mode == 1) { //CBC mode
	     cbcleft = (iv.charCodeAt(m++) << 24) | (iv.charCodeAt(m++) << 16) | (iv.charCodeAt(m++) << 8) | iv.charCodeAt(m++);
	     cbcright = (iv.charCodeAt(m++) << 24) | (iv.charCodeAt(m++) << 16) | (iv.charCodeAt(m++) << 8) | iv.charCodeAt(m++);
	     m=0;
	   }
	 
	   //loop through each 64 bit chunk of the message
	   while (m < len) {
	     left = (message.charCodeAt(m++) << 24) | (message.charCodeAt(m++) << 16) | (message.charCodeAt(m++) << 8) | message.charCodeAt(m++);
	     right = (message.charCodeAt(m++) << 24) | (message.charCodeAt(m++) << 16) | (message.charCodeAt(m++) << 8) | message.charCodeAt(m++);
	 
	     //for Cipher Block Chaining mode, xor the message with the previous result
	     if (mode == 1) {if (encrypt) {left ^= cbcleft; right ^= cbcright;} else {cbcleft2 = cbcleft; cbcright2 = cbcright; cbcleft = left; cbcright = right;}}
	 
	     //first each 64 but chunk of the message must be permuted according to IP
	     temp = ((left >>> 4) ^ right) & 0x0f0f0f0f; right ^= temp; left ^= (temp << 4);
	     temp = ((left >>> 16) ^ right) & 0x0000ffff; right ^= temp; left ^= (temp << 16);
	     temp = ((right >>> 2) ^ left) & 0x33333333; left ^= temp; right ^= (temp << 2);
	     temp = ((right >>> 8) ^ left) & 0x00ff00ff; left ^= temp; right ^= (temp << 8);
	     temp = ((left >>> 1) ^ right) & 0x55555555; right ^= temp; left ^= (temp << 1);
	 
	     left = ((left << 1) | (left >>> 31)); 
	     right = ((right << 1) | (right >>> 31)); 
	 
	     //do this either 1 or 3 times for each chunk of the message
	     for (j=0; j<iterations; j+=3) {
	       endloop = looping[j+1];
	       loopinc = looping[j+2];
	       //now go through and perform the encryption or decryption  
	       for (i=looping[j]; i!=endloop; i+=loopinc) { //for efficiency
	         right1 = right ^ keys[i]; 
	         right2 = ((right >>> 4) | (right << 28)) ^ keys[i+1];
	         //the result is attained by passing these bytes through the S selection functions
	         temp = left;
	         left = right;
	         right = temp ^ (spfunction2[(right1 >>> 24) & 0x3f] | spfunction4[(right1 >>> 16) & 0x3f]
	               | spfunction6[(right1 >>>  8) & 0x3f] | spfunction8[right1 & 0x3f]
	               | spfunction1[(right2 >>> 24) & 0x3f] | spfunction3[(right2 >>> 16) & 0x3f]
	               | spfunction5[(right2 >>>  8) & 0x3f] | spfunction7[right2 & 0x3f]);
	       }
	       temp = left; left = right; right = temp; //unreverse left and right
	     } //for either 1 or 3 iterations
	 
	     //move then each one bit to the right
	     left = ((left >>> 1) | (left << 31)); 
	     right = ((right >>> 1) | (right << 31)); 
	 
	     //now perform IP-1, which is IP in the opposite direction
	     temp = ((left >>> 1) ^ right) & 0x55555555; right ^= temp; left ^= (temp << 1);
	     temp = ((right >>> 8) ^ left) & 0x00ff00ff; left ^= temp; right ^= (temp << 8);
	     temp = ((right >>> 2) ^ left) & 0x33333333; left ^= temp; right ^= (temp << 2);
	     temp = ((left >>> 16) ^ right) & 0x0000ffff; right ^= temp; left ^= (temp << 16);
	     temp = ((left >>> 4) ^ right) & 0x0f0f0f0f; right ^= temp; left ^= (temp << 4);
	 
	     //for Cipher Block Chaining mode, xor the message with the previous result
	     if (mode == 1) {if (encrypt) {cbcleft = left; cbcright = right;} else {left ^= cbcleft2; right ^= cbcright2;}}
	     tempresult += String.fromCharCode ((left>>>24), ((left>>>16) & 0xff), ((left>>>8) & 0xff), (left & 0xff), (right>>>24), ((right>>>16) & 0xff), ((right>>>8) & 0xff), (right & 0xff));
	 
	     chunk += 8;
	     if (chunk == 512) {result += tempresult; tempresult = ""; chunk = 0;}
	   } //for every 8 characters, or 64 bits in the message
	 
	   //return the result as an array
	   result += tempresult;
	     
	   //only remove padding if decrypting - note that you need to use the same padding option for both encrypt and decrypt
	   if (!encrypt) {
	     result = des_removePadding(result, padding);
	   }
	 
	     return result;
	 } //end of des
	 
	 
	 
	 //des_createKeys
	 //this takes as input a 64 bit key (even though only 56 bits are used)
	 //as an array of 2 integers, and returns 16 48 bit keys
	 function des_createKeys (key) {
	   //declaring this locally speeds things up a bit
	   pc2bytes0  = new Array (0,0x4,0x20000000,0x20000004,0x10000,0x10004,0x20010000,0x20010004,0x200,0x204,0x20000200,0x20000204,0x10200,0x10204,0x20010200,0x20010204);
	   pc2bytes1  = new Array (0,0x1,0x100000,0x100001,0x4000000,0x4000001,0x4100000,0x4100001,0x100,0x101,0x100100,0x100101,0x4000100,0x4000101,0x4100100,0x4100101);
	   pc2bytes2  = new Array (0,0x8,0x800,0x808,0x1000000,0x1000008,0x1000800,0x1000808,0,0x8,0x800,0x808,0x1000000,0x1000008,0x1000800,0x1000808);
	   pc2bytes3  = new Array (0,0x200000,0x8000000,0x8200000,0x2000,0x202000,0x8002000,0x8202000,0x20000,0x220000,0x8020000,0x8220000,0x22000,0x222000,0x8022000,0x8222000);
	   pc2bytes4  = new Array (0,0x40000,0x10,0x40010,0,0x40000,0x10,0x40010,0x1000,0x41000,0x1010,0x41010,0x1000,0x41000,0x1010,0x41010);
	   pc2bytes5  = new Array (0,0x400,0x20,0x420,0,0x400,0x20,0x420,0x2000000,0x2000400,0x2000020,0x2000420,0x2000000,0x2000400,0x2000020,0x2000420);
	   pc2bytes6  = new Array (0,0x10000000,0x80000,0x10080000,0x2,0x10000002,0x80002,0x10080002,0,0x10000000,0x80000,0x10080000,0x2,0x10000002,0x80002,0x10080002);
	   pc2bytes7  = new Array (0,0x10000,0x800,0x10800,0x20000000,0x20010000,0x20000800,0x20010800,0x20000,0x30000,0x20800,0x30800,0x20020000,0x20030000,0x20020800,0x20030800);
	   pc2bytes8  = new Array (0,0x40000,0,0x40000,0x2,0x40002,0x2,0x40002,0x2000000,0x2040000,0x2000000,0x2040000,0x2000002,0x2040002,0x2000002,0x2040002);
	   pc2bytes9  = new Array (0,0x10000000,0x8,0x10000008,0,0x10000000,0x8,0x10000008,0x400,0x10000400,0x408,0x10000408,0x400,0x10000400,0x408,0x10000408);
	   pc2bytes10 = new Array (0,0x20,0,0x20,0x100000,0x100020,0x100000,0x100020,0x2000,0x2020,0x2000,0x2020,0x102000,0x102020,0x102000,0x102020);
	   pc2bytes11 = new Array (0,0x1000000,0x200,0x1000200,0x200000,0x1200000,0x200200,0x1200200,0x4000000,0x5000000,0x4000200,0x5000200,0x4200000,0x5200000,0x4200200,0x5200200);
	   pc2bytes12 = new Array (0,0x1000,0x8000000,0x8001000,0x80000,0x81000,0x8080000,0x8081000,0x10,0x1010,0x8000010,0x8001010,0x80010,0x81010,0x8080010,0x8081010);
	   pc2bytes13 = new Array (0,0x4,0x100,0x104,0,0x4,0x100,0x104,0x1,0x5,0x101,0x105,0x1,0x5,0x101,0x105);
	 
	   //how many iterations (1 for des, 3 for triple des)
	   var iterations = key.length > 8 ? 3 : 1; //changed by Paul 16/6/2007 to use Triple DES for 9+ byte keys
	   //stores the return keys
	   var keys = new Array (32 * iterations);
	   //now define the left shifts which need to be done
	   var shifts = new Array (0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0);
	   //other variables
	   var lefttemp, righttemp, m=0, n=0, temp;
	 
	   for (var j=0; j<iterations; j++) { //either 1 or 3 iterations
	     left = (key.charCodeAt(m++) << 24) | (key.charCodeAt(m++) << 16) | (key.charCodeAt(m++) << 8) | key.charCodeAt(m++);
	     right = (key.charCodeAt(m++) << 24) | (key.charCodeAt(m++) << 16) | (key.charCodeAt(m++) << 8) | key.charCodeAt(m++);
	 
	     temp = ((left >>> 4) ^ right) & 0x0f0f0f0f; right ^= temp; left ^= (temp << 4);
	     temp = ((right >>> -16) ^ left) & 0x0000ffff; left ^= temp; right ^= (temp << -16);
	     temp = ((left >>> 2) ^ right) & 0x33333333; right ^= temp; left ^= (temp << 2);
	     temp = ((right >>> -16) ^ left) & 0x0000ffff; left ^= temp; right ^= (temp << -16);
	     temp = ((left >>> 1) ^ right) & 0x55555555; right ^= temp; left ^= (temp << 1);
	     temp = ((right >>> 8) ^ left) & 0x00ff00ff; left ^= temp; right ^= (temp << 8);
	     temp = ((left >>> 1) ^ right) & 0x55555555; right ^= temp; left ^= (temp << 1);
	 
	     //the right side needs to be shifted and to get the last four bits of the left side
	     temp = (left << 8) | ((right >>> 20) & 0x000000f0);
	     //left needs to be put upside down
	     left = (right << 24) | ((right << 8) & 0xff0000) | ((right >>> 8) & 0xff00) | ((right >>> 24) & 0xf0);
	     right = temp;
	 
	     //now go through and perform these shifts on the left and right keys
	     for (i=0; i < shifts.length; i++) {
	       //shift the keys either one or two bits to the left
	       if (shifts[i]) {left = (left << 2) | (left >>> 26); right = (right << 2) | (right >>> 26);}
	       else {left = (left << 1) | (left >>> 27); right = (right << 1) | (right >>> 27);}
	       left &= -0xf; right &= -0xf;
	 
	       //now apply PC-2, in such a way that E is easier when encrypting or decrypting
	       //this conversion will look like PC-2 except only the last 6 bits of each byte are used
	       //rather than 48 consecutive bits and the order of lines will be according to 
	       //how the S selection functions will be applied: S2, S4, S6, S8, S1, S3, S5, S7
	       lefttemp = pc2bytes0[left >>> 28] | pc2bytes1[(left >>> 24) & 0xf]
	               | pc2bytes2[(left >>> 20) & 0xf] | pc2bytes3[(left >>> 16) & 0xf]
	               | pc2bytes4[(left >>> 12) & 0xf] | pc2bytes5[(left >>> 8) & 0xf]
	               | pc2bytes6[(left >>> 4) & 0xf];
	       righttemp = pc2bytes7[right >>> 28] | pc2bytes8[(right >>> 24) & 0xf]
	                 | pc2bytes9[(right >>> 20) & 0xf] | pc2bytes10[(right >>> 16) & 0xf]
	                 | pc2bytes11[(right >>> 12) & 0xf] | pc2bytes12[(right >>> 8) & 0xf]
	                 | pc2bytes13[(right >>> 4) & 0xf];
	       temp = ((righttemp >>> 16) ^ lefttemp) & 0x0000ffff; 
	       keys[n++] = lefttemp ^ temp; keys[n++] = righttemp ^ (temp << 16);
	     }
	   } //for each iterations
	   //return the keys we've created
	   return keys;
	 } //end of des_createKeys
	 
	 
	 function des_addPadding(message, padding) {
	     var padLength = 8 - (message.length % 8);
	     if ((padding == 2) && (padLength < 8)) {            //pad the message with spaces
	         message += "        ".substr(0, padLength);
	     }
	     else if (padding == 1) {                            //PKCS7 padding
	         message += String.fromCharCode(padLength, padLength, padLength, padLength, padLength, padLength, padLength, padLength).substr(0, padLength);
	     }
	     else if (!padding && (padLength < 8)) {             //pad the message out with null bytes
	         message += "\0\0\0\0\0\0\0\0".substr(0, padLength);
	     }
	     return message;
	 }
	 
	 function des_removePadding(message, padding) {
	     if (padding == 2) {         // space padded
	         message = message.replace(/ *$/g, "");
	     }
	     else if (padding == 1) {    // PKCS7
	         var padCount = message.charCodeAt(message.length - 1);
	         message = message.substr(0, message.length - padCount);
	     }
	     else if (!padding) {        // null padding
	         message = message.replace(/\0*$/g, "");
	     }
	     return message;
	 }
	 
	 /* Modified by Recurity Labs GmbH 
	  * 
	  * Cipher.js
	  * A block-cipher algorithm implementation on JavaScript
	  * See Cipher.readme.txt for further information.
	  *
	  * Copyright(c) 2009 Atsushi Oka [ http://oka.nu/ ]
	  * This script file is distributed under the LGPL
	  *
	  * ACKNOWLEDGMENT
	  *
	  *     The main subroutines are written by Michiel van Everdingen.
	  * 
	  *     Michiel van Everdingen
	  *     http://home.versatel.nl/MAvanEverdingen/index.html
	  * 
	  *     All rights for these routines are reserved to Michiel van Everdingen.
	  *
	  */
	 
	 // added by Recurity Labs
	 function TFencrypt(block, key) {
	 	var block_copy = [].concat(block);
	 	var tf = createTwofish();
	 	tf.open(util.str2bin(key),0);
	 	var result = tf.encrypt(block_copy, 0);
	 	tf.close();
	 	return result;
	 }
	 
	 ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	 //Math
	 ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	 
	 var MAXINT = 0xFFFFFFFF;
	 
	 function rotb(b,n){ return ( b<<n | b>>>( 8-n) ) & 0xFF; }
	 function rotw(w,n){ return ( w<<n | w>>>(32-n) ) & MAXINT; }
	 function getW(a,i){ return a[i]|a[i+1]<<8|a[i+2]<<16|a[i+3]<<24; }
	 function setW(a,i,w){ a.splice(i,4,w&0xFF,(w>>>8)&0xFF,(w>>>16)&0xFF,(w>>>24)&0xFF); }
	 function setWInv(a,i,w){ a.splice(i,4,(w>>>24)&0xFF,(w>>>16)&0xFF,(w>>>8)&0xFF,w&0xFF); }
	 function getB(x,n){ return (x>>>(n*8))&0xFF; }
	 
	 function getNrBits(i){ var n=0; while (i>0){ n++; i>>>=1; } return n; }
	 function getMask(n){ return (1<<n)-1; }
	 
	 //added 2008/11/13 XXX MUST USE ONE-WAY HASH FUNCTION FOR SECURITY REASON
	 function randByte() {
	  return Math.floor( Math.random() * 256 );
	 }
	 // //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	 // Twofish
	 // //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	 
	 function createTwofish() {
	 	//
	 	var keyBytes = null;
	 	var dataBytes = null;
	 	var dataOffset = -1;
	 	// var dataLength = -1;
	 	var algorithmName = null;
	 	// var idx2 = -1;
	 	//
	 
	 	algorithmName = "twofish";
	 
	 	var tfsKey = [];
	 	var tfsM = [ [], [], [], [] ];
	 
	 	function tfsInit(key) {
	 		keyBytes = key;
	 		var i, a, b, c, d, meKey = [], moKey = [], inKey = [];
	 		var kLen;
	 		var sKey = [];
	 		var f01, f5b, fef;
	 
	 		var q0 = [ [ 8, 1, 7, 13, 6, 15, 3, 2, 0, 11, 5, 9, 14, 12, 10, 4 ],
	 				[ 2, 8, 11, 13, 15, 7, 6, 14, 3, 1, 9, 4, 0, 10, 12, 5 ] ];
	 		var q1 = [ [ 14, 12, 11, 8, 1, 2, 3, 5, 15, 4, 10, 6, 7, 0, 9, 13 ],
	 				[ 1, 14, 2, 11, 4, 12, 3, 7, 6, 13, 10, 5, 15, 9, 0, 8 ] ];
	 		var q2 = [ [ 11, 10, 5, 14, 6, 13, 9, 0, 12, 8, 15, 3, 2, 4, 7, 1 ],
	 				[ 4, 12, 7, 5, 1, 6, 9, 10, 0, 14, 13, 8, 2, 11, 3, 15 ] ];
	 		var q3 = [ [ 13, 7, 15, 4, 1, 2, 6, 14, 9, 11, 3, 0, 8, 5, 12, 10 ],
	 				[ 11, 9, 5, 1, 12, 3, 13, 14, 6, 4, 7, 15, 2, 0, 8, 10 ] ];
	 		var ror4 = [ 0, 8, 1, 9, 2, 10, 3, 11, 4, 12, 5, 13, 6, 14, 7, 15 ];
	 		var ashx = [ 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 5, 14, 7 ];
	 		var q = [ [], [] ];
	 		var m = [ [], [], [], [] ];
	 
	 		function ffm5b(x) {
	 			return x ^ (x >> 2) ^ [ 0, 90, 180, 238 ][x & 3];
	 		}
	 		function ffmEf(x) {
	 			return x ^ (x >> 1) ^ (x >> 2) ^ [ 0, 238, 180, 90 ][x & 3];
	 		}
	 
	 		function mdsRem(p, q) {
	 			var i, t, u;
	 			for (i = 0; i < 8; i++) {
	 				t = q >>> 24;
	 				q = ((q << 8) & MAXINT) | p >>> 24;
	 				p = (p << 8) & MAXINT;
	 				u = t << 1;
	 				if (t & 128) {
	 					u ^= 333;
	 				}
	 				q ^= t ^ (u << 16);
	 				u ^= t >>> 1;
	 				if (t & 1) {
	 					u ^= 166;
	 				}
	 				q ^= u << 24 | u << 8;
	 			}
	 			return q;
	 		}
	 
	 		function qp(n, x) {
	 			var a, b, c, d;
	 			a = x >> 4;
	 			b = x & 15;
	 			c = q0[n][a ^ b];
	 			d = q1[n][ror4[b] ^ ashx[a]];
	 			return q3[n][ror4[d] ^ ashx[c]] << 4 | q2[n][c ^ d];
	 		}
	 
	 		function hFun(x, key) {
	 			var a = getB(x, 0), b = getB(x, 1), c = getB(x, 2), d = getB(x, 3);
	 			switch (kLen) {
	 			case 4:
	 				a = q[1][a] ^ getB(key[3], 0);
	 				b = q[0][b] ^ getB(key[3], 1);
	 				c = q[0][c] ^ getB(key[3], 2);
	 				d = q[1][d] ^ getB(key[3], 3);
	 			case 3:
	 				a = q[1][a] ^ getB(key[2], 0);
	 				b = q[1][b] ^ getB(key[2], 1);
	 				c = q[0][c] ^ getB(key[2], 2);
	 				d = q[0][d] ^ getB(key[2], 3);
	 			case 2:
	 				a = q[0][q[0][a] ^ getB(key[1], 0)] ^ getB(key[0], 0);
	 				b = q[0][q[1][b] ^ getB(key[1], 1)] ^ getB(key[0], 1);
	 				c = q[1][q[0][c] ^ getB(key[1], 2)] ^ getB(key[0], 2);
	 				d = q[1][q[1][d] ^ getB(key[1], 3)] ^ getB(key[0], 3);
	 			}
	 			return m[0][a] ^ m[1][b] ^ m[2][c] ^ m[3][d];
	 		}
	 
	 		keyBytes = keyBytes.slice(0, 32);
	 		i = keyBytes.length;
	 		while (i != 16 && i != 24 && i != 32)
	 			keyBytes[i++] = 0;
	 
	 		for (i = 0; i < keyBytes.length; i += 4) {
	 			inKey[i >> 2] = getW(keyBytes, i);
	 		}
	 		for (i = 0; i < 256; i++) {
	 			q[0][i] = qp(0, i);
	 			q[1][i] = qp(1, i);
	 		}
	 		for (i = 0; i < 256; i++) {
	 			f01 = q[1][i];
	 			f5b = ffm5b(f01);
	 			fef = ffmEf(f01);
	 			m[0][i] = f01 + (f5b << 8) + (fef << 16) + (fef << 24);
	 			m[2][i] = f5b + (fef << 8) + (f01 << 16) + (fef << 24);
	 			f01 = q[0][i];
	 			f5b = ffm5b(f01);
	 			fef = ffmEf(f01);
	 			m[1][i] = fef + (fef << 8) + (f5b << 16) + (f01 << 24);
	 			m[3][i] = f5b + (f01 << 8) + (fef << 16) + (f5b << 24);
	 		}
	 
	 		kLen = inKey.length / 2;
	 		for (i = 0; i < kLen; i++) {
	 			a = inKey[i + i];
	 			meKey[i] = a;
	 			b = inKey[i + i + 1];
	 			moKey[i] = b;
	 			sKey[kLen - i - 1] = mdsRem(a, b);
	 		}
	 		for (i = 0; i < 40; i += 2) {
	 			a = 0x1010101 * i;
	 			b = a + 0x1010101;
	 			a = hFun(a, meKey);
	 			b = rotw(hFun(b, moKey), 8);
	 			tfsKey[i] = (a + b) & MAXINT;
	 			tfsKey[i + 1] = rotw(a + 2 * b, 9);
	 		}
	 		for (i = 0; i < 256; i++) {
	 			a = b = c = d = i;
	 			switch (kLen) {
	 			case 4:
	 				a = q[1][a] ^ getB(sKey[3], 0);
	 				b = q[0][b] ^ getB(sKey[3], 1);
	 				c = q[0][c] ^ getB(sKey[3], 2);
	 				d = q[1][d] ^ getB(sKey[3], 3);
	 			case 3:
	 				a = q[1][a] ^ getB(sKey[2], 0);
	 				b = q[1][b] ^ getB(sKey[2], 1);
	 				c = q[0][c] ^ getB(sKey[2], 2);
	 				d = q[0][d] ^ getB(sKey[2], 3);
	 			case 2:
	 				tfsM[0][i] = m[0][q[0][q[0][a] ^ getB(sKey[1], 0)]
	 						^ getB(sKey[0], 0)];
	 				tfsM[1][i] = m[1][q[0][q[1][b] ^ getB(sKey[1], 1)]
	 						^ getB(sKey[0], 1)];
	 				tfsM[2][i] = m[2][q[1][q[0][c] ^ getB(sKey[1], 2)]
	 						^ getB(sKey[0], 2)];
	 				tfsM[3][i] = m[3][q[1][q[1][d] ^ getB(sKey[1], 3)]
	 						^ getB(sKey[0], 3)];
	 			}
	 		}
	 	}
	 
	 	function tfsG0(x) {
	 		return tfsM[0][getB(x, 0)] ^ tfsM[1][getB(x, 1)] ^ tfsM[2][getB(x, 2)]
	 				^ tfsM[3][getB(x, 3)];
	 	}
	 	function tfsG1(x) {
	 		return tfsM[0][getB(x, 3)] ^ tfsM[1][getB(x, 0)] ^ tfsM[2][getB(x, 1)]
	 				^ tfsM[3][getB(x, 2)];
	 	}
	 
	 	function tfsFrnd(r, blk) {
	 		var a = tfsG0(blk[0]);
	 		var b = tfsG1(blk[1]);
	 		blk[2] = rotw(blk[2] ^ (a + b + tfsKey[4 * r + 8]) & MAXINT, 31);
	 		blk[3] = rotw(blk[3], 1) ^ (a + 2 * b + tfsKey[4 * r + 9]) & MAXINT;
	 		a = tfsG0(blk[2]);
	 		b = tfsG1(blk[3]);
	 		blk[0] = rotw(blk[0] ^ (a + b + tfsKey[4 * r + 10]) & MAXINT, 31);
	 		blk[1] = rotw(blk[1], 1) ^ (a + 2 * b + tfsKey[4 * r + 11]) & MAXINT;
	 	}
	 
	 	function tfsIrnd(i, blk) {
	 		var a = tfsG0(blk[0]);
	 		var b = tfsG1(blk[1]);
	 		blk[2] = rotw(blk[2], 1) ^ (a + b + tfsKey[4 * i + 10]) & MAXINT;
	 		blk[3] = rotw(blk[3] ^ (a + 2 * b + tfsKey[4 * i + 11]) & MAXINT, 31);
	 		a = tfsG0(blk[2]);
	 		b = tfsG1(blk[3]);
	 		blk[0] = rotw(blk[0], 1) ^ (a + b + tfsKey[4 * i + 8]) & MAXINT;
	 		blk[1] = rotw(blk[1] ^ (a + 2 * b + tfsKey[4 * i + 9]) & MAXINT, 31);
	 	}
	 
	 	function tfsClose() {
	 		tfsKey = [];
	 		tfsM = [ [], [], [], [] ];
	 	}
	 
	 	function tfsEncrypt(data, offset) {
	 		dataBytes = data;
	 		dataOffset = offset;
	 		var blk = [ getW(dataBytes, dataOffset) ^ tfsKey[0],
	 				getW(dataBytes, dataOffset + 4) ^ tfsKey[1],
	 				getW(dataBytes, dataOffset + 8) ^ tfsKey[2],
	 				getW(dataBytes, dataOffset + 12) ^ tfsKey[3] ];
	 		for ( var j = 0; j < 8; j++) {
	 			tfsFrnd(j, blk);
	 		}
	 		setW(dataBytes, dataOffset, blk[2] ^ tfsKey[4]);
	 		setW(dataBytes, dataOffset + 4, blk[3] ^ tfsKey[5]);
	 		setW(dataBytes, dataOffset + 8, blk[0] ^ tfsKey[6]);
	 		setW(dataBytes, dataOffset + 12, blk[1] ^ tfsKey[7]);
	 		dataOffset += 16;
	 		return dataBytes;
	 	}
	 
	 	function tfsDecrypt(data, offset) {
	 		dataBytes = data;
	 		dataOffset = offset;
	 		var blk = [ getW(dataBytes, dataOffset) ^ tfsKey[4],
	 				getW(dataBytes, dataOffset + 4) ^ tfsKey[5],
	 				getW(dataBytes, dataOffset + 8) ^ tfsKey[6],
	 				getW(dataBytes, dataOffset + 12) ^ tfsKey[7] ];
	 		for ( var j = 7; j >= 0; j--) {
	 			tfsIrnd(j, blk);
	 		}
	 		setW(dataBytes, dataOffset, blk[2] ^ tfsKey[0]);
	 		setW(dataBytes, dataOffset + 4, blk[3] ^ tfsKey[1]);
	 		setW(dataBytes, dataOffset + 8, blk[0] ^ tfsKey[2]);
	 		setW(dataBytes, dataOffset + 12, blk[1] ^ tfsKey[3]);
	 		dataOffset += 16;
	 	}
	 	
	 	// added by Recurity Labs
	 	function tfsFinal() {
	 		return dataBytes;
	 	}
	 
	 	return {
	 		name : "twofish",
	 		blocksize : 128 / 8,
	 		open : tfsInit,
	 		close : tfsClose,
	 		encrypt : tfsEncrypt,
	 		decrypt : tfsDecrypt,
	 		// added by Recurity Labs
	 		finalize: tfsFinal
	 	};
	 }
	 
	 JXG = {exists: (function(undefined){return function(v){return !(v===undefined || v===null);}})()};
	 JXG.decompress = function(str) {return unescape((new JXG.Util.Unzip(JXG.Util.Base64.decodeAsArray(str))).unzip()[0][0]);};
	 /*
	     Copyright 2008-2012
	         Matthias Ehmann,
	         Michael Gerhaeuser,
	         Carsten Miller,
	         Bianca Valentin,
	         Alfred Wassermann,
	         Peter Wilfahrt
	 
	     This file is part of JSXGraph.
	     
	     Dual licensed under the Apache License Version 2.0, or LGPL Version 3 licenses.
	 
	     You should have received a copy of the GNU Lesser General Public License
	     along with JSXCompressor.  If not, see <http://www.gnu.org/licenses/>.
	     
	     You should have received a copy of the Apache License along with JSXCompressor.  
	     If not, see <http://www.apache.org/licenses/>.
	 
	 */
	 
	 /**
	   * @class Util class
	   * @classdesc Utilities for uncompressing and base64 decoding
	   * Class for gunzipping, unzipping and base64 decoding of files.
	   * It is used for reading GEONExT, Geogebra and Intergeo files.
	   *
	   * Only Huffman codes are decoded in gunzip.
	   * The code is based on the source code for gunzip.c by Pasi Ojala 
	   * {@link http://www.cs.tut.fi/~albert/Dev/gunzip/gunzip.c}
	   * {@link http://www.cs.tut.fi/~albert}
	   */
	 JXG.Util = {};
	                                  
	 /**
	  * Unzip zip files
	  */
	 JXG.Util.Unzip = function (barray){
	     var outputArr = [],
	         output = "",
	         debug = false,
	         gpflags,
	         files = 0,
	         unzipped = [],
	         crc,
	         buf32k = new Array(32768),
	         bIdx = 0,
	         modeZIP=false,
	 
	         CRC, SIZE,
	     
	         bitReverse = [
	         0x00, 0x80, 0x40, 0xc0, 0x20, 0xa0, 0x60, 0xe0,
	         0x10, 0x90, 0x50, 0xd0, 0x30, 0xb0, 0x70, 0xf0,
	         0x08, 0x88, 0x48, 0xc8, 0x28, 0xa8, 0x68, 0xe8,
	         0x18, 0x98, 0x58, 0xd8, 0x38, 0xb8, 0x78, 0xf8,
	         0x04, 0x84, 0x44, 0xc4, 0x24, 0xa4, 0x64, 0xe4,
	         0x14, 0x94, 0x54, 0xd4, 0x34, 0xb4, 0x74, 0xf4,
	         0x0c, 0x8c, 0x4c, 0xcc, 0x2c, 0xac, 0x6c, 0xec,
	         0x1c, 0x9c, 0x5c, 0xdc, 0x3c, 0xbc, 0x7c, 0xfc,
	         0x02, 0x82, 0x42, 0xc2, 0x22, 0xa2, 0x62, 0xe2,
	         0x12, 0x92, 0x52, 0xd2, 0x32, 0xb2, 0x72, 0xf2,
	         0x0a, 0x8a, 0x4a, 0xca, 0x2a, 0xaa, 0x6a, 0xea,
	         0x1a, 0x9a, 0x5a, 0xda, 0x3a, 0xba, 0x7a, 0xfa,
	         0x06, 0x86, 0x46, 0xc6, 0x26, 0xa6, 0x66, 0xe6,
	         0x16, 0x96, 0x56, 0xd6, 0x36, 0xb6, 0x76, 0xf6,
	         0x0e, 0x8e, 0x4e, 0xce, 0x2e, 0xae, 0x6e, 0xee,
	         0x1e, 0x9e, 0x5e, 0xde, 0x3e, 0xbe, 0x7e, 0xfe,
	         0x01, 0x81, 0x41, 0xc1, 0x21, 0xa1, 0x61, 0xe1,
	         0x11, 0x91, 0x51, 0xd1, 0x31, 0xb1, 0x71, 0xf1,
	         0x09, 0x89, 0x49, 0xc9, 0x29, 0xa9, 0x69, 0xe9,
	         0x19, 0x99, 0x59, 0xd9, 0x39, 0xb9, 0x79, 0xf9,
	         0x05, 0x85, 0x45, 0xc5, 0x25, 0xa5, 0x65, 0xe5,
	         0x15, 0x95, 0x55, 0xd5, 0x35, 0xb5, 0x75, 0xf5,
	         0x0d, 0x8d, 0x4d, 0xcd, 0x2d, 0xad, 0x6d, 0xed,
	         0x1d, 0x9d, 0x5d, 0xdd, 0x3d, 0xbd, 0x7d, 0xfd,
	         0x03, 0x83, 0x43, 0xc3, 0x23, 0xa3, 0x63, 0xe3,
	         0x13, 0x93, 0x53, 0xd3, 0x33, 0xb3, 0x73, 0xf3,
	         0x0b, 0x8b, 0x4b, 0xcb, 0x2b, 0xab, 0x6b, 0xeb,
	         0x1b, 0x9b, 0x5b, 0xdb, 0x3b, 0xbb, 0x7b, 0xfb,
	         0x07, 0x87, 0x47, 0xc7, 0x27, 0xa7, 0x67, 0xe7,
	         0x17, 0x97, 0x57, 0xd7, 0x37, 0xb7, 0x77, 0xf7,
	         0x0f, 0x8f, 0x4f, 0xcf, 0x2f, 0xaf, 0x6f, 0xef,
	         0x1f, 0x9f, 0x5f, 0xdf, 0x3f, 0xbf, 0x7f, 0xff
	     ],
	     
	     cplens = [
	         3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
	         35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0
	     ],
	 
	     cplext = [
	         0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2,
	         3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 99, 99
	     ], /* 99==invalid */
	 
	     cpdist = [
	         0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0007, 0x0009, 0x000d,
	         0x0011, 0x0019, 0x0021, 0x0031, 0x0041, 0x0061, 0x0081, 0x00c1,
	         0x0101, 0x0181, 0x0201, 0x0301, 0x0401, 0x0601, 0x0801, 0x0c01,
	         0x1001, 0x1801, 0x2001, 0x3001, 0x4001, 0x6001
	     ],
	 
	     cpdext = [
	         0,  0,  0,  0,  1,  1,  2,  2,
	         3,  3,  4,  4,  5,  5,  6,  6,
	         7,  7,  8,  8,  9,  9, 10, 10,
	         11, 11, 12, 12, 13, 13
	     ],
	     
	     border = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15],
	     
	     bA = barray,
	 
	     bytepos=0,
	     bitpos=0,
	     bb = 1,
	     bits=0,
	     
	     NAMEMAX = 256,
	     
	     nameBuf = [],
	     
	     fileout;
	     
	     function readByte(){
	         bits+=8;
	         if (bytepos<bA.length){
	             //if (debug)
	             //    document.write(bytepos+": "+bA[bytepos]+"<br>");
	             return bA[bytepos++];
	         } else
	             return -1;
	     };
	 
	     function byteAlign(){
	         bb = 1;
	     };
	     
	     function readBit(){
	         var carry;
	         bits++;
	         carry = (bb & 1);
	         bb >>= 1;
	         if (bb==0){
	             bb = readByte();
	             carry = (bb & 1);
	             bb = (bb>>1) | 0x80;
	         }
	         return carry;
	     };
	 
	     function readBits(a) {
	         var res = 0,
	             i = a;
	     
	         while(i--) {
	             res = (res<<1) | readBit();
	         }
	         if(a) {
	             res = bitReverse[res]>>(8-a);
	         }
	         return res;
	     };
	         
	     function flushBuffer(){
	         //document.write('FLUSHBUFFER:'+buf32k);
	         bIdx = 0;
	     };
	     function addBuffer(a){
	         SIZE++;
	         //CRC=updcrc(a,crc);
	         buf32k[bIdx++] = a;
	         outputArr.push(String.fromCharCode(a));
	         //output+=String.fromCharCode(a);
	         if(bIdx==0x8000){
	             //document.write('ADDBUFFER:'+buf32k);
	             bIdx=0;
	         }
	     };
	     
	     function HufNode() {
	         this.b0=0;
	         this.b1=0;
	         this.jump = null;
	         this.jumppos = -1;
	     };
	 
	     var LITERALS = 288;
	     
	     var literalTree = new Array(LITERALS);
	     var distanceTree = new Array(32);
	     var treepos=0;
	     var Places = null;
	     var Places2 = null;
	     
	     var impDistanceTree = new Array(64);
	     var impLengthTree = new Array(64);
	     
	     var len = 0;
	     var fpos = new Array(17);
	     fpos[0]=0;
	     var flens;
	     var fmax;
	     
	     function IsPat() {
	         while (1) {
	             if (fpos[len] >= fmax)
	                 return -1;
	             if (flens[fpos[len]] == len)
	                 return fpos[len]++;
	             fpos[len]++;
	         }
	     };
	 
	     function Rec() {
	         var curplace = Places[treepos];
	         var tmp;
	         if (debug)
	     		document.write("<br>len:"+len+" treepos:"+treepos);
	         if(len==17) { //war 17
	             return -1;
	         }
	         treepos++;
	         len++;
	     	
	         tmp = IsPat();
	         if (debug)
	         	document.write("<br>IsPat "+tmp);
	         if(tmp >= 0) {
	             curplace.b0 = tmp;    /* leaf cell for 0-bit */
	             if (debug)
	             	document.write("<br>b0 "+curplace.b0);
	         } else {
	         /* Not a Leaf cell */
	         curplace.b0 = 0x8000;
	         if (debug)
	         	document.write("<br>b0 "+curplace.b0);
	         if(Rec())
	             return -1;
	         }
	         tmp = IsPat();
	         if(tmp >= 0) {
	             curplace.b1 = tmp;    /* leaf cell for 1-bit */
	             if (debug)
	             	document.write("<br>b1 "+curplace.b1);
	             curplace.jump = null;    /* Just for the display routine */
	         } else {
	             /* Not a Leaf cell */
	             curplace.b1 = 0x8000;
	             if (debug)
	             	document.write("<br>b1 "+curplace.b1);
	             curplace.jump = Places[treepos];
	             curplace.jumppos = treepos;
	             if(Rec())
	                 return -1;
	         }
	         len--;
	         return 0;
	     };
	 
	     function CreateTree(currentTree, numval, lengths, show) {
	         var i;
	         /* Create the Huffman decode tree/table */
	         //document.write("<br>createtree<br>");
	         if (debug)
	         	document.write("currentTree "+currentTree+" numval "+numval+" lengths "+lengths+" show "+show);
	         Places = currentTree;
	         treepos=0;
	         flens = lengths;
	         fmax  = numval;
	         for (i=0;i<17;i++)
	             fpos[i] = 0;
	         len = 0;
	         if(Rec()) {
	             //fprintf(stderr, "invalid huffman tree\n");
	             if (debug)
	             	alert("invalid huffman tree\n");
	             return -1;
	         }
	         if (debug){
	         	document.write('<br>Tree: '+Places.length);
	         	for (var a=0;a<32;a++){
	             	document.write("Places["+a+"].b0="+Places[a].b0+"<br>");
	             	document.write("Places["+a+"].b1="+Places[a].b1+"<br>");
	         	}
	         }
	     
	         /*if(show) {
	             var tmp;
	             for(tmp=currentTree;tmp<Places;tmp++) {
	                 fprintf(stdout, "0x%03x  0x%03x (0x%04x)",tmp-currentTree, tmp->jump?tmp->jump-currentTree:0,(tmp->jump?tmp->jump-currentTree:0)*6+0xcf0);
	                 if(!(tmp.b0 & 0x8000)) {
	                     //fprintf(stdout, "  0x%03x (%c)", tmp->b0,(tmp->b0<256 && isprint(tmp->b0))?tmp->b0:'�');
	                 }
	                 if(!(tmp.b1 & 0x8000)) {
	                     if((tmp.b0 & 0x8000))
	                         fprintf(stdout, "           ");
	                     fprintf(stdout, "  0x%03x (%c)", tmp->b1,(tmp->b1<256 && isprint(tmp->b1))?tmp->b1:'�');
	                 }
	                 fprintf(stdout, "\n");
	             }
	         }*/
	         return 0;
	     };
	     
	     function DecodeValue(currentTree) {
	         var len, i,
	             xtreepos=0,
	             X = currentTree[xtreepos],
	             b;
	 
	         /* decode one symbol of the data */
	         while(1) {
	             b=readBit();
	             if (debug)
	             	document.write("b="+b);
	             if(b) {
	                 if(!(X.b1 & 0x8000)){
	                 	if (debug)
	                     	document.write("ret1");
	                     return X.b1;    /* If leaf node, return data */
	                 }
	                 X = X.jump;
	                 len = currentTree.length;
	                 for (i=0;i<len;i++){
	                     if (currentTree[i]===X){
	                         xtreepos=i;
	                         break;
	                     }
	                 }
	                 //xtreepos++;
	             } else {
	                 if(!(X.b0 & 0x8000)){
	                 	if (debug)
	                     	document.write("ret2");
	                     return X.b0;    /* If leaf node, return data */
	                 }
	                 //X++; //??????????????????
	                 xtreepos++;
	                 X = currentTree[xtreepos];
	             }
	         }
	         if (debug)
	         	document.write("ret3");
	         return -1;
	     };
	     
	     function DeflateLoop() {
	     var last, c, type, i, len;
	 
	     do {
	         /*if((last = readBit())){
	             fprintf(errfp, "Last Block: ");
	         } else {
	             fprintf(errfp, "Not Last Block: ");
	         }*/
	         last = readBit();
	         type = readBits(2);
	         switch(type) {
	             case 0:
	             	if (debug)
	                 	alert("Stored\n");
	                 break;
	             case 1:
	             	if (debug)
	                 	alert("Fixed Huffman codes\n");
	                 break;
	             case 2:
	             	if (debug)
	                 	alert("Dynamic Huffman codes\n");
	                 break;
	             case 3:
	             	if (debug)
	                 	alert("Reserved block type!!\n");
	                 break;
	             default:
	             	if (debug)
	                 	alert("Unexpected value %d!\n", type);
	                 break;
	         }
	 
	         if(type==0) {
	             var blockLen, cSum;
	 
	             // Stored 
	             byteAlign();
	             blockLen = readByte();
	             blockLen |= (readByte()<<8);
	 
	             cSum = readByte();
	             cSum |= (readByte()<<8);
	 
	             if(((blockLen ^ ~cSum) & 0xffff)) {
	                 document.write("BlockLen checksum mismatch\n");
	             }
	             while(blockLen--) {
	                 c = readByte();
	                 addBuffer(c);
	             }
	         } else if(type==1) {
	             var j;
	 
	             /* Fixed Huffman tables -- fixed decode routine */
	             while(1) {
	             /*
	                 256    0000000        0
	                 :   :     :
	                 279    0010111        23
	                 0   00110000    48
	                 :    :      :
	                 143    10111111    191
	                 280 11000000    192
	                 :    :      :
	                 287 11000111    199
	                 144    110010000    400
	                 :    :       :
	                 255    111111111    511
	     
	                 Note the bit order!
	                 */
	 
	             j = (bitReverse[readBits(7)]>>1);
	             if(j > 23) {
	                 j = (j<<1) | readBit();    /* 48..255 */
	 
	                 if(j > 199) {    /* 200..255 */
	                     j -= 128;    /*  72..127 */
	                     j = (j<<1) | readBit();        /* 144..255 << */
	                 } else {        /*  48..199 */
	                     j -= 48;    /*   0..151 */
	                     if(j > 143) {
	                         j = j+136;    /* 280..287 << */
	                         /*   0..143 << */
	                     }
	                 }
	             } else {    /*   0..23 */
	                 j += 256;    /* 256..279 << */
	             }
	             if(j < 256) {
	                 addBuffer(j);
	                 //document.write("out:"+String.fromCharCode(j));
	                 /*fprintf(errfp, "@%d %02x\n", SIZE, j);*/
	             } else if(j == 256) {
	                 /* EOF */
	                 break;
	             } else {
	                 var len, dist;
	 
	                 j -= 256 + 1;    /* bytes + EOF */
	                 len = readBits(cplext[j]) + cplens[j];
	 
	                 j = bitReverse[readBits(5)]>>3;
	                 if(cpdext[j] > 8) {
	                     dist = readBits(8);
	                     dist |= (readBits(cpdext[j]-8)<<8);
	                 } else {
	                     dist = readBits(cpdext[j]);
	                 }
	                 dist += cpdist[j];
	 
	                 /*fprintf(errfp, "@%d (l%02x,d%04x)\n", SIZE, len, dist);*/
	                 for(j=0;j<len;j++) {
	                     var c = buf32k[(bIdx - dist) & 0x7fff];
	                     addBuffer(c);
	                 }
	             }
	             } // while
	         } else if(type==2) {
	             var j, n, literalCodes, distCodes, lenCodes;
	             var ll = new Array(288+32);    // "static" just to preserve stack
	     
	             // Dynamic Huffman tables 
	     
	             literalCodes = 257 + readBits(5);
	             distCodes = 1 + readBits(5);
	             lenCodes = 4 + readBits(4);
	             //document.write("<br>param: "+literalCodes+" "+distCodes+" "+lenCodes+"<br>");
	             for(j=0; j<19; j++) {
	                 ll[j] = 0;
	             }
	     
	             // Get the decode tree code lengths
	     
	             //document.write("<br>");
	             for(j=0; j<lenCodes; j++) {
	                 ll[border[j]] = readBits(3);
	                 //document.write(ll[border[j]]+" ");
	             }
	             //fprintf(errfp, "\n");
	             //document.write('<br>ll:'+ll);
	             len = distanceTree.length;
	             for (i=0; i<len; i++)
	                 distanceTree[i]=new HufNode();
	             if(CreateTree(distanceTree, 19, ll, 0)) {
	                 flushBuffer();
	                 return 1;
	             }
	             if (debug){
	             	document.write("<br>distanceTree");
	             	for(var a=0;a<distanceTree.length;a++){
	                 	document.write("<br>"+distanceTree[a].b0+" "+distanceTree[a].b1+" "+distanceTree[a].jump+" "+distanceTree[a].jumppos);
	                 	/*if (distanceTree[a].jumppos!=-1)
	                     	document.write(" "+distanceTree[a].jump.b0+" "+distanceTree[a].jump.b1);
	                 	*/
	             	}
	             }
	             //document.write('<BR>tree created');
	     
	             //read in literal and distance code lengths
	             n = literalCodes + distCodes;
	             i = 0;
	             var z=-1;
	             if (debug)
	             	document.write("<br>n="+n+" bits: "+bits+"<br>");
	             while(i < n) {
	                 z++;
	                 j = DecodeValue(distanceTree);
	                 if (debug)
	                 	document.write("<br>"+z+" i:"+i+" decode: "+j+"    bits "+bits+"<br>");
	                 if(j<16) {    // length of code in bits (0..15)
	                        ll[i++] = j;
	                 } else if(j==16) {    // repeat last length 3 to 6 times 
	                        var l;
	                     j = 3 + readBits(2);
	                     if(i+j > n) {
	                         flushBuffer();
	                         return 1;
	                     }
	                     l = i ? ll[i-1] : 0;
	                     while(j--) {
	                         ll[i++] = l;
	                     }
	                 } else {
	                     if(j==17) {        // 3 to 10 zero length codes
	                         j = 3 + readBits(3);
	                     } else {        // j == 18: 11 to 138 zero length codes 
	                         j = 11 + readBits(7);
	                     }
	                     if(i+j > n) {
	                         flushBuffer();
	                         return 1;
	                     }
	                     while(j--) {
	                         ll[i++] = 0;
	                     }
	                 }
	             }
	             /*for(j=0; j<literalCodes+distCodes; j++) {
	                 //fprintf(errfp, "%d ", ll[j]);
	                 if ((j&7)==7)
	                     fprintf(errfp, "\n");
	             }
	             fprintf(errfp, "\n");*/
	             // Can overwrite tree decode tree as it is not used anymore
	             len = literalTree.length;
	             for (i=0; i<len; i++)
	                 literalTree[i]=new HufNode();
	             if(CreateTree(literalTree, literalCodes, ll, 0)) {
	                 flushBuffer();
	                 return 1;
	             }
	             len = literalTree.length;
	             for (i=0; i<len; i++)
	                 distanceTree[i]=new HufNode();
	             var ll2 = new Array();
	             for (i=literalCodes; i <ll.length; i++){
	                 ll2[i-literalCodes]=ll[i];
	             }    
	             if(CreateTree(distanceTree, distCodes, ll2, 0)) {
	                 flushBuffer();
	                 return 1;
	             }
	             if (debug)
	            		document.write("<br>literalTree");
	             outer:
	             while(1) {
	                 j = DecodeValue(literalTree);
	                 if(j >= 256) {        // In C64: if carry set
	                     var len, dist;
	                     j -= 256;
	                     if(j == 0) {
	                         // EOF
	                         break;
	                     }
	                     j--;
	                     len = readBits(cplext[j]) + cplens[j];
	     
	                     j = DecodeValue(distanceTree);
	                     if(cpdext[j] > 8) {
	                         dist = readBits(8);
	                         dist |= (readBits(cpdext[j]-8)<<8);
	                     } else {
	                         dist = readBits(cpdext[j]);
	                     }
	                     dist += cpdist[j];
	                     while(len--) {
	                         if(bIdx - dist < 0) {
	                             break outer;
	                         }
	                         var c = buf32k[(bIdx - dist) & 0x7fff];
	                         addBuffer(c);
	                     }
	                 } else {
	                     addBuffer(j);
	                 }
	             }
	         }
	     } while(!last);
	     flushBuffer();
	 
	     byteAlign();
	     return 0;
	 };
	 
	 JXG.Util.Unzip.prototype.unzipFile = function(name) {
	     var i;
	 	this.unzip();
	 	//alert(unzipped[0][1]);
	 	for (i=0;i<unzipped.length;i++){
	 		if(unzipped[i][1]==name) {
	 			return unzipped[i][0];
	 		}
	 	}
	 	
	   };
	 
	 JXG.Util.Unzip.prototype.deflate = function() {
	     outputArr = [];
	     var tmp = [];
	     modeZIP = false;
	     DeflateLoop();
	     if (debug)
	         alert(outputArr.join(''));
	     unzipped[files] = new Array(2);
	     unzipped[files][0] = outputArr.join('');
	     unzipped[files][1] = "DEFLATE";
	     files++;
	     return unzipped;
	 }    
	     
	 JXG.Util.Unzip.prototype.unzip = function() {
	 	//convertToByteArray(input);
	 	if (debug)
	 		alert(bA);
	 	/*for (i=0;i<bA.length*8;i++){
	 		document.write(readBit());
	 		if ((i+1)%8==0)
	 			document.write(" ");
	 	}*/
	 	/*for (i=0;i<bA.length;i++){
	 		document.write(readByte()+" ");
	 		if ((i+1)%8==0)
	 			document.write(" ");
	 	}
	 	for (i=0;i<bA.length;i++){
	 		document.write(bA[i]+" ");
	 		if ((i+1)%16==0)
	 			document.write("<br>");
	 	}	
	 	*/
	 	//alert(bA);
	 	nextFile();
	 	return unzipped;
	   };
	     
	  function nextFile(){
	  	if (debug)
	  		alert("NEXTFILE");
	  	outputArr = [];
	  	var tmp = [];
	  	modeZIP = false;
	 	tmp[0] = readByte();
	 	tmp[1] = readByte();
	 	if (debug)
	 		alert("type: "+tmp[0]+" "+tmp[1]);
	 	if (tmp[0] == parseInt("78",16) && tmp[1] == parseInt("da",16)){ //GZIP
	 		if (debug)
	 			alert("GEONExT-GZIP");
	 		DeflateLoop();
	 		if (debug)
	 			alert(outputArr.join(''));
	 		unzipped[files] = new Array(2);
	     	unzipped[files][0] = outputArr.join('');
	     	unzipped[files][1] = "geonext.gxt";
	     	files++;
	 	}
	 	if (tmp[0] == parseInt("78",16) && tmp[1] == parseInt("9c",16)){ //ZLIB
	 		if (debug)
	 			alert("ZLIB");
	 		DeflateLoop();
	 		if (debug)
	 			alert(outputArr.join(''));
	 		unzipped[files] = new Array(2);
	     	unzipped[files][0] = outputArr.join('');
	     	unzipped[files][1] = "ZLIB";
	     	files++;
	 	}
	 	if (tmp[0] == parseInt("1f",16) && tmp[1] == parseInt("8b",16)){ //GZIP
	 		if (debug)
	 			alert("GZIP");
	 		//DeflateLoop();
	 		skipdir();
	 		if (debug)
	 			alert(outputArr.join(''));
	 		unzipped[files] = new Array(2);
	     	unzipped[files][0] = outputArr.join('');
	     	unzipped[files][1] = "file";
	     	files++;
	 	}
	 	if (tmp[0] == parseInt("50",16) && tmp[1] == parseInt("4b",16)){ //ZIP
	 		modeZIP = true;
	 		tmp[2] = readByte();
	 		tmp[3] = readByte();
	 		if (tmp[2] == parseInt("3",16) && tmp[3] == parseInt("4",16)){
	 			//MODE_ZIP
	 			tmp[0] = readByte();
	 			tmp[1] = readByte();
	 			if (debug)
	 				alert("ZIP-Version: "+tmp[1]+" "+tmp[0]/10+"."+tmp[0]%10);
	 			
	 			gpflags = readByte();
	 			gpflags |= (readByte()<<8);
	 			if (debug)
	 				alert("gpflags: "+gpflags);
	 			
	 			var method = readByte();
	 			method |= (readByte()<<8);
	 			if (debug)
	 				alert("method: "+method);
	 			
	 			readByte();
	 			readByte();
	 			readByte();
	 			readByte();
	 			
	 			var crc = readByte();
	 			crc |= (readByte()<<8);
	 			crc |= (readByte()<<16);
	 			crc |= (readByte()<<24);
	 			
	 			var compSize = readByte();
	 			compSize |= (readByte()<<8);
	 			compSize |= (readByte()<<16);
	 			compSize |= (readByte()<<24);
	 			
	 			var size = readByte();
	 			size |= (readByte()<<8);
	 			size |= (readByte()<<16);
	 			size |= (readByte()<<24);
	 			
	 			if (debug)
	 				alert("local CRC: "+crc+"\nlocal Size: "+size+"\nlocal CompSize: "+compSize);
	 			
	 			var filelen = readByte();
	 			filelen |= (readByte()<<8);
	 			
	 			var extralen = readByte();
	 			extralen |= (readByte()<<8);
	 			
	 			if (debug)
	 				alert("filelen "+filelen);
	 			i = 0;
	 			nameBuf = [];
	 			while (filelen--){ 
	 				var c = readByte();
	 				if (c == "/" | c ==":"){
	 					i = 0;
	 				} else if (i < NAMEMAX-1)
	 					nameBuf[i++] = String.fromCharCode(c);
	 			}
	 			if (debug)
	 				alert("nameBuf: "+nameBuf);
	 			
	 			//nameBuf[i] = "\0";
	 			if (!fileout)
	 				fileout = nameBuf;
	 			
	 			var i = 0;
	 			while (i < extralen){
	 				c = readByte();
	 				i++;
	 			}
	 				
	 			CRC = 0xffffffff;
	 			SIZE = 0;
	 			
	 			if (size = 0 && fileOut.charAt(fileout.length-1)=="/"){
	 				//skipdir
	 				if (debug)
	 					alert("skipdir");
	 			}
	 			if (method == 8){
	 				DeflateLoop();
	 				if (debug)
	 					alert(outputArr.join(''));
	 				unzipped[files] = new Array(2);
	 				unzipped[files][0] = outputArr.join('');
	     			unzipped[files][1] = nameBuf.join('');
	     			files++;
	 				//return outputArr.join('');
	 			}
	 			skipdir();
	 		}
	 	}
	  };
	 	
	 function skipdir(){
	     var crc, 
	         tmp = [],
	         compSize, size, os, i, c;
	     
	 	if ((gpflags & 8)) {
	 		tmp[0] = readByte();
	 		tmp[1] = readByte();
	 		tmp[2] = readByte();
	 		tmp[3] = readByte();
	 		
	 		if (tmp[0] == parseInt("50",16) && 
	             tmp[1] == parseInt("4b",16) && 
	             tmp[2] == parseInt("07",16) && 
	             tmp[3] == parseInt("08",16))
	         {
	             crc = readByte();
	             crc |= (readByte()<<8);
	             crc |= (readByte()<<16);
	             crc |= (readByte()<<24);
	 		} else {
	 			crc = tmp[0] | (tmp[1]<<8) | (tmp[2]<<16) | (tmp[3]<<24);
	 		}
	 		
	 		compSize = readByte();
	 		compSize |= (readByte()<<8);
	 		compSize |= (readByte()<<16);
	 		compSize |= (readByte()<<24);
	 		
	 		size = readByte();
	 		size |= (readByte()<<8);
	 		size |= (readByte()<<16);
	 		size |= (readByte()<<24);
	 		
	 		if (debug)
	 			alert("CRC:");
	 	}
	 
	 	if (modeZIP)
	 		nextFile();
	 	
	 	tmp[0] = readByte();
	 	if (tmp[0] != 8) {
	 		if (debug)
	 			alert("Unknown compression method!");
	         return 0;	
	 	}
	 	
	 	gpflags = readByte();
	 	if (debug){
	 		if ((gpflags & ~(parseInt("1f",16))))
	 			alert("Unknown flags set!");
	 	}
	 	
	 	readByte();
	 	readByte();
	 	readByte();
	 	readByte();
	 	
	 	readByte();
	 	os = readByte();
	 	
	 	if ((gpflags & 4)){
	 		tmp[0] = readByte();
	 		tmp[2] = readByte();
	 		len = tmp[0] + 256*tmp[1];
	 		if (debug)
	 			alert("Extra field size: "+len);
	 		for (i=0;i<len;i++)
	 			readByte();
	 	}
	 	
	 	if ((gpflags & 8)){
	 		i=0;
	 		nameBuf=[];
	 		while (c=readByte()){
	 			if(c == "7" || c == ":")
	 				i=0;
	 			if (i<NAMEMAX-1)
	 				nameBuf[i++] = c;
	 		}
	 		//nameBuf[i] = "\0";
	 		if (debug)
	 			alert("original file name: "+nameBuf);
	 	}
	 		
	 	if ((gpflags & 16)){
	 		while (c=readByte()){
	 			//FILE COMMENT
	 		}
	 	}
	 	
	 	if ((gpflags & 2)){
	 		readByte();
	 		readByte();
	 	}
	 	
	 	DeflateLoop();
	 	
	 	crc = readByte();
	 	crc |= (readByte()<<8);
	 	crc |= (readByte()<<16);
	 	crc |= (readByte()<<24);
	 	
	 	size = readByte();
	 	size |= (readByte()<<8);
	 	size |= (readByte()<<16);
	 	size |= (readByte()<<24);
	 	
	 	if (modeZIP)
	 		nextFile();
	 	
	 };
	 
	 };
	 
	 /**
	 *  Base64 encoding / decoding
	 *  {@link http://www.webtoolkit.info/}
	 */
	 JXG.Util.Base64 = {
	 
	     // private property
	     _keyStr : "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
	 
	     // public method for encoding
	     encode : function (input) {
	         var output = [],
	             chr1, chr2, chr3, enc1, enc2, enc3, enc4,
	             i = 0;
	 
	         input = JXG.Util.Base64._utf8_encode(input);
	 
	         while (i < input.length) {
	 
	             chr1 = input.charCodeAt(i++);
	             chr2 = input.charCodeAt(i++);
	             chr3 = input.charCodeAt(i++);
	 
	             enc1 = chr1 >> 2;
	             enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
	             enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
	             enc4 = chr3 & 63;
	 
	             if (isNaN(chr2)) {
	                 enc3 = enc4 = 64;
	             } else if (isNaN(chr3)) {
	                 enc4 = 64;
	             }
	 
	             output.push([this._keyStr.charAt(enc1),
	                          this._keyStr.charAt(enc2),
	                          this._keyStr.charAt(enc3),
	                          this._keyStr.charAt(enc4)].join(''));
	         }
	 
	         return output.join('');
	     },
	 
	     // public method for decoding
	     decode : function (input, utf8) {
	         var output = [],
	             chr1, chr2, chr3,
	             enc1, enc2, enc3, enc4,
	             i = 0;
	 
	         input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
	 
	         while (i < input.length) {
	 
	             enc1 = this._keyStr.indexOf(input.charAt(i++));
	             enc2 = this._keyStr.indexOf(input.charAt(i++));
	             enc3 = this._keyStr.indexOf(input.charAt(i++));
	             enc4 = this._keyStr.indexOf(input.charAt(i++));
	 
	             chr1 = (enc1 << 2) | (enc2 >> 4);
	             chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
	             chr3 = ((enc3 & 3) << 6) | enc4;
	 
	             output.push(String.fromCharCode(chr1));
	 
	             if (enc3 != 64) {
	                 output.push(String.fromCharCode(chr2));
	             }
	             if (enc4 != 64) {
	                 output.push(String.fromCharCode(chr3));
	             }
	         }
	         
	         output = output.join(''); 
	         
	         if (utf8) {
	             output = JXG.Util.Base64._utf8_decode(output);
	         }
	         return output;
	 
	     },
	 
	     // private method for UTF-8 encoding
	     _utf8_encode : function (string) {
	         string = string.replace(/\r\n/g,"\n");
	         var utftext = "";
	 
	         for (var n = 0; n < string.length; n++) {
	 
	             var c = string.charCodeAt(n);
	 
	             if (c < 128) {
	                 utftext += String.fromCharCode(c);
	             }
	             else if((c > 127) && (c < 2048)) {
	                 utftext += String.fromCharCode((c >> 6) | 192);
	                 utftext += String.fromCharCode((c & 63) | 128);
	             }
	             else {
	                 utftext += String.fromCharCode((c >> 12) | 224);
	                 utftext += String.fromCharCode(((c >> 6) & 63) | 128);
	                 utftext += String.fromCharCode((c & 63) | 128);
	             }
	 
	         }
	 
	         return utftext;
	     },
	 
	     // private method for UTF-8 decoding
	     _utf8_decode : function (utftext) {
	         var string = [],
	             i = 0,
	             c = 0, c2 = 0, c3 = 0;
	 
	         while ( i < utftext.length ) {
	             c = utftext.charCodeAt(i);
	             if (c < 128) {
	                 string.push(String.fromCharCode(c));
	                 i++;
	             }
	             else if((c > 191) && (c < 224)) {
	                 c2 = utftext.charCodeAt(i+1);
	                 string.push(String.fromCharCode(((c & 31) << 6) | (c2 & 63)));
	                 i += 2;
	             }
	             else {
	                 c2 = utftext.charCodeAt(i+1);
	                 c3 = utftext.charCodeAt(i+2);
	                 string.push(String.fromCharCode(((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63)));
	                 i += 3;
	             }
	         }
	         return string.join('');
	     },
	     
	     _destrip: function (stripped, wrap){
	         var lines = [], lineno, i,
	             destripped = [];
	         
	         if (wrap==null) 
	             wrap = 76;
	             
	         stripped.replace(/ /g, "");
	         lineno = stripped.length / wrap;
	         for (i = 0; i < lineno; i++)
	             lines[i]=stripped.substr(i * wrap, wrap);
	         if (lineno != stripped.length / wrap)
	             lines[lines.length]=stripped.substr(lineno * wrap, stripped.length-(lineno * wrap));
	             
	         for (i = 0; i < lines.length; i++)
	             destripped.push(lines[i]);
	         return destripped.join('\n');
	     },
	     
	     decodeAsArray: function (input){
	         var dec = this.decode(input),
	             ar = [], i;
	         for (i=0;i<dec.length;i++){
	             ar[i]=dec.charCodeAt(i);
	         }
	         return ar;
	     },
	     
	     decodeGEONExT : function (input) {
	         return decodeAsArray(destrip(input),false);
	     }
	 };
	 
	 /**
	  * @private
	  */
	 JXG.Util.asciiCharCodeAt = function(str,i){
	 	var c = str.charCodeAt(i);
	 	if (c>255){
	     	switch (c) {
	 			case 8364: c=128;
	 	    	break;
	 	    	case 8218: c=130;
	 	    	break;
	 	    	case 402: c=131;
	 	    	break;
	 	    	case 8222: c=132;
	 	    	break;
	 	    	case 8230: c=133;
	 	    	break;
	 	    	case 8224: c=134;
	 	    	break;
	 	    	case 8225: c=135;
	 	    	break;
	 	    	case 710: c=136;
	 	    	break;
	 	    	case 8240: c=137;
	 	    	break;
	 	    	case 352: c=138;
	 	    	break;
	 	    	case 8249: c=139;
	 	    	break;
	 	    	case 338: c=140;
	 	    	break;
	 	    	case 381: c=142;
	 	    	break;
	 	    	case 8216: c=145;
	 	    	break;
	 	    	case 8217: c=146;
	 	    	break;
	 	    	case 8220: c=147;
	 	    	break;
	 	    	case 8221: c=148;
	 	    	break;
	 	    	case 8226: c=149;
	 	    	break;
	 	    	case 8211: c=150;
	 	    	break;
	 	    	case 8212: c=151;
	 	    	break;
	 	    	case 732: c=152;
	 	    	break;
	 	    	case 8482: c=153;
	 	    	break;
	 	    	case 353: c=154;
	 	    	break;
	 	    	case 8250: c=155;
	 	    	break;
	 	    	case 339: c=156;
	 	    	break;
	 	    	case 382: c=158;
	 	    	break;
	 	    	case 376: c=159;
	 	    	break;
	 	    	default:
	 	    	break;
	 	    }
	 	}
	 	return c;
	 };
	 
	 /**
	  * Decoding string into utf-8
	  * @param {String} string to decode
	  * @return {String} utf8 decoded string
	  */
	 JXG.Util.utf8Decode = function(utftext) {
	   var string = [];
	   var i = 0;
	   var c = 0, c1 = 0, c2 = 0, c3;
	   if (!JXG.exists(utftext)) return '';
	   
	   while ( i < utftext.length ) {
	     c = utftext.charCodeAt(i);
	 
	     if (c < 128) {
	       string.push(String.fromCharCode(c));
	       i++;
	     } else if((c > 191) && (c < 224)) {
	       c2 = utftext.charCodeAt(i+1);
	       string.push(String.fromCharCode(((c & 31) << 6) | (c2 & 63)));
	       i += 2;
	     } else {
	       c2 = utftext.charCodeAt(i+1);
	       c3 = utftext.charCodeAt(i+2);
	       string.push(String.fromCharCode(((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63)));
	       i += 3;
	     }
	   };
	   return string.join('');
	 };
	 
	 /**
	  * Generate a random uuid.
	  * http://www.broofa.com
	  * mailto:robert@broofa.com
	  *
	  * Copyright (c) 2010 Robert Kieffer
	  * Dual licensed under the MIT and GPL licenses.
	  *
	  * EXAMPLES:
	  *   >>> Math.uuid()
	  *   "92329D39-6F5C-4520-ABFC-AAB64544E172"
	  */
	 JXG.Util.genUUID = function() {
	     // Private array of chars to use
	     var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split(''),
	         uuid = new Array(36), rnd=0, r;
	 
	     for (var i = 0; i < 36; i++) {
	       if (i==8 || i==13 ||  i==18 || i==23) {
	         uuid[i] = '-';
	       } else if (i==14) {
	         uuid[i] = '4';
	       } else {
	         if (rnd <= 0x02) rnd = 0x2000000 + (Math.random()*0x1000000)|0;
	         r = rnd & 0xf;
	         rnd = rnd >> 4;
	         uuid[i] = chars[(i == 19) ? (r & 0x3) | 0x8 : r];
	       }
	     }
	 
	     return uuid.join('');
	 };
	 
	 // GPG4Browsers - An OpenPGP implementation in javascript
	 // Copyright (C) 2011 Recurity Labs GmbH
	 //
	 // This library is free software; you can redistribute it and/or
	 // modify it under the terms of the GNU Lesser General Public
	 // License as published by the Free Software Foundation; either
	 // version 2.1 of the License, or (at your option) any later version.
	 //
	 // This library is distributed in the hope that it will be useful,
	 // but WITHOUT ANY WARRANTY; without even the implied warranty of
	 // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
	 // Lesser General Public License for more details.
	 //
	 // You should have received a copy of the GNU Lesser General Public
	 // License along with this library; if not, write to the Free Software
	 // Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
	 
	 /**
	  *
	  * This object contains configuration values and implements
	  * storing and retrieving configuration them from HTML5 local storage.
	  *
	  * This object can be accessed after calling openpgp.init()
	  * using openpgp.config
	  * Stored config parameters can be accessed using
	  * openpgp.config.config
	  * @class
	  * @classdesc Implementation of the GPG4Browsers config object
	  */
	 function openpgp_config() {
	 	/**
	 	 * The variable with the actual configuration
	 	 * @property {Integer} prefer_hash_algorithm
	 	 * @property {Integer} encryption_cipher
	 	 * @property {Integer} compression
	 	 * @property {Boolean} show_version
	 	 * @property {Boolean} show_comment
	 	 * @property {Boolean} integrity_protect
	 	 * @property {Integer} composition_behavior
	 	 * @property {String} keyserver
	 	 */
	 	this.config = null;
	 
	 	/**
	 	 * The default config object which is used if no
	 	 * configuration was in place
	 	 */
	 	this.default_config = {
	 			prefer_hash_algorithm: 8,
	 			encryption_cipher: 9,
	 			compression: 1,
	 			show_version: true,
	 			show_comment: true,
	 			integrity_protect: true,
	 			composition_behavior: 0,
	 			keyserver: "keyserver.linux.it" // "pgp.mit.edu:11371"
	 	};
	 
	 	this.versionstring ="OpenPGP.js VERSION";
	 	this.commentstring ="http://openpgpjs.org";
	 	/**
	 	 * Reads the config out of the HTML5 local storage
	 	 * and initializes the object config.
	 	 * if config is null the default config will be used
	 	 */
	 	function read() {
	 		var cf = JSON.parse(compat.local_storage_get("config"));
	 		if (cf == null) {
	 			this.config = this.default_config;
	 			this.write();
	 		}
	 		else
	 			this.config = cf;
	 	}
	 
	 	/**
	 	 * If enabled, debug messages will be printed
	 	 */
	 	this.debug = false;
	 
	 	/**
	 	 * Writes the config to HTML5 local storage
	 	 */
	 	function write() {
	 		compat.local_storage_set("config",JSON.stringify(this.config));
	 	}
	 
	 	this.read = read;
	 	this.write = write;
	 }
	 /* OpenPGP radix-64/base64 string encoding/decoding
	  * Copyright 2005 Herbert Hanewinkel, www.haneWIN.de
	  * version 1.0, check www.haneWIN.de for the latest version
	  *
	  * This software is provided as-is, without express or implied warranty.  
	  * Permission to use, copy, modify, distribute or sell this software, with or
	  * without fee, for any purpose and by any individual or organization, is hereby
	  * granted, provided that the above copyright notice and this paragraph appear 
	  * in all copies. Distribution as a part of an application or binary must
	  * include the above copyright notice in the documentation and/or other materials
	  * provided with the application or distribution.
	  */
	 
	 var b64s = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
	 
	 function s2r(t) {
	 	var a, c, n;
	 	var r = '', l = 0, s = 0;
	 	var tl = t.length;
	 
	 	for (n = 0; n < tl; n++) {
	 		c = t.charCodeAt(n);
	 		if (s == 0) {
	 			r += b64s.charAt((c >> 2) & 63);
	 			a = (c & 3) << 4;
	 		} else if (s == 1) {
	 			r += b64s.charAt((a | (c >> 4) & 15));
	 			a = (c & 15) << 2;
	 		} else if (s == 2) {
	 			r += b64s.charAt(a | ((c >> 6) & 3));
	 			l += 1;
	 			if ((l % 60) == 0)
	 				r += "\n";
	 			r += b64s.charAt(c & 63);
	 		}
	 		l += 1;
	 		if ((l % 60) == 0)
	 			r += "\n";
	 
	 		s += 1;
	 		if (s == 3)
	 			s = 0;
	 	}
	 	if (s > 0) {
	 		r += b64s.charAt(a);
	 		l += 1;
	 		if ((l % 60) == 0)
	 			r += "\n";
	 		r += '=';
	 		l += 1;
	 	}
	 	if (s == 1) {
	 		if ((l % 60) == 0)
	 			r += "\n";
	 		r += '=';
	 	}
	 
	 	return r;
	 }
	 
	 function r2s(t) {
	 	var c, n;
	 	var r = '', s = 0, a = 0;
	 	var tl = t.length;
	 
	 	for (n = 0; n < tl; n++) {
	 		c = b64s.indexOf(t.charAt(n));
	 		if (c >= 0) {
	 			if (s)
	 				r += String.fromCharCode(a | (c >> (6 - s)) & 255);
	 			s = (s + 2) & 7;
	 			a = (c << s) & 255;
	 		}
	 	}
	 	return r;
	 }
	 // GPG4Browsers - An OpenPGP implementation in javascript
	 // Copyright (C) 2011 Recurity Labs GmbH
	 //
	 // This library is free software; you can redistribute it and/or
	 // modify it under the terms of the GNU Lesser General Public
	 // License as published by the Free Software Foundation; either
	 // version 2.1 of the License, or (at your option) any later version.
	 //
	 // This library is distributed in the hope that it will be useful,
	 // but WITHOUT ANY WARRANTY; without even the implied warranty of
	 // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
	 // Lesser General Public License for more details.
	 //
	 // You should have received a copy of the GNU Lesser General Public
	 // License along with this library; if not, write to the Free Software
	 // Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
	 
	 /**
	  * DeArmor an OpenPGP armored message; verify the checksum and return 
	  * the encoded bytes
	  * @param {String} text OpenPGP armored message
	  * @returns {(Boolean|Object)} Either false in case of an error 
	  * or an object with attribute "text" containing the message text
	  * and an attribute "openpgp" containing the bytes.
	  */
	 function openpgp_encoding_deArmor(text) {
	 	text = text.replace(/\r/g, '')
	 	// remove whitespace of blank line to allow later split at \n\n
	 	text = text.replace(/\n\s+\n/, '\n\n');
	 
	 	var type = openpgp_encoding_get_type(text);
	 
	 	if (type != 2) {
	 		var splittedtext = text.split('-----');
	 
	 		var data = { 
	 			openpgp: openpgp_encoding_base64_decode(
	 				splittedtext[2]
	 					.split('\n\n')[1]
	 					.split("\n=")[0]
	 					.replace(/\n- /g,"\n")),
	 			type: type
	 		};
	 
	 		if (verifyCheckSum(data.openpgp, 
	 			splittedtext[2]
	 				.split('\n\n')[1]
	 				.split("\n=")[1]
	 				.split('\n')[0]))
	 
	 			return data;
	 		else {
	 			util.print_error("Ascii armor integrity check on message failed: '"
	 				+ splittedtext[2]
	 					.split('\n\n')[1]
	 					.split("\n=")[1]
	 					.split('\n')[0] 
	 				+ "' should be '"
	 				+ getCheckSum(data)) + "'";
	 			return false;
	 		}
	 	} else {
	 		var splittedtext = text.split('-----');
	 
	 		var result = {
	 			text: splittedtext[2]
	 				.replace(/\n- /g,"\n")
	 				.split("\n\n")[1],
	 			openpgp: openpgp_encoding_base64_decode(splittedtext[4]
	 				.split("\n\n")[1]
	 				.split("\n=")[0]),
	 			type: type
	 		};
	 
	 		if (verifyCheckSum(result.openpgp, splittedtext[4]
	 			.split("\n\n")[1]
	 			.split("\n=")[1]))
	 
	 				return result;
	 		else {
	 			util.print_error("Ascii armor integrity check on message failed");
	 			return false;
	 		}
	 	}
	 }
	 
	 /**
	  * Finds out which Ascii Armoring type is used. This is an internal function
	  * @param {String} text [String] ascii armored text
	  * @returns {Integer} 0 = MESSAGE PART n of m
	  *         1 = MESSAGE PART n
	  *         2 = SIGNED MESSAGE
	  *         3 = PGP MESSAGE
	  *         4 = PUBLIC KEY BLOCK
	  *         5 = PRIVATE KEY BLOCK
	  *         null = unknown
	  */
	 function openpgp_encoding_get_type(text) {
	 	var splittedtext = text.split('-----');
	 	// BEGIN PGP MESSAGE, PART X/Y
	 	// Used for multi-part messages, where the armor is split amongst Y
	 	// parts, and this is the Xth part out of Y.
	 	if (splittedtext[1].match(/BEGIN PGP MESSAGE, PART \d+\/\d+/)) {
	 		return 0;
	 	} else
	 		// BEGIN PGP MESSAGE, PART X
	 		// Used for multi-part messages, where this is the Xth part of an
	 		// unspecified number of parts. Requires the MESSAGE-ID Armor
	 		// Header to be used.
	 	if (splittedtext[1].match(/BEGIN PGP MESSAGE, PART \d+/)) {
	 		return 1;
	 
	 	} else
	 		// BEGIN PGP SIGNATURE
	 		// Used for detached signatures, OpenPGP/MIME signatures, and
	 		// cleartext signatures. Note that PGP 2.x uses BEGIN PGP MESSAGE
	 		// for detached signatures.
	 	if (splittedtext[1].match(/BEGIN PGP SIGNED MESSAGE/)) {
	 		return 2;
	 
	 	} else
	   	    // BEGIN PGP MESSAGE
	 	    // Used for signed, encrypted, or compressed files.
	 	if (splittedtext[1].match(/BEGIN PGP MESSAGE/)) {
	 		return 3;
	 
	 	} else
	 		// BEGIN PGP PUBLIC KEY BLOCK
	 		// Used for armoring public keys.
	 	if (splittedtext[1].match(/BEGIN PGP PUBLIC KEY BLOCK/)) {
	 		return 4;
	 
	 	} else
	 		// BEGIN PGP PRIVATE KEY BLOCK
	 		// Used for armoring private keys.
	 	if (splittedtext[1].match(/BEGIN PGP PRIVATE KEY BLOCK/)) {
	 		return 5;
	 	}
	 }
	 
	 /**
	  * Add additional information to the armor version of an OpenPGP binary
	  * packet block.
	  * @author  Alex
	  * @version 2011-12-16
	  * @returns {String} The header information
	  */
	 function openpgp_encoding_armor_addheader() {
	     var result = "";
	 	if (openpgp.config.config.show_version) {
	         result += "Version: "+openpgp.config.versionstring+'\r\n';
	     }
	 	if (openpgp.config.config.show_comment) {
	         result += "Comment: "+openpgp.config.commentstring+'\r\n';
	     }
	     result += '\r\n';
	     return result;
	 }
	 
	 /**
	  * Armor an OpenPGP binary packet block
	  * @param {Integer} messagetype type of the message
	  * @param data
	  * @param {Integer} partindex
	  * @param {Integer} parttotal
	  * @returns {String} Armored text
	  */
	 function openpgp_encoding_armor(messagetype, data, partindex, parttotal) {
	 	var result = "";
	 	switch(messagetype) {
	 	case 0:
	 		result += "-----BEGIN PGP MESSAGE, PART "+partindex+"/"+parttotal+"-----\r\n";
	 		result += openpgp_encoding_armor_addheader();
	 		result += openpgp_encoding_base64_encode(data);
	 		result += "\r\n="+getCheckSum(data)+"\r\n";
	 		result += "-----END PGP MESSAGE, PART "+partindex+"/"+parttotal+"-----\r\n";
	 		break;
	 	case 1:
	 		result += "-----BEGIN PGP MESSAGE, PART "+partindex+"-----\r\n";
	 		result += openpgp_encoding_armor_addheader();
	 		result += openpgp_encoding_base64_encode(data);
	 		result += "\r\n="+getCheckSum(data)+"\r\n";
	 		result += "-----END PGP MESSAGE, PART "+partindex+"-----\r\n";
	 		break;
	 	case 2:
	 		result += "\r\n-----BEGIN PGP SIGNED MESSAGE-----\r\nHash: "+data.hash+"\r\n\r\n";
	 		result += data.text.replace(/\n-/g,"\n- -");
	 		result += "\r\n-----BEGIN PGP SIGNATURE-----\r\n";
	 		result += openpgp_encoding_armor_addheader();
	 		result += openpgp_encoding_base64_encode(data.openpgp);
	 		result += "\r\n="+getCheckSum(data.openpgp)+"\r\n";
	 		result += "-----END PGP SIGNATURE-----\r\n";
	 		break;
	 	case 3:
	 		result += "-----BEGIN PGP MESSAGE-----\r\n";
	 		result += openpgp_encoding_armor_addheader();
	 		result += openpgp_encoding_base64_encode(data);
	 		result += "\r\n="+getCheckSum(data)+"\r\n";
	 		result += "-----END PGP MESSAGE-----\r\n";
	 		break;
	 	case 4:
	 		result += "-----BEGIN PGP PUBLIC KEY BLOCK-----\r\n";
	 		result += openpgp_encoding_armor_addheader();
	 		result += openpgp_encoding_base64_encode(data);
	 		result += "\r\n="+getCheckSum(data)+"\r\n";
	 		result += "-----END PGP PUBLIC KEY BLOCK-----\r\n\r\n";
	 		break;
	 	case 5:
	 		result += "-----BEGIN PGP PRIVATE KEY BLOCK-----\r\n";
	 		result += openpgp_encoding_armor_addheader();
	 		result += openpgp_encoding_base64_encode(data);
	 		result += "\r\n="+getCheckSum(data)+"\r\n";
	 		result += "-----END PGP PRIVATE KEY BLOCK-----\r\n";
	 		break;
	 	}
	 
	 	return result;
	 }
	 
	 /**
	  * Calculates a checksum over the given data and returns it base64 encoded
	  * @param {String} data Data to create a CRC-24 checksum for
	  * @return {String} Base64 encoded checksum
	  */
	 function getCheckSum(data) {
	 	var c = createcrc24(data);
	 	var str = "" + String.fromCharCode(c >> 16)+
	 				   String.fromCharCode((c >> 8) & 0xFF)+
	 				   String.fromCharCode(c & 0xFF);
	 	return openpgp_encoding_base64_encode(str);
	 }
	 
	 /**
	  * Calculates the checksum over the given data and compares it with the 
	  * given base64 encoded checksum
	  * @param {String} data Data to create a CRC-24 checksum for
	  * @param {String} checksum Base64 encoded checksum
	  * @return {Boolean} True if the given checksum is correct; otherwise false
	  */
	 function verifyCheckSum(data, checksum) {
	 	var c = getCheckSum(data);
	 	var d = checksum;
	 	return c[0] == d[0] && c[1] == d[1] && c[2] == d[2];
	 }
	 /**
	  * Internal function to calculate a CRC-24 checksum over a given string (data)
	  * @param {String} data Data to create a CRC-24 checksum for
	  * @return {Integer} The CRC-24 checksum as number
	  */
	 var crc_table = [
	 0x00000000, 0x00864cfb, 0x018ad50d, 0x010c99f6, 0x0393e6e1, 0x0315aa1a, 0x021933ec, 0x029f7f17, 0x07a18139, 0x0727cdc2, 0x062b5434, 0x06ad18cf, 0x043267d8, 0x04b42b23, 0x05b8b2d5, 0x053efe2e, 0x0fc54e89, 0x0f430272, 0x0e4f9b84, 0x0ec9d77f, 0x0c56a868, 0x0cd0e493, 0x0ddc7d65, 0x0d5a319e, 0x0864cfb0, 0x08e2834b, 0x09ee1abd, 0x09685646, 0x0bf72951, 0x0b7165aa, 0x0a7dfc5c, 0x0afbb0a7, 0x1f0cd1e9, 0x1f8a9d12, 0x1e8604e4, 0x1e00481f, 0x1c9f3708, 0x1c197bf3, 0x1d15e205, 0x1d93aefe, 0x18ad50d0, 0x182b1c2b, 0x192785dd, 0x19a1c926, 0x1b3eb631, 0x1bb8faca, 0x1ab4633c, 0x1a322fc7, 0x10c99f60, 0x104fd39b, 0x11434a6d, 0x11c50696, 0x135a7981, 0x13dc357a, 0x12d0ac8c, 0x1256e077, 0x17681e59, 0x17ee52a2, 0x16e2cb54, 0x166487af, 0x14fbf8b8, 0x147db443, 0x15712db5, 0x15f7614e, 0x3e19a3d2, 0x3e9fef29, 0x3f9376df, 0x3f153a24, 0x3d8a4533, 0x3d0c09c8, 0x3c00903e, 0x3c86dcc5, 0x39b822eb, 0x393e6e10, 0x3832f7e6, 0x38b4bb1d, 0x3a2bc40a, 0x3aad88f1, 0x3ba11107, 0x3b275dfc, 0x31dced5b, 0x315aa1a0,
	 0x30563856, 0x30d074ad, 0x324f0bba, 0x32c94741, 0x33c5deb7, 0x3343924c, 0x367d6c62, 0x36fb2099, 0x37f7b96f, 0x3771f594, 0x35ee8a83, 0x3568c678, 0x34645f8e, 0x34e21375, 0x2115723b, 0x21933ec0, 0x209fa736, 0x2019ebcd, 0x228694da, 0x2200d821, 0x230c41d7, 0x238a0d2c, 0x26b4f302, 0x2632bff9, 0x273e260f, 0x27b86af4, 0x252715e3, 0x25a15918, 0x24adc0ee, 0x242b8c15, 0x2ed03cb2, 0x2e567049, 0x2f5ae9bf, 0x2fdca544, 0x2d43da53, 0x2dc596a8, 0x2cc90f5e, 0x2c4f43a5, 0x2971bd8b, 0x29f7f170, 0x28fb6886, 0x287d247d, 0x2ae25b6a, 0x2a641791, 0x2b688e67, 0x2beec29c, 0x7c3347a4, 0x7cb50b5f, 0x7db992a9, 0x7d3fde52, 0x7fa0a145, 0x7f26edbe, 0x7e2a7448, 0x7eac38b3, 0x7b92c69d, 0x7b148a66, 0x7a181390, 0x7a9e5f6b, 0x7801207c, 0x78876c87, 0x798bf571, 0x790db98a, 0x73f6092d, 0x737045d6, 0x727cdc20, 0x72fa90db, 0x7065efcc, 0x70e3a337, 0x71ef3ac1, 0x7169763a, 0x74578814, 0x74d1c4ef, 0x75dd5d19, 0x755b11e2, 0x77c46ef5, 0x7742220e, 0x764ebbf8, 0x76c8f703, 0x633f964d, 0x63b9dab6, 0x62b54340, 0x62330fbb,
	 0x60ac70ac, 0x602a3c57, 0x6126a5a1, 0x61a0e95a, 0x649e1774, 0x64185b8f, 0x6514c279, 0x65928e82, 0x670df195, 0x678bbd6e, 0x66872498, 0x66016863, 0x6cfad8c4, 0x6c7c943f, 0x6d700dc9, 0x6df64132, 0x6f693e25, 0x6fef72de, 0x6ee3eb28, 0x6e65a7d3, 0x6b5b59fd, 0x6bdd1506, 0x6ad18cf0, 0x6a57c00b, 0x68c8bf1c, 0x684ef3e7, 0x69426a11, 0x69c426ea, 0x422ae476, 0x42aca88d, 0x43a0317b, 0x43267d80, 0x41b90297, 0x413f4e6c, 0x4033d79a, 0x40b59b61, 0x458b654f, 0x450d29b4, 0x4401b042, 0x4487fcb9, 0x461883ae, 0x469ecf55, 0x479256a3, 0x47141a58, 0x4defaaff, 0x4d69e604, 0x4c657ff2, 0x4ce33309, 0x4e7c4c1e, 0x4efa00e5, 0x4ff69913, 0x4f70d5e8, 0x4a4e2bc6, 0x4ac8673d, 0x4bc4fecb, 0x4b42b230, 0x49ddcd27, 0x495b81dc, 0x4857182a, 0x48d154d1, 0x5d26359f, 0x5da07964, 0x5cace092, 0x5c2aac69, 0x5eb5d37e, 0x5e339f85, 0x5f3f0673, 0x5fb94a88, 0x5a87b4a6, 0x5a01f85d, 0x5b0d61ab, 0x5b8b2d50, 0x59145247, 0x59921ebc, 0x589e874a, 0x5818cbb1, 0x52e37b16, 0x526537ed, 0x5369ae1b, 0x53efe2e0, 0x51709df7, 0x51f6d10c,
	 0x50fa48fa, 0x507c0401, 0x5542fa2f, 0x55c4b6d4, 0x54c82f22, 0x544e63d9, 0x56d11cce, 0x56575035, 0x575bc9c3, 0x57dd8538];
	 
	 function createcrc24(input) {
	   var crc = 0xB704CE;
	   var index = 0;
	 
	   while((input.length - index) > 16)  {
	    crc = (crc << 8) ^ crc_table[((crc >> 16) ^ input.charCodeAt(index)) & 0xff];
	    crc = (crc << 8) ^ crc_table[((crc >> 16) ^ input.charCodeAt(index+1)) & 0xff];
	    crc = (crc << 8) ^ crc_table[((crc >> 16) ^ input.charCodeAt(index+2)) & 0xff];
	    crc = (crc << 8) ^ crc_table[((crc >> 16) ^ input.charCodeAt(index+3)) & 0xff];
	    crc = (crc << 8) ^ crc_table[((crc >> 16) ^ input.charCodeAt(index+4)) & 0xff];
	    crc = (crc << 8) ^ crc_table[((crc >> 16) ^ input.charCodeAt(index+5)) & 0xff];
	    crc = (crc << 8) ^ crc_table[((crc >> 16) ^ input.charCodeAt(index+6)) & 0xff];
	    crc = (crc << 8) ^ crc_table[((crc >> 16) ^ input.charCodeAt(index+7)) & 0xff];
	    crc = (crc << 8) ^ crc_table[((crc >> 16) ^ input.charCodeAt(index+8)) & 0xff];
	    crc = (crc << 8) ^ crc_table[((crc >> 16) ^ input.charCodeAt(index+9)) & 0xff];
	    crc = (crc << 8) ^ crc_table[((crc >> 16) ^ input.charCodeAt(index+10)) & 0xff];
	    crc = (crc << 8) ^ crc_table[((crc >> 16) ^ input.charCodeAt(index+11)) & 0xff];
	    crc = (crc << 8) ^ crc_table[((crc >> 16) ^ input.charCodeAt(index+12)) & 0xff];
	    crc = (crc << 8) ^ crc_table[((crc >> 16) ^ input.charCodeAt(index+13)) & 0xff];
	    crc = (crc << 8) ^ crc_table[((crc >> 16) ^ input.charCodeAt(index+14)) & 0xff];
	    crc = (crc << 8) ^ crc_table[((crc >> 16) ^ input.charCodeAt(index+15)) & 0xff];
	    index += 16;
	   }
	 
	   for(var j = index; j < input.length; j++) {
	    crc = (crc << 8) ^ crc_table[((crc >> 16) ^ input.charCodeAt(index++)) & 0xff]
	   }
	   return crc & 0xffffff;
	 }
	 
	 // GPG4Browsers - An OpenPGP implementation in javascript
	 // Copyright (C) 2011 Recurity Labs GmbH
	 // 
	 // This library is free software; you can redistribute it and/or
	 // modify it under the terms of the GNU Lesser General Public
	 // License as published by the Free Software Foundation; either
	 // version 2.1 of the License, or (at your option) any later version.
	 // 
	 // This library is distributed in the hope that it will be useful,
	 // but WITHOUT ANY WARRANTY; without even the implied warranty of
	 // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
	 // Lesser General Public License for more details.
	 // 
	 // You should have received a copy of the GNU Lesser General Public
	 // License along with this library; if not, write to the Free Software
	 // Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
	 
	 /**
	  * Wrapper function for the base64 codec. 
	  * This function encodes a String (message) in base64 (radix-64)
	  * @param {String} message The message to encode
	  * @return {String} The base64 encoded data
	  */
	 function openpgp_encoding_base64_encode(message) {
	 	return s2r(message);
	 }
	 
	 
	 /**
	  * Wrapper function for the base64 codec.
	  * This function decodes a String(message) in base64 (radix-64)
	  * @param {String} message Base64 encoded data
	  * @return {String} Raw data after decoding
	  */
	 function openpgp_encoding_base64_decode(message) {
	 	return r2s(message);
	 }
	 
	 /**
	  * Wrapper function for jquery library.
	  * This function escapes HTML characters within a string. This is used 
	  * to prevent XSS.
	  * @param {String} message Message to escape
	  * @return {String} Html encoded string
	  */
	 function openpgp_encoding_html_encode(message) {
	 	return compat.html_encode(message);
	 }
	 
	 /**
	  * create a EME-PKCS1-v1_5 padding (See RFC4880 13.1.1)
	  * @param {String} message message to be padded
	  * @param {Integer} length Length to the resulting message
	  * @return {String} EME-PKCS1 padded message
	  */
	 function openpgp_encoding_eme_pkcs1_encode(message, length) {
	 	if (message.length > length-11)
	 		return -1;
	 	var result = "";
	 	result += String.fromCharCode(0);
	 	result += String.fromCharCode(2);
	 	for (var i = 0; i < length - message.length - 3; i++) {
	 		result += String.fromCharCode(openpgp_crypto_getPseudoRandom(1,255));
	 	}
	 	result += String.fromCharCode(0);
	 	result += message;
	 	return result;
	 }
	 
	 /**
	  * decodes a EME-PKCS1-v1_5 padding (See RFC4880 13.1.2)
	  * @param {String} message EME-PKCS1 padded message
	  * @return {String} decoded message 
	  */
	 function openpgp_encoding_eme_pkcs1_decode(message, len) {
	 	if (message.length < len)
	 	    message = String.fromCharCode(0)+message;
	 	if (message.length < 12 || message.charCodeAt(0) != 0 || message.charCodeAt(1) != 2)
	 		return -1;
	 	var i = 2;
	 	while (message.charCodeAt(i) != 0 && message.length > i)
	 	    i++;
	 	return message.substring(i+1, message.length);
	 }
	 /**
	  * ASN1 object identifiers for hashes (See RFC4880 5.2.2)
	  */
	 hash_headers = new Array();
	 hash_headers[1]  = [0x30,0x20,0x30,0x0c,0x06,0x08,0x2a,0x86,0x48,0x86,0xf7,0x0d,0x02,0x05,0x05,0x00,0x04,0x10];
	 hash_headers[3]  = [0x30,0x21,0x30,0x09,0x06,0x05,0x2B,0x24,0x03,0x02,0x01,0x05,0x00,0x04,0x14];
	 hash_headers[2]  = [0x30,0x21,0x30,0x09,0x06,0x05,0x2b,0x0e,0x03,0x02,0x1a,0x05,0x00,0x04,0x14];
	 hash_headers[8]  = [0x30,0x31,0x30,0x0d,0x06,0x09,0x60,0x86,0x48,0x01,0x65,0x03,0x04,0x02,0x01,0x05,0x00,0x04,0x20];
	 hash_headers[9]  = [0x30,0x41,0x30,0x0d,0x06,0x09,0x60,0x86,0x48,0x01,0x65,0x03,0x04,0x02,0x02,0x05,0x00,0x04,0x30];
	 hash_headers[10] = [0x30,0x51,0x30,0x0d,0x06,0x09,0x60,0x86,0x48,0x01,0x65,0x03,0x04,0x02,0x03,0x05,0x00,0x04,0x40];
	 hash_headers[11] = [0x30,0x31,0x30,0x0d,0x06,0x09,0x60,0x86,0x48,0x01,0x65,0x03,0x04,0x02,0x04,0x05,0x00,0x04,0x1C];
	 
	 /**
	  * create a EMSA-PKCS1-v1_5 padding (See RFC4880 13.1.3)
	  * @param {Integer} algo Hash algorithm type used
	  * @param {String} data Data to be hashed
	  * @param {Integer} keylength Key size of the public mpi in bytes
	  * @returns {String} Hashcode with pkcs1padding as string
	  */
	 function openpgp_encoding_emsa_pkcs1_encode(algo, data, keylength) {
	 	var data2 = "";
	 	data2 += String.fromCharCode(0x00);
	 	data2 += String.fromCharCode(0x01);
	 	for (var i = 0; i < (keylength - hash_headers[algo].length - 3 - openpgp_crypto_getHashByteLength(algo)); i++)
	 		data2 += String.fromCharCode(0xff);
	 	data2 += String.fromCharCode(0x00);
	 	
	 	for (var i = 0; i < hash_headers[algo].length; i++)
	 		data2 += String.fromCharCode(hash_headers[algo][i]);
	 	
	 	data2 += openpgp_crypto_hashData(algo, data);
	 	return new BigInteger(util.hexstrdump(data2),16);
	 }
	 
	 /**
	  * extract the hash out of an EMSA-PKCS1-v1.5 padding (See RFC4880 13.1.3) 
	  * @param {String} data Hash in pkcs1 encoding
	  * @returns {String} The hash as string
	  */
	 function openpgp_encoding_emsa_pkcs1_decode(algo, data) { 
	 	var i = 0;
	 	if (data.charCodeAt(0) == 0) i++;
	 	else if (data.charCodeAt(0) != 1) return -1;
	 	else i++;
	 
	 	while (data.charCodeAt(i) == 0xFF) i++;
	 	if (data.charCodeAt(i++) != 0) return -1;
	 	var j = 0;
	 	for (j = 0; j < hash_headers[algo].length && j+i < data.length; j++) {
	 		if (data.charCodeAt(j+i) != hash_headers[algo][j]) return -1;
	 	}
	 	i+= j;	
	 	if (data.substring(i).length < openpgp_crypto_getHashByteLength(algo)) return -1;
	 	return data.substring(i);
	 }
	 // GPG4Browsers - An OpenPGP implementation in javascript
	 // Copyright (C) 2011 Recurity Labs GmbH
	 // 
	 // This library is free software; you can redistribute it and/or
	 // modify it under the terms of the GNU Lesser General Public
	 // License as published by the Free Software Foundation; either
	 // version 2.1 of the License, or (at your option) any later version.
	 // 
	 // This library is distributed in the hope that it will be useful,
	 // but WITHOUT ANY WARRANTY; without even the implied warranty of
	 // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
	 // Lesser General Public License for more details.
	 // 
	 // You should have received a copy of the GNU Lesser General Public
	 // License along with this library; if not, write to the Free Software
	 // Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
	 
	 /**
	  * @fileoverview The openpgp base class should provide all of the functionality 
	  * to consume the openpgp.js library. All additional classes are documented 
	  * for extending and developing on top of the base library.
	  */
	 
	 /**
	  * GPG4Browsers Core interface. A single instance is hold
	  * from the beginning. To use this library call "openpgp.init()"
	  * @alias openpgp
	  * @class
	  * @classdesc Main Openpgp.js class. Use this to initiate and make all calls to this library.
	  */
	 function _openpgp () {
	 	this.tostring = "";
	 	
	 	/**
	 	 * initializes the library:
	 	 * - reading the keyring from local storage
	 	 * - reading the config from local storage
	 	 */
	 	function init() {
	 		this.config = new openpgp_config();
	 		this.config.read();
	 		this.keyring = new openpgp_keyring();
	 		this.keyring.init();
	 	}
	 	
	 	/**
	 	 * reads several publicKey objects from a ascii armored
	 	 * representation an returns openpgp_msg_publickey packets
	 	 * @param {String} armoredText OpenPGP armored text containing
	 	 * the public key(s)
	 	 * @return {openpgp_msg_publickey[]} on error the function
	 	 * returns null
	 	 */
	 	function read_publicKey(armoredText) {
	 		var mypos = 0;
	 		var publicKeys = new Array();
	 		var publicKeyCount = 0;
	 		var input = openpgp_encoding_deArmor(armoredText.replace(/\r/g,'')).openpgp;
	 		var l = input.length;
	 		while (mypos != input.length) {
	 			var first_packet = openpgp_packet.read_packet(input, mypos, l);
	 			// public key parser
	 			if (input[mypos].charCodeAt() == 0x99 || first_packet.tagType == 6) {
	 				publicKeys[publicKeyCount] = new openpgp_msg_publickey();				
	 				publicKeys[publicKeyCount].header = input.substring(mypos,mypos+3);
	 				if (input[mypos].charCodeAt() == 0x99) {
	 					// parse the length and read a tag6 packet
	 					mypos++;
	 					var l = (input[mypos++].charCodeAt() << 8)
	 							| input[mypos++].charCodeAt();
	 					publicKeys[publicKeyCount].publicKeyPacket = new openpgp_packet_keymaterial();
	 					publicKeys[publicKeyCount].publicKeyPacket.header = publicKeys[publicKeyCount].header;
	 					publicKeys[publicKeyCount].publicKeyPacket.read_tag6(input, mypos, l);
	 					mypos += publicKeys[publicKeyCount].publicKeyPacket.packetLength;
	 					mypos += publicKeys[publicKeyCount].read_nodes(publicKeys[publicKeyCount].publicKeyPacket, input, mypos, (input.length - mypos));
	 				} else {
	 					publicKeys[publicKeyCount] = new openpgp_msg_publickey();
	 					publicKeys[publicKeyCount].publicKeyPacket = first_packet;
	 					mypos += first_packet.headerLength+first_packet.packetLength;
	 					mypos += publicKeys[publicKeyCount].read_nodes(first_packet, input, mypos, input.length -mypos);
	 				}
	 			} else {
	 				util.print_error("no public key found!");
	 				return null;
	 			}
	 			publicKeys[publicKeyCount].data = input.substring(0,mypos);
	 			publicKeyCount++;
	 		}
	 		return publicKeys;
	 	}
	 	
	 	/**
	 	 * reads several privateKey objects from a ascii armored
	 	 * representation an returns openpgp_msg_privatekey objects
	 	 * @param {String} armoredText OpenPGP armored text containing
	 	 * the private key(s)
	 	 * @return {openpgp_msg_privatekey[]} on error the function
	 	 * returns null
	 	 */
	 	function read_privateKey(armoredText) {
	 		var privateKeys = new Array();
	 		var privateKeyCount = 0;
	 		var mypos = 0;
	 		var input = openpgp_encoding_deArmor(armoredText.replace(/\r/g,'')).openpgp;
	 		var l = input.length;
	 		while (mypos != input.length) {
	 			var first_packet = openpgp_packet.read_packet(input, mypos, l);
	 			if (first_packet.tagType == 5) {
	 				privateKeys[privateKeys.length] = new openpgp_msg_privatekey();
	 				mypos += first_packet.headerLength+first_packet.packetLength;
	 				mypos += privateKeys[privateKeyCount].read_nodes(first_packet, input, mypos, l);
	 			// other blocks	            
	 			} else {
	 				util.print_error('no block packet found!');
	 				return null;
	 			}
	 			privateKeys[privateKeyCount].data = input.substring(0,mypos);
	 			privateKeyCount++;
	 		}
	 		return privateKeys;		
	 	}
	 
	 	/**
	 	 * reads message packets out of an OpenPGP armored text and
	 	 * returns an array of message objects
	 	 * @param {String} armoredText text to be parsed
	 	 * @return {openpgp_msg_message[]} on error the function
	 	 * returns null
	 	 */
	 	function read_message(armoredText) {
	 		var dearmored;
	 		try{
	     		dearmored = openpgp_encoding_deArmor(armoredText.replace(/\r/g,''));
	 		}
	 		catch(e){
	     		util.print_error('no message found!');
	     		return null;
	 		}
	 		return read_messages_dearmored(dearmored);
	 		}
	 		
	 	/**
	 	 * reads message packets out of an OpenPGP armored text and
	 	 * returns an array of message objects. Can be called externally or internally.
	 	 * External call will parse a de-armored messaged and return messages found.
	 	 * Internal will be called to read packets wrapped in other packets (i.e. compressed)
	 	 * @param {String} input dearmored text of OpenPGP packets, to be parsed
	 	 * @return {openpgp_msg_message[]} on error the function
	 	 * returns null
	 	 */
	 	function read_messages_dearmored(input){
	 		var messageString = input.openpgp;
	 		var signatureText = input.text; //text to verify signatures against. Modified by Tag11.
	 		var messages = new Array();
	 		var messageCount = 0;
	 		var mypos = 0;
	 		var l = messageString.length;
	 		while (mypos < messageString.length) {
	 			var first_packet = openpgp_packet.read_packet(messageString, mypos, l);
	 			if (!first_packet) {
	 				break;
	 			}
	 			// public key parser (definition from the standard:)
	 			// OpenPGP Message      :- Encrypted Message | Signed Message |
	 			//                         Compressed Message | Literal Message.
	 			// Compressed Message   :- Compressed Data Packet.
	 			// 
	 			// Literal Message      :- Literal Data Packet.
	 			// 
	 			// ESK                  :- Public-Key Encrypted Session Key Packet |
	 			//                         Symmetric-Key Encrypted Session Key Packet.
	 			// 
	 			// ESK Sequence         :- ESK | ESK Sequence, ESK.
	 			// 
	 			// Encrypted Data       :- Symmetrically Encrypted Data Packet |
	 			//                         Symmetrically Encrypted Integrity Protected Data Packet
	 			// 
	 			// Encrypted Message    :- Encrypted Data | ESK Sequence, Encrypted Data.
	 			// 
	 			// One-Pass Signed Message :- One-Pass Signature Packet,
	 			//                         OpenPGP Message, Corresponding Signature Packet.
	 
	 			// Signed Message       :- Signature Packet, OpenPGP Message |
	 			//                         One-Pass Signed Message.
	 			if (first_packet.tagType ==  1 ||
	 			    (first_packet.tagType == 2 && first_packet.signatureType < 16) ||
	 			     first_packet.tagType ==  3 ||
	 			     first_packet.tagType ==  4 ||
	 				 first_packet.tagType ==  8 ||
	 				 first_packet.tagType ==  9 ||
	 				 first_packet.tagType == 10 ||
	 				 first_packet.tagType == 11 ||
	 				 first_packet.tagType == 18 ||
	 				 first_packet.tagType == 19) {
	 				messages[messages.length] = new openpgp_msg_message();
	 				messages[messageCount].messagePacket = first_packet;
	 				messages[messageCount].type = input.type;
	 				// Encrypted Message
	 				if (first_packet.tagType == 9 ||
	 				    first_packet.tagType == 1 ||
	 				    first_packet.tagType == 3 ||
	 				    first_packet.tagType == 18) {
	 					if (first_packet.tagType == 9) {
	 						util.print_error("unexpected openpgp packet");
	 						break;
	 					} else if (first_packet.tagType == 1) {
	 						util.print_debug("session key found:\n "+first_packet.toString());
	 						var issessionkey = true;
	 						messages[messageCount].sessionKeys = new Array();
	 						var sessionKeyCount = 0;
	 						while (issessionkey) {
	 							messages[messageCount].sessionKeys[sessionKeyCount] = first_packet;
	 							mypos += first_packet.packetLength + first_packet.headerLength;
	 							l -= (first_packet.packetLength + first_packet.headerLength);
	 							first_packet = openpgp_packet.read_packet(messageString, mypos, l);
	 							
	 							if (first_packet.tagType != 1 && first_packet.tagType != 3)
	 								issessionkey = false;
	 							sessionKeyCount++;
	 						}
	 						if (first_packet.tagType == 18 || first_packet.tagType == 9) {
	 							util.print_debug("encrypted data found:\n "+first_packet.toString());
	 							messages[messageCount].encryptedData = first_packet;
	 							mypos += first_packet.packetLength+first_packet.headerLength;
	 							l -= (first_packet.packetLength+first_packet.headerLength);
	 							messageCount++;
	 							
	 						} else {
	 							util.print_debug("something is wrong: "+first_packet.tagType);
	 						}
	 						
	 					} else if (first_packet.tagType == 18) {
	 						util.print_debug("symmetric encrypted data");
	 						break;
	 					}
	 				} else 
	 					if (first_packet.tagType == 2 && first_packet.signatureType < 3) {
	 					// Signed Message
	 						mypos += first_packet.packetLength + first_packet.headerLength;
	 						l -= (first_packet.packetLength + first_packet.headerLength);
	 						messages[messageCount].text = signatureText;
	 						messages[messageCount].signature = first_packet;
	 				        messageCount++;
	 				} else 
	 					// Signed Message
	 					if (first_packet.tagType == 4) {
	 						//TODO: Implement check
	 						mypos += first_packet.packetLength + first_packet.headerLength;
	 						l -= (first_packet.packetLength + first_packet.headerLength);
	 				} else 
	 					if (first_packet.tagType == 8) {
	 					// Compressed Message
	 						mypos += first_packet.packetLength + first_packet.headerLength;
	 						l -= (first_packet.packetLength + first_packet.headerLength);
	 				        var decompressedText = first_packet.decompress();
	 				        messages = messages.concat(openpgp.read_messages_dearmored({text: decompressedText, openpgp: decompressedText}));
	 				} else
	 					// Marker Packet (Obsolete Literal Packet) (Tag 10)
	 					// "Such a packet MUST be ignored when received." see http://tools.ietf.org/html/rfc4880#section-5.8
	 					if (first_packet.tagType == 10) {
	 						// reset messages
	 						messages.length = 0;
	 						// continue with next packet
	 						mypos += first_packet.packetLength + first_packet.headerLength;
	 						l -= (first_packet.packetLength + first_packet.headerLength);
	 				} else 
	 					if (first_packet.tagType == 11) {
	 					// Literal Message -- work is already done in read_packet
	 					mypos += first_packet.packetLength + first_packet.headerLength;
	 					l -= (first_packet.packetLength + first_packet.headerLength);
	 					signatureText = first_packet.data;
	 					messages[messageCount].data = first_packet.data;
	 					messageCount++;
	 				} else 
	 					if (first_packet.tagType == 19) {
	 					// Modification Detect Code
	 						mypos += first_packet.packetLength + first_packet.headerLength;
	 						l -= (first_packet.packetLength + first_packet.headerLength);
	 				}
	 			} else {
	 				util.print_error('no message found!');
	 				return null;
	 			}
	 		}
	 		
	 		return messages;
	 	}
	 	
	 	/**
	 	 * creates a binary string representation of an encrypted and signed message.
	 	 * The message will be encrypted with the public keys specified and signed
	 	 * with the specified private key.
	 	 * @param {Object} privatekey {obj: [openpgp_msg_privatekey]} Private key 
	 	 * to be used to sign the message
	 	 * @param {Object[]} publickeys An arraf of {obj: [openpgp_msg_publickey]}
	 	 * - public keys to be used to encrypt the message 
	 	 * @param {String} messagetext message text to encrypt and sign
	 	 * @return {String} a binary string representation of the message which 
	 	 * can be OpenPGP armored
	 	 */
	 	function write_signed_and_encrypted_message(privatekey, publickeys, messagetext) {
	 		var result = "";
	 		var literal = new openpgp_packet_literaldata().write_packet(messagetext.replace(/\r\n/g,"\n").replace(/\n/g,"\r\n"));
	 		util.print_debug_hexstr_dump("literal_packet: |"+literal+"|\n",literal);
	 		for (var i = 0; i < publickeys.length; i++) {
	 			var onepasssignature = new openpgp_packet_onepasssignature();
	 			var onepasssigstr = "";
	 			if (i == 0)
	 				onepasssigstr = onepasssignature.write_packet(1, openpgp.config.config.prefer_hash_algorithm,  privatekey, false);
	 			else
	 				onepasssigstr = onepasssignature.write_packet(1, openpgp.config.config.prefer_hash_algorithm,  privatekey, false);
	 			util.print_debug_hexstr_dump("onepasssigstr: |"+onepasssigstr+"|\n",onepasssigstr);
	 			var datasignature = new openpgp_packet_signature().write_message_signature(1, messagetext.replace(/\r\n/g,"\n").replace(/\n/g,"\r\n"), privatekey);
	 			util.print_debug_hexstr_dump("datasignature: |"+datasignature.openpgp+"|\n",datasignature.openpgp);
	 			if (i == 0) {
	 				result = onepasssigstr+literal+datasignature.openpgp;
	 			} else {
	 				result = onepasssigstr+result+datasignature.openpgp;
	 			}
	 		}
	 		
	 		util.print_debug_hexstr_dump("signed packet: |"+result+"|\n",result);
	 		// signatures done.. now encryption
	 		var sessionkey = openpgp_crypto_generateSessionKey(openpgp.config.config.encryption_cipher); 
	 		var result2 = "";
	 		
	 		// creating session keys for each recipient
	 		for (var i = 0; i < publickeys.length; i++) {
	 			var pkey = publickeys[i].getEncryptionKey();
	 			if (pkey == null) {
	 				util.print_error("no encryption key found! Key is for signing only.");
	 				return null;
	 			}
	 			result2 += new openpgp_packet_encryptedsessionkey().
	 					write_pub_key_packet(
	 						pkey.getKeyId(),
	 						pkey.MPIs,
	 						pkey.publicKeyAlgorithm,
	 						openpgp.config.config.encryption_cipher,
	 						sessionkey);
	 		}
	 		if (openpgp.config.config.integrity_protect) {
	 			result2 += new openpgp_packet_encryptedintegrityprotecteddata().write_packet(openpgp.config.config.encryption_cipher, sessionkey, result);
	 		} else {
	 			result2 += new openpgp_packet_encrypteddata().write_packet(openpgp.config.config.encryption_cipher, sessionkey, result);
	 		}
	 		return openpgp_encoding_armor(3,result2,null,null);
	 	}
	 	/**
	 	 * creates a binary string representation of an encrypted message.
	 	 * The message will be encrypted with the public keys specified 
	 	 * @param {Object[]} publickeys An array of {obj: [openpgp_msg_publickey]}
	 	 * -public keys to be used to encrypt the message 
	 	 * @param {String} messagetext message text to encrypt
	 	 * @return {String} a binary string representation of the message
	 	 * which can be OpenPGP armored
	 	 */
	 	function write_encrypted_message(publickeys, messagetext) {
	 		var result = "";
	 		var literal = new openpgp_packet_literaldata().write_packet(messagetext.replace(/\r\n/g,"\n").replace(/\n/g,"\r\n"));
	 		util.print_debug_hexstr_dump("literal_packet: |"+literal+"|\n",literal);
	 		result = literal;
	 		
	 		// signatures done.. now encryption
	 		var sessionkey = openpgp_crypto_generateSessionKey(openpgp.config.config.encryption_cipher); 
	 		var result2 = "";
	 		
	 		// creating session keys for each recipient
	 		for (var i = 0; i < publickeys.length; i++) {
	 			var pkey = publickeys[i].getEncryptionKey();
	 			if (pkey == null) {
	 				util.print_error("no encryption key found! Key is for signing only.");
	 				return null;
	 			}
	 			result2 += new openpgp_packet_encryptedsessionkey().
	 					write_pub_key_packet(
	 						pkey.getKeyId(),
	 						pkey.MPIs,
	 						pkey.publicKeyAlgorithm,
	 						openpgp.config.config.encryption_cipher,
	 						sessionkey);
	 		}
	 		if (openpgp.config.config.integrity_protect) {
	 			result2 += new openpgp_packet_encryptedintegrityprotecteddata().write_packet(openpgp.config.config.encryption_cipher, sessionkey, result);
	 		} else {
	 			result2 += new openpgp_packet_encrypteddata().write_packet(openpgp.config.config.encryption_cipher, sessionkey, result);
	 		}
	 		return openpgp_encoding_armor(3,result2,null,null);
	 	}
	 	
	 	/**
	 	 * creates a binary string representation a signed message.
	 	 * The message will be signed with the specified private key.
	 	 * @param {Object} privatekey {obj: [openpgp_msg_privatekey]}
	 	 * - the private key to be used to sign the message 
	 	 * @param {String} messagetext message text to sign
	 	 * @return {Object} {Object: text [String]}, openpgp: {String} a binary
	 	 *  string representation of the message which can be OpenPGP
	 	 *   armored(openpgp) and a text representation of the message (text). 
	 	 * This can be directly used to OpenPGP armor the message
	 	 */
	 	function write_signed_message(privatekey, messagetext) {
	 		var sig = new openpgp_packet_signature().write_message_signature(1, messagetext.replace(/\r\n/g,"\n").replace(/\n/,"\r\n"), privatekey);
	 		var result = {text: messagetext.replace(/\r\n/g,"\n").replace(/\n/,"\r\n"), openpgp: sig.openpgp, hash: sig.hash};
	 		return openpgp_encoding_armor(2,result, null, null)
	 	}
	 	
	 	/**
	 	 * generates a new key pair for openpgp. Beta stage. Currently only 
	 	 * supports RSA keys, and no subkeys.
	 	 * @param {Integer} keyType to indicate what type of key to make. 
	 	 * RSA is 1. Follows algorithms outlined in OpenPGP.
	 	 * @param {Integer} numBits number of bits for the key creation. (should 
	 	 * be 1024+, generally)
	 	 * @param {String} userId assumes already in form of "User Name 
	 	 * <username@email.com>"
	 	 * @param {String} passphrase The passphrase used to encrypt the resulting private key
	 	 * @return {Object} {privateKey: [openpgp_msg_privatekey], 
	 	 * privateKeyArmored: [string], publicKeyArmored: [string]}
	 	 */
	 	function generate_key_pair(keyType, numBits, userId, passphrase){
	 		var userIdPacket = new openpgp_packet_userid();
	 		var userIdString = userIdPacket.write_packet(userId);
	 		
	 		var keyPair = openpgp_crypto_generateKeyPair(keyType,numBits, passphrase, openpgp.config.config.prefer_hash_algorithm, 3);
	 		var privKeyString = keyPair.privateKey;
	 		var privKeyPacket = new openpgp_packet_keymaterial().read_priv_key(privKeyString.string,3,privKeyString.string.length);
	 		if(!privKeyPacket.decryptSecretMPIs(passphrase))
	 		    util.print_error('Issue creating key. Unable to read resulting private key');
	 		var privKey = new openpgp_msg_privatekey();
	 		privKey.privateKeyPacket = privKeyPacket;
	 		privKey.getPreferredSignatureHashAlgorithm = function(){return openpgp.config.config.prefer_hash_algorithm};//need to override this to solve catch 22 to generate signature. 8 is value for SHA256
	 		
	 		var publicKeyString = privKey.privateKeyPacket.publicKey.data;
	 		userId = util.encode_utf8(userId); // needs same encoding as in userIdString
	 		var hashData = String.fromCharCode(0x99)+ String.fromCharCode(((publicKeyString.length) >> 8) & 0xFF) 
	 			+ String.fromCharCode((publicKeyString.length) & 0xFF) +publicKeyString+String.fromCharCode(0xB4) +
	 			String.fromCharCode((userId.length) >> 24) +String.fromCharCode(((userId.length) >> 16) & 0xFF) 
	 			+ String.fromCharCode(((userId.length) >> 8) & 0xFF) + String.fromCharCode((userId.length) & 0xFF) + userId
	 		var signature = new openpgp_packet_signature();
	 		signature = signature.write_message_signature(16,hashData, privKey);
	 		var publicArmored = openpgp_encoding_armor(4, keyPair.publicKey.string + userIdString + signature.openpgp );
	 
	 		var privArmored = openpgp_encoding_armor(5,privKeyString.string+userIdString+signature.openpgp);
	 		
	 		return {privateKey : privKey, privateKeyArmored: privArmored, publicKeyArmored: publicArmored}
	 	}
	 	
	 	this.generate_key_pair = generate_key_pair;
	 	this.write_signed_message = write_signed_message; 
	 	this.write_signed_and_encrypted_message = write_signed_and_encrypted_message;
	 	this.write_encrypted_message = write_encrypted_message;
	 	this.read_message = read_message;
	 	this.read_messages_dearmored = read_messages_dearmored;
	 	this.read_publicKey = read_publicKey;
	 	this.read_privateKey = read_privateKey;
	 	this.init = init;
	 }
	 
	 var openpgp = new _openpgp();
	 
	 
	 // GPG4Browsers - An OpenPGP implementation in javascript
	 // Copyright (C) 2011 Recurity Labs GmbH
	 // 
	 // This library is free software; you can redistribute it and/or
	 // modify it under the terms of the GNU Lesser General Public
	 // License as published by the Free Software Foundation; either
	 // version 2.1 of the License, or (at your option) any later version.
	 // 
	 // This library is distributed in the hope that it will be useful,
	 // but WITHOUT ANY WARRANTY; without even the implied warranty of
	 // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
	 // Lesser General Public License for more details.
	 // 
	 // You should have received a copy of the GNU Lesser General Public
	 // License along with this library; if not, write to the Free Software
	 // Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
	 
	 /**
	  * @class
	  * @classdesc The class that deals with storage of the keyring. Currently the only option is to use HTML5 local storage.
	  */
	 function openpgp_keyring() {
	 		
	 	/**
	 	 * Initialization routine for the keyring. This method reads the 
	 	 * keyring from HTML5 local storage and initializes this instance.
	 	 * This method is called by openpgp.init().
	 	 */
	 	function init() {
	 		var sprivatekeys = JSON.parse(compat.local_storage_get("privatekeys"));
	 		var spublickeys = JSON.parse(compat.local_storage_get("publickeys"));
	 		if (sprivatekeys == null || sprivatekeys.length == 0) {
	 			sprivatekeys = new Array();
	 		}
	 
	 		if (spublickeys == null || spublickeys.length == 0) {
	 			spublickeys = new Array();
	 		}
	 		this.publicKeys = new Array();
	 		this.privateKeys = new Array();
	 		var k = 0;
	 		for (var i =0; i < sprivatekeys.length; i++) {
	 			var r = openpgp.read_privateKey(sprivatekeys[i]);
	 			this.privateKeys[k] = { armored: sprivatekeys[i], obj: r[0], keyId: r[0].getKeyId()};
	 			k++;
	 		}
	 		k = 0;
	 		for (var i =0; i < spublickeys.length; i++) {
	 			var r = openpgp.read_publicKey(spublickeys[i]);
	 			if (r[0] != null) {
	 				this.publicKeys[k] = { armored: spublickeys[i], obj: r[0], keyId: r[0].getKeyId()};
	 				k++;
	 			}
	 		}
	 	}
	 	this.init = init;
	 
	 	/**
	 	 * Checks if at least one private key is in the keyring
	 	 * @return {Boolean} True if there are private keys, else false.
	 	 */
	 	function hasPrivateKey() {
	 		return this.privateKeys.length > 0;
	 	}
	 	this.hasPrivateKey = hasPrivateKey;
	 
	 	/**
	 	 * Saves the current state of the keyring to HTML5 local storage.
	 	 * The privateKeys array and publicKeys array gets Stringified using JSON
	 	 */
	 	function store() { 
	 		var priv = new Array();
	 		for (var i = 0; i < this.privateKeys.length; i++) {
	 			priv[i] = this.privateKeys[i].armored;
	 		}
	 		var pub = new Array();
	 		for (var i = 0; i < this.publicKeys.length; i++) {
	 			pub[i] = this.publicKeys[i].armored;
	 		}
	 		compat.local_storage_set("privatekeys",JSON.stringify(priv));
	 		compat.local_storage_set("publickeys",JSON.stringify(pub));
	 	}
	 	this.store = store;
	 	/**
	 	 * searches all public keys in the keyring matching the address or address part of the user ids
	 	 * @param {String} email_address
	 	 * @return {openpgp_msg_publickey[]} The public keys associated with provided email address.
	 	 */
	 	function getPublicKeyForAddress(email_address) {
	 		var results = new Array();
	 		var spl = email_address.split("<");
	 		var email = "";
	 		if (spl.length > 1) {
	 			email = spl[1].split(">")[0];
	 		} else {
	 			email = email_address.trim();
	 		}
	 		email = email.toLowerCase();
	 		if(!util.emailRegEx.test(email)){
	 		    return results;
	 		}
	 		for (var i =0; i < this.publicKeys.length; i++) {
	 			for (var j = 0; j < this.publicKeys[i].obj.userIds.length; j++) {
	 				if (this.publicKeys[i].obj.userIds[j].text.toLowerCase().indexOf(email) >= 0)
	 					results[results.length] = this.publicKeys[i];
	 			}
	 		}
	 		return results;
	 	}
	 	this.getPublicKeyForAddress = getPublicKeyForAddress;
	 
	 	/**
	 	 * Searches the keyring for a private key containing the specified email address
	 	 * @param {String} email_address email address to search for
	 	 * @return {openpgp_msg_privatekey[]} private keys found
	 	 */
	 	function getPrivateKeyForAddress(email_address) {
	 		var results = new Array();
	 		var spl = email_address.split("<");
	 		var email = "";
	 		if (spl.length > 1) {
	 			email = spl[1].split(">")[0];
	 		} else {
	 			email = email_address.trim();
	 		}
	 		email = email.toLowerCase();
	 		if(!util.emailRegEx.test(email)){
	 		    return results;
	 		}
	 		for (var i =0; i < this.privateKeys.length; i++) {
	 			for (var j = 0; j < this.privateKeys[i].obj.userIds.length; j++) {
	 				if (this.privateKeys[i].obj.userIds[j].text.toLowerCase().indexOf(email) >= 0)
	 					results[results.length] = this.privateKeys[i];
	 			}
	 		}
	 		return results;
	 	}
	 
	 	this.getPrivateKeyForAddress = getPrivateKeyForAddress;
	 	/**
	 	 * Searches the keyring for public keys having the specified key id
	 	 * @param {String} keyId provided as string of hex number (lowercase)
	 	 * @return {openpgp_msg_privatekey[]} public keys found
	 	 */
	 	function getPublicKeysForKeyId(keyId) {
	 		var result = new Array();
	 		for (var i=0; i < this.publicKeys.length; i++) {
	 			var key = this.publicKeys[i];
	 			if (keyId == key.obj.getKeyId())
	 				result[result.length] = key;
	 			else if (key.obj.subKeys != null) {
	 				for (var j=0; j < key.obj.subKeys.length; j++) {
	 					var subkey = key.obj.subKeys[j];
	 					if (keyId == subkey.getKeyId()) {
	 						result[result.length] = {
	 								obj: key.obj.getSubKeyAsKey(j),
	 								keyId: subkey.getKeyId()
	 						}
	 					}
	 				}
	 			}
	 		}
	 		return result;
	 	}
	 	this.getPublicKeysForKeyId = getPublicKeysForKeyId;
	 	
	 	/**
	 	 * Searches the keyring for private keys having the specified key id
	 	 * @param {String} keyId 8 bytes as string containing the key id to look for
	 	 * @return {openpgp_msg_privatekey[]} private keys found
	 	 */
	 	function getPrivateKeyForKeyId(keyId) {
	 		var result = new Array();
	 		for (var i=0; i < this.privateKeys.length; i++) {
	 			if (keyId == this.privateKeys[i].obj.getKeyId()) {
	 				result[result.length] = { key: this.privateKeys[i], keymaterial: this.privateKeys[i].obj.privateKeyPacket};
	 			}
	 			if (this.privateKeys[i].obj.subKeys != null) {
	 				var subkeyids = this.privateKeys[i].obj.getSubKeyIds();
	 				for (var j=0; j < subkeyids.length; j++)
	 					if (keyId == util.hexstrdump(subkeyids[j])) {
	 						result[result.length] = { key: this.privateKeys[i], keymaterial: this.privateKeys[i].obj.subKeys[j]};
	 					}
	 			}
	 		}
	 		return result;
	 	}
	 	this.getPrivateKeyForKeyId = getPrivateKeyForKeyId;
	 	
	 	/**
	 	 * Imports a public key from an exported ascii armored message 
	 	 * @param {String} armored_text PUBLIC KEY BLOCK message to read the public key from
	 	 */
	 	function importPublicKey (armored_text) {
	 		var result = openpgp.read_publicKey(armored_text);
	 		for (var i = 0; i < result.length; i++) {
	 			this.publicKeys[this.publicKeys.length] = {armored: armored_text, obj: result[i], keyId: result[i].getKeyId()};
	 		}
	 		return true;
	 	}
	 
	 	/**
	 	 * Imports a private key from an exported ascii armored message 
	 	 * @param {String} armored_text PRIVATE KEY BLOCK message to read the private key from
	 	 */
	 	function importPrivateKey (armored_text, password) {
	 		var result = openpgp.read_privateKey(armored_text);
	 		if(!result[0].decryptSecretMPIs(password))
	 		    return false;
	 		for (var i = 0; i < result.length; i++) {
	 			this.privateKeys[this.privateKeys.length] = {armored: armored_text, obj: result[i], keyId: result[i].getKeyId()};
	 		}
	 		return true;
	 	}
	 
	 	this.importPublicKey = importPublicKey;
	 	this.importPrivateKey = importPrivateKey;
	 	
	 	/**
	 	 * returns the openpgp_msg_privatekey representation of the public key at public key ring index  
	 	 * @param {Integer} index the index of the public key within the publicKeys array
	 	 * @return {openpgp_msg_privatekey} the public key object
	 	 */
	 	function exportPublicKey(index) {
	 		return this.publicKey[index];
	 	}
	 	this.exportPublicKey = exportPublicKey;
	 		
	 	
	 	/**
	 	 * Removes a public key from the public key keyring at the specified index 
	 	 * @param {Integer} index the index of the public key within the publicKeys array
	 	 * @return {openpgp_msg_privatekey} The public key object which has been removed
	 	 */
	 	function removePublicKey(index) {
	 		var removed = this.publicKeys.splice(index,1);
	 		this.store();
	 		return removed;
	 	}
	 	this.removePublicKey = removePublicKey;
	 
	 	/**
	 	 * returns the openpgp_msg_privatekey representation of the private key at private key ring index  
	 	 * @param {Integer} index the index of the private key within the privateKeys array
	 	 * @return {openpgp_msg_privatekey} the private key object
	 	 */	
	 	function exportPrivateKey(index) {
	 		return this.privateKeys[index];
	 	}
	 	this.exportPrivateKey = exportPrivateKey;
	 
	 	/**
	 	 * Removes a private key from the private key keyring at the specified index 
	 	 * @param {Integer} index the index of the private key within the privateKeys array
	 	 * @return {openpgp_msg_privatekey} The private key object which has been removed
	 	 */
	 	function removePrivateKey(index) {
	 		var removed = this.privateKeys.splice(index,1);
	 		this.store();
	 		return removed;
	 	}
	 	this.removePrivateKey = removePrivateKey;
	 
	 }
	 // GPG4Browsers - An OpenPGP implementation in javascript
	 // Copyright (C) 2011 Recurity Labs GmbH
	 // 
	 // This library is free software; you can redistribute it and/or
	 // modify it under the terms of the GNU Lesser General Public
	 // License as published by the Free Software Foundation; either
	 // version 2.1 of the License, or (at your option) any later version.
	 // 
	 // This library is distributed in the hope that it will be useful,
	 // but WITHOUT ANY WARRANTY; without even the implied warranty of
	 // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
	 // Lesser General Public License for more details.
	 // 
	 // You should have received a copy of the GNU Lesser General Public
	 // License along with this library; if not, write to the Free Software
	 // Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
	 
	 /**
	  * @protected
	  * @class
	  * @classdesc Top-level message object. Contains information from one or more packets
	  */
	 
	 function openpgp_msg_message() {
	 	
	 	// -1 = no valid passphrase submitted
	 	// -2 = no private key found
	 	// -3 = decryption error
	 	// text = valid decryption
	 	this.text = "";
	 	this.messagePacket = null;
	 	this.type = null;
	 	
	 	/**
	 	 * Decrypts a message and generates user interface message out of the found.
	 	 * MDC will be verified as well as message signatures
	 	 * @param {openpgp_msg_privatekey} private_key the private the message is encrypted with (corresponding to the session key)
	 	 * @param {openpgp_packet_encryptedsessionkey} sessionkey the session key to be used to decrypt the message
	 	 * @return {String} plaintext of the message or null on error
	 	 */
	 	function decrypt(private_key, sessionkey) {
	         return this.decryptAndVerifySignature(private_key, sessionkey).text;
	 	}
	 
	 	/**
	 	 * Decrypts a message and generates user interface message out of the found.
	 	 * MDC will be verified as well as message signatures
	 	 * @param {openpgp_msg_privatekey} private_key the private the message is encrypted with (corresponding to the session key)
	 	 * @param {openpgp_packet_encryptedsessionkey} sessionkey the session key to be used to decrypt the message
	 	 * @param {openpgp_msg_publickey} pubkey Array of public keys to check signature against. If not provided, checks local keystore.
	 	 * @return {String} plaintext of the message or null on error
	 	 */
	 	function decryptAndVerifySignature(private_key, sessionkey, pubkey) {
	 		if (private_key == null || sessionkey == null || sessionkey == "")
	 			return null;
	 		var decrypted = sessionkey.decrypt(this, private_key.keymaterial);
	 		if (decrypted == null)
	 			return null;
	 		var packet;
	 		var position = 0;
	 		var len = decrypted.length;
	 		var validSignatures = new Array();
	 		util.print_debug_hexstr_dump("openpgp.msg.messge decrypt:\n",decrypted);
	 		
	 		var messages = openpgp.read_messages_dearmored({text: decrypted, openpgp: decrypted});
	 		for(var m in messages){
	 			if(messages[m].data){
	 				this.text = messages[m].data;
	 			}
	 			if(messages[m].signature){
	 			    validSignatures.push(messages[m].verifySignature(pubkey));
	 			}
	 		}
	 		return {text:this.text, validSignatures:validSignatures};
	 	}
	 	
	 	/**
	 	 * Verifies a message signature. This function can be called after read_message if the message was signed only.
	 	 * @param {openpgp_msg_publickey} pubkey Array of public keys to check signature against. If not provided, checks local keystore.
	 	 * @return {boolean} true if the signature was correct; otherwise false
	 	 */
	 	function verifySignature(pubkey) {
	 		var result = false;
	 		if (this.signature.tagType == 2) {
	 		    if(!pubkey || pubkey.length == 0){
	 			    var pubkey;
	 			    if (this.signature.version == 4) {
	 				    pubkey = openpgp.keyring.getPublicKeysForKeyId(this.signature.issuerKeyId);
	 			    } else if (this.signature.version == 3) {
	 				    pubkey = openpgp.keyring.getPublicKeysForKeyId(this.signature.keyId);
	 			    } else {
	 				    util.print_error("unknown signature type on message!");
	 				    return false;
	 			    }
	 			}
	 			if (pubkey.length == 0)
	 				util.print_warning("Unable to verify signature of issuer: "+util.hexstrdump(this.signature.issuerKeyId)+". Public key not found in keyring.");
	 			else {
	 				for (var i = 0 ; i < pubkey.length; i++) {
	 					var tohash = this.text.replace(/\r\n/g,"\n").replace(/\n/g,"\r\n");
	 					if (this.signature.verify(tohash, pubkey[i])) {
	 						util.print_info("Found Good Signature from "+pubkey[i].obj.userIds[0].text+" (0x"+util.hexstrdump(pubkey[i].obj.getKeyId()).substring(8)+")");
	 						result = true;
	 					} else {
	 						util.print_error("Signature verification failed: Bad Signature from "+pubkey[i].obj.userIds[0].text+" (0x"+util.hexstrdump(pubkey[0].obj.getKeyId()).substring(8)+")");
	 					}
	 				}
	 			}
	 		}
	 		return result;
	 	}
	 	
	 	function toString() {
	 		var result = "Session Keys:\n";
	 		if (this.sessionKeys !=null)
	 		for (var i = 0; i < this.sessionKeys.length; i++) {
	 			result += this.sessionKeys[i].toString();
	 		}
	 		result += "\n\n EncryptedData:\n";
	 		if(this.encryptedData != null)
	 		result += this.encryptedData.toString();
	 		
	 		result += "\n\n Signature:\n";
	 		if(this.signature != null)
	 		result += this.signature.toString();
	 		
	 		result += "\n\n Text:\n"
	 		if(this.signature != null)
	 			result += this.text;
	 		return result;
	 	}
	 	this.decrypt = decrypt;
	 	this.decryptAndVerifySignature = decryptAndVerifySignature;
	 	this.verifySignature = verifySignature;
	 	this.toString = toString;
	 }
	 // GPG4Browsers - An OpenPGP implementation in javascript
	 // Copyright (C) 2011 Recurity Labs GmbH
	 // 
	 // This library is free software; you can redistribute it and/or
	 // modify it under the terms of the GNU Lesser General Public
	 // License as published by the Free Software Foundation; either
	 // version 2.1 of the License, or (at your option) any later version.
	 // 
	 // This library is distributed in the hope that it will be useful,
	 // but WITHOUT ANY WARRANTY; without even the implied warranty of
	 // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
	 // Lesser General Public License for more details.
	 // 
	 // You should have received a copy of the GNU Lesser General Public
	 // License along with this library; if not, write to the Free Software
	 // Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
	 
	 /**
	  * @class
	  * @classdesc Class that represents a decoded private key for internal openpgp.js use
	  */
	 
	 function openpgp_msg_privatekey() {
	 	this.subKeys = new Array();
	 	this.privateKeyPacket = null;
	 	this.userIds = new Array();
	 	this.userAttributes = new Array();
	 	this.revocationSignatures = new Array();
	 	this.subKeys = new Array();
	 
	 	/**
	 	 * 
	 	 * @return last position
	 	 */
	 	function read_nodes(parent_node, input, position, len) {
	 		this.privateKeyPacket = parent_node;
	 		
	 		var pos = position;
	 		while (input.length > pos) {
	 			var result = openpgp_packet.read_packet(input, pos, input.length - pos);
	 			if (result == null) {
	 				util.print_error("openpgp.msg.messge decrypt:\n"+'[pub/priv_key]parsing ends here @:' + pos + " l:" + len);
	 				break;
	 			} else {
	 				switch (result.tagType) {
	 				case 2: // public key revocation signature
	 					if (result.signatureType == 32)
	 						this.revocationSignatures[this.revocationSignatures.length] = result;
	 					else if (result.signatureType > 15 && result.signatureType < 20) {
	 						if (this.certificationsignatures == null)
	 							this.certificationSignatures = new Array();
	 						this.certificationSignatures[this.certificationSignatures.length] = result;
	 					} else
	 						util.print_error("openpgp.msg.messge decrypt:\n"+"unknown signature type directly on key "+result.signatureType+" @"+pos);
	 					pos += result.packetLength + result.headerLength;
	 					break;
	 				case 7: // PrivateSubkey Packet
	 					this.subKeys[this.subKeys.length] = result;
	 					pos += result.packetLength + result.headerLength;
	 					pos += result.read_nodes(this.privateKeyPacket,input, pos, input.length - pos);
	 					break;
	 				case 17: // User Attribute Packet
	 					this.userAttributes[this.userAttributes.length] = result;
	 					pos += result.packetLength + result.headerLength;
	 					pos += result.read_nodes(this.privateKeyPacket,input, pos, input.length - pos);
	 					break;
	 				case 13: // User ID Packet
	 					this.userIds[this.userIds.length] = result;
	 					pos += result.packetLength + result.headerLength;
	 					pos += result.read_nodes(this.privateKeyPacket, input, pos, input.length - pos);
	 					break;
	 				default:
	 					this.position = position - this.privateKeyPacket.packetLength - this.privateKeyPacket.headerLength;
	 					this.len = pos - position;
	 					return this.len;
	 				}
	 			}
	 		}
	 		this.position = position - this.privateKeyPacket.packetLength - this.privateKeyPacket.headerLength;
	 		this.len = pos - position;
	 		
	 		return this.len;
	 	}
	 	
	 	function getKeyId() {
	 		return this.privateKeyPacket.publicKey.getKeyId();
	 	}
	 	
	 	
	 	function getSubKeyIds() {
	 		if (this.privateKeyPacket.publicKey.version == 4) // V3 keys MUST NOT have subkeys.
	 		var result = new Array();
	 		for (var i = 0; i < this.subKeys.length; i++) {
	 			result[i] = str_sha1(this.subKeys[i].publicKey.header+this.subKeys[i].publicKey.data).substring(12,20);
	 		}
	 		return result;
	 	}
	 	
	 	
	 	function getSigningKey() {
	 		if ((this.privateKeyPacket.publicKey.publicKeyAlgorithm == 17 ||
	 			 this.privateKeyPacket.publicKey.publicKeyAlgorithm != 2)
	 			&& this.privateKeyPacket.publicKey.verifyKey() == 3)
	 			return this.privateKeyPacket;
	 		else if (this.privateKeyPacket.publicKey.version == 4) // V3 keys MUST NOT have subkeys.
	 			for (var j = 0; j < this.privateKeyPacket.subKeys.length; j++) {
	 				if ((this.privateKeyPacket.subKeys[j].publicKey.publicKeyAlgorithm == 17 ||
	 					 this.privateKeyPacket.subKeys[j].publicKey.publicKeyAlgorithm != 2) &&
	 					 this.privateKeyPacket.subKeys[j].publicKey.verifyKey() == 3)
	 					return this.privateKeyPacket.subKeys[j];
	 			}
	 		return null;
	 	}
	 	
	 	function getPreferredSignatureHashAlgorithm() {
	 		var pkey = this.getSigningKey();
	 		if (pkey == null) {
	 			util.print_error("private key is for encryption only! Cannot create a signature.")
	 			return null;
	 		}
	 		if (pkey.publicKey.publicKeyAlgorithm == 17) {
	 			var dsa = new DSA();
	 			return dsa.select_hash_algorithm(pkey.publicKey.MPIs[1].toBigInteger()); // q
	 		}
	 		//TODO implement: https://tools.ietf.org/html/rfc4880#section-5.2.3.8
	 		//separate private key preference from digest preferences
	 		return openpgp.config.config.prefer_hash_algorithm;
	 			
	 	}
	 
	 	function decryptSecretMPIs(str_passphrase) {
	 		return this.privateKeyPacket.decryptSecretMPIs(str_passphrase);
	 	}
	 	
	 	function getFingerprint() {
	 		return this.privateKeyPacket.publicKey.getFingerprint();
	 	}
	 
	 	// TODO need to implement this
	 	function revoke() {
	 		
	 	}
	 
	 	/**
	 	 * extracts the public key part
	 	 * @return {String} OpenPGP armored text containing the public key
	 	 *                  returns null if no sufficient data to extract public key
	 	 */
	 	function extractPublicKey() {
	 		// add public key
	 		var key = this.privateKeyPacket.publicKey.header + this.privateKeyPacket.publicKey.data;
	 		for (var i = 0; i < this.userIds.length; i++) {
	 			// verify userids
	 			if (this.userIds[i].certificationSignatures.length === 0) {
	 				util.print_error("extractPublicKey - missing certification signatures");
	 				return null;
	 			}
	 			var userIdPacket = new openpgp_packet_userid();
	 			// add userids
	 			key += userIdPacket.write_packet(this.userIds[i].text);
	 			for (var j = 0; j < this.userIds[i].certificationSignatures.length; j++) {
	 				var certSig = this.userIds[i].certificationSignatures[j];
	 				// add signatures
	 				key += openpgp_packet.write_packet_header(2, certSig.data.length) + certSig.data;
	 			}
	 		}
	 		for (var k = 0; k < this.subKeys.length; k++) {
	 			var pubSubKey = this.subKeys[k].publicKey;
	 			// add public subkey package
	 			key += openpgp_packet.write_old_packet_header(14, pubSubKey.data.length) + pubSubKey.data;
	 			var subKeySig = this.subKeys[k].subKeySignature;
	 			if (subKeySig !== null) {
	 				// add subkey signature
	 				key += openpgp_packet.write_packet_header(2, subKeySig.data.length) + subKeySig.data;
	 			} else {
	 				util.print_error("extractPublicKey - missing subkey signature");
	 				return null;
	 			}
	 		}
	 		var publicArmored = openpgp_encoding_armor(4, key);
	 		return publicArmored;
	 	}
	 
	 	this.extractPublicKey = extractPublicKey;
	 	this.getSigningKey = getSigningKey;
	 	this.getFingerprint = getFingerprint;
	 	this.getPreferredSignatureHashAlgorithm = getPreferredSignatureHashAlgorithm;
	 	this.read_nodes = read_nodes;
	 	this.decryptSecretMPIs = decryptSecretMPIs;
	 	this.getSubKeyIds = getSubKeyIds;
	 	this.getKeyId = getKeyId;
	 	
	 }
	 // GPG4Browsers - An OpenPGP implementation in javascript
	 // Copyright (C) 2011 Recurity Labs GmbH
	 // 
	 // This library is free software; you can redistribute it and/or
	 // modify it under the terms of the GNU Lesser General Public
	 // License as published by the Free Software Foundation; either
	 // version 2.1 of the License, or (at your option) any later version.
	 // 
	 // This library is distributed in the hope that it will be useful,
	 // but WITHOUT ANY WARRANTY; without even the implied warranty of
	 // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
	 // Lesser General Public License for more details.
	 // 
	 // You should have received a copy of the GNU Lesser General Public
	 // License along with this library; if not, write to the Free Software
	 // Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
	 
	 /**
	  * @class
	  * @classdesc Decoded public key object for internal openpgp.js use
	  */
	 function openpgp_msg_publickey() {
	 	this.data;
	 	this.position;
	 	this.len;
	 	this.tostring = "OPENPGP PUBLIC KEY\n";
	 	this.bindingSignature = null;
	 	this.publicKeyPacket = null;
	 	this.userIds = new Array();
	 	this.userAttributes = new Array();
	 	this.revocationSignatures = new Array();
	 	this.subKeys = new Array();
	 	this.arbitraryPacket = new Array();
	 	this.directSignatures = new Array();
	 	/**
	 	 * 
	 	 * @return last position
	 	 */
	 	function read_nodes(parent_node, input, position, len) {
	 		this.publicKeyPacket = parent_node;
	 		var exit = false;
	 		var pos = position;
	 		var l = len;
	 		while (input.length != pos) {
	 			var result = openpgp_packet.read_packet(input, pos, input.length - pos);
	 			if (result == null) {
	 				util.print_error("openpgp.msg.publickey read_nodes:\n"+'[pub_key]parsing ends here @:' + pos + " l:" + l);
	 				break;
	 			} else {
	 				switch (result.tagType) {
	 				case 2: // public key revocation signature
	 					if (result.signatureType == 32)
	 						this.revocationSignatures[this.revocationSignatures.length] = result;
	 					else if (result.signatureType == 16 || result.signatureType == 17 || result.signatureType == 18  || result.signatureType == 19)
	 						this.certificationSignature = result;
	 					else if (result.signatureType == 25) {
	 						this.bindingSignature = result;
	 					} else if (result.signatureType == 31) {
	 						this.directSignatures[this.directSignatures.length] = result;
	 					} else
	 						util.print_error("openpgp.msg.publickey read_nodes:\n"+"unknown signature type directly on key "+result.signatureType);
	 					pos += result.packetLength + result.headerLength;
	 					break;
	 				case 14: // Public-Subkey Packet
	 					this.subKeys[this.subKeys.length] = result;
	 					pos += result.packetLength + result.headerLength;
	 					pos += result.read_nodes(this.publicKeyPacket,input, pos, input.length - pos);
	 					break;
	 				case 17: // User Attribute Packet
	 					this.userAttributes[this.userAttributes.length] = result;
	 					pos += result.packetLength + result.headerLength;
	 					pos += result.read_nodes(this.publicKeyPacket,input, pos, input.length - pos);
	 					break;
	 				case 13: // User ID Packet
	 					this.userIds[this.userIds.length] = result;
	 					pos += result.packetLength + result.headerLength;
	 					pos += result.read_nodes(this.publicKeyPacket, input, pos, input.length - pos);
	 					break;
	 				default:
	 					this.data = input;
	 					this.position = position - this.publicKeyPacket.packetLength - this.publicKeyPacket.headerLength;
	 					this.len = pos - position;
	 					return this.len;
	 				}
	 			}
	 		}
	 		this.data = input;
	 		this.position = position - (this.publicKeyPacket.packetLength - this.publicKeyPacket.headerLength);
	 		this.len = pos - position;
	 		return this.len;
	 	}
	 
	 	function write() {
	 
	 	}
	 
	 	function getKeyId() {
	 		return this.publicKeyPacket.getKeyId();
	 	}
	 	
	 	function getFingerprint() {
	 		return this.publicKeyPacket.getFingerprint();
	 	}
	 
	 
	 	
	 	function validate() {
	 		// check revocation keys
	 		for (var i = 0; i < this.revocationSignatures.length; i++) {
	 			var tohash = this.publicKeyPacket.header+this.publicKeyPacket.data;
	 			if (this.revocationSignatures[i].verify(tohash, this.publicKeyPacket))
	 				return false;
	 		}
	 		
	 		if (this.subKeys.length != 0) {
	 			// search for a valid subkey
	 			var found = false;
	 			for (var i = 0; i < this.subKeys.length; i++)
	 				if (this.subKeys[i].verifyKey() == 3) {
	 					found = true;
	 					break;
	 				}
	 			if (!found)
	 				return false;
	 		}
	 		// search for one valid userid
	 		found = false;
	 		for (var i = 0; i < this.userIds.length; i++)
	 			if (this.userIds[i].verify(this.publicKeyPacket) == 0) {
	 				found = true;
	 				break;
	 			}
	 		if (!found)
	 			return false;
	 		return true;
	 	}
	 	
	 	/**
	 	 * verifies all signatures
	 	 * @return a 2 dimensional array. the first dimension corresponds to the userids available
	 	 */
	 	function verifyCertificationSignatures() {
	 		var result = new Array();
	 		for (var i = 0; i < this.userIds.length; i++) {
	 			result[i] = this.userIds[i].verifyCertificationSignatures(this.publicKeyPacket);
	 		}
	 		return result;
	 	}
	 	this.verifyCertificationSignatures = verifyCertificationSignatures;
	 	
	 	/**
	 	 * verifies:
	 	 *  - revocation certificates directly on key
	 	 *  - self signatures
	 	 *  - subkey binding and revocation certificates
	 	 *  
	 	 *  This is useful for validating the key
	 	 *  @returns {Boolean} true if the basic signatures are all valid
	 	 */
	 	function verifyBasicSignatures() {
	 		for (var i = 0; i < this.revocationSignatures.length; i++) {
	 			var tohash = this.publicKeyPacket.header+this.publicKeyPacket.data;
	 			if (this.revocationSignatures[i].verify(tohash, this.publicKeyPacket))
	 				return false;
	 		}
	 		
	 		if (this.subKeys.length != 0) {
	 			// search for a valid subkey
	 			var found = false;
	 			for (var i = 0; i < this.subKeys.length; i++) {
	 				if (this.subKeys[i] == null)
	 					continue;
	 				var result = this.subKeys[i].verifyKey();
	 				if (result == 3) {
	 					found = true;
	 					break;
	 				} 
	 			}
	 			if (!found)
	 				return false;
	 		}
	 		var keyId = this.getKeyId();
	 		for (var i = 0; i < this.userIds.length; i++) {
	 			for (var j = 0; j < this.userIds[i].certificationRevocationSignatures.length; j++) {
	 				if (this.userIds[i].certificationSignatures[j].getIssuer == keyId &&
	 					this.userIds[i].certificationSignatures[j].verifyBasic(this.publicKeyPacket) != 4)
	 					return false;
	 			}
	 		}
	 		return true;
	 	}
	 	
	 	function toString() {
	 		var result = " OPENPGP Public Key\n    length: "+this.len+"\n";
	 		result += "    Revocation Signatures:\n"
	 		for (var i=0; i < this.revocationSignatures.length; i++) {
	 			result += "    "+this.revocationSignatures[i].toString(); 
	 		}
	 		result += "    User Ids:\n";
	 		for (var i=0; i < this.userIds.length; i++) {
	 			result += "    "+this.userIds[i].toString(); 
	 		}
	 		result += "    User Attributes:\n";
	 		for (var i=0; i < this.userAttributes.length; i++) {
	 			result += "    "+this.userAttributes[i].toString(); 
	 		}
	 		result += "    Public Key SubKeys:\n";
	 		for (var i=0; i < this.subKeys.length; i++) {
	 			result += "    "+this.subKeys[i].toString(); 
	 		}
	 		return result;
	 	}
	 	
	 	/**
	 	 * finds an encryption key for this public key
	 	 * @returns null if no encryption key has been found
	 	 */
	 	function getEncryptionKey() {
	 		// V4: by convention subkeys are prefered for encryption service
	 		// V3: keys MUST NOT have subkeys
	 		for (var j = 0; j < this.subKeys.length; j++)
	 				if (this.subKeys[j].publicKeyAlgorithm != 17 &&
	 						this.subKeys[j].publicKeyAlgorithm != 3 &&
	 						this.subKeys[j].verifyKey()) {
	 					return this.subKeys[j];
	 				}
	 		// if no valid subkey for encryption, use primary key
	 		if (this.publicKeyPacket.publicKeyAlgorithm != 17 && this.publicKeyPacket.publicKeyAlgorithm != 3
	 			&& this.publicKeyPacket.verifyKey()) {
	 			return this.publicKeyPacket;	
	 		}
	 		return null;
	 	}
	 	
	 	function getSigningKey() {
	 		if ((this.publicKeyPacket.publicKeyAlgorithm == 17 ||
	 			 this.publicKeyPacket.publicKeyAlgorithm != 2))
	 			return this.publicKeyPacket;
	 		else if (this.publicKeyPacket.version == 4) // V3 keys MUST NOT have subkeys.
	 			for (var j = 0; j < this.subKeys.length; j++) {
	 				if ((this.subKeys[j].publicKeyAlgorithm == 17 ||
	 					 this.subKeys[j].publicKeyAlgorithm != 2) &&
	 					 this.subKeys[j].verifyKey())
	 					return this.subKeys[j];
	 			}
	 		return null;
	 	}
	 
	         /* Returns the i-th subKey as a openpgp_msg_publickey object */
	 	function getSubKeyAsKey(i) {
	 		var ret = new openpgp_msg_publickey();
	 		ret.userIds = this.userIds;
	 		ret.userAttributes = this.userAttributes;
	 		ret.publicKeyPacket = this.subKeys[i];
	 		return ret;
	 	}
	 
	 	this.getEncryptionKey = getEncryptionKey;
	 	this.getSigningKey = getSigningKey;
	 	this.read_nodes = read_nodes;
	 	this.write = write;
	 	this.toString = toString;
	 	this.validate = validate;
	 	this.getFingerprint = getFingerprint;
	 	this.getKeyId = getKeyId;
	 	this.verifyBasicSignatures = verifyBasicSignatures;
	 	this.getSubKeyAsKey = getSubKeyAsKey;
	 }
	 // GPG4Browsers - An OpenPGP implementation in javascript
	 // Copyright (C) 2011 Recurity Labs GmbH
	 // 
	 // This library is free software; you can redistribute it and/or
	 // modify it under the terms of the GNU Lesser General Public
	 // License as published by the Free Software Foundation; either
	 // version 2.1 of the License, or (at your option) any later version.
	 // 
	 // This library is distributed in the hope that it will be useful,
	 // but WITHOUT ANY WARRANTY; without even the implied warranty of
	 // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
	 // Lesser General Public License for more details.
	 // 
	 // You should have received a copy of the GNU Lesser General Public
	 // License along with this library; if not, write to the Free Software
	 // Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
	 
	 /**
	  * @class
	  * @classdesc Implementation of the Compressed Data Packet (Tag 8)
	  * 
	  * RFC4880 5.6:
	  * The Compressed Data packet contains compressed data.  Typically, this
	  * packet is found as the contents of an encrypted packet, or following
	  * a Signature or One-Pass Signature packet, and contains a literal data
	  * packet.
	  */   
	 function openpgp_packet_compressed() {
	 	this.tagType = 8;
	 	this.decompressedData = null;
	 	
	 	/**
	 	 * Parsing function for the packet.
	 	 * @param {String} input Payload of a tag 8 packet
	 	 * @param {Integer} position Position to start reading from the input string
	 	 * @param {Integer} len Length of the packet or the remaining length of 
	 	 * input at position
	 	 * @return {openpgp_packet_compressed} Object representation
	 	 */
	 	function read_packet (input, position, len) {
	 		this.packetLength = len;
	 		var mypos = position;
	 		// One octet that gives the algorithm used to compress the packet.
	 		this.type = input.charCodeAt(mypos++);
	 		// Compressed data, which makes up the remainder of the packet.
	 		this.compressedData = input.substring(position+1, position+len);
	 		return this;
	 	}
	 	/**
	 	 * Decompression method for decompressing the compressed data
	 	 * read by read_packet
	 	 * @return {String} The decompressed data
	 	 */
	 	function decompress() {
	 		if (this.decompressedData != null)
	 			return this.decompressedData;
	 
	 		if (this.type == null)
	 			return null;
	 
	 		switch (this.type) {
	 		case 0: // - Uncompressed
	 			this.decompressedData = this.compressedData;
	 			break;
	 		case 1: // - ZIP [RFC1951]
	 			util.print_info('Decompressed packet [Type 1-ZIP]: ' + this.toString());
	 			var compData = this.compressedData;
	 			var radix = s2r(compData).replace(/\n/g,"");
	 			// no header in this case, directly call deflate
	 			var jxg_obj = new JXG.Util.Unzip(JXG.Util.Base64.decodeAsArray(radix));
	 			this.decompressedData = unescape(jxg_obj.deflate()[0][0]);
	 			break;
	 		case 2: // - ZLIB [RFC1950]
	 			util.print_info('Decompressed packet [Type 2-ZLIB]: ' + this.toString());
	 			var compressionMethod = this.compressedData.charCodeAt(0) % 0x10; //RFC 1950. Bits 0-3 Compression Method
	 			//Bits 4-7 RFC 1950 are LZ77 Window. Generally this value is 7 == 32k window size.
	 			//2nd Byte in RFC 1950 is for "FLAGs" Allows for a Dictionary (how is this defined). Basic checksum, and compression level.
	 			if (compressionMethod == 8) { //CM 8 is for DEFLATE, RFC 1951
	 				// remove 4 bytes ADLER32 checksum from the end
	 				var compData = this.compressedData.substring(0, this.compressedData.length - 4);
	 				var radix = s2r(compData).replace(/\n/g,"");
	 				//TODO check ADLER32 checksum
	 				this.decompressedData = JXG.decompress(radix);
	 				break;
	 			} else {
	 				util.print_error("Compression algorithm ZLIB only supports DEFLATE compression method.");
	 			}
	 			break;
	 		case 3: //  - BZip2 [BZ2]
	 			// TODO: need to implement this
	 			util.print_error("Compression algorithm BZip2 [BZ2] is not implemented.");
	 			break;
	 		default:
	 			util.print_error("Compression algorithm unknown :"+this.type);
	 			break;
	 		}
	 		util.print_debug("decompressed:"+util.hexstrdump(this.decompressedData));
	 		return this.decompressedData; 
	 	}
	 
	 	/**
	 	 * Compress the packet data (member decompressedData)
	 	 * @param {Integer} type Algorithm to be used // See RFC 4880 9.3
	 	 * @param {String} data Data to be compressed
	 	 * @return {String} The compressed data stored in attribute compressedData
	 	 */
	 	function compress(type, data) {
	 		this.type = type;
	 		this.decompressedData = data;
	 		switch (this.type) {
	 		case 0: // - Uncompressed
	 			this.compressedData = this.decompressedData;
	 			break;
	 		case 1: // - ZIP [RFC1951]
	 			util.print_error("Compression algorithm ZIP [RFC1951] is not implemented.");
	 			break;
	 		case 2: // - ZLIB [RFC1950]
	 			// TODO: need to implement this
	 			util.print_error("Compression algorithm ZLIB [RFC1950] is not implemented.");
	 			break;
	 		case 3: //  - BZip2 [BZ2]
	 			// TODO: need to implement this
	 			util.print_error("Compression algorithm BZip2 [BZ2] is not implemented.");
	 			break;
	 		default:
	 			util.print_error("Compression algorithm unknown :"+this.type);
	 			break;
	 		}
	 		this.packetLength = this.compressedData.length +1;
	 		return this.compressedData; 
	 	}
	 	
	 	/**
	 	 * Creates a string representation of the packet
	 	 * @param {Integer} algorithm Algorithm to be used // See RFC 4880 9.3
	 	 * @param {String} data Data to be compressed
	 	 * @return {String} String-representation of the packet
	 	 */
	 	function write_packet(algorithm, data) {
	 		this.decompressedData = data;
	 		if (algorithm == null) {
	 			this.type = 1;
	 		}
	 		var result = String.fromCharCode(this.type)+this.compress(this.type);
	 		return openpgp_packet.write_packet_header(8, result.length)+result;
	 	}
	 	
	 	/**
	 	 * Pretty printing the packet (useful for debug purposes)
	 	 * @return {String}
	 	 */
	 	function toString() {
	 		return '5.6.  Compressed Data Packet (Tag 8)\n'+
	 		   '    length:  '+this.packetLength+'\n'+
	 			   '    Compression Algorithm = '+this.type+'\n'+
	 		       '    Compressed Data: Byte ['+util.hexstrdump(this.compressedData)+']\n';
	 	}
	 	
	 	this.read_packet = read_packet;
	 	this.toString = toString;
	 	this.compress = compress;
	 	this.decompress = decompress;
	 	this.write_packet = write_packet;
	 };
	 // GPG4Browsers - An OpenPGP implementation in javascript
	 // Copyright (C) 2011 Recurity Labs GmbH
	 // 
	 // This library is free software; you can redistribute it and/or
	 // modify it under the terms of the GNU Lesser General Public
	 // License as published by the Free Software Foundation; either
	 // version 2.1 of the License, or (at your option) any later version.
	 // 
	 // This library is distributed in the hope that it will be useful,
	 // but WITHOUT ANY WARRANTY; without even the implied warranty of
	 // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
	 // Lesser General Public License for more details.
	 // 
	 // You should have received a copy of the GNU Lesser General Public
	 // License along with this library; if not, write to the Free Software
	 // Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
	 
	 /**
	  * @class
	  * @classdesc Implementation of the Symmetrically Encrypted Data Packet (Tag 9)
	  * 
	  * RFC4880 5.7: The Symmetrically Encrypted Data packet contains data encrypted
	  * with a symmetric-key algorithm. When it has been decrypted, it contains other
	  * packets (usually a literal data packet or compressed data packet, but in
	  * theory other Symmetrically Encrypted Data packets or sequences of packets
	  * that form whole OpenPGP messages).
	  */
	 
	 function openpgp_packet_encrypteddata() {
	 	this.tagType = 9;
	 	this.packetLength = null;
	 	this.encryptedData = null;
	 	this.decryptedData = null;
	 
	 	/**
	 	 * Parsing function for the packet.
	 	 * 
	 	 * @param {String} input Payload of a tag 9 packet
	 	 * @param {Integer} position Position to start reading from the input string
	 	 * @param {Integer} len Length of the packet or the remaining length of
	 	 *            input at position
	 	 * @return {openpgp_packet_encrypteddata} Object representation
	 	 */
	 	function read_packet(input, position, len) {
	 		var mypos = position;
	 		this.packetLength = len;
	 		// - Encrypted data, the output of the selected symmetric-key cipher
	 		// operating in OpenPGP's variant of Cipher Feedback (CFB) mode.
	 		this.encryptedData = input.substring(position, position + len);
	 		return this;
	 	}
	 
	 	/**
	 	 * Symmetrically decrypt the packet data
	 	 * 
	 	 * @param {Integer} symmetric_algorithm_type
	 	 *             Symmetric key algorithm to use // See RFC4880 9.2
	 	 * @param {String} key
	 	 *             Key as string with the corresponding length to the
	 	 *            algorithm
	 	 * @return The decrypted data;
	 	 */
	 	function decrypt_sym(symmetric_algorithm_type, key) {
	 		this.decryptedData = openpgp_crypto_symmetricDecrypt(
	 				symmetric_algorithm_type, key, this.encryptedData, true);
	 		util.print_debug("openpgp.packet.encryptedintegrityprotecteddata.js\n"+
	 				"data: "+util.hexstrdump(this.decryptedData));
	 		return this.decryptedData;
	 	}
	 
	 	/**
	 	 * Creates a string representation of the packet
	 	 * 
	 	 * @param {Integer} algo Symmetric key algorithm to use // See RFC4880 9.2
	 	 * @param {String} key Key as string with the corresponding length to the
	 	 *            algorithm
	 	 * @param {String} data Data to be
	 	 * @return {String} String-representation of the packet
	 	 */
	 	function write_packet(algo, key, data) {
	 		var result = "";
	 		result += openpgp_crypto_symmetricEncrypt(
	 				openpgp_crypto_getPrefixRandom(algo), algo, key, data, true);
	 		result = openpgp_packet.write_packet_header(9, result.length) + result;
	 		return result;
	 	}
	 
	 	function toString() {
	 		return '5.7.  Symmetrically Encrypted Data Packet (Tag 9)\n'
	 				+ '    length:  ' + this.packetLength + '\n'
	 				+ '    Used symmetric algorithm: ' + this.algorithmType + '\n'
	 				+ '    encrypted data: Bytes ['
	 				+ util.hexstrdump(this.encryptedData) + ']\n';
	 	}
	 	this.decrypt_sym = decrypt_sym;
	 	this.toString = toString;
	 	this.read_packet = read_packet;
	 	this.write_packet = write_packet;
	 };
	 // GPG4Browsers - An OpenPGP implementation in javascript
	 // Copyright (C) 2011 Recurity Labs GmbH
	 // 
	 // This library is free software; you can redistribute it and/or
	 // modify it under the terms of the GNU Lesser General Public
	 // License as published by the Free Software Foundation; either
	 // version 2.1 of the License, or (at your option) any later version.
	 // 
	 // This library is distributed in the hope that it will be useful,
	 // but WITHOUT ANY WARRANTY; without even the implied warranty of
	 // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
	 // Lesser General Public License for more details.
	 // 
	 // You should have received a copy of the GNU Lesser General Public
	 // License along with this library; if not, write to the Free Software
	 // Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
	 
	 /**
	  * @class
	  * @classdesc Implementation of the Sym. Encrypted Integrity Protected Data 
	  * Packet (Tag 18)
	  * 
	  * RFC4880 5.13: The Symmetrically Encrypted Integrity Protected Data packet is
	  * a variant of the Symmetrically Encrypted Data packet. It is a new feature
	  * created for OpenPGP that addresses the problem of detecting a modification to
	  * encrypted data. It is used in combination with a Modification Detection Code
	  * packet.
	  */
	 
	 function openpgp_packet_encryptedintegrityprotecteddata() {
	 	this.tagType = 18;
	 	this.version = null; // integer == 1
	 	this.packetLength = null; // integer
	 	this.encryptedData = null; // string
	 	this.decrytpedData = null; // string
	 	this.hash = null; // string
	 	/**
	 	 * Parsing function for the packet.
	 	 * 
	 	 * @param {String} input Payload of a tag 18 packet
	 	 * @param {Integer} position
	 	 *             position to start reading from the input string
	 	 * @param {Integer} len Length of the packet or the remaining length of
	 	 *            input at position
	 	 * @return {openpgp_packet_encryptedintegrityprotecteddata} object
	 	 *         representation
	 	 */
	 	function read_packet(input, position, len) {
	 		this.packetLength = len;
	 		// - A one-octet version number. The only currently defined value is
	 		// 1.
	 		this.version = input[position].charCodeAt();
	 		if (this.version != 1) {
	 			util
	 					.print_error('openpgp.packet.encryptedintegrityprotecteddata.js\nunknown encrypted integrity protected data packet version: '
	 							+ this.version
	 							+ " , @ "
	 							+ position
	 							+ "hex:"
	 							+ util.hexstrdump(input));
	 			return null;
	 		}
	 		// - Encrypted data, the output of the selected symmetric-key cipher
	 		//   operating in Cipher Feedback mode with shift amount equal to the
	 		//   block size of the cipher (CFB-n where n is the block size).
	 		this.encryptedData = input.substring(position + 1, position + 1 + len);
	 		util.print_debug("openpgp.packet.encryptedintegrityprotecteddata.js\n"
	 				+ this.toString());
	 		return this;
	 	}
	 
	 	/**
	 	 * Creates a string representation of a Sym. Encrypted Integrity Protected
	 	 * Data Packet (tag 18) (see RFC4880 5.13)
	 	 * 
	 	 * @param {Integer} symmetric_algorithm
	 	 *            The selected symmetric encryption algorithm to be used
	 	 * @param {String} key The key of cipher blocksize length to be used
	 	 * @param {String} data
	 	 *            Plaintext data to be encrypted within the packet
	 	 * @return {String} A string representation of the packet
	 	 */
	 	function write_packet(symmetric_algorithm, key, data) {
	 
	 		var prefixrandom = openpgp_crypto_getPrefixRandom(symmetric_algorithm);
	 		var prefix = prefixrandom
	 				+ prefixrandom.charAt(prefixrandom.length - 2)
	 				+ prefixrandom.charAt(prefixrandom.length - 1);
	 		var tohash = data;
	 		tohash += String.fromCharCode(0xD3);
	 		tohash += String.fromCharCode(0x14);
	 		util.print_debug_hexstr_dump("data to be hashed:"
	 				, prefix + tohash);
	 		tohash += str_sha1(prefix + tohash);
	 		util.print_debug_hexstr_dump("hash:"
	 				, tohash.substring(tohash.length - 20,
	 						tohash.length));
	 		var result = openpgp_crypto_symmetricEncrypt(prefixrandom,
	 				symmetric_algorithm, key, tohash, false).substring(0,
	 				prefix.length + tohash.length);
	 		var header = openpgp_packet.write_packet_header(18, result.length + 1)
	 				+ String.fromCharCode(1);
	 		this.encryptedData = result;
	 		return header + result;
	 	}
	 
	 	/**
	 	 * Decrypts the encrypted data contained in this object read_packet must
	 	 * have been called before
	 	 * 
	 	 * @param {Integer} symmetric_algorithm_type
	 	 *            The selected symmetric encryption algorithm to be used
	 	 * @param {String} key The key of cipher blocksize length to be used
	 	 * @return {String} The decrypted data of this packet
	 	 */
	 	function decrypt(symmetric_algorithm_type, key) {
	 		this.decryptedData = openpgp_crypto_symmetricDecrypt(
	 				symmetric_algorithm_type, key, this.encryptedData, false);
	 		// there must be a modification detection code packet as the
	 		// last packet and everything gets hashed except the hash itself
	 		this.hash = str_sha1(openpgp_crypto_MDCSystemBytes(
	 				symmetric_algorithm_type, key, this.encryptedData)
	 				+ this.decryptedData.substring(0,
	 						this.decryptedData.length - 20));
	 		util.print_debug_hexstr_dump("calc hash = ", this.hash);
	 		if (this.hash == this.decryptedData.substring(
	 				this.decryptedData.length - 20, this.decryptedData.length))
	 			return this.decryptedData;
	 		else
	 			util
	 					.print_error("Decryption stopped: discovered a modification of encrypted data.");
	 		return null;
	 	}
	 
	 	function toString() {
	 	    var data = '';
	 	    if(openpgp.config.debug)
	 	        data = '    data: Bytes ['
	 				+ util.hexstrdump(this.encryptedData) + ']';
	 	    
	 		return '5.13.  Sym. Encrypted Integrity Protected Data Packet (Tag 18)\n'
	 				+ '    length:  '
	 				+ this.packetLength
	 				+ '\n'
	 				+ '    version: '
	 				+ this.version
	 				+ '\n'
	 				+ data;
	 	}
	 
	 	this.write_packet = write_packet;
	 	this.read_packet = read_packet;
	 	this.toString = toString;
	 	this.decrypt = decrypt;
	 };
	 // GPG4Browsers - An OpenPGP implementation in javascript
	 // Copyright (C) 2011 Recurity Labs GmbH
	 // 
	 // This library is free software; you can redistribute it and/or
	 // modify it under the terms of the GNU Lesser General Public
	 // License as published by the Free Software Foundation; either
	 // version 2.1 of the License, or (at your option) any later version.
	 // 
	 // This library is distributed in the hope that it will be useful,
	 // but WITHOUT ANY WARRANTY; without even the implied warranty of
	 // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
	 // Lesser General Public License for more details.
	 // 
	 // You should have received a copy of the GNU Lesser General Public
	 // License along with this library; if not, write to the Free Software
	 // Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
	 
	 /**
	  * @class
	  * @classdesc Public-Key Encrypted Session Key Packets (Tag 1)
	  * 
	  * RFC4880 5.1: A Public-Key Encrypted Session Key packet holds the session key
	  * used to encrypt a message. Zero or more Public-Key Encrypted Session Key
	  * packets and/or Symmetric-Key Encrypted Session Key packets may precede a
	  * Symmetrically Encrypted Data Packet, which holds an encrypted message. The
	  * message is encrypted with the session key, and the session key is itself
	  * encrypted and stored in the Encrypted Session Key packet(s). The
	  * Symmetrically Encrypted Data Packet is preceded by one Public-Key Encrypted
	  * Session Key packet for each OpenPGP key to which the message is encrypted.
	  * The recipient of the message finds a session key that is encrypted to their
	  * public key, decrypts the session key, and then uses the session key to
	  * decrypt the message.
	  */
	 function openpgp_packet_encryptedsessionkey() {
	 
	 	/**
	 	 * Parsing function for a publickey encrypted session key packet (tag 1).
	 	 * 
	 	 * @param {String} input Payload of a tag 1 packet
	 	 * @param {Integer} position Position to start reading from the input string
	 	 * @param {Integer} len Length of the packet or the remaining length of
	 	 *            input at position
	 	 * @return {openpgp_packet_encrypteddata} Object representation
	 	 */
	 	function read_pub_key_packet(input, position, len) {
	 		this.tagType = 1;
	 		this.packetLength = len;
	 		var mypos = position;
	 		if (len < 10) {
	 			util
	 					.print_error("openpgp.packet.encryptedsessionkey.js\n" + 'invalid length');
	 			return null;
	 		}
	 
	 		this.version = input[mypos++].charCodeAt();
	 		this.keyId = new openpgp_type_keyid();
	 		this.keyId.read_packet(input, mypos);
	 		mypos += 8;
	 		this.publicKeyAlgorithmUsed = input[mypos++].charCodeAt();
	 
	 		switch (this.publicKeyAlgorithmUsed) {
	 		case 1:
	 		case 2: // RSA
	 			this.MPIs = new Array();
	 			this.MPIs[0] = new openpgp_type_mpi();
	 			this.MPIs[0].read(input, mypos, mypos - position);
	 			break;
	 		case 16: // Elgamal
	 			this.MPIs = new Array();
	 			this.MPIs[0] = new openpgp_type_mpi();
	 			this.MPIs[0].read(input, mypos, mypos - position);
	 			mypos += this.MPIs[0].packetLength;
	 			this.MPIs[1] = new openpgp_type_mpi();
	 			this.MPIs[1].read(input, mypos, mypos - position);
	 			break;
	 		default:
	 			util.print_error("openpgp.packet.encryptedsessionkey.js\n"
	 					+ "unknown public key packet algorithm type "
	 					+ this.publicKeyAlgorithmType);
	 			break;
	 		}
	 		return this;
	 	}
	 
	 	/**
	 	 * Create a string representation of a tag 1 packet
	 	 * 
	 	 * @param {String} publicKeyId
	 	 *             The public key id corresponding to publicMPIs key as string
	 	 * @param {openpgp_type_mpi[]} publicMPIs
	 	 *            Multiprecision integer objects describing the public key
	 	 * @param {Integer} pubalgo
	 	 *            The corresponding public key algorithm // See RFC4880 9.1
	 	 * @param {Integer} symmalgo
	 	 *            The symmetric cipher algorithm used to encrypt the data 
	 	 *            within an encrypteddatapacket or encryptedintegrity-
	 	 *            protecteddatapacket 
	 	 *            following this packet //See RFC4880 9.2
	 	 * @param {String} sessionkey
	 	 *            A string of randombytes representing the session key
	 	 * @return {String} The string representation
	 	 */
	 	function write_pub_key_packet(publicKeyId, publicMPIs, pubalgo, symmalgo,
	 			sessionkey) {
	 		var result = String.fromCharCode(3);
	 		var data = String.fromCharCode(symmalgo);
	 		data += sessionkey;
	 		var checksum = util.calc_checksum(sessionkey);
	 		data += String.fromCharCode((checksum >> 8) & 0xFF);
	 		data += String.fromCharCode((checksum) & 0xFF);
	 		result += publicKeyId;
	 		result += String.fromCharCode(pubalgo);
	 		var mpi = new openpgp_type_mpi();
	 		var mpiresult = openpgp_crypto_asymetricEncrypt(pubalgo, publicMPIs,
	 				mpi.create(openpgp_encoding_eme_pkcs1_encode(data,
	 						publicMPIs[0].mpiByteLength)));
	 		for ( var i = 0; i < mpiresult.length; i++) {
	 			result += mpiresult[i];
	 		}
	 		result = openpgp_packet.write_packet_header(1, result.length) + result;
	 		return result;
	 	}
	 
	 	/**
	 	 * Parsing function for a symmetric encrypted session key packet (tag 3).
	 	 * 
	 	 * @param {String} input Payload of a tag 1 packet
	 	 * @param {Integer} position Position to start reading from the input string
	 	 * @param {Integer} len
	 	 *            Length of the packet or the remaining length of
	 	 *            input at position
	 	 * @return {openpgp_packet_encrypteddata} Object representation
	 	 */
	 	function read_symmetric_key_packet(input, position, len) {
	 		this.tagType = 3;
	 		var mypos = position;
	 		// A one-octet version number. The only currently defined version is 4.
	 		this.version = input[mypos++];
	 
	 		// A one-octet number describing the symmetric algorithm used.
	 		this.symmetricKeyAlgorithmUsed = input[mypos++];
	 		// A string-to-key (S2K) specifier, length as defined above.
	 		this.s2k = new openpgp_type_s2k();
	 		this.s2k.read(input, mypos);
	 
	 		// Optionally, the encrypted session key itself, which is decrypted
	 		// with the string-to-key object.
	 		if ((s2k.s2kLength + mypos) < len) {
	 			this.encryptedSessionKey = new Array();
	 			for ( var i = (mypos - position); i < len; i++) {
	 				this.encryptedSessionKey[i] = input[mypos++];
	 			}
	 		}
	 		return this;
	 	}
	 	/**
	 	 * Decrypts the session key (only for public key encrypted session key
	 	 * packets (tag 1)
	 	 * 
	 	 * @param {openpgp_msg_message} msg
	 	 *            The message object (with member encryptedData
	 	 * @param {openpgp_msg_privatekey} key
	 	 *            Private key with secMPIs unlocked
	 	 * @return {String} The unencrypted session key
	 	 */
	 	function decrypt(msg, key) {
	 		if (this.tagType == 1) {
	 			var result = openpgp_crypto_asymetricDecrypt(
	 					this.publicKeyAlgorithmUsed, key.publicKey.MPIs,
	 					key.secMPIs, this.MPIs).toMPI();
	 			var checksum = ((result.charCodeAt(result.length - 2) << 8) + result
	 					.charCodeAt(result.length - 1));
	 			var decoded = openpgp_encoding_eme_pkcs1_decode(result.substring(2, result.length - 2), key.publicKey.MPIs[0].getByteLength());
	 			var sesskey = decoded.substring(1);
	 			var algo = decoded.charCodeAt(0);
	 			if (msg.encryptedData.tagType == 18)
	 				return msg.encryptedData.decrypt(algo, sesskey);
	 			else
	 				return msg.encryptedData.decrypt_sym(algo, sesskey);
	 		} else if (this.tagType == 3) {
	 			util
	 					.print_error("Symmetric encrypted sessionkey is not supported!");
	 			return null;
	 		}
	 	}
	 
	 	/**
	 	 * Creates a string representation of this object (useful for debug
	 	 * purposes)
	 	 * 
	 	 * @return {String} The string containing a openpgp description
	 	 */
	 	function toString() {
	 		if (this.tagType == 1) {
	 			var result = '5.1.  Public-Key Encrypted Session Key Packets (Tag 1)\n'
	 					+ '    KeyId:  '
	 					+ this.keyId.toString()
	 					+ '\n'
	 					+ '    length: '
	 					+ this.packetLength
	 					+ '\n'
	 					+ '    version:'
	 					+ this.version
	 					+ '\n'
	 					+ '    pubAlgUs:'
	 					+ this.publicKeyAlgorithmUsed + '\n';
	 			for ( var i = 0; i < this.MPIs.length; i++) {
	 				result += this.MPIs[i].toString();
	 			}
	 			return result;
	 		} else
	 			return '5.3 Symmetric-Key Encrypted Session Key Packets (Tag 3)\n'
	 					+ '    KeyId:  ' + this.keyId.toString() + '\n'
	 					+ '    length: ' + this.packetLength + '\n'
	 					+ '    version:' + this.version + '\n' + '    symKeyA:'
	 					+ this.symmetricKeyAlgorithmUsed + '\n' + '    s2k:    '
	 					+ this.s2k + '\n';
	 	}
	 
	 	this.read_pub_key_packet = read_pub_key_packet;
	 	this.read_symmetric_key_packet = read_symmetric_key_packet;
	 	this.write_pub_key_packet = write_pub_key_packet;
	 	this.toString = toString;
	 	this.decrypt = decrypt;
	 };
	 
	 // GPG4Browsers - An OpenPGP implementation in javascript
	 // Copyright (C) 2011 Recurity Labs GmbH
	 // 
	 // This library is free software; you can redistribute it and/or
	 // modify it under the terms of the GNU Lesser General Public
	 // License as published by the Free Software Foundation; either
	 // version 2.1 of the License, or (at your option) any later version.
	 // 
	 // This library is distributed in the hope that it will be useful,
	 // but WITHOUT ANY WARRANTY; without even the implied warranty of
	 // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
	 // Lesser General Public License for more details.
	 // 
	 // You should have received a copy of the GNU Lesser General Public
	 // License along with this library; if not, write to the Free Software
	 // Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
	 
	 /**
	  * @class
	  * @classdesc Parent openpgp packet class. Operations focus on determining 
	  * packet types and packet header.
	  */
	 function _openpgp_packet() {
	 	/**
	 	 * Encodes a given integer of length to the openpgp length specifier to a
	 	 * string
	 	 * 
	 	 * @param {Integer} length The length to encode
	 	 * @return {String} String with openpgp length representation
	 	 */
	 	function encode_length(length) {
	 		result = "";
	 		if (length < 192) {
	 			result += String.fromCharCode(length);
	 		} else if (length > 191 && length < 8384) {
	 			/*
	 			 * let a = (total data packet length) - 192 let bc = two octet
	 			 * representation of a let d = b + 192
	 			 */
	 			result += String.fromCharCode(((length - 192) >> 8) + 192);
	 			result += String.fromCharCode((length - 192) & 0xFF);
	 		} else {
	 			result += String.fromCharCode(255);
	 			result += String.fromCharCode((length >> 24) & 0xFF);
	 			result += String.fromCharCode((length >> 16) & 0xFF);
	 			result += String.fromCharCode((length >> 8) & 0xFF);
	 			result += String.fromCharCode(length & 0xFF);
	 		}
	 		return result;
	 	}
	 	this.encode_length = encode_length;
	 
	 	/**
	 	 * Writes a packet header version 4 with the given tag_type and length to a
	 	 * string
	 	 * 
	 	 * @param {Integer} tag_type Tag type
	 	 * @param {Integer} length Length of the payload
	 	 * @return {String} String of the header
	 	 */
	 	function write_packet_header(tag_type, length) {
	 		/* we're only generating v4 packet headers here */
	 		var result = "";
	 		result += String.fromCharCode(0xC0 | tag_type);
	 		result += encode_length(length);
	 		return result;
	 	}
	 
	 	/**
	 	 * Writes a packet header Version 3 with the given tag_type and length to a
	 	 * string
	 	 * 
	 	 * @param {Integer} tag_type Tag type
	 	 * @param {Integer} length Length of the payload
	 	 * @return {String} String of the header
	 	 */
	 	function write_old_packet_header(tag_type, length) {
	 		var result = "";
	 		if (length < 256) {
	 			result += String.fromCharCode(0x80 | (tag_type << 2));
	 			result += String.fromCharCode(length);
	 		} else if (length < 65536) {
	 			result += String.fromCharCode(0x80 | (tag_type << 2) | 1);
	 			result += String.fromCharCode(length >> 8);
	 			result += String.fromCharCode(length & 0xFF);
	 		} else {
	 			result += String.fromCharCode(0x80 | (tag_type << 2) | 2);
	 			result += String.fromCharCode((length >> 24) & 0xFF);
	 			result += String.fromCharCode((length >> 16) & 0xFF);
	 			result += String.fromCharCode((length >> 8) & 0xFF);
	 			result += String.fromCharCode(length & 0xFF);
	 		}
	 		return result;
	 	}
	 	this.write_old_packet_header = write_old_packet_header;
	 	this.write_packet_header = write_packet_header;
	 	/**
	 	 * Generic static Packet Parser function
	 	 * 
	 	 * @param {String} input Input stream as string
	 	 * @param {integer} position Position to start parsing
	 	 * @param {integer} len Length of the input from position on
	 	 * @return {Object} Returns a parsed openpgp_packet
	 	 */
	 	function read_packet(input, position, len) {
	 		// some sanity checks
	 		if (input == null || input.length <= position
	 				|| input.substring(position).length < 2
	 				|| (input[position].charCodeAt() & 0x80) == 0) {
	 			util
	 					.print_error("Error during parsing. This message / key is probably not containing a valid OpenPGP format.");
	 			return null;
	 		}
	 		var mypos = position;
	 		var tag = -1;
	 		var format = -1;
	 
	 		format = 0; // 0 = old format; 1 = new format
	 		if ((input[mypos].charCodeAt() & 0x40) != 0) {
	 			format = 1;
	 		}
	 
	 		var packet_length_type;
	 		if (format) {
	 			// new format header
	 			tag = input[mypos].charCodeAt() & 0x3F; // bit 5-0
	 		} else {
	 			// old format header
	 			tag = (input[mypos].charCodeAt() & 0x3F) >> 2; // bit 5-2
	 			packet_length_type = input[mypos].charCodeAt() & 0x03; // bit 1-0
	 		}
	 
	 		// header octet parsing done
	 		mypos++;
	 
	 		// parsed length from length field
	 		var bodydata = null;
	 
	 		// used for partial body lengths
	 		var real_packet_length = -1;
	 		if (!format) {
	 			// 4.2.1. Old Format Packet Lengths
	 			switch (packet_length_type) {
	 			case 0: // The packet has a one-octet length. The header is 2 octets
	 				// long.
	 				packet_length = input[mypos++].charCodeAt();
	 				break;
	 			case 1: // The packet has a two-octet length. The header is 3 octets
	 				// long.
	 				packet_length = (input[mypos++].charCodeAt() << 8)
	 						| input[mypos++].charCodeAt();
	 				break;
	 			case 2: // The packet has a four-octet length. The header is 5
	 				// octets long.
	 				packet_length = (input[mypos++].charCodeAt() << 24)
	 						| (input[mypos++].charCodeAt() << 16)
	 						| (input[mypos++].charCodeAt() << 8)
	 						| input[mypos++].charCodeAt();
	 				break;
	 			default:
	 				// 3 - The packet is of indeterminate length. The header is 1
	 				// octet long, and the implementation must determine how long
	 				// the packet is. If the packet is in a file, this means that
	 				// the packet extends until the end of the file. In general, 
	 				// an implementation SHOULD NOT use indeterminate-length 
	 				// packets except where the end of the data will be clear 
	 				// from the context, and even then it is better to use a 
	 				// definite length, or a new format header. The new format 
	 				// headers described below have a mechanism for precisely
	 				// encoding data of indeterminate length.
	 				packet_length = len;
	 				break;
	 			}
	 
	 		} else // 4.2.2. New Format Packet Lengths
	 		{
	 
	 			// 4.2.2.1. One-Octet Lengths
	 			if (input[mypos].charCodeAt() < 192) {
	 				packet_length = input[mypos++].charCodeAt();
	 				util.print_debug("1 byte length:" + packet_length);
	 				// 4.2.2.2. Two-Octet Lengths
	 			} else if (input[mypos].charCodeAt() >= 192
	 					&& input[mypos].charCodeAt() < 224) {
	 				packet_length = ((input[mypos++].charCodeAt() - 192) << 8)
	 						+ (input[mypos++].charCodeAt()) + 192;
	 				util.print_debug("2 byte length:" + packet_length);
	 				// 4.2.2.4. Partial Body Lengths
	 			} else if (input[mypos].charCodeAt() > 223
	 					&& input[mypos].charCodeAt() < 255) {
	 				packet_length = 1 << (input[mypos++].charCodeAt() & 0x1F);
	 				util.print_debug("4 byte length:" + packet_length);
	 				// EEEK, we're reading the full data here...
	 				var mypos2 = mypos + packet_length;
	 				bodydata = input.substring(mypos, mypos + packet_length);
	 				while (true) {
	 					if (input[mypos2].charCodeAt() < 192) {
	 						var tmplen = input[mypos2++].charCodeAt();
	 						packet_length += tmplen;
	 						bodydata += input.substring(mypos2, mypos2 + tmplen);
	 						mypos2 += tmplen;
	 						break;
	 					} else if (input[mypos2].charCodeAt() >= 192
	 							&& input[mypos2].charCodeAt() < 224) {
	 						var tmplen = ((input[mypos2++].charCodeAt() - 192) << 8)
	 								+ (input[mypos2++].charCodeAt()) + 192;
	 						packet_length += tmplen;
	 						bodydata += input.substring(mypos2, mypos2 + tmplen);
	 						mypos2 += tmplen;
	 						break;
	 					} else if (input[mypos2].charCodeAt() > 223
	 							&& input[mypos2].charCodeAt() < 255) {
	 						var tmplen = 1 << (input[mypos2++].charCodeAt() & 0x1F);
	 						packet_length += tmplen;
	 						bodydata += input.substring(mypos2, mypos2 + tmplen);
	 						mypos2 += tmplen;
	 					} else {
	 						mypos2++;
	 						var tmplen = (input[mypos2++].charCodeAt() << 24)
	 								| (input[mypos2++].charCodeAt() << 16)
	 								| (input[mypos2++].charCodeAt() << 8)
	 								| input[mypos2++].charCodeAt();
	 						bodydata += input.substring(mypos2, mypos2 + tmplen);
	 						packet_length += tmplen;
	 						mypos2 += tmplen;
	 						break;
	 					}
	 				}
	 				real_packet_length = mypos2;
	 				// 4.2.2.3. Five-Octet Lengths
	 			} else {
	 				mypos++;
	 				packet_length = (input[mypos++].charCodeAt() << 24)
	 						| (input[mypos++].charCodeAt() << 16)
	 						| (input[mypos++].charCodeAt() << 8)
	 						| input[mypos++].charCodeAt();
	 			}
	 		}
	 
	 		// if there was'nt a partial body length: use the specified
	 		// packet_length
	 		if (real_packet_length == -1) {
	 			real_packet_length = packet_length;
	 		}
	 
	 		if (bodydata == null) {
	 			bodydata = input.substring(mypos, mypos + real_packet_length);
	 		}
	 
	 		// alert('tag type: '+this.tag+' length: '+packet_length);
	 		var version = 1; // (old format; 2= new format)
	 		// if (input[mypos++].charCodeAt() > 15)
	 		// version = 2;
	 
	 		switch (tag) {
	 		case 0: // Reserved - a packet tag MUST NOT have this value
	 			break;
	 		case 1: // Public-Key Encrypted Session Key Packet
	 			var result = new openpgp_packet_encryptedsessionkey();
	 			if (result.read_pub_key_packet(bodydata, 0, packet_length) != null) {
	 				result.headerLength = mypos - position;
	 				result.packetLength = real_packet_length;
	 				return result;
	 			}
	 			break;
	 		case 2: // Signature Packet
	 			var result = new openpgp_packet_signature();
	 			if (result.read_packet(bodydata, 0, packet_length) != null) {
	 				result.headerLength = mypos - position;
	 				result.packetLength = real_packet_length;
	 				return result;
	 			}
	 			break;
	 		case 3: // Symmetric-Key Encrypted Session Key Packet
	 			var result = new openpgp_packet_encryptedsessionkey();
	 			if (result.read_symmetric_key_packet(bodydata, 0, packet_length) != null) {
	 				result.headerLength = mypos - position;
	 				result.packetLength = real_packet_length;
	 				return result;
	 			}
	 			break;
	 		case 4: // One-Pass Signature Packet
	 			var result = new openpgp_packet_onepasssignature();
	 			if (result.read_packet(bodydata, 0, packet_length)) {
	 				result.headerLength = mypos - position;
	 				result.packetLength = real_packet_length;
	 				return result;
	 			}
	 			break;
	 		case 5: // Secret-Key Packet
	 			var result = new openpgp_packet_keymaterial();
	 			result.header = input.substring(position, mypos);
	 			if (result.read_tag5(bodydata, 0, packet_length) != null) {
	 				result.headerLength = mypos - position;
	 				result.packetLength = real_packet_length;
	 				return result;
	 			}
	 			break;
	 		case 6: // Public-Key Packet
	 			var result = new openpgp_packet_keymaterial();
	 			result.header = input.substring(position, mypos);
	 			if (result.read_tag6(bodydata, 0, packet_length) != null) {
	 				result.headerLength = mypos - position;
	 				result.packetLength = real_packet_length;
	 				return result;
	 			}
	 			break;
	 		case 7: // Secret-Subkey Packet
	 			var result = new openpgp_packet_keymaterial();
	 			if (result.read_tag7(bodydata, 0, packet_length) != null) {
	 				result.headerLength = mypos - position;
	 				result.packetLength = real_packet_length;
	 				return result;
	 			}
	 			break;
	 		case 8: // Compressed Data Packet
	 			var result = new openpgp_packet_compressed();
	 			if (result.read_packet(bodydata, 0, packet_length) != null) {
	 				result.headerLength = mypos - position;
	 				result.packetLength = real_packet_length;
	 				return result;
	 			}
	 			break;
	 		case 9: // Symmetrically Encrypted Data Packet
	 			var result = new openpgp_packet_encrypteddata();
	 			if (result.read_packet(bodydata, 0, packet_length) != null) {
	 				result.headerLength = mypos - position;
	 				result.packetLength = real_packet_length;
	 				return result;
	 			}
	 			break;
	 		case 10: // Marker Packet = PGP (0x50, 0x47, 0x50)
	 			var result = new openpgp_packet_marker();
	 			if (result.read_packet(bodydata, 0, packet_length) != null) {
	 				result.headerLength = mypos - position;
	 				result.packetLength = real_packet_length;
	 				return result;
	 			}
	 			break;
	 		case 11: // Literal Data Packet
	 			var result = new openpgp_packet_literaldata();
	 			if (result.read_packet(bodydata, 0, packet_length) != null) {
	 				result.headerLength = mypos - position;
	 				result.header = input.substring(position, mypos);
	 				result.packetLength = real_packet_length;
	 				return result;
	 			}
	 			break;
	 		case 12: // Trust Packet
	 			// TODO: to be implemented
	 			break;
	 		case 13: // User ID Packet
	 			var result = new openpgp_packet_userid();
	 			if (result.read_packet(bodydata, 0, packet_length) != null) {
	 				result.headerLength = mypos - position;
	 				result.packetLength = real_packet_length;
	 				return result;
	 			}
	 			break;
	 		case 14: // Public-Subkey Packet
	 			var result = new openpgp_packet_keymaterial();
	 			result.header = input.substring(position, mypos);
	 			if (result.read_tag14(bodydata, 0, packet_length) != null) {
	 				result.headerLength = mypos - position;
	 				result.packetLength = real_packet_length;
	 				return result;
	 			}
	 			break;
	 		case 17: // User Attribute Packet
	 			var result = new openpgp_packet_userattribute();
	 			if (result.read_packet(bodydata, 0, packet_length) != null) {
	 				result.headerLength = mypos - position;
	 				result.packetLength = real_packet_length;
	 				return result;
	 			}
	 			break;
	 		case 18: // Sym. Encrypted and Integrity Protected Data Packet
	 			var result = new openpgp_packet_encryptedintegrityprotecteddata();
	 			if (result.read_packet(bodydata, 0, packet_length) != null) {
	 				result.headerLength = mypos - position;
	 				result.packetLength = real_packet_length;
	 				return result;
	 			}
	 			break;
	 		case 19: // Modification Detection Code Packet
	 			var result = new openpgp_packet_modificationdetectioncode();
	 			if (result.read_packet(bodydata, 0, packet_length) != null) {
	 				result.headerLength = mypos - position;
	 				result.packetLength = real_packet_length;
	 				return result;
	 			}
	 			break;
	 		default:
	 			util.print_error("openpgp.packet.js\n"
	 					+ "[ERROR] openpgp_packet: failed to parse packet @:"
	 					+ mypos + "\nchar:'"
	 					+ util.hexstrdump(input.substring(mypos)) + "'\ninput:"
	 					+ util.hexstrdump(input));
	 			return null;
	 			break;
	 		}
	 	}
	 
	 	this.read_packet = read_packet;
	 }
	 
	 var openpgp_packet = new _openpgp_packet();
	 // GPG4Browsers - An OpenPGP implementation in javascript
	 // Copyright (C) 2011 Recurity Labs GmbH
	 // 
	 // This library is free software; you can redistribute it and/or
	 // modify it under the terms of the GNU Lesser General Public
	 // License as published by the Free Software Foundation; either
	 // version 2.1 of the License, or (at your option) any later version.
	 // 
	 // This library is distributed in the hope that it will be useful,
	 // but WITHOUT ANY WARRANTY; without even the implied warranty of
	 // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
	 // Lesser General Public License for more details.
	 // 
	 // You should have received a copy of the GNU Lesser General Public
	 // License along with this library; if not, write to the Free Software
	 // Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
	 
	 /**
	  * @class
	  * @classdesc Implementation of the Key Material Packet (Tag 5,6,7,14)
	  *   
	  * RFC4480 5.5:
	  * A key material packet contains all the information about a public or
	  * private key.  There are four variants of this packet type, and two
	  * major versions.  Consequently, this section is complex.
	  */
	 function openpgp_packet_keymaterial() {
	 	// members:
	 	this.publicKeyAlgorithm = null;
	 	this.tagType = null;
	 	this.creationTime = null;
	 	this.version = null;
	 	this.expiration  = null;// V3
	 	this.MPIs = null;
	 	this.secMPIs = null;
	 	this.publicKey = null;
	 	this.symmetricEncryptionAlgorithm = null;
	 	this.s2kUsageConventions = null;
	 	this.IVLength  = null;
	     this.encryptedMPIData = null;
	     this.hasUnencryptedSecretKeyData = null;
	     this.checksum = null;
	     this.parentNode = null;
	 	this.subKeySignature = null;
	 	this.subKeyRevocationSignature = null;
	 
	 	// 5.5.1. Key Packet Variants
	 	
	 	// 5.5.1.3. Secret-Key Packet (Tag 5)
	 	/**
	 	 * This function reads the payload of a secret key packet (Tag 5)
	 	 * and initializes the openpgp_packet_keymaterial
	 	 * @param {String} input Input string to read the packet from
	 	 * @param {Integer} position Start position for the parser
	 	 * @param {Intefer} len Length of the packet or remaining length of input
	 	 * @return {openpgp_packet_keymaterial}
	 	 */
	 	function read_tag5(input, position, len) {
	 		this.tagType = 5;
	 		this.read_priv_key(input, position, len);
	 		return this;
	 	}
	 
	 	// 5.5.1.1. Public-Key Packet (Tag 6)
	 	/**
	 	 * This function reads the payload of a public key packet (Tag 6)
	 	 * and initializes the openpgp_packet_keymaterial
	 	 * @param {String} input Input string to read the packet from
	 	 * @param {Integer} position Start position for the parser
	 	 * @param {Integer} len Length of the packet or remaining length of input
	 	 * @return {openpgp_packet_keymaterial}
	 	 */
	 	function read_tag6(input, position, len) {
	 		// A Public-Key packet starts a series of packets that forms an OpenPGP
	 		// key (sometimes called an OpenPGP certificate).
	 		this.tagType = 6;
	 		this.packetLength = len;
	 		this.read_pub_key(input, position,len);
	 		
	 		return this;
	 	}
	 
	 	// 5.5.1.4. Secret-Subkey Packet (Tag 7)
	 	/**
	 	 * This function reads the payload of a secret key sub packet (Tag 7)
	 	 * and initializes the openpgp_packet_keymaterial
	 	 * @param {String} input Input string to read the packet from
	 	 * @param {Integer} position Start position for the parser
	 	 * @param {Integer} len Length of the packet or remaining length of input
	 	 * @return {openpgp_packet_keymaterial}
	 	 */
	 	function read_tag7(input, position, len) {
	 		this.tagType = 7;
	 		this.packetLength = len;
	 		return this.read_priv_key(input, position, len);
	 	}
	 
	 	// 5.5.1.2. Public-Subkey Packet (Tag 14)
	 	/**
	 	 * This function reads the payload of a public key sub packet (Tag 14)
	 	 * and initializes the openpgp_packet_keymaterial
	 	 * @param {String} input Input string to read the packet from
	 	 * @param {Integer} position Start position for the parser
	 	 * @param {Integer} len Length of the packet or remaining length of input
	 	 * @return {openpgp_packet_keymaterial}
	 	 */
	 	function read_tag14(input, position, len) {
	 		this.subKeySignature = null;
	 		this.subKeyRevocationSignature = new Array();
	 		this.tagType = 14;
	 		this.packetLength = len;
	 		this.read_pub_key(input, position,len);
	 		return this;
	 	}
	 	
	 	/**
	 	 * Internal Parser for public keys as specified in RFC 4880 section 
	 	 * 5.5.2 Public-Key Packet Formats
	 	 * called by read_tag&lt;num&gt;
	 	 * @param {String} input Input string to read the packet from
	 	 * @param {Integer} position Start position for the parser
	 	 * @param {Integer} len Length of the packet or remaining length of input
	 	 * @return {Object} This object with attributes set by the parser
	 	 */  
	 	function read_pub_key(input, position, len) {
	 		var mypos = position;
	 		// A one-octet version number (3 or 4).
	 		this.version = input[mypos++].charCodeAt();
	 		if (this.version == 3) {
	 			// A four-octet number denoting the time that the key was created.
	 			this.creationTime = new Date(((input[mypos++].charCodeAt() << 24) |
	 				(input[mypos++].charCodeAt() << 16) |
	 				(input[mypos++].charCodeAt() <<  8) |
	 				(input[mypos++].charCodeAt()))*1000);
	 			
	 		    // - A two-octet number denoting the time in days that this key is
	 		    //   valid.  If this number is zero, then it does not expire.
	 			this.expiration = (input[mypos++].charCodeAt() << 8) & input[mypos++].charCodeAt();
	 	
	 		    // - A one-octet number denoting the public-key algorithm of this key.
	 			this.publicKeyAlgorithm = input[mypos++].charCodeAt();
	 			var mpicount = 0;
	 		    // - A series of multiprecision integers comprising the key material:
	 			//   Algorithm-Specific Fields for RSA public keys:
	 		    //       - a multiprecision integer (MPI) of RSA public modulus n;
	 		    //       - an MPI of RSA public encryption exponent e.
	 			if (this.publicKeyAlgorithm > 0 && this.publicKeyAlgorithm < 4)
	 				mpicount = 2;
	 			//   Algorithm-Specific Fields for Elgamal public keys:
	 			//     - MPI of Elgamal prime p;
	 			//     - MPI of Elgamal group generator g;
	 			//     - MPI of Elgamal public key value y (= g**x mod p where x  is secret).
	 
	 			else if (this.publicKeyAlgorithm == 16)
	 				mpicount = 3;
	 			//   Algorithm-Specific Fields for DSA public keys:
	 			//       - MPI of DSA prime p;
	 			//       - MPI of DSA group order q (q is a prime divisor of p-1);
	 			//       - MPI of DSA group generator g;
	 			//       - MPI of DSA public-key value y (= g**x mod p where x  is secret).
	 			else if (this.publicKeyAlgorithm == 17)
	 				mpicount = 4;
	 
	 			this.MPIs = new Array();
	 			for (var i = 0; i < mpicount; i++) {
	 				this.MPIs[i] = new openpgp_type_mpi();
	 				if (this.MPIs[i].read(input, mypos, (mypos-position)) != null && 
	 						!this.packetLength < (mypos-position)) {
	 					mypos += this.MPIs[i].packetLength;
	 				} else {
	 					util.print_error("openpgp.packet.keymaterial.js\n"+'error reading MPI @:'+mypos);
	 				}
	 			}
	 			this.packetLength = mypos-position;
	 		} else if (this.version == 4) {
	 			// - A four-octet number denoting the time that the key was created.
	 			this.creationTime = new Date(((input[mypos++].charCodeAt() << 24) |
	 			(input[mypos++].charCodeAt() << 16) |
	 			(input[mypos++].charCodeAt() <<  8) |
	 			(input[mypos++].charCodeAt()))*1000);
	 			
	 			// - A one-octet number denoting the public-key algorithm of this key.
	 			this.publicKeyAlgorithm = input[mypos++].charCodeAt();
	 			var mpicount = 0;
	 		    // - A series of multiprecision integers comprising the key material:
	 			//   Algorithm-Specific Fields for RSA public keys:
	 		    //       - a multiprecision integer (MPI) of RSA public modulus n;
	 		    //       - an MPI of RSA public encryption exponent e.
	 			if (this.publicKeyAlgorithm > 0 && this.publicKeyAlgorithm < 4)
	 					mpicount = 2;
	 			//   Algorithm-Specific Fields for Elgamal public keys:
	 			//     - MPI of Elgamal prime p;
	 			//     - MPI of Elgamal group generator g;
	 			//     - MPI of Elgamal public key value y (= g**x mod p where x  is secret).
	 			else if (this.publicKeyAlgorithm == 16)
	 				mpicount = 3;
	 
	 			//   Algorithm-Specific Fields for DSA public keys:
	 			//       - MPI of DSA prime p;
	 			//       - MPI of DSA group order q (q is a prime divisor of p-1);
	 			//       - MPI of DSA group generator g;
	 			//       - MPI of DSA public-key value y (= g**x mod p where x  is secret).
	 			else if (this.publicKeyAlgorithm == 17)
	 				mpicount = 4;
	 
	 			this.MPIs = new Array();
	 			var i = 0;
	 			for (var i = 0; i < mpicount; i++) {
	 				this.MPIs[i] = new openpgp_type_mpi();
	 				if (this.MPIs[i].read(input, mypos, (mypos-position)) != null &&
	 						!this.packetLength < (mypos-position)) {
	 					mypos += this.MPIs[i].packetLength;
	 				} else {
	 					util.print_error("openpgp.packet.keymaterial.js\n"+'error reading MPI @:'+mypos);
	 				}
	 			}
	 			this.packetLength = mypos-position;
	 		} else {
	 			return null;
	 		}
	 		this.data = input.substring(position, mypos);
	 		this.packetdata = input.substring(position, mypos);
	 		return this;
	 	}
	 	
	 	// 5.5.3.  Secret-Key Packet Formats
	 	
	 	/**
	 	 * Internal parser for private keys as specified in RFC 4880 section 5.5.3
	 	 * @param {String} input Input string to read the packet from
	 	 * @param {Integer} position Start position for the parser
	 	 * @param {Integer} len Length of the packet or remaining length of input
	 	 * @return {Object} This object with attributes set by the parser
	 	 */
	 	function read_priv_key(input,position, len) {
	 	    // - A Public-Key or Public-Subkey packet, as described above.
	 	    this.publicKey = new openpgp_packet_keymaterial();
	 		if (this.publicKey.read_pub_key(input,position, len) == null) {
	 			util.print_error("openpgp.packet.keymaterial.js\n"+"Failed reading public key portion of a private key: "+input[position].charCodeAt()+" "+position+" "+len+"\n Aborting here...");
	 			return null;
	 		}
	 		this.publicKey.header = openpgp_packet.write_old_packet_header(6,this.publicKey.packetLength);
	 		// this.publicKey.header = String.fromCharCode(0x99) + String.fromCharCode(this.publicKey.packetLength >> 8 & 0xFF)+String.fromCharCode(this.publicKey.packetLength & 0xFF);
	 		var mypos = position + this.publicKey.data.length;
	 		this.packetLength = len;
	 		
	 	    // - One octet indicating string-to-key usage conventions.  Zero
	 	    //   indicates that the secret-key data is not encrypted.  255 or 254
	 	    //   indicates that a string-to-key specifier is being given.  Any
	 	    //   other value is a symmetric-key encryption algorithm identifier.
	 	    this.s2kUsageConventions = input[mypos++].charCodeAt();
	 	    
	 	    if (this.s2kUsageConventions == 0)
	 	    	this.hasUnencryptedSecretKeyData = true;
	 	   
	 	    // - [Optional] If string-to-key usage octet was 255 or 254, a one-
	 	    //   octet symmetric encryption algorithm.
	 	    if (this.s2kUsageConventions == 255 || this.s2kUsageConventions == 254) {
	 	    	this.symmetricEncryptionAlgorithm = input[mypos++].charCodeAt();
	 	    }
	 	     
	 	    // - [Optional] If string-to-key usage octet was 255 or 254, a
	 	    //   string-to-key specifier.  The length of the string-to-key
	 	    //   specifier is implied by its type, as described above.
	 	    if (this.s2kUsageConventions == 255 || this.s2kUsageConventions == 254) {
	 	    	this.s2k = new openpgp_type_s2k();
	 	    	this.s2k.read(input, mypos);
	 	    	mypos +=this.s2k.s2kLength;
	 	    }
	 	    
	 	    // - [Optional] If secret data is encrypted (string-to-key usage octet
	 	    //   not zero), an Initial Vector (IV) of the same length as the
	 	    //   cipher's block size.
	 	    this.symkeylength = 0;
	 	    if (this.s2kUsageConventions != 0 && this.s2kUsageConventions != 255 &&
	 	    		this.s2kUsageConventions != 254) {
	 	    	this.symmetricEncryptionAlgorithm = this.s2kUsageConventions;
	 	    }
	 	    if (this.s2kUsageConventions != 0 && this.s2k.type != 1001) {
	 	    	this.hasIV = true;
	 	    	switch (this.symmetricEncryptionAlgorithm) {
	 		    case  1: // - IDEA [IDEA]
	 		    	util.print_error("openpgp.packet.keymaterial.js\n"+"symmetric encrytryption algorithim: IDEA is not implemented");
	 		    	return null;
	 	    	case  2: // - TripleDES (DES-EDE, [SCHNEIER] [HAC] - 168 bit key derived from 192)
	 	    	case  3: // - CAST5 (128 bit key, as per [RFC2144])
	 	    		this.IVLength = 8;
	 		    	break;
	 		    case  4: // - Blowfish (128 bit key, 16 rounds) [BLOWFISH]
	 		    case  7: // - AES with 128-bit key [AES]
	 	    	case  8: // - AES with 192-bit key
	 	    	case  9: // - AES with 256-bit key
	 	    		this.IVLength = 16;
	 		    	break;
	 	    	case 10: // - Twofish with 256-bit key [TWOFISH]
	 	    		this.IVLength = 32;	    		
	 		    	break;
	 	    	case  5: // - Reserved
	 	    	case  6: // - Reserved
	 	    	default:
	 	    		util.print_error("openpgp.packet.keymaterial.js\n"+"unknown encryption algorithm for secret key :"+this.symmetricEncryptionAlgorithm);
	 	    		return null;
	 	    	}
	 	    	mypos++; 
	 	    	this.IV = input.substring(mypos, mypos+this.IVLength);
	 	    	mypos += this.IVLength;
	 	    }
	 	    // - Plain or encrypted multiprecision integers comprising the secret
	 	    //   key data.  These algorithm-specific fields are as described
	 	    //   below.
	 
	       // s2k type 1001 corresponds to GPG specific extension without primary key secrets
	       // http://www.gnupg.org/faq/GnuPG-FAQ.html#how-can-i-use-gnupg-in-an-automated-environment
	 	    if (this.s2kUsageConventions != 0 && this.s2k.type == 1001) {
	 	    	this.secMPIs = null;
	 	    	this.encryptedMPIData = null;
	 	    } else if (!this.hasUnencryptedSecretKeyData) {
	 	    	this.encryptedMPIData = input.substring(mypos, len);
	 	    	mypos += this.encryptedMPIData.length;
	 	    } else {
	 	    	if (this.publicKey.publicKeyAlgorithm > 0 && this.publicKey.publicKeyAlgorithm < 4) {
	 	    		//   Algorithm-Specific Fields for RSA secret keys:
	 	    		//   - multiprecision integer (MPI) of RSA secret exponent d.
	 	    		//   - MPI of RSA secret prime value p.
	 	    		//   - MPI of RSA secret prime value q (p < q).
	 	    		//   - MPI of u, the multiplicative inverse of p, mod q.
	 	    		this.secMPIs = new Array();
	 	    		this.secMPIs[0] = new openpgp_type_mpi();
	 	    		this.secMPIs[0].read(input, mypos, len-2- (mypos - position));
	 	    		mypos += this.secMPIs[0].packetLength;
	 	    		this.secMPIs[1] = new openpgp_type_mpi();
	 	    		this.secMPIs[1].read(input, mypos, len-2- (mypos - position));
	 	    		mypos += this.secMPIs[1].packetLength;
	 	    		this.secMPIs[2] = new openpgp_type_mpi();
	 	    		this.secMPIs[2].read(input, mypos, len-2- (mypos - position));
	 	    		mypos += this.secMPIs[2].packetLength;
	 	    		this.secMPIs[3] = new openpgp_type_mpi();
	 	    		this.secMPIs[3].read(input, mypos, len-2- (mypos - position));
	 	    		mypos += this.secMPIs[3].packetLength;
	 	    	} else if (this.publicKey.publicKeyAlgorithm == 16) {
	 	    		// Algorithm-Specific Fields for Elgamal secret keys:
	 	    		//   - MPI of Elgamal secret exponent x.
	 	    		this.secMPIs = new Array();
	 	    		this.secMPIs[0] = new openpgp_type_mpi();
	 	    		this.secMPIs[0].read(input, mypos, len-2- (mypos - position));
	 	    		mypos += this.secMPIs[0].packetLength;
	 	    	} else if (this.publicKey.publicKeyAlgorithm == 17) {
	 	    		// Algorithm-Specific Fields for DSA secret keys:
	 	    		//   - MPI of DSA secret exponent x.
	 	    		this.secMPIs = new Array();
	 	    		this.secMPIs[0] = new openpgp_type_mpi();
	 	    		this.secMPIs[0].read(input, mypos, len-2- (mypos - position));
	 	    		mypos += this.secMPIs[0].packetLength;
	 	    	}
	 	    	// checksum because s2k usage convention is 0
	 	        this.checksum = new Array(); 
	 		    this.checksum[0] = input[mypos++].charCodeAt();
	 		    this.checksum[1] = input[mypos++].charCodeAt();
	 	    }
	 	    return this;
	 	}
	 	
	 
	 	/**
	 	 * Decrypts the private key MPIs which are needed to use the key.
	 	 * openpgp_packet_keymaterial.hasUnencryptedSecretKeyData should be 
	 	 * false otherwise
	 	 * a call to this function is not needed
	 	 * 
	 	 * @param {String} str_passphrase The passphrase for this private key 
	 	 * as string
	 	 * @return {Boolean} True if the passphrase was correct; false if not
	 	 */
	 	function decryptSecretMPIs(str_passphrase) {
	 		if (this.hasUnencryptedSecretKeyData)
	 			return this.secMPIs;
	 		// creating a key out of the passphrase
	 		var key = this.s2k.produce_key(str_passphrase);
	 		var cleartextMPIs = "";
	     	switch (this.symmetricEncryptionAlgorithm) {
	 	    case  1: // - IDEA [IDEA]
	 	    	util.print_error("openpgp.packet.keymaterial.js\n"+"symmetric encryption algorithim: IDEA is not implemented");
	 	    	return false;
	     	case  2: // - TripleDES (DES-EDE, [SCHNEIER] [HAC] - 168 bit key derived from 192)
	     		cleartextMPIs = normal_cfb_decrypt(function(block, key) {
	     			return des(key, block,1,null,0);
	     		}, this.IVLength, key, this.encryptedMPIData, this.IV);
	     		break;
	     	case  3: // - CAST5 (128 bit key, as per [RFC2144])
	     		cleartextMPIs = normal_cfb_decrypt(function(block, key) {
	         		var cast5 = new openpgp_symenc_cast5();
	         		cast5.setKey(key);
	         		return cast5.encrypt(util.str2bin(block)); 
	     		}, this.IVLength, util.str2bin(key.substring(0,16)), this.encryptedMPIData, this.IV);
	     		break;
	 	    case  4: // - Blowfish (128 bit key, 16 rounds) [BLOWFISH]
	 	    	cleartextMPIs = normal_cfb_decrypt(function(block, key) {
	     			var blowfish = new Blowfish(key);
	         		return blowfish.encrypt(block); 
	     		}, this.IVLength, key, this.encryptedMPIData, this.IV);
	     		break;
	 	    case  7: // - AES with 128-bit key [AES]
	     	case  8: // - AES with 192-bit key
	     	case  9: // - AES with 256-bit key
	     	    var numBytes = 16;
	             //This is a weird way to achieve this. If's within a switch is probably not ideal.
	     	    if(this.symmetricEncryptionAlgorithm == 8){
	     	        numBytes = 24;
	     	        key = this.s2k.produce_key(str_passphrase,numBytes);
	     	    }
	     	    if(this.symmetricEncryptionAlgorithm == 9){
	     	        numBytes = 32;
	     	        key = this.s2k.produce_key(str_passphrase,numBytes);
	     	    }
	     		cleartextMPIs = normal_cfb_decrypt(function(block,key){
	     		    return AESencrypt(util.str2bin(block),key);
	     		},
	     				this.IVLength, keyExpansion(key.substring(0,numBytes)), this.encryptedMPIData, this.IV);
	 	    	break;
	     	case 10: // - Twofish with 256-bit key [TWOFISH]
	     		util.print_error("openpgp.packet.keymaterial.js\n"+"Key material is encrypted with twofish: not implemented");   		
	 	    	return false;
	     	case  5: // - Reserved
	     	case  6: // - Reserved
	     	default:
	     		util.print_error("openpgp.packet.keymaterial.js\n"+"unknown encryption algorithm for secret key :"+this.symmetricEncryptionAlgorithm);
	     		return false;
	     	}
	     	
	     	if (cleartextMPIs == null) {
	     		util.print_error("openpgp.packet.keymaterial.js\n"+"cleartextMPIs was null");
	     		return false;
	     	}
	     	
	     	var cleartextMPIslength = cleartextMPIs.length;
	 
	     	if (this.s2kUsageConventions == 254 &&
	     			str_sha1(cleartextMPIs.substring(0,cleartextMPIs.length - 20)) == 
	     				cleartextMPIs.substring(cleartextMPIs.length - 20)) {
	     		cleartextMPIslength -= 20;
	     	} else if (this.s2kUsageConventions != 254 && util.calc_checksum(cleartextMPIs.substring(0,cleartextMPIs.length - 2)) == 
	     			(cleartextMPIs.charCodeAt(cleartextMPIs.length -2) << 8 | cleartextMPIs.charCodeAt(cleartextMPIs.length -1))) {
	     		cleartextMPIslength -= 2;
	     	} else {
	     		return false;
	     	}
	 
	     	if (this.publicKey.publicKeyAlgorithm > 0 && this.publicKey.publicKeyAlgorithm < 4) {
	     		//   Algorithm-Specific Fields for RSA secret keys:
	     		//   - multiprecision integer (MPI) of RSA secret exponent d.
	     		//   - MPI of RSA secret prime value p.
	     		//   - MPI of RSA secret prime value q (p < q).
	     		//   - MPI of u, the multiplicative inverse of p, mod q.
	     		var mypos = 0;
	     		this.secMPIs = new Array();
	     		this.secMPIs[0] = new openpgp_type_mpi();
	     		this.secMPIs[0].read(cleartextMPIs, 0, cleartextMPIslength);
	     		mypos += this.secMPIs[0].packetLength;
	     		this.secMPIs[1] = new openpgp_type_mpi();
	     		this.secMPIs[1].read(cleartextMPIs, mypos, cleartextMPIslength-mypos);
	     		mypos += this.secMPIs[1].packetLength;
	     		this.secMPIs[2] = new openpgp_type_mpi();
	     		this.secMPIs[2].read(cleartextMPIs, mypos, cleartextMPIslength-mypos);
	     		mypos += this.secMPIs[2].packetLength;
	     		this.secMPIs[3] = new openpgp_type_mpi();
	     		this.secMPIs[3].read(cleartextMPIs, mypos, cleartextMPIslength-mypos);
	     		mypos += this.secMPIs[3].packetLength;
	     	} else if (this.publicKey.publicKeyAlgorithm == 16) {
	     		// Algorithm-Specific Fields for Elgamal secret keys:
	     		//   - MPI of Elgamal secret exponent x.
	     		this.secMPIs = new Array();
	     		this.secMPIs[0] = new openpgp_type_mpi();
	     		this.secMPIs[0].read(cleartextMPIs, 0, cleartextMPIs);
	     	} else if (this.publicKey.publicKeyAlgorithm == 17) {
	     		// Algorithm-Specific Fields for DSA secret keys:
	     		//   - MPI of DSA secret exponent x.
	     		this.secMPIs = new Array();
	     		this.secMPIs[0] = new openpgp_type_mpi();
	     		this.secMPIs[0].read(cleartextMPIs, 0, cleartextMPIslength);
	     	}
	     	return true;
	 	}
	 	
	 	/**
	 	 * Generates Debug output
	 	 * @return String which gives some information about the keymaterial
	 	 */
	 	function toString() {
	 		var result = "";
	 		switch (this.tagType) {
	 		case 6:
	 			 result += '5.5.1.1. Public-Key Packet (Tag 6)\n'+
	 			   '    length:             '+this.packetLength+'\n'+
	 			   '    version:            '+this.version+'\n'+
	 			   '    creation time:      '+this.creationTime+'\n'+
	 			   '    expiration time:    '+this.expiration+'\n'+
	 			   '    publicKeyAlgorithm: '+this.publicKeyAlgorithm+'\n';
	 			break;
	 		case 14:
	 			result += '5.5.1.2. Public-Subkey Packet (Tag 14)\n'+
	 			   '    length:             '+this.packetLength+'\n'+
	 			   '    version:            '+this.version+'\n'+
	 			   '    creation time:      '+this.creationTime+'\n'+
	 			   '    expiration time:    '+this.expiration+'\n'+
	 			   '    publicKeyAlgorithm: '+this.publicKeyAlgorithm+'\n';
	 			break;
	 		case 5:
	 			result +='5.5.1.3. Secret-Key Packet (Tag 5)\n'+
	 			   '    length:             '+this.packetLength+'\n'+
	 			   '    version:            '+this.publicKey.version+'\n'+
	 			   '    creation time:      '+this.publicKey.creationTime+'\n'+
	 			   '    expiration time:    '+this.publicKey.expiration+'\n'+
	 			   '    publicKeyAlgorithm: '+this.publicKey.publicKeyAlgorithm+'\n';
	 			break;
	 		case 7:
	 			result += '5.5.1.4. Secret-Subkey Packet (Tag 7)\n'+
	 			   '    length:             '+this.packetLength+'\n'+
	 			   '    version[1]:         '+(this.version == 4)+'\n'+
	 			   '    creationtime[4]:    '+this.creationTime+'\n'+
	 			   '    expiration[2]:      '+this.expiration+'\n'+
	 			   '    publicKeyAlgorithm: '+this.publicKeyAlgorithm+'\n';
	 			break;
	 		default:
	 			result += 'unknown key material packet\n';
	 		}
	 		if (this.MPIs != null) {
	 			result += "Public Key MPIs:\n";
	 			for (var i = 0; i < this.MPIs.length; i++) {
	       	  	result += this.MPIs[i].toString();
	         	}
	 		}
	 		if (this.publicKey != null && this.publicKey.MPIs != null) {
	 			result += "Public Key MPIs:\n";
	 			for (var i = 0; i < this.publicKey.MPIs.length; i++) {
	 	      	  	result += this.publicKey.MPIs[i].toString();
	         	}
	 		}
	 		if (this.secMPIs != null) {
	 			result += "Secret Key MPIs:\n";
	 			for (var i = 0; i < this.secMPIs.length; i++) {
	 		      	  result += this.secMPIs[i].toString();
	 		        }
	 		}
	 		
	 		if (this.subKeySignature != null)
	 			result += "subKey Signature:\n"+this.subKeySignature.toString();
	 		
	 		if (this.subKeyRevocationSignature != null )
	 			result += "subKey Revocation Signature:\n"+this.subKeyRevocationSignature.toString();
	         return result;
	 	}
	 	
	 	/**
	 	 * Continue parsing packets belonging to the key material such as signatures
	 	 * @param {Object} parent_node The parent object
	 	 * @param {String} input Input string to read the packet(s) from
	 	 * @param {Integer} position Start position for the parser
	 	 * @param {Integer} len Length of the packet(s) or remaining length of input
	 	 * @return {Integer} Length of nodes read
	 	 */
	 	function read_nodes(parent_node, input, position, len) {
	 		this.parentNode = parent_node;
	 		if (this.tagType == 14) { // public sub-key packet
	 			var pos = position;
	 			var result = null;
	 			while (input.length != pos) {
	 				var l = input.length - pos;
	 				result = openpgp_packet.read_packet(input, pos, l);
	 				if (result == null) {
	 					util.print_error("openpgp.packet.keymaterial.js\n"+'[user_keymat_pub]parsing ends here @:' + pos + " l:" + l);
	 					break;
	 				} else {
	 					
	 					switch (result.tagType) {
	 					case 2: // Signature Packet certification signature
	 						if (result.signatureType == 24)  { // subkey binding signature
	 							this.subKeySignature = result;
	 							pos += result.packetLength + result.headerLength;
	 							break;
	 						} else if (result.signatureType == 40) { // subkey revocation signature
	 							this.subKeyRevocationSignature[this.subKeyRevocationSignature.length] = result;
	 							pos += result.packetLength + result.headerLength;
	 							break;
	 						} else {
	 							util.print_error("openpgp.packet.keymaterial.js\nunknown signature:"+result.toString());
	 						}
	 						
	 					default:
	 						this.data = input;
	 						this.position = position - this.parentNode.packetLength;
	 						this.len = pos - position;
	 						return this.len;
	 						break;
	 					}
	 				}
	 			}
	 			this.data = input;
	 			this.position = position - this.parentNode.packetLength;
	 			this.len = pos - position;
	 			return this.len;
	 		} else if (this.tagType == 7) { // private sub-key packet
	 			var pos = position;
	 			while (input.length != pos) {
	 				var result = openpgp_packet.read_packet(input, pos, len - (pos - position));
	 				if (result == null) {
	 					util.print_error("openpgp.packet.keymaterial.js\n"+'[user_keymat_priv] parsing ends here @:' + pos);
	 					break;
	 				} else {
	 					switch (result.tagType) {
	 					case 2: // Signature Packet certification signature
	 						if (result.signatureType == 24) // subkey embedded signature
	 							this.subKeySignature = result; 
	 						else if (result.signatureType == 40) // subkey revocation signature
	 							this.subKeyRevocationSignature[this.subKeyRevocationSignature.length] = result;
	 						pos += result.packetLength + result.headerLength;
	 						break;
	 					default:
	 						this.data = input;
	 						this.position = position - this.parentNode.packetLength;
	 						this.len = pos - position;
	 						return this.len;
	 					}
	 				}
	 			}
	 			this.data = input;
	 			this.position = position - this.parentNode.packetLength;
	 			this.len = pos - position;
	 			return this.len;
	 		} else {
	 			util.print_error("openpgp.packet.keymaterial.js\n"+"unknown parent node for a key material packet "+parent_node.tagType);
	 		}
	 	}
	 
	 	/**
	 	 * Checks the validity for usage of this (sub)key
	 	 * @return {Integer} 0 = bad key, 1 = expired, 2 = revoked, 3 = valid
	 	 */
	 	function verifyKey() {
	 		if (this.tagType == 14) {
	 			if (this.subKeySignature == null) {
	 				return 0;
	 			}
	 			if (this.subKeySignature.version == 4 &&
	 				this.subKeySignature.keyNeverExpires != null &&
	 				!this.subKeySignature.keyNeverExpires &&
	 				new Date((this.subKeySignature.keyExpirationTime*1000)+ this.creationTime.getTime()) < new Date()) {
	 				    return 1;
	 				}
	 			var hashdata = String.fromCharCode(0x99)+this.parentNode.header.substring(1)+this.parentNode.data+
	 			String.fromCharCode(0x99)+this.header.substring(1)+this.packetdata;
	 			if (!this.subKeySignature.verify(hashdata,this.parentNode)) {
	 				return 0;
	 			}
	 			for (var i = 0; i < this.subKeyRevocationSignature.length; i++) {
	 			    if (this.getKeyId() == this.subKeyRevocationSignature[i].keyId){
	 			        return 2;
	 			    }
	 			}
	 		}
	 		return 3;
	 	}
	 
	 	/**
	 	 * Calculates the key id of they key 
	 	 * @return {String} A 8 byte key id
	 	 */
	 	function getKeyId() {
	 		if (this.version == 4) {
	 			var f = this.getFingerprint();
	 			return f.substring(12,20);
	 		} else if (this.version == 3 && this.publicKeyAlgorithm > 0 && this.publicKeyAlgorithm < 4) {
	 			var key_id = this.MPIs[0].MPI.substring((this.MPIs[0].mpiByteLength-8));
	 			util.print_debug("openpgp.msg.publickey read_nodes:\n"+"V3 key ID: "+key_id);
	 			return key_id;
	 		}
	 	}
	 	
	 	/**
	 	 * Calculates the fingerprint of the key
	 	 * @return {String} A string containing the fingerprint
	 	 */
	 	function getFingerprint() {
	 		if (this.version == 4) {
	 			tohash = String.fromCharCode(0x99)+ String.fromCharCode(((this.packetdata.length) >> 8) & 0xFF) 
	 				+ String.fromCharCode((this.packetdata.length) & 0xFF)+this.packetdata;
	 			util.print_debug("openpgp.msg.publickey creating subkey fingerprint by hashing:"+util.hexstrdump(tohash)+"\npublickeyalgorithm: "+this.publicKeyAlgorithm);
	 			return str_sha1(tohash, tohash.length);
	 		} else if (this.version == 3 && this.publicKeyAlgorithm > 0 && this.publicKeyAlgorithm < 4) {
	 			return MD5(this.MPIs[0].MPI);
	 		}
	 	}
	 	
	 	/*
	      * Creates an OpenPGP key packet for the given key. much 
	 	 * TODO in regards to s2k, subkeys.
	      * @param {Integer} keyType Follows the OpenPGP algorithm standard, 
	 	 * IE 1 corresponds to RSA.
	      * @param {RSA.keyObject} key
	      * @param password
	      * @param s2kHash
	      * @param symmetricEncryptionAlgorithm
	      * @param timePacket
	      * @return {Object} {body: [string]OpenPGP packet body contents, 
	 		header: [string] OpenPGP packet header, string: [string] header+body}
	      */
	     function write_private_key(keyType, key, password, s2kHash, symmetricEncryptionAlgorithm, timePacket){
	         this.symmetricEncryptionAlgorithm = symmetricEncryptionAlgorithm;
	 		var tag = 5;
	 		var body = String.fromCharCode(4);
	 		body += timePacket;
	 		switch(keyType){
	 		case 1:
	 		    body += String.fromCharCode(keyType);//public key algo
	 		    body += key.n.toMPI();
	 		    body += key.ee.toMPI();
	 		    var algorithmStart = body.length;
	 		    //below shows ske/s2k
	 		    if(password){
	 		        body += String.fromCharCode(254); //octet of 254 indicates s2k with SHA1
	 		        //if s2k == 255,254 then 1 octet symmetric encryption algo
	 		        body += String.fromCharCode(this.symmetricEncryptionAlgorithm);
	 		        //if s2k == 255,254 then s2k specifier
	 		        body += String.fromCharCode(3); //s2k salt+iter
	 		        body += String.fromCharCode(s2kHash);
	 		        //8 octet salt value
	 		        //1 octet count
	 		        var cleartextMPIs = key.d.toMPI() + key.p.toMPI() + key.q.toMPI() + key.u.toMPI();
	 		        var sha1Hash = str_sha1(cleartextMPIs);
	    		        util.print_debug_hexstr_dump('write_private_key sha1: ',sha1Hash);
	 		        var salt = openpgp_crypto_getRandomBytes(8);
	 		        util.print_debug_hexstr_dump('write_private_key Salt: ',salt);
	 		        body += salt;
	 		        var c = 96; //c of 96 translates to count of 65536
	 		        body += String.fromCharCode(c);
	 		        util.print_debug('write_private_key c: '+ c);
	 		        var s2k = new openpgp_type_s2k();
	 		        var hashKey = s2k.write(3, s2kHash, password, salt, c);
	 		        //if s2k, IV of same length as cipher's block
	 		        switch(this.symmetricEncryptionAlgorithm){
	 		        case 3:
	 		            this.IVLength = 8;
	 		            this.IV = openpgp_crypto_getRandomBytes(this.IVLength);
	             		ciphertextMPIs = normal_cfb_encrypt(function(block, key) {
	                 		var cast5 = new openpgp_symenc_cast5();
	                 		cast5.setKey(key);
	                 		return cast5.encrypt(util.str2bin(block)); 
	             		}, this.IVLength, util.str2bin(hashKey.substring(0,16)), cleartextMPIs + sha1Hash, this.IV);
	             		body += this.IV + ciphertextMPIs;
	 		            break;
	 		        case 7:
	 		        case 8:
	 		        case 9:
	 		            this.IVLength = 16;
	 		            this.IV = openpgp_crypto_getRandomBytes(this.IVLength);
	 		            ciphertextMPIs = normal_cfb_encrypt(AESencrypt,
	             				this.IVLength, hashKey, cleartextMPIs + sha1Hash, this.IV);
	             		body += this.IV + ciphertextMPIs;
	 	            	break;
	 		        }
	 		    }
	 		    else{
	 		        body += String.fromCharCode(0);//1 octet -- s2k, 0 for no s2k
	 		        body += key.d.toMPI() + key.p.toMPI() + key.q.toMPI() + key.u.toMPI();
	 		        var checksum = util.calc_checksum(key.d.toMPI() + key.p.toMPI() + key.q.toMPI() + key.u.toMPI());
	         		body += String.fromCharCode(checksum/0x100) + String.fromCharCode(checksum%0x100);//DEPRECATED:s2k == 0, 255: 2 octet checksum, sum all octets%65536
	         		util.print_debug_hexstr_dump('write_private_key basic checksum: '+ checksum);
	 		    }
	 		    break;
	 		default :
	 			body = "";
	 			util.print_error("openpgp.packet.keymaterial.js\n"+'error writing private key, unknown type :'+keyType);
	         }
	 		var header = openpgp_packet.write_packet_header(tag,body.length);
	 		return {string: header+body , header: header, body: body};
	     }
	 	
	 	/*
	      * Same as write_private_key, but has less information because of 
	 	 * public key.
	      * @param {Integer} keyType Follows the OpenPGP algorithm standard, 
	 	 * IE 1 corresponds to RSA.
	      * @param {RSA.keyObject} key
	      * @param timePacket
	      * @return {Object} {body: [string]OpenPGP packet body contents, 
	 	 * header: [string] OpenPGP packet header, string: [string] header+body}
	      */
	     function write_public_key(keyType, key, timePacket){
	         var tag = 6;
	         var body = String.fromCharCode(4);
	         body += timePacket;
	 		switch(keyType){
	 		case 1:
	 		    body += String.fromCharCode(1);//public key algo
	 		    body += key.n.toMPI();
	 		    body += key.ee.toMPI();
	 		    break;
	 	    default:
	 	    	util.print_error("openpgp.packet.keymaterial.js\n"+'error writing private key, unknown type :'+keyType);
	 	    }
	         var header = openpgp_packet.write_packet_header(tag,body.length);
	         return {string: header+body , header: header, body: body};
	         }
	 
	 	
	 	this.read_tag5 = read_tag5;
	 	this.read_tag6 = read_tag6;
	 	this.read_tag7 = read_tag7;
	 	this.read_tag14 = read_tag14;
	 	this.toString = toString;
	 	this.read_pub_key = read_pub_key;
	 	this.read_priv_key = read_priv_key;
	 	this.decryptSecretMPIs = decryptSecretMPIs;
	 	this.read_nodes = read_nodes;
	 	this.verifyKey = verifyKey;
	 	this.getKeyId = getKeyId;
	 	this.getFingerprint = getFingerprint;
	 	this.write_private_key = write_private_key;
	 	this.write_public_key = write_public_key;
	 }
	 // GPG4Browsers - An OpenPGP implementation in javascript
	 // Copyright (C) 2011 Recurity Labs GmbH
	 // 
	 // This library is free software; you can redistribute it and/or
	 // modify it under the terms of the GNU Lesser General Public
	 // License as published by the Free Software Foundation; either
	 // version 2.1 of the License, or (at your option) any later version.
	 // 
	 // This library is distributed in the hope that it will be useful,
	 // but WITHOUT ANY WARRANTY; without even the implied warranty of
	 // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
	 // Lesser General Public License for more details.
	 // 
	 // You should have received a copy of the GNU Lesser General Public
	 // License along with this library; if not, write to the Free Software
	 // Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
	 
	 /**
	  * @class
	  * @classdesc Implementation of the Literal Data Packet (Tag 11)
	  * 
	  * RFC4880 5.9: A Literal Data packet contains the body of a message; data that
	  * is not to be further interpreted.
	  */
	 function openpgp_packet_literaldata() {
	 	this.tagType = 11;
	 
	 	
	 	/**
	 	 * Set the packet data to a javascript native string or a squence of 
	 	 * bytes. Conversion to a proper utf8 encoding takes place when the 
	 	 * packet is written.
	 	 * @param {String} str Any native javascript string
	 	 * @param {openpgp_packet_literaldata.formats} format 
	 	 */
	 	this.set_data = function(str, format) {
	 		this.format = format;
	 		this.data = str;
	 	}
	 
	 	/**
	 	 * Set the packet data to value represented by the provided string
	 	 * of bytes together with the appropriate conversion format.
	 	 * @param {String} bytes The string of bytes
	 	 * @param {openpgp_packet_literaldata.formats} format
	 	 */
	 	this.set_data_bytes = function(bytes, format) {
	 		this.format = format;
	 
	 		if(format == openpgp_packet_literaldata.formats.utf8)
	 			bytes = util.decode_utf8(bytes);
	 
	 		this.data = bytes;
	 	}
	 
	 	/**
	 	 * Get the byte sequence representing the literal packet data
	 	 * @returns {String} A sequence of bytes
	 	 */
	 	this.get_data_bytes = function() {
	 		if(this.format == openpgp_packet_literaldata.formats.utf8)
	 			return util.encode_utf8(this.data);
	 		else
	 			return this.data;
	 	}
	 	
	 	
	 
	 	/**
	 	 * Parsing function for a literal data packet (tag 11).
	 	 * 
	 	 * @param {String} input Payload of a tag 11 packet
	 	 * @param {Integer} position
	 	 *            Position to start reading from the input string
	 	 * @param {Integer} len
	 	 *            Length of the packet or the remaining length of
	 	 *            input at position
	 	 * @return {openpgp_packet_encrypteddata} object representation
	 	 */
	 	this.read_packet = function(input, position, len) {
	 		this.packetLength = len;
	 		// - A one-octet field that describes how the data is formatted.
	 
	 		var format = input[position];
	 
	 		this.filename = util.decode_utf8(input.substr(position + 2, input
	 				.charCodeAt(position + 1)));
	 
	 		this.date = new Date(parseInt(input.substr(position + 2
	 				+ input.charCodeAt(position + 1), 4)) * 1000);
	 
	 		var bytes = input.substring(position + 6
	 				+ input.charCodeAt(position + 1));
	 	
	 		this.set_data_bytes(bytes, format);
	 		return this;
	 	}
	 
	 	/**
	 	 * Creates a string representation of the packet
	 	 * 
	 	 * @param {String} data The data to be inserted as body
	 	 * @return {String} string-representation of the packet
	 	 */
	 	this.write_packet = function(data) {
	 		this.set_data(data, openpgp_packet_literaldata.formats.utf8);
	 		this.filename = util.encode_utf8("msg.txt");
	 		this.date = new Date();
	 
	 		data = this.get_data_bytes();
	 
	 		var result = openpgp_packet.write_packet_header(11, data.length + 6
	 				+ this.filename.length);
	 		result += this.format;
	 		result += String.fromCharCode(this.filename.length);
	 		result += this.filename;
	 		result += String
	 				.fromCharCode((Math.round(this.date.getTime() / 1000) >> 24) & 0xFF);
	 		result += String
	 				.fromCharCode((Math.round(this.date.getTime() / 1000) >> 16) & 0xFF);
	 		result += String
	 				.fromCharCode((Math.round(this.date.getTime() / 1000) >> 8) & 0xFF);
	 		result += String
	 				.fromCharCode(Math.round(this.date.getTime() / 1000) & 0xFF);
	 		result += data;
	 		return result;
	 	}
	 
	 	/**
	 	 * Generates debug output (pretty print)
	 	 * 
	 	 * @return {String} String which gives some information about the keymaterial
	 	 */
	 	this.toString = function() {
	 		return '5.9.  Literal Data Packet (Tag 11)\n' + '    length: '
	 				+ this.packetLength + '\n' + '    format: ' + this.format
	 				+ '\n' + '    filename:' + this.filename + '\n'
	 				+ '    date:   ' + this.date + '\n' + '    data:  |'
	 				+ this.data + '|\n' + '    rdata: |' + this.real_data + '|\n';
	 	}
	 }
	 
	 /**
	  * Data types in the literal packet
	  * @readonly
	  * @enum {String}
	  */
	 openpgp_packet_literaldata.formats = {
	 	/** Binary data */
	 	binary: 'b',
	 	/** Text data */
	 	text: 't',
	 	/** Utf8 data */
	 	utf8: 'u'
	 };
	 // GPG4Browsers - An OpenPGP implementation in javascript
	 // Copyright (C) 2011 Recurity Labs GmbH
	 // 
	 // This library is free software; you can redistribute it and/or
	 // modify it under the terms of the GNU Lesser General Public
	 // License as published by the Free Software Foundation; either
	 // version 2.1 of the License, or (at your option) any later version.
	 // 
	 // This library is distributed in the hope that it will be useful,
	 // but WITHOUT ANY WARRANTY; without even the implied warranty of
	 // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
	 // Lesser General Public License for more details.
	 // 
	 // You should have received a copy of the GNU Lesser General Public
	 // License along with this library; if not, write to the Free Software
	 // Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
	 
	 /**
	  * @class
	  * @classdesc Implementation of the strange "Marker packet" (Tag 10)
	  * 
	  * RFC4880 5.8: An experimental version of PGP used this packet as the Literal
	  * packet, but no released version of PGP generated Literal packets with this
	  * tag. With PGP 5.x, this packet has been reassigned and is reserved for use as
	  * the Marker packet.
	  * 
	  * Such a packet MUST be ignored when received.
	  */
	 function openpgp_packet_marker() {
	 	this.tagType = 10;
	 	/**
	 	 * Parsing function for a literal data packet (tag 10).
	 	 * 
	 	 * @param {String} input Payload of a tag 10 packet
	 	 * @param {Integer} position
	 	 *            Position to start reading from the input string
	 	 * @param {Integer} len
	 	 *            Length of the packet or the remaining length of
	 	 *            input at position
	 	 * @return {openpgp_packet_encrypteddata} Object representation
	 	 */
	 	function read_packet(input, position, len) {
	 		this.packetLength = 3;
	 		if (input[position].charCodeAt() == 0x50 && // P
	 				input[position + 1].charCodeAt() == 0x47 && // G
	 				input[position + 2].charCodeAt() == 0x50) // P
	 			return this;
	 		// marker packet does not contain "PGP"
	 		return null;
	 	}
	 
	 	/**
	 	 * Generates Debug output
	 	 * 
	 	 * @return {String} String which gives some information about the 
	 	 * keymaterial
	 	 */
	 	function toString() {
	 		return "5.8.  Marker Packet (Obsolete Literal Packet) (Tag 10)\n"
	 				+ "     packet reads: \"PGP\"\n";
	 	}
	 
	 	this.read_packet = read_packet;
	 	this.toString = toString;
	 }
	 // GPG4Browsers - An OpenPGP implementation in javascript
	 // Copyright (C) 2011 Recurity Labs GmbH
	 // 
	 // This library is free software; you can redistribute it and/or
	 // modify it under the terms of the GNU Lesser General Public
	 // License as published by the Free Software Foundation; either
	 // version 2.1 of the License, or (at your option) any later version.
	 // 
	 // This library is distributed in the hope that it will be useful,
	 // but WITHOUT ANY WARRANTY; without even the implied warranty of
	 // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
	 // Lesser General Public License for more details.
	 // 
	 // You should have received a copy of the GNU Lesser General Public
	 // License along with this library; if not, write to the Free Software
	 // Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
	 
	 /**
	  * @class
	  * @classdesc Implementation of the Modification Detection Code Packet (Tag 19)
	  * 
	  * RFC4880 5.14: The Modification Detection Code packet contains a SHA-1 hash of
	  * plaintext data, which is used to detect message modification. It is only used
	  * with a Symmetrically Encrypted Integrity Protected Data packet. The
	  * Modification Detection Code packet MUST be the last packet in the plaintext
	  * data that is encrypted in the Symmetrically Encrypted Integrity Protected
	  * Data packet, and MUST appear in no other place.
	  */
	 
	 function openpgp_packet_modificationdetectioncode() {
	 	this.tagType = 19;
	 	this.hash = null;
	 	/**
	 	 * parsing function for a modification detection code packet (tag 19).
	 	 * 
	 	 * @param {String} input payload of a tag 19 packet
	 	 * @param {Integer} position
	 	 *            position to start reading from the input string
	 	 * @param {Integer} len
	 	 *            length of the packet or the remaining length of
	 	 *            input at position
	 	 * @return {openpgp_packet_encrypteddata} object representation
	 	 */
	 	function read_packet(input, position, len) {
	 		this.packetLength = len;
	 
	 		if (len != 20) {
	 			util
	 					.print_error("openpgp.packet.modificationdetectioncode.js\n"
	 							+ 'invalid length for a modification detection code packet!'
	 							+ len);
	 			return null;
	 		}
	 		// - A 20-octet SHA-1 hash of the preceding plaintext data of the
	 		// Symmetrically Encrypted Integrity Protected Data packet,
	 		// including prefix data, the tag octet, and length octet of the
	 		// Modification Detection Code packet.
	 		this.hash = input.substring(position, position + 20);
	 		return this;
	 	}
	 
	 	/*
	 	 * this packet is created within the encryptedintegrityprotected packet
	 	 * function write_packet(data) { }
	 	 */
	 
	 	/**
	 	 * generates debug output (pretty print)
	 	 * 
	 	 * @return {String} String which gives some information about the 
	 	 * modification detection code
	 	 */
	 	function toString() {
	 		return '5.14 Modification detection code packet\n' + '    bytes ('
	 				+ this.hash.length + '): [' + util.hexstrdump(this.hash) + ']';
	 	}
	 	this.read_packet = read_packet;
	 	this.toString = toString;
	 };
	 // GPG4Browsers - An OpenPGP implementation in javascript
	 // Copyright (C) 2011 Recurity Labs GmbH
	 // 
	 // This library is free software; you can redistribute it and/or
	 // modify it under the terms of the GNU Lesser General Public
	 // License as published by the Free Software Foundation; either
	 // version 2.1 of the License, or (at your option) any later version.
	 // 
	 // This library is distributed in the hope that it will be useful,
	 // but WITHOUT ANY WARRANTY; without even the implied warranty of
	 // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
	 // Lesser General Public License for more details.
	 // 
	 // You should have received a copy of the GNU Lesser General Public
	 // License along with this library; if not, write to the Free Software
	 // Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
	 
	 /**
	  * @class
	  * @classdesc Implementation of the One-Pass Signature Packets (Tag 4)
	  * 
	  * RFC4880 5.4:
	  * The One-Pass Signature packet precedes the signed data and contains
	  * enough information to allow the receiver to begin calculating any
	  * hashes needed to verify the signature.  It allows the Signature
	  * packet to be placed at the end of the message, so that the signer
	  * can compute the entire signed message in one pass.
	  */
	 function openpgp_packet_onepasssignature() {
	 	this.tagType = 4;
	 	this.version = null; // A one-octet version number.  The current version is 3.
	 	this.type = null; 	 // A one-octet signature type.  Signature types are described in RFC4880 Section 5.2.1.
	 	this.hashAlgorithm = null; 	   // A one-octet number describing the hash algorithm used. (See RFC4880 9.4)
	 	this.publicKeyAlgorithm = null;	     // A one-octet number describing the public-key algorithm used. (See RFC4880 9.1)
	 	this.signingKeyId = null; // An eight-octet number holding the Key ID of the signing key.
	 	this.flags = null; 	//  A one-octet number holding a flag showing whether the signature is nested.  A zero value indicates that the next packet is another One-Pass Signature packet that describes another signature to be applied to the same message data.
	 
	 	/**
	 	 * parsing function for a one-pass signature packet (tag 4).
	 	 * @param {String} input payload of a tag 4 packet
	 	 * @param {Integer} position position to start reading from the input string
	 	 * @param {Integer} len length of the packet or the remaining length of input at position
	 	 * @return {openpgp_packet_encrypteddata} object representation
	 	 */
	 	function read_packet(input, position, len) {
	 		this.packetLength = len;
	 		var mypos = position;
	 		// A one-octet version number.  The current version is 3.
	 		this.version = input.charCodeAt(mypos++);
	 
	 	     // A one-octet signature type.  Signature types are described in
	 	     //   Section 5.2.1.
	 		this.type = input.charCodeAt(mypos++);
	 
	 	     // A one-octet number describing the hash algorithm used.
	 		this.hashAlgorithm = input.charCodeAt(mypos++);
	 
	 	     // A one-octet number describing the public-key algorithm used.
	 		this.publicKeyAlgorithm = input.charCodeAt(mypos++);
	 	     // An eight-octet number holding the Key ID of the signing key.
	 		this.signingKeyId = new openpgp_type_keyid();
	 		this.signingKeyId.read_packet(input,mypos);
	 		mypos += 8;
	 		
	 	     // A one-octet number holding a flag showing whether the signature
	 	     //   is nested.  A zero value indicates that the next packet is
	 	     //   another One-Pass Signature packet that describes another
	 	     //   signature to be applied to the same message data.
	 		this.flags = input.charCodeAt(mypos++);
	 		return this;
	 	}
	 
	 	/**
	 	 * creates a string representation of a one-pass signature packet
	 	 * @param {Integer} type Signature types as described in RFC4880 Section 5.2.1.
	 	 * @param {Integer} hashalgorithm the hash algorithm used within the signature
	 	 * @param {openpgp_msg_privatekey} privatekey the private key used to generate the signature
	 	 * @param {Integer} length length of data to be signed
	 	 * @param {boolean} nested boolean showing whether the signature is nested. 
	 	 *  "true" indicates that the next packet is another One-Pass Signature packet
	 	 *   that describes another signature to be applied to the same message data. 
	 	 * @return {String} a string representation of a one-pass signature packet
	 	 */
	 	function write_packet(type, hashalgorithm, privatekey,length, nested) {
	 		var result =""; 
	 		
	 		result += openpgp_packet.write_packet_header(4,13);
	 		result += String.fromCharCode(3);
	 		result += String.fromCharCode(type);
	 		result += String.fromCharCode(hashalgorithm);
	 		result += String.fromCharCode(privatekey.privateKeyPacket.publicKey.publicKeyAlgorithm);
	 		result += privatekey.getKeyId();
	 		if (nested)
	 			result += String.fromCharCode(0);
	 		else
	 			result += String.fromCharCode(1);
	 		
	 		return result;
	 	}
	 	
	 	/**
	 	 * generates debug output (pretty print)
	 	 * @return {String} String which gives some information about the one-pass signature packet
	 	 */
	 	function toString() {
	 		return '5.4.  One-Pass Signature Packets (Tag 4)\n'+
	 			   '    length: '+this.packetLength+'\n'+
	 			   '    type:   '+this.type+'\n'+
	 			   '    keyID:  '+this.signingKeyId.toString()+'\n'+
	 			   '    hashA:  '+this.hashAlgorithm+'\n'+
	 			   '    pubKeyA:'+this.publicKeyAlgorithm+'\n'+
	 			   '    flags:  '+this.flags+'\n'+
	 			   '    version:'+this.version+'\n';
	 	}
	 	
	 	this.read_packet = read_packet;
	 	this.toString = toString;
	 	this.write_packet = write_packet;
	 };
	 // GPG4Browsers - An OpenPGP implementation in javascript
	 // Copyright (C) 2011 Recurity Labs GmbH
	 // 
	 // This library is free software; you can redistribute it and/or
	 // modify it under the terms of the GNU Lesser General Public
	 // License as published by the Free Software Foundation; either
	 // version 2.1 of the License, or (at your option) any later version.
	 // 
	 // This library is distributed in the hope that it will be useful,
	 // but WITHOUT ANY WARRANTY; without even the implied warranty of
	 // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
	 // Lesser General Public License for more details.
	 // 
	 // You should have received a copy of the GNU Lesser General Public
	 // License along with this library; if not, write to the Free Software
	 // Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
	 
	 /**
	  * @class
	  * @classdesc Implementation of the Signature Packet (Tag 2)
	  * 
	  * RFC4480 5.2:
	  * A Signature packet describes a binding between some public key and
	  * some data.  The most common signatures are a signature of a file or a
	  * block of text, and a signature that is a certification of a User ID.
	  */
	 function openpgp_packet_signature() {
	 	this.tagType = 2;
	 	this.signatureType = null;
	 	this.creationTime = null;
	 	this.keyId = null;
	 	this.signatureData = null;
	 	this.signatureExpirationTime = null;
	 	this.signatureNeverExpires = null;
	 	this.signedHashValue = null;
	 	this.MPIs = null;
	 	this.publicKeyAlgorithm = null; 
	 	this.hashAlgorithm = null;
	 	this.exportable = null;
	 	this.trustLevel = null;
	 	this.trustAmount = null;
	 	this.regular_expression = null;
	 	this.revocable = null;
	 	this.keyExpirationTime = null;
	 	this.keyNeverExpires = null;
	 	this.preferredSymmetricAlgorithms = null;
	 	this.revocationKeyClass = null;
	 	this.revocationKeyAlgorithm = null;
	 	this.revocationKeyFingerprint = null;
	 	this.issuerKeyId = null;
	 	this.notationFlags = null; 
	 	this.notationName = null;
	 	this.notationValue = null;
	 	this.preferredHashAlgorithms = null;
	 	this.preferredCompressionAlgorithms = null;
	 	this.keyServerPreferences = null;
	 	this.preferredKeyServer = null;
	 	this.isPrimaryUserID = null;
	 	this.policyURI = null;
	 	this.keyFlags = null;
	 	this.signersUserId = null;
	 	this.reasonForRevocationFlag = null;
	 	this.reasonForRevocationString = null;
	 	this.signatureTargetPublicKeyAlgorithm = null;
	 	this.signatureTargetHashAlgorithm = null;
	 	this.signatureTargetHash = null;
	 	this.embeddedSignature = null;
	 	this.verified = false;
	 	
	 
	 	/**
	 	 * parsing function for a signature packet (tag 2).
	 	 * @param {String} input payload of a tag 2 packet
	 	 * @param {Integer} position position to start reading from the input string
	 	 * @param {Integer} len length of the packet or the remaining length of input at position
	 	 * @return {openpgp_packet_encrypteddata} object representation
	 	 */
	 	function read_packet(input, position, len) {
	 		this.data = input.substring	(position, position+len);
	 		if (len < 0) {
	 			util.print_debug("openpgp.packet.signature.js\n"+"openpgp_packet_signature read_packet length < 0 @:"+position);
	 			return null;
	 		}
	 		var mypos = position;
	 		this.packetLength = len;
	 		// alert('starting parsing signature: '+position+' '+this.packetLength);
	 		this.version = input[mypos++].charCodeAt();
	 		// switch on version (3 and 4)
	 		switch (this.version) {
	 		case 3:
	 			// One-octet length of following hashed material. MUST be 5.
	 			if (input[mypos++].charCodeAt() != 5)
	 				util.print_debug("openpgp.packet.signature.js\n"+'invalid One-octet length of following hashed material.  MUST be 5. @:'+(mypos-1));
	 			var sigpos = mypos;
	 			// One-octet signature type.
	 			this.signatureType = input[mypos++].charCodeAt();
	 
	 			// Four-octet creation time.
	 			this.creationTime = new Date(((input[mypos++].charCodeAt()) << 24 |
	 					(input[mypos++].charCodeAt() << 16) | (input[mypos++].charCodeAt() << 8) |
	 					input[mypos++].charCodeAt())* 1000);
	 			
	 			// storing data appended to data which gets verified
	 			this.signatureData = input.substring(position, mypos);
	 			
	 			// Eight-octet Key ID of signer.
	 			this.keyId = input.substring(mypos, mypos +8);
	 			mypos += 8;
	 
	 			// One-octet public-key algorithm.
	 			this.publicKeyAlgorithm = input[mypos++].charCodeAt();
	 
	 			// One-octet hash algorithm.
	 			this.hashAlgorithm = input[mypos++].charCodeAt();
	 
	 			// Two-octet field holding left 16 bits of signed hash value.
	 			this.signedHashValue = (input[mypos++].charCodeAt() << 8) | input[mypos++].charCodeAt();
	 			var mpicount = 0;
	 			// Algorithm-Specific Fields for RSA signatures:
	 			// 	    - multiprecision integer (MPI) of RSA signature value m**d mod n.
	 			if (this.publicKeyAlgorithm > 0 && this.publicKeyAlgorithm < 4)
	 				mpicount = 1;
	 			//    Algorithm-Specific Fields for DSA signatures:
	 			//      - MPI of DSA value r.
	 			//      - MPI of DSA value s.
	 			else if (this.publicKeyAlgorithm == 17)
	 				mpicount = 2;
	 			
	 			this.MPIs = new Array();
	 			for (var i = 0; i < mpicount; i++) {
	 				this.MPIs[i] = new openpgp_type_mpi();
	 				if (this.MPIs[i].read(input, mypos, (mypos-position)) != null && 
	 						!this.packetLength < (mypos-position)) {
	 					mypos += this.MPIs[i].packetLength;
	 				} else {
	 			 		util.print_error('signature contains invalid MPI @:'+mypos);
	 				}
	 			}
	 		break;
	 		case 4:
	 			this.signatureType = input[mypos++].charCodeAt();
	 			this.publicKeyAlgorithm = input[mypos++].charCodeAt();
	 			this.hashAlgorithm = input[mypos++].charCodeAt();
	 
	 			// Two-octet scalar octet count for following hashed subpacket
	 			// data.
	 			var hashed_subpacket_count = (input[mypos++].charCodeAt() << 8) + input[mypos++].charCodeAt();
	 
	 			// Hashed subpacket data set (zero or more subpackets)
	 			var subpacket_length = 0;
	 			while (hashed_subpacket_count != subpacket_length) {
	 				if (hashed_subpacket_count < subpacket_length) {
	 					util.print_debug("openpgp.packet.signature.js\n"+"hashed missed something: "+mypos+" c:"+hashed_subpacket_count+" l:"+subpacket_length);
	 				}
	 
	 				subpacket_length += this._raw_read_signature_sub_packet(input,
	 						mypos + subpacket_length, hashed_subpacket_count
	 								- subpacket_length);
	 			}
	 			
	 			mypos += hashed_subpacket_count;
	 			this.signatureData = input.substring(position, mypos);
	 
	 			// alert("signatureData: "+util.hexstrdump(this.signatureData));
	 			
	 			// Two-octet scalar octet count for the following unhashed subpacket
	 			var subpacket_count = (input[mypos++].charCodeAt() << 8) + input[mypos++].charCodeAt();
	 				
	 			// Unhashed subpacket data set (zero or more subpackets).
	 			subpacket_length = 0;
	 			while (subpacket_count != subpacket_length) {
	 				if (subpacket_count < subpacket_length) {
	 					util.print_debug("openpgp.packet.signature.js\n"+"missed something: "+subpacket_length+" c:"+subpacket_count+" "+" l:"+subpacket_length);
	 				}
	 				subpacket_length += this._raw_read_signature_sub_packet(input,
	 						mypos + subpacket_length, subpacket_count
	 								- subpacket_length);
	 
	 			}
	 			mypos += subpacket_count;
	 			// Two-octet field holding the left 16 bits of the signed hash
	 			// value.
	 			this.signedHashValue = (input[mypos++].charCodeAt() << 8) | input[mypos++].charCodeAt();
	 			// One or more multiprecision integers comprising the signature.
	 			// This portion is algorithm specific, as described above.
	 			var mpicount = 0;
	 			if (this.publicKeyAlgorithm > 0 && this.publicKeyAlgorithm < 4)
	 				mpicount = 1;
	 			else if (this.publicKeyAlgorithm == 17)
	 				mpicount = 2;
	 			
	 			this.MPIs = new Array();
	 			for (var i = 0; i < mpicount; i++) {
	 				this.MPIs[i] = new openpgp_type_mpi();
	 				if (this.MPIs[i].read(input, mypos, (mypos-position)) != null && 
	 						!this.packetLength < (mypos-position)) {
	 					mypos += this.MPIs[i].packetLength;
	 				} else {
	 			 		util.print_error('signature contains invalid MPI @:'+mypos);
	 				}
	 			}
	 			break;
	 		default:
	 			util.print_error("openpgp.packet.signature.js\n"+'unknown signature packet version'+this.version);
	 			break;
	 		}
	 		// util.print_message("openpgp.packet.signature.js\n"+"end signature: l: "+this.packetLength+"m: "+mypos+" m-p: "+(mypos-position));
	 		return this;
	 	}
	 	/**
	 	 * creates a string representation of a message signature packet (tag 2).
	 	 * This can be only used on text data
	 	 * @param {Integer} signature_type should be 1 (one) 
	 	 * @param {String} data data to be signed
	 	 * @param {openpgp_msg_privatekey} privatekey private key used to sign the message. (secMPIs MUST be unlocked)
	 	 * @return {String} string representation of a signature packet
	 	 */
	 	function write_message_signature(signature_type, data, privatekey) {
	 		var publickey = privatekey.privateKeyPacket.publicKey;
	 		var hash_algo = privatekey.getPreferredSignatureHashAlgorithm();
	 		var result = String.fromCharCode(4); 
	 		result += String.fromCharCode(signature_type);
	 		result += String.fromCharCode(publickey.publicKeyAlgorithm);
	 		result += String.fromCharCode(hash_algo);
	 		var d = Math.round(new Date().getTime() / 1000);
	 		var datesubpacket = write_sub_signature_packet(2,""+
	 				String.fromCharCode((d >> 24) & 0xFF) + 
	 				String.fromCharCode((d >> 16) & 0xFF) +
	 				String.fromCharCode((d >> 8) & 0xFF) + 
	 				String.fromCharCode(d & 0xFF));
	 		var issuersubpacket = write_sub_signature_packet(16, privatekey.getKeyId());
	 		result += String.fromCharCode(((datesubpacket.length + issuersubpacket.length) >> 8) & 0xFF);
	 		result += String.fromCharCode ((datesubpacket.length + issuersubpacket.length) & 0xFF);
	 		result += datesubpacket;
	 		result += issuersubpacket;
	 		var trailer = '';
	 		
	 		trailer += String.fromCharCode(4);
	 		trailer += String.fromCharCode(0xFF);
	 		trailer += String.fromCharCode((result.length) >> 24);
	 		trailer += String.fromCharCode(((result.length) >> 16) & 0xFF);
	 		trailer += String.fromCharCode(((result.length) >> 8) & 0xFF);
	 		trailer += String.fromCharCode((result.length) & 0xFF);
	 		var result2 = String.fromCharCode(0);
	 		result2 += String.fromCharCode(0);
	 		var hash = openpgp_crypto_hashData(hash_algo, data+result+trailer);
	 		util.print_debug("DSA Signature is calculated with:|"+data+result+trailer+"|\n"+util.hexstrdump(data+result+trailer)+"\n hash:"+util.hexstrdump(hash));
	 		result2 += hash.charAt(0);
	 		result2 += hash.charAt(1);
	 		result2 += openpgp_crypto_signData(hash_algo,privatekey.privateKeyPacket.publicKey.publicKeyAlgorithm,
	 				publickey.MPIs,
	 				privatekey.privateKeyPacket.secMPIs,
	 				data+result+trailer);
	 		return {openpgp: (openpgp_packet.write_packet_header(2, (result+result2).length)+result + result2), 
	 				hash: util.get_hashAlgorithmString(hash_algo)};
	 	}
	 	/**
	 	 * creates a string representation of a sub signature packet (See RFC 4880 5.2.3.1)
	 	 * @param {Integer} type subpacket signature type. Signature types as described in RFC4880 Section 5.2.3.2
	 	 * @param {String} data data to be included
	 	 * @return {String} a string-representation of a sub signature packet (See RFC 4880 5.2.3.1)
	 	 */
	 	function write_sub_signature_packet(type, data) {
	 		var result = "";
	 		result += openpgp_packet.encode_length(data.length+1);
	 		result += String.fromCharCode(type);
	 		result += data;
	 		return result;
	 	}
	 	
	 	// V4 signature sub packets
	 	
	 	this._raw_read_signature_sub_packet = function(input, position, len) {
	 		if (len < 0)
	 			util.print_debug("openpgp.packet.signature.js\n"+"_raw_read_signature_sub_packet length < 0 @:"+position);
	 		var mypos = position;
	 		var subplen = 0;
	 		// alert('starting signature subpackage read at position:'+position+' length:'+len);
	 		if (input[mypos].charCodeAt() < 192) {
	 			subplen = input[mypos++].charCodeAt();
	 		} else if (input[mypos].charCodeAt() >= 192 && input[mypos].charCodeAt() < 224) {
	 			subplen = ((input[mypos++].charCodeAt() - 192) << 8) + (input[mypos++].charCodeAt()) + 192;
	 		} else if (input[mypos].charCodeAt() > 223 && input[mypos].charCodeAt() < 255) {
	 			subplen = 1 << (input[mypos++].charCodeAt() & 0x1F);
	 		} else if (input[mypos].charCodeAt() < 255) {
	 			mypos++;
	 			subplen = (input[mypos++].charCodeAt() << 24) | (input[mypos++].charCodeAt() << 16)
	 					|  (input[mypos++].charCodeAt() << 8) |  input[mypos++].charCodeAt();
	 		}
	 		
	 		var type = input[mypos++].charCodeAt() & 0x7F;
	 		// alert('signature subpacket type '+type+" with length: "+subplen);
	 		// subpacket type
	 		switch (type) {
	 		case 2: // Signature Creation Time
	 			this.creationTime = new Date(((input[mypos++].charCodeAt() << 24) | (input[mypos++].charCodeAt() << 16)
	 					| (input[mypos++].charCodeAt() << 8) | input[mypos++].charCodeAt())*1000);
	 			break;
	 		case 3: // Signature Expiration Time
	 			this.signatureExpirationTime =  (input[mypos++].charCodeAt() << 24)
	 					| (input[mypos++].charCodeAt() << 16) | (input[mypos++].charCodeAt() << 8)
	 					| input[mypos++].charCodeAt();
	 			this.signatureNeverExpires = (this.signature_expiration_time == 0);
	 			
	 			break;
	 		case 4: // Exportable Certification
	 			this.exportable = input[mypos++].charCodeAt() == 1;
	 			break;
	 		case 5: // Trust Signature
	 			this.trustLevel = input[mypos++].charCodeAt();
	 			this.trustAmount = input[mypos++].charCodeAt();
	 			break;
	 		case 6: // Regular Expression
	 			this.regular_expression = new String();
	 			for (var i = 0; i < subplen - 1; i++)
	 				this.regular_expression += (input[mypos++]);
	 			break;
	 		case 7: // Revocable
	 			this.revocable = input[mypos++].charCodeAt() == 1;
	 			break;
	 		case 9: // Key Expiration Time
	 			this.keyExpirationTime = (input[mypos++].charCodeAt() << 24)
	 					| (input[mypos++].charCodeAt() << 16) | (input[mypos++].charCodeAt() << 8)
	 					| input[mypos++].charCodeAt();
	 			this.keyNeverExpires = (this.keyExpirationTime == 0);
	 			break;
	 		case 11: // Preferred Symmetric Algorithms
	 			this.preferredSymmetricAlgorithms = new Array();
	 			for (var i = 0; i < subplen-1; i++) {
	 				this.preferredSymmetricAlgorithms = input[mypos++].charCodeAt();
	 			}
	 			break;
	 		case 12: // Revocation Key
	 			// (1 octet of class, 1 octet of public-key algorithm ID, 20
	 			// octets of
	 			// fingerprint)
	 			this.revocationKeyClass = input[mypos++].charCodeAt();
	 			this.revocationKeyAlgorithm = input[mypos++].charCodeAt();
	 			this.revocationKeyFingerprint = new Array();
	 			for ( var i = 0; i < 20; i++) {
	 				this.revocationKeyFingerprint = input[mypos++].charCodeAt();
	 			}
	 			break;
	 		case 16: // Issuer
	 			this.issuerKeyId = input.substring(mypos,mypos+8);
	 			mypos += 8;
	 			break;
	 		case 20: // Notation Data
	 			this.notationFlags = (input[mypos++].charCodeAt() << 24) | 
	 								 (input[mypos++].charCodeAt() << 16) |
	 								 (input[mypos++].charCodeAt() <<  8) | 
	 								 (input[mypos++].charCodeAt());
	 			var nameLength = (input[mypos++].charCodeAt() <<  8) | (input[mypos++].charCodeAt());
	 			var valueLength = (input[mypos++].charCodeAt() <<  8) | (input[mypos++].charCodeAt());
	 			this.notationName = "";
	 			for (var i = 0; i < nameLength; i++) {
	 				this.notationName += input[mypos++];
	 			}
	 			this.notationValue = "";
	 			for (var i = 0; i < valueLength; i++) {
	 				this.notationValue += input[mypos++];
	 			}
	 			break;
	 		case 21: // Preferred Hash Algorithms
	 			this.preferredHashAlgorithms = new Array();
	 			for (var i = 0; i < subplen-1; i++) {
	 				this.preferredHashAlgorithms = input[mypos++].charCodeAt();
	 			}
	 			break;
	 		case 22: // Preferred Compression Algorithms
	 			this.preferredCompressionAlgorithms = new Array();
	 			for ( var i = 0; i < subplen-1; i++) {
	 				this.preferredCompressionAlgorithms = input[mypos++].charCodeAt();
	 			}
	 			break;
	 		case 23: // Key Server Preferences
	 			this.keyServerPreferences = new Array();
	 			for ( var i = 0; i < subplen-1; i++) {
	 				this.keyServerPreferences = input[mypos++].charCodeAt();
	 			}
	 			break;
	 		case 24: // Preferred Key Server
	 			this.preferredKeyServer = new String();
	 			for ( var i = 0; i < subplen-1; i++) {
	 				this.preferredKeyServer += input[mypos++];
	 			}
	 			break;
	 		case 25: // Primary User ID
	 			this.isPrimaryUserID = input[mypos++] != 0;
	 			break;
	 		case 26: // Policy URI
	 			this.policyURI = new String();
	 			for ( var i = 0; i < subplen-1; i++) {
	 				this.policyURI += input[mypos++];
	 			}
	 			break;
	 		case 27: // Key Flags
	 			this.keyFlags = new Array();
	 			for ( var i = 0; i < subplen-1; i++) {
	 				this.keyFlags = input[mypos++].charCodeAt();
	 			}
	 			break;
	 		case 28: // Signer's User ID
	 			this.signersUserId = new String();
	 			for ( var i = 0; i < subplen-1; i++) {
	 				this.signersUserId += input[mypos++];
	 			}
	 			break;
	 		case 29: // Reason for Revocation
	 			this.reasonForRevocationFlag = input[mypos++].charCodeAt();
	 			this.reasonForRevocationString = new String();
	 			for ( var i = 0; i < subplen -2; i++) {
	 				this.reasonForRevocationString += input[mypos++];
	 			}
	 			break;
	 		case 30: // Features
	 			// TODO: to be implemented
	 			return subplen+1;
	 		case 31: // Signature Target
	 			// (1 octet public-key algorithm, 1 octet hash algorithm, N octets hash)
	 			this.signatureTargetPublicKeyAlgorithm = input[mypos++].charCodeAt();
	 			this.signatureTargetHashAlgorithm = input[mypos++].charCodeAt();
	 			var signatureTargetHashAlgorithmLength = 0;
	 			switch(this.signatureTargetHashAlgorithm) {
	 			case  1: // - MD5 [HAC]                             "MD5"
	 			case  2: // - SHA-1 [FIPS180]                       "SHA1"
	 				signatureTargetHashAlgorithmLength = 20;
	 				break;
	 			case  3: // - RIPE-MD/160 [HAC]                     "RIPEMD160"
	 			case  8: // - SHA256 [FIPS180]                      "SHA256"
	 			case  9: // - SHA384 [FIPS180]                      "SHA384"
	 			case 10: // - SHA512 [FIPS180]                      "SHA512"
	 			case 11: // - SHA224 [FIPS180]                      "SHA224"
	 				break;
	 			// 100 to 110 - Private/Experimental algorithm
	 	    	default:
	 	    		util.print_error("openpgp.packet.signature.js\n"+"unknown signature target hash algorithm:"+this.signatureTargetHashAlgorithm);
	 	    		return null;
	 			}
	 			this.signatureTargetHash = new Array();
	 			for (var i = 0; i < signatureTargetHashAlgorithmLength; i++) {
	 				this.signatureTargetHash[i] = input[mypos++]; 
	 			}
	 		case 32: // Embedded Signature
	 			this.embeddedSignature = new openpgp_packet_signature();
	 			this.embeddedSignature.read_packet(input, mypos, len -(mypos-position));
	 			return ((mypos+ this.embeddedSignature.packetLength) - position);
	 			break;
	 		case 100: // Private or experimental
	 		case 101: // Private or experimental
	 		case 102: // Private or experimental
	 		case 103: // Private or experimental
	 		case 104: // Private or experimental
	 		case 105: // Private or experimental
	 		case 106: // Private or experimental
	 		case 107: // Private or experimental
	 		case 108: // Private or experimental
	 		case 109: // Private or experimental
	 		case 110: // Private or experimental
	 			util.print_error("openpgp.packet.signature.js\n"+'private or experimental signature subpacket type '+type+" @:"+mypos+" subplen:"+subplen+" len:"+len);
	 			return subplen+1;
	 			break;	
	 		case 0: // Reserved
	 		case 1: // Reserved
	 		case 8: // Reserved
	 		case 10: // Placeholder for backward compatibility
	 		case 13: // Reserved
	 		case 14: // Reserved
	 		case 15: // Reserved
	 		case 17: // Reserved
	 		case 18: // Reserved
	 		case 19: // Reserved
	 		default:
	 			util.print_error("openpgp.packet.signature.js\n"+'unknown signature subpacket type '+type+" @:"+mypos+" subplen:"+subplen+" len:"+len);
	 			return subplen+1;
	 			break;
	 		}
	 		return mypos -position;
	 	};
	 	/**
	 	 * verifys the signature packet. Note: not signature types are implemented
	 	 * @param {String} data data which on the signature applies
	 	 * @param {openpgp_msg_privatekey} key the public key to verify the signature
	 	 * @return {boolean} True if message is verified, else false.
	 	 */
	 	function verify(data, key) {
	 		// calculating the trailer
	 		var trailer = '';
	 		trailer += String.fromCharCode(this.version);
	 		trailer += String.fromCharCode(0xFF);
	 		trailer += String.fromCharCode(this.signatureData.length >> 24);
	 		trailer += String.fromCharCode((this.signatureData.length >> 16) &0xFF);
	 		trailer += String.fromCharCode((this.signatureData.length >> 8) &0xFF);
	 		trailer += String.fromCharCode(this.signatureData.length & 0xFF);
	 		switch(this.signatureType) {
	 		case 0: // 0x00: Signature of a binary document.
	 			if (this.version == 4) {
	 				this.verified = openpgp_crypto_verifySignature(this.publicKeyAlgorithm, this.hashAlgorithm, 
	 					this.MPIs, key.obj.publicKeyPacket.MPIs, data+this.signatureData+trailer);
	 			}
	 			break;
	 
	 		case 1: // 0x01: Signature of a canonical text document.
	 			if (this.version == 4) {
	 				this.verified = openpgp_crypto_verifySignature(this.publicKeyAlgorithm, this.hashAlgorithm, 
	 					this.MPIs, key.obj.publicKeyPacket.MPIs, data+this.signatureData+trailer);
	 				return this.verified;
	 			}
	 			break;
	 				
	 		case 2: // 0x02: Standalone signature.
	 			// This signature is a signature of only its own subpacket contents.
	 			// It is calculated identically to a signature over a zero-length
	 			// binary document.  Note that it doesn't make sense to have a V3
	 			// standalone signature.
	 			if (this.version == 3) {
	 				this.verified = false;
	 				break;
	 				}
	 			
	 			this.verified = openpgp_crypto_verifySignature(this.publicKeyAlgorithm, this.hashAlgorithm, 
	 					this.MPIs, key.obj.publicKeyPacket.MPIs, this.signatureData+trailer);
	 			break;
	 		case 16:			
	 			// 0x10: Generic certification of a User ID and Public-Key packet.
	 			// The issuer of this certification does not make any particular
	 			// assertion as to how well the certifier has checked that the owner
	 			// of the key is in fact the person described by the User ID.
	 		case 17:
	 			// 0x11: Persona certification of a User ID and Public-Key packet.
	 			// The issuer of this certification has not done any verification of
	 			// the claim that the owner of this key is the User ID specified.
	 		case 18:
	 			// 0x12: Casual certification of a User ID and Public-Key packet.
	 			// The issuer of this certification has done some casual
	 			// verification of the claim of identity.
	 		case 19:
	 			// 0x13: Positive certification of a User ID and Public-Key packet.
	 			// The issuer of this certification has done substantial
	 			// verification of the claim of identity.
	 			// 
	 			// Most OpenPGP implementations make their "key signatures" as 0x10
	 			// certifications.  Some implementations can issue 0x11-0x13
	 			// certifications, but few differentiate between the types.
	 		case 48:
	 			// 0x30: Certification revocation signature
	 			// This signature revokes an earlier User ID certification signature
	 			// (signature class 0x10 through 0x13) or direct-key signature
	 			// (0x1F).  It should be issued by the same key that issued the
	 			// revoked signature or an authorized revocation key.  The signature
	 			// is computed over the same data as the certificate that it
	 			// revokes, and should have a later creation date than that
	 			// certificate.
	 
	 			this.verified = openpgp_crypto_verifySignature(this.publicKeyAlgorithm, this.hashAlgorithm, 
	 					this.MPIs, key.MPIs, data+this.signatureData+trailer);
	 			break;
	 						
	 		case 24:
	 			// 0x18: Subkey Binding Signature
	 			// This signature is a statement by the top-level signing key that
	 			// indicates that it owns the subkey.  This signature is calculated
	 			// directly on the primary key and subkey, and not on any User ID or
	 			// other packets.  A signature that binds a signing subkey MUST have
	 			// an Embedded Signature subpacket in this binding signature that
	 			// contains a 0x19 signature made by the signing subkey on the
	 			// primary key and subkey.
	 			if (this.version == 3) {
	 				this.verified = false;
	 				break;
	 			}
	 			
	 			this.verified = openpgp_crypto_verifySignature(this.publicKeyAlgorithm, this.hashAlgorithm, 
	 					this.MPIs, key.MPIs, data+this.signatureData+trailer);
	 			break;
	 		case 25:
	 			// 0x19: Primary Key Binding Signature
	 			// This signature is a statement by a signing subkey, indicating
	 			// that it is owned by the primary key and subkey.  This signature
	 			// is calculated the same way as a 0x18 signature: directly on the
	 			// primary key and subkey, and not on any User ID or other packets.
	 			
	 			// When a signature is made over a key, the hash data starts with the
	 			// octet 0x99, followed by a two-octet length of the key, and then body
	 			// of the key packet.  (Note that this is an old-style packet header for
	 			// a key packet with two-octet length.)  A subkey binding signature
	 			// (type 0x18) or primary key binding signature (type 0x19) then hashes
	 			// the subkey using the same format as the main key (also using 0x99 as
	 			// the first octet).
	 		case 31:
	 			// 0x1F: Signature directly on a key
	 			// This signature is calculated directly on a key.  It binds the
	 			// information in the Signature subpackets to the key, and is
	 			// appropriate to be used for subpackets that provide information
	 			// about the key, such as the Revocation Key subpacket.  It is also
	 			// appropriate for statements that non-self certifiers want to make
	 			// about the key itself, rather than the binding between a key and a
	 			// name.
	 		case 32:
	 			// 0x20: Key revocation signature
	 			// The signature is calculated directly on the key being revoked.  A
	 			// revoked key is not to be used.  Only revocation signatures by the
	 			// key being revoked, or by an authorized revocation key, should be
	 			// considered valid revocation signatures.
	 		case 40:
	 			// 0x28: Subkey revocation signature
	 			// The signature is calculated directly on the subkey being revoked.
	 			// A revoked subkey is not to be used.  Only revocation signatures
	 			// by the top-level signature key that is bound to this subkey, or
	 			// by an authorized revocation key, should be considered valid
	 			// revocation signatures.
	 			this.verified = openpgp_crypto_verifySignature(this.publicKeyAlgorithm, this.hashAlgorithm, 
	 					this.MPIs, key.MPIs, data+this.signatureData+trailer);
	 			break;
	 			
	 			// Key revocation signatures (types 0x20 and 0x28)
	 			// hash only the key being revoked.
	 		case 64:
	 			// 0x40: Timestamp signature.
	 			// This signature is only meaningful for the timestamp contained in
	 			// it.
	 		case 80:
	 			//    0x50: Third-Party Confirmation signature.
	 			// This signature is a signature over some other OpenPGP Signature
	 			// packet(s).  It is analogous to a notary seal on the signed data.
	 			// A third-party signature SHOULD include Signature Target
	 			// subpacket(s) to give easy identification.  Note that we really do
	 			// mean SHOULD.  There are plausible uses for this (such as a blind
	 			// party that only sees the signature, not the key or source
	 			// document) that cannot include a target subpacket.
	 		default:
	 			util.print_error("openpgp.packet.signature.js\n"+"signature verification for type"+ this.signatureType+" not implemented");
	 			break;
	 		}
	 		return this.verified;
	 	}
	 	/**
	 	 * generates debug output (pretty print)
	 	 * @return {String} String which gives some information about the signature packet
	 	 */
	 
	 	function toString () {
	 		if (this.version == 3) {
	 			var result = '5.2. Signature Packet (Tag 2)\n'+
	 	          "Packet Length:                     :"+this.packetLength+'\n'+
	 	          "Packet version:                    :"+this.version+'\n'+
	 	          "One-octet signature type           :"+this.signatureType+'\n'+
	 	          "Four-octet creation time.          :"+this.creationTime+'\n'+
	 	         "Eight-octet Key ID of signer.       :"+util.hexidump(this.keyId)+'\n'+
	 	          "One-octet public-key algorithm.    :"+this.publicKeyAlgorithm+'\n'+
	 	          "One-octet hash algorithm.          :"+this.hashAlgorithm+'\n'+
	 	          "Two-octet field holding left\n" +
	 	          " 16 bits of signed hash value.     :"+this.signedHashValue+'\n';
	 		} else {
	           var result = '5.2. Signature Packet (Tag 2)\n'+
	           "Packet Length:                     :"+this.packetLength+'\n'+
	           "Packet version:                    :"+this.version+'\n'+
	           "One-octet signature type           :"+this.signatureType+'\n'+
	           "One-octet public-key algorithm.    :"+this.publicKeyAlgorithm+'\n'+
	           "One-octet hash algorithm.          :"+this.hashAlgorithm+'\n'+
	           "Two-octet field holding left\n" +
	           " 16 bits of signed hash value.     :"+this.signedHashValue+'\n'+
	           "Signature Creation Time            :"+this.creationTime+'\n'+
	           "Signature Expiration Time          :"+this.signatureExpirationTime+'\n'+
	           "Signature Never Expires            :"+this.signatureNeverExpires+'\n'+
	           "Exportable Certification           :"+this.exportable+'\n'+
	           "Trust Signature level:             :"+this.trustLevel+' amount'+this.trustAmount+'\n'+
	           "Regular Expression                 :"+this.regular_expression+'\n'+
	           "Revocable                          :"+this.revocable+'\n'+
	           "Key Expiration Time                :"+this.keyExpirationTime+" "+this.keyNeverExpires+'\n'+
	           "Preferred Symmetric Algorithms     :"+this.preferredSymmetricAlgorithms+'\n'+
	           "Revocation Key"+'\n'+
	           "   ( 1 octet of class,             :"+this.revocationKeyClass +'\n'+
	           "     1 octet of public-key ID,     :" +this.revocationKeyAlgorithm+'\n'+
	           "    20 octets of fingerprint)      :"+this.revocationKeyFingerprint+'\n'+
	           "Issuer                             :"+util.hexstrdump(this.issuerKeyId)+'\n'+
	           "Preferred Hash Algorithms          :"+this.preferredHashAlgorithms+'\n'+
	           "Preferred Compression Alg.         :"+this.preferredCompressionAlgorithms+'\n'+
	           "Key Server Preferences             :"+this.keyServerPreferences+'\n'+
	           "Preferred Key Server               :"+this.preferredKeyServer+'\n'+
	           "Primary User ID                    :"+this.isPrimaryUserID+'\n'+
	           "Policy URI                         :"+this.policyURI+'\n'+
	           "Key Flags                          :"+this.keyFlags+'\n'+
	           "Signer's User ID                   :"+this.signersUserId+'\n'+
	           "Notation                           :"+this.notationName+" = "+this.notationValue+"\n"+
	           "Reason for Revocation\n"+
	           "      Flag                         :"+this.reasonForRevocationFlag+'\n'+
	           "      Reason                       :"+this.reasonForRevocationString+'\nMPI:\n';
	 		}
	           for (var i = 0; i < this.MPIs.length; i++) {
	         	  result += this.MPIs[i].toString();
	           }
	           return result;
	      }
	 
	 	/**
	 	 * gets the issuer key id of this signature
	 	 * @return {String} issuer key id as string (8bytes)
	 	 */
	 	function getIssuer() {
	 		 if (this.version == 4)
	 			 return this.issuerKeyId;
	 		 if (this.verions == 4)
	 			 return this.keyId;
	 		 return null;
	 	}
	 
	 	/**
	 	 * Tries to get the corresponding public key out of the public keyring for the issuer created this signature
	 	 * @return {Object} {obj: [openpgp_msg_publickey], text: [String]} if found the public key will be returned. null otherwise
	 	 */
	 	function getIssuerKey() {
	 		 var result = null;
	 		 if (this.version == 4) {
	 			 result = openpgp.keyring.getPublicKeysForKeyId(this.issuerKeyId);
	 		 } else if (this.version == 3) {
	 			 result = openpgp.keyring.getPublicKeysForKeyId(this.keyId);
	 		 } else return null;
	 		 if (result.length == 0)
	 			 return null;
	 		 return result[0];
	 	}
	 	this.getIssuerKey = getIssuerKey;
	 	this.getIssuer = getIssuer;	 
	 	this.write_message_signature = write_message_signature;
	 	this.verify = verify;
	     this.read_packet = read_packet;
	     this.toString = toString;
	 }
	 // GPG4Browsers - An OpenPGP implementation in javascript
	 // Copyright (C) 2011 Recurity Labs GmbH
	 // 
	 // This library is free software; you can redistribute it and/or
	 // modify it under the terms of the GNU Lesser General Public
	 // License as published by the Free Software Foundation; either
	 // version 2.1 of the License, or (at your option) any later version.
	 // 
	 // This library is distributed in the hope that it will be useful,
	 // but WITHOUT ANY WARRANTY; without even the implied warranty of
	 // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
	 // Lesser General Public License for more details.
	 // 
	 // You should have received a copy of the GNU Lesser General Public
	 // License along with this library; if not, write to the Free Software
	 // Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
	 
	 /** 
	  * @class
	  * @classdesc Implementation of the User Attribute Packet (Tag 17)
	  *  The User Attribute packet is a variation of the User ID packet.  It
	  *  is capable of storing more types of data than the User ID packet,
	  *  which is limited to text.  Like the User ID packet, a User Attribute
	  *  packet may be certified by the key owner ("self-signed") or any other
	  *  key owner who cares to certify it.  Except as noted, a User Attribute
	  *  packet may be used anywhere that a User ID packet may be used.
	  *
	  *  While User Attribute packets are not a required part of the OpenPGP
	  *  standard, implementations SHOULD provide at least enough
	  *  compatibility to properly handle a certification signature on the
	  *  User Attribute packet.  A simple way to do this is by treating the
	  *  User Attribute packet as a User ID packet with opaque contents, but
	  *  an implementation may use any method desired.
	  */
	 function openpgp_packet_userattribute() {
	 	this.tagType = 17;
	 	this.certificationSignatures = new Array();
	 	this.certificationRevocationSignatures = new Array();
	 	this.revocationSignatures = new Array();
	 	this.parentNode = null;
	 
	 	/**
	 	 * parsing function for a user attribute packet (tag 17).
	 	 * @param {String} input payload of a tag 17 packet
	 	 * @param {Integer} position position to start reading from the input string
	 	 * @param {Integer} len length of the packet or the remaining length of input at position
	 	 * @return {openpgp_packet_encrypteddata} object representation
	 	 */
	 	function read_packet (input, position, len) {
	 		var total_len = 0;
	 		this.packetLength = len;
	 		this.userattributes = new Array();
	 		var count = 0;
	 		var mypos = position;
	 		while (len != total_len) {
	 			var current_len = 0;
	 			// 4.2.2.1. One-Octet Lengths
	 			if (input[mypos].charCodeAt() < 192) {
	 				packet_length = input[mypos++].charCodeAt();
	 				current_len = 1;
	 			// 4.2.2.2. Two-Octet Lengths
	 			} else if (input[mypos].charCodeAt() >= 192 && input[mypos].charCodeAt() < 224) {
	 				packet_length = ((input[mypos++].charCodeAt() - 192) << 8)
	 					+ (input[mypos++].charCodeAt()) + 192;
	 				current_len = 2;
	 			// 4.2.2.4. Partial Body Lengths
	 			} else if (input[mypos].charCodeAt() > 223 && input[mypos].charCodeAt() < 255) {
	 				packet_length = 1 << (input[mypos++].charCodeAt() & 0x1F);
	 				current_len = 1;
	 			// 4.2.2.3. Five-Octet Lengths
	 			} else {
	 				current_len = 5;
	 				mypos++;
	 				packet_length = (input[mypos++].charCodeAt() << 24) | (input[mypos++].charCodeAt() << 16)
	 					| (input[mypos++].charCodeAt() << 8) | input[mypos++].charCodeAt();
	 			}
	 			
	 			var subpackettype = input[mypos++].charCodeAt();
	 			packet_length--;
	 			current_len++;
	 			this.userattributes[count] = new Array();
	 			this.userattributes[count] = input.substring(mypos, mypos + packet_length);
	 			mypos += packet_length;
	 			total_len += current_len+packet_length;
	 		}
	 		this.packetLength = mypos - position;
	 		return this;
	 	}
	 	
	 	/**
	 	 * generates debug output (pretty print)
	 	 * @return {String} String which gives some information about the user attribute packet
	 	 */
	 	function toString() {
	 		var result = '5.12.  User Attribute Packet (Tag 17)\n'+
	 		             '    AttributePackets: (count = '+this.userattributes.length+')\n';
	 		for (var i = 0; i < this.userattributes.length; i++) {
	 			result += '    ('+this.userattributes[i].length+') bytes: ['+util.hexidump(this.userattributes[i])+']\n'; 
	 		}
	 		return result;
	 	}
	 	
	 	/**
	 	 * Continue parsing packets belonging to the user attribute packet such as signatures
	 	 * @param {Object} parent_node the parent object
	 	 * @param {String} input input string to read the packet(s) from
	 	 * @param {Integer} position start position for the parser
	 	 * @param {Integer} len length of the packet(s) or remaining length of input
	 	 * @return {Integer} length of nodes read
	 	 */
	 	function read_nodes(parent_node, input, position, len) {
	 		
	 		this.parentNode = parent_node;
	 		var exit = false;
	 		var pos = position;
	 		var l = len;
	 		while (input.length != pos) {
	 			var result = openpgp_packet.read_packet(input, pos, l);
	 			if (result == null) {
	 				util.print_error("openpgp.packet.userattribute.js\n"+'[user_attr] parsing ends here @:' + pos + " l:" + l);
	 				break;
	 			} else {
	 				switch (result.tagType) {
	 				case 2: // Signature Packet
	 					if (result.signatureType > 15
	 							&& result.signatureType < 20) // certification
	 						// //
	 						// signature
	 						this.certificationSignatures[this.certificationSignatures.length] = result;
	 					else if (result.signatureType == 32) // certification revocation signature
	 						this.certificationRevocationSignatures[this.certificationRevocationSignatures.length] = result;
	 					pos += result.packetLength + result.headerLength;
	 					l = len - (pos - position);
	 					break;
	 				default:
	 					this.data = input;
	 					this.position = position - parent_node.packetLength;
	 					this.len = pos - position;
	 					return this.len;
	 					break;
	 				}
	 			}
	 		}
	 		this.data = input;
	 		this.position = position - parent_node.packetLength;
	 		this.len = pos - position;
	 		return this.len;
	 
	 	}
	 	
	 	this.read_packet = read_packet;
	 	this.read_nodes = read_nodes;
	 	this.toString = toString;
	 	
	 };
	 // GPG4Browsers - An OpenPGP implementation in javascript
	 // Copyright (C) 2011 Recurity Labs GmbH
	 // 
	 // This library is free software; you can redistribute it and/or
	 // modify it under the terms of the GNU Lesser General Public
	 // License as published by the Free Software Foundation; either
	 // version 2.1 of the License, or (at your option) any later version.
	 // 
	 // This library is distributed in the hope that it will be useful,
	 // but WITHOUT ANY WARRANTY; without even the implied warranty of
	 // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
	 // Lesser General Public License for more details.
	 // 
	 // You should have received a copy of the GNU Lesser General Public
	 // License along with this library; if not, write to the Free Software
	 // Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
	 
	 /**
	  * @class
	  * @classdesc Implementation of the User ID Packet (Tag 13)
	  * A User ID packet consists of UTF-8 text that is intended to represent
	  * the name and email address of the key holder.  By convention, it
	  * includes an RFC 2822 [RFC2822] mail name-addr, but there are no
	  * restrictions on its content.  The packet length in the header
	  * specifies the length of the User ID. 
	  */
	 
	 function openpgp_packet_userid() {
	 	this.text = ''
	 	this.tagType = 13;
	 	this.certificationSignatures = new Array();
	 	this.certificationRevocationSignatures = new Array();
	 	this.revocationSignatures = new Array();
	 	this.parentNode = null;
	 	
	 	/**
	 	 * Set the packet text field to a native javascript string
	 	 * Conversion to a proper utf8 encoding takes place when the 
	 	 * packet is written.
	 	 * @param {String} str Any native javascript string
	 	 */
	 	this.set_text = function(str) {
	 		this.text = str;
	 	}
	 
	 	/**
	 	 * Set the packet text to value represented by the provided string
	 	 * of bytes.
	 	 * @param {String} bytes A string of bytes
	 	 */
	 	this.set_text_bytes = function(bytes) {
	 		this.text = util.decode_utf8(bytes);
	 	}
	 
	 	/**
	 	 * Get the byte sequence representing the text of this packet.
	 	 * @returns {String} A sequence of bytes
	 	 */
	 	this.get_text_bytes = function() {
	 		return util.encode_utf8(this.text);
	 	}
	 	
	 
	 	/**
	 	 * Parsing function for a user id packet (tag 13).
	 	 * @param {String} input payload of a tag 13 packet
	 	 * @param {Integer} position position to start reading from the input string
	 	 * @param {Integer} len length of the packet or the remaining length of input at position
	 	 * @return {openpgp_packet_encrypteddata} object representation
	 	 */
	 	this.read_packet = function(input, position, len) {
	 		this.packetLength = len;
	 
	 		var bytes = '';
	 		for ( var i = 0; i < len; i++) {
	 			bytes += input[position + i];
	 		}
	 
	 		this.set_text_bytes(bytes);
	 		return this;
	 	}
	 
	 	/**
	 	 * Creates a string representation of the user id packet
	 	 * @param {String} user_id the user id as string ("John Doe <john.doe@mail.us")
	 	 * @return {String} string representation
	 	 */
	 	this.write_packet = function(user_id) {
	 		this.set_text(user_id);
	 		var bytes = this.get_text_bytes();
	 
	 		var result = openpgp_packet.write_packet_header(13, bytes.length);
	 		result += bytes;
	 		return result;
	 	}
	 
	 	/**
	 	 * Continue parsing packets belonging to the userid packet such as signatures
	 	 * @param {Object} parent_node the parent object
	 	 * @param {String} input input string to read the packet(s) from
	 	 * @param {Integer} position start position for the parser
	 	 * @param {Integer} len length of the packet(s) or remaining length of input
	 	 * @return {Integer} length of nodes read
	 	 */
	 	this.read_nodes = function(parent_node, input, position, len) {
	 		if (parent_node.tagType == 6) { // public key
	 			this.parentNode = parent_node;
	 			var pos = position;
	 			var l = len;
	 			while (input.length != pos) {
	 				var result = openpgp_packet.read_packet(input, pos, l - (pos - position));
	 				if (result == null) {
	 					util.print_error('[user_id] parsing ends here @:' + pos + " l:" + l);
	 					break;
	 				} else {
	 					
	 					pos += result.packetLength + result.headerLength;
	 					l = input.length - pos;
	 					switch (result.tagType) {
	 					case 2: // Signature Packet
	 						if (result.signatureType > 15
	 								&& result.signatureType < 20) { // certification
	 							// //
	 							// signature
	 							this.certificationSignatures[this.certificationSignatures.length] = result;
	 							break;
	 						} else if (result.signatureType == 48) {// certification revocation signature
	 							this.certificationRevocationSignatures[this.certificationRevocationSignatures.length] = result;
	 							break;
	 						} else if (result.signatureType == 24) { // omg. standalone signature 
	 							this.certificationSignatures[this.certificationSignatures.length] = result;
	 							break;
	 						} else {
	 							util.print_debug("unknown sig t: "+result.signatureType+"@"+(pos - (result.packetLength + result.headerLength)));
	 						}
	 					default:
	 						this.data = input;
	 						this.position = position - parent_node.packetLength;
	 						this.len = pos - position -(result.headerLength + result.packetLength);
	 						return this.len;
	 					}
	 				}
	 			}
	 			this.data = input;
	 			this.position = position - parent_node.packetLength;
	 			this.len = pos - position -(result.headerLength + result.packetLength);
	 			return this.len;
	 		} else if (parent_node.tagType == 5) { // secret Key
	 			this.parentNode = parent_node;
	 			var exit = false;
	 			var pos = position;
	 			while (input.length != pos) {
	 				var result = openpgp_packet.read_packet(input, pos, l - (pos - position));
	 				if (result == null) {
	 					util.print_error('parsing ends here @:' + pos + " l:" + l);
	 					break;
	 				} else {
	 					pos += result.packetLength + result.headerLength;
	 					l = input.length - pos;
	 					switch (result.tagType) {
	 					case 2: // Signature Packet certification signature
	 						if (result.signatureType > 15
	 								&& result.signatureType < 20)
	 							this.certificationSignatures[this.certificationSignatures.length] = result;
	 						// certification revocation signature
	 						else if (result.signatureType == 48)
	 							this.certificationRevocationSignatures[this.certificationRevocationSignatures.length] = result;
	 					default:
	 						this.data = input;
	 						this.position = position - parent_node.packetLength;
	 						this.len = pos - position -(result.headerLength + result.packetLength);
	 						return this.len;
	 					}
	 				}
	 			}
	 		} else {
	 			util.print_error("unknown parent node for a userId packet "+parent_node.tagType);
	 		}
	 	}
	 	
	 	/**
	 	 * generates debug output (pretty print)
	 	 * @return {String} String which gives some information about the user id packet
	 	 */
	 	this.toString = function() {
	 		var result = '     5.11.  User ID Packet (Tag 13)\n' + '    text ('
	 				+ this.text.length + '): "' + this.text.replace("<", "&lt;")
	 				+ '"\n';
	 		result +="certification signatures:\n";
	 		for (var i = 0; i < this.certificationSignatures.length; i++) {
	 			result += "        "+this.certificationSignatures[i].toString();
	 		}
	 		result +="certification revocation signatures:\n";
	 		for (var i = 0; i < this.certificationRevocationSignatures.length; i++) {
	 			result += "        "+this.certificationRevocationSignatures[i].toString();
	 		}
	 		return result;
	 	}
	 
	 	/**
	 	 * lookup function to find certification revocation signatures
	 	 * @param {String} keyId string containing the key id of the issuer of this signature
	 	 * @return a CertificationRevocationSignature if found; otherwise null
	 	 */
	 	this.hasCertificationRevocationSignature = function(keyId) {
	 		for (var i = 0; i < this.certificationRevocationSignatures.length; i++) {
	 			if ((this.certificationRevocationSignatures[i].version == 3 &&
	 				 this.certificationRevocationSignatures[i].keyId == keyId) ||
	 				(this.certificationRevocationSignatures[i].version == 4 &&
	 				 this.certificationRevocationSignatures[i].issuerKeyId == keyId))
	 				return this.certificationRevocationSignatures[i];
	 		}
	 		return null;
	 	}
	 
	 	/**
	 	 * Verifies all certification signatures. This method does not consider possible revocation signatures.
	 	 * @param {Object} publicKeyPacket the top level key material
	 	 * @return {Integer[]} An array of integers corresponding to the array of certification signatures. The meaning of each integer is the following:
	 	 * 0 = bad signature
	 	 * 1 = signature expired
	 	 * 2 = issuer key not available
	 	 * 3 = revoked
	 	 * 4 = signature valid
	 	 * 5 = signature by key owner expired
	 	 * 6 = signature by key owner revoked
	 	 */
	 	this.verifyCertificationSignatures = function(publicKeyPacket) {
	 		var bytes = this.get_text_bytes();
	 		result = new Array();
	 		for (var i = 0 ; i < this.certificationSignatures.length; i++) {
	 			// A certification signature (type 0x10 through 0x13) hashes the User
	 			// ID being bound to the key into the hash context after the above
	 			// data.  A V3 certification hashes the contents of the User ID or
	 			// attribute packet packet, without any header.  A V4 certification
	 			// hashes the constant 0xB4 for User ID certifications or the constant
	 			// 0xD1 for User Attribute certifications, followed by a four-octet
	 			// number giving the length of the User ID or User Attribute data, and
	 			// then the User ID or User Attribute data.
	 
	 			if (this.certificationSignatures[i].version == 4) {
	 				if (this.certificationSignatures[i].signatureExpirationTime != null &&
	 						this.certificationSignatures[i].signatureExpirationTime != null &&
	 						this.certificationSignatures[i].signatureExpirationTime != 0 &&
	 						!this.certificationSignatures[i].signatureNeverExpires &&
	 						new Date(this.certificationSignatures[i].creationTime.getTime() +(this.certificationSignatures[i].signatureExpirationTime*1000)) < new Date()) {
	 					if (this.certificationSignatures[i].issuerKeyId == publicKeyPacket.getKeyId())
	 						result[i] = 5;
	 					else
	 						result[i] = 1;
	 					continue;
	 				}
	 				if (this.certificationSignatures[i].issuerKeyId == null) {
	 					result[i] = 0;
	 					continue;
	 				}
	 				var issuerPublicKey = openpgp.keyring.getPublicKeysForKeyId(this.certificationSignatures[i].issuerKeyId);
	 				if (issuerPublicKey == null || issuerPublicKey.length == 0) {
	 					result[i] = 2;
	 					continue;
	 				}
	 				// TODO: try to verify all returned issuer public keys (key ids are not unique!)
	 				var issuerPublicKey = issuerPublicKey[0];
	 				var signingKey = issuerPublicKey.obj.getSigningKey();
	 				if (signingKey == null) {
	 					result[i] = 0;
	 					continue;
	 				}
	 				var revocation = this.hasCertificationRevocationSignature(this.certificationSignatures[i].issuerKeyId);
	 				if (revocation != null && revocation.creationTime > 
	 					this.certificationSignatures[i].creationTime) {
	 
	 					var signaturedata = String.fromCharCode(0x99)+ publicKeyPacket.header.substring(1)+
	 					publicKeyPacket.data+String.fromCharCode(0xB4)+
	 					String.fromCharCode((bytes.length >> 24) & 0xFF)+
	 					String.fromCharCode((bytes.length >> 16) & 0xFF)+
	 					String.fromCharCode((bytes.length >>  8) & 0xFF)+
	 					String.fromCharCode((bytes.length) & 0xFF)+
	 					bytes;
	 					if (revocation.verify(signaturedata, signingKey)) {
	 						if (this.certificationSignatures[i].issuerKeyId == publicKeyPacket.getKeyId())
	 							result[i] = 6;
	 						else
	 							result[i] = 3;
	 						continue;
	 					}
	 				}
	 
	 				var signaturedata = String.fromCharCode(0x99)+ publicKeyPacket.header.substring(1)+
	 						publicKeyPacket.data+String.fromCharCode(0xB4)+
	 						String.fromCharCode((bytes.length >> 24) & 0xFF)+
	 						String.fromCharCode((bytes.length >> 16) & 0xFF)+
	 						String.fromCharCode((bytes.length >>  8) & 0xFF)+
	 						String.fromCharCode((bytes.length) & 0xFF)+
	 						bytes;
	 				if (this.certificationSignatures[i].verify(signaturedata, signingKey)) {
	 					result[i] = 4;
	 				} else
	 				result[i] = 0;
	 			} else if (this.certificationSignatures[i].version == 3) {
	 				if (this.certificationSignatures[i].keyId == null) {
	 					result[i] = 0;
	 					continue;
	 				}
	 				var issuerPublicKey = openpgp.keyring.getPublicKeysForKeyId(this.certificationSignatures[i].keyId);
	 				if (issuerPublicKey == null || issuerPublicKey.length == 0) {
	 					result[i] = 2;
	 					continue;
	 				}
	 				issuerPublicKey = issuerPublicKey[0];
	 				var signingKey = publicKey.obj.getSigningKey();
	 				if (signingKey == null) {
	 					result[i] = 0;
	 					continue;
	 				}
	 				var revocation = this.hasCertificationRevocationSignature(this.certificationSignatures[i].keyId);
	 				if (revocation != null && revocation.creationTime > 
	 					this.certificationSignatures[i].creationTime) {
	 					var signaturedata = String.fromCharCode(0x99)+ this.publicKeyPacket.header.substring(1)+
	 					this.publicKeyPacket.data+bytes;
	 					if (revocation.verify(signaturedata, signingKey)) {
	 						if (revocation.keyId == publicKeyPacket.getKeyId())
	 							result[i] = 6;
	 						else
	 							result[i] = 3;
	 						continue;
	 					}
	 				}
	 				var signaturedata = String.fromCharCode(0x99)+ publicKeyPacket.header.substring(1)+
	 					publicKeyPacket.data + bytes;
	 				if (this.certificationSignatures[i].verify(signaturedata, signingKey)) {
	 					result[i] = 4;
	 				} else 
	 				result[i] = 0;
	 			} else {
	 				result[i] = 0;
	 			}
	 		}
	 		return result;
	 	}
	 
	 	/**
	 	 * verifies the signatures of the user id
	 	 * @return 0 if the userid is valid; 1 = userid expired; 2 = userid revoked
	 	 */
	 	this.verify = function(publicKeyPacket) {
	 		var result = this.verifyCertificationSignatures(publicKeyPacket);
	 		if (result.indexOf(6) != -1)
	 			return 2;
	 		if (result.indexOf(5) != -1)
	 			return 1;
	 		return 0;
	 	}
	 
	 	// TODO: implementation missing
	 	this.addCertification = function(publicKeyPacket, privateKeyPacket) {
	 		
	 	}
	 
	 	// TODO: implementation missing
	 	this.revokeCertification = function(publicKeyPacket, privateKeyPacket) {
	 		
	 	}
	 }
	 // GPG4Browsers - An OpenPGP implementation in javascript
	 // Copyright (C) 2011 Recurity Labs GmbH
	 // 
	 // This library is free software; you can redistribute it and/or
	 // modify it under the terms of the GNU Lesser General Public
	 // License as published by the Free Software Foundation; either
	 // version 2.1 of the License, or (at your option) any later version.
	 // 
	 // This library is distributed in the hope that it will be useful,
	 // but WITHOUT ANY WARRANTY; without even the implied warranty of
	 // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
	 // Lesser General Public License for more details.
	 // 
	 // You should have received a copy of the GNU Lesser General Public
	 // License along with this library; if not, write to the Free Software
	 // Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
	 
	 /**
	  * @class
	  * @classdesc Implementation of type key id (RFC4880 3.3)
	  *  A Key ID is an eight-octet scalar that identifies a key.
	    Implementations SHOULD NOT assume that Key IDs are unique.  The
	    section "Enhanced Key Formats" below describes how Key IDs are
	    formed.
	  */
	 function openpgp_type_keyid() {
	 	/**
	 	 * Parsing method for a key id
	 	 * @param {String} input Input to read the key id from 
	 	 * @param {integer} position Position where to start reading the key 
	 	 * id from input
	 	 * @return {openpgp_type_keyid} This object
	 	 */
	 	function read_packet(input, position) {
	 		this.bytes = input.substring(position, position+8);
	 		return this;
	 	}
	 	
	 	/**
	 	 * Generates debug output (pretty print)
	 	 * @return {String} Key Id as hexadecimal string
	 	 */
	 	function toString() {
	 		return util.hexstrdump(this.bytes);
	 	}
	 	
	 	this.read_packet = read_packet;
	 	this.toString = toString;
	 };
	 // GPG4Browsers - An OpenPGP implementation in javascript
	 // Copyright (C) 2011 Recurity Labs GmbH
	 // 
	 // This library is free software; you can redistribute it and/or
	 // modify it under the terms of the GNU Lesser General Public
	 // License as published by the Free Software Foundation; either
	 // version 2.1 of the License, or (at your option) any later version.
	 // 
	 // This library is distributed in the hope that it will be useful,
	 // but WITHOUT ANY WARRANTY; without even the implied warranty of
	 // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
	 // Lesser General Public License for more details.
	 // 
	 // You should have received a copy of the GNU Lesser General Public
	 // License along with this library; if not, write to the Free Software
	 // Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
	 
	 // Hint: We hold our MPIs as an array of octets in big endian format preceeding a two
	 // octet scalar: MPI: [a,b,c,d,e,f]
	 // - MPI size: (a << 8) | b 
	 // - MPI = c | d << 8 | e << ((MPI.length -2)*8) | f ((MPI.length -2)*8)
	 
	 /**
	  * @class
	  * @classdescImplementation of type MPI (RFC4880 3.2)
	  * Multiprecision integers (also called MPIs) are unsigned integers used
	  * to hold large integers such as the ones used in cryptographic
	  * calculations.
	  * An MPI consists of two pieces: a two-octet scalar that is the length
	  * of the MPI in bits followed by a string of octets that contain the
	  * actual integer.
	  */
	 function openpgp_type_mpi() {
	 	this.MPI = null;
	 	this.mpiBitLength = null;
	 	this.mpiByteLength = null;
	 	this.data = null;
	 	/**
	 	 * Parsing function for a mpi (RFC 4880 3.2).
	 	 * @param {String} input Payload of mpi data
	 	 * @param {Integer} position Position to start reading from the input 
	 	 * string
	 	 * @param {Integer} len Length of the packet or the remaining length of 
	 	 * input at position
	 	 * @return {openpgp_type_mpi} Object representation
	 	 */
	 	function read(input, position, len) {
	 		var mypos = position;
	 		
	 		this.mpiBitLength = (input[mypos++].charCodeAt() << 8) | input[mypos++].charCodeAt();
	 		
	 		// Additional rules:
	 		//
	 		//    The size of an MPI is ((MPI.length + 7) / 8) + 2 octets.
	 		//
	 		//    The length field of an MPI describes the length starting from its
	 		//	  most significant non-zero bit.  Thus, the MPI [00 02 01] is not
	 		//    formed correctly.  It should be [00 01 01].
	 
	 		// TODO: Verification of this size method! This size calculation as
	 		// 		 specified above is not applicable in JavaScript
	 		this.mpiByteLength = (this.mpiBitLength - (this.mpiBitLength % 8)) / 8;
	 		if (this.mpiBitLength % 8 != 0)
	 			this.mpiByteLength++;
	 		
	 		this.MPI = input.substring(mypos,mypos+this.mpiByteLength);
	 		this.data = input.substring(position, position+2+this.mpiByteLength);
	 		this.packetLength = this.mpiByteLength +2;
	 		return this;
	 	}
	 	
	 	/**
	 	 * Generates debug output (pretty print)
	 	 * @return {String} String which gives some information about the mpi
	 	 */
	 	function toString() {
	 		var r = "    MPI("+this.mpiBitLength+"b/"+this.mpiByteLength+"B) : 0x";
	 		r+=util.hexstrdump(this.MPI);
	 		return r+'\n';
	 	}
	 	
	 	/**
	 	 * Converts the mpi to an BigInteger object
	 	 * @return {BigInteger}
	 	 */
	 	function getBigInteger() {
	 		return new BigInteger(util.hexstrdump(this.MPI),16); 
	 	}
	 
	 	
	 	function getBits(num) {
	 		for (var i = 0; i < 9; i++)
	 		if (num >> i == 0)
	 		return i;
	 	}
	 	
	 	/**
	 	 * Gets the length of the mpi in bytes
	 	 * @return {Integer} Mpi byte length
	 	 */
	 	function getByteLength() {
	 		return this.mpiByteLength;
	 	}
	 	
	 	/**
	 	 * Creates an mpi from the specified string
	 	 * @param {String} data Data to read the mpi from
	 	 * @return {openpgp_type_mpi} 
	 	 */
	 	function create(data) {
	 		this.MPI = data;
	 		this.mpiBitLength = (data.length -1) *8 + getBits(data.charCodeAt(0));
	 		this.mpiByteLength = data.length;
	 		return this;
	 	}
	 	
	 	/**
	 	 * Converts the mpi object to a string as specified in RFC4880 3.2
	 	 * @return {String} mpi Byte representation
	 	 */
	 	function toBin() {
	 		var result = String.fromCharCode((this.mpiBitLength >> 8) & 0xFF);
	 		result += String.fromCharCode(this.mpiBitLength & 0xFF);
	 		result += this.MPI;
	 		return result;
	 	}
	 	
	 	this.read = read;
	 	this.toBigInteger = getBigInteger;
	 	this.toString = toString;
	 	this.create = create;
	 	this.toBin = toBin;
	 	this.getByteLength = getByteLength;
	 }
	 
	 // GPG4Browsers - An OpenPGP implementation in javascript
	 // Copyright (C) 2011 Recurity Labs GmbH
	 // 
	 // This library is free software; you can redistribute it and/or
	 // modify it under the terms of the GNU Lesser General Public
	 // License as published by the Free Software Foundation; either
	 // version 2.1 of the License, or (at your option) any later version.
	 // 
	 // This library is distributed in the hope that it will be useful,
	 // but WITHOUT ANY WARRANTY; without even the implied warranty of
	 // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
	 // Lesser General Public License for more details.
	 // 
	 // You should have received a copy of the GNU Lesser General Public
	 // License along with this library; if not, write to the Free Software
	 // Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
	 
	 /**
	  * @class
	  * @classdesc Implementation of the String-to-key specifier (RFC4880 3.7)
	  * String-to-key (S2K) specifiers are used to convert passphrase strings
	    into symmetric-key encryption/decryption keys.  They are used in two
	    places, currently: to encrypt the secret part of private keys in the
	    private keyring, and to convert passphrases to encryption keys for
	    symmetrically encrypted messages.
	  */
	 function openpgp_type_s2k() {
	 	/**
	 	 * Parsing function for a string-to-key specifier (RFC 4880 3.7).
	 	 * @param {String} input Payload of string-to-key specifier
	 	 * @param {Integer} position Position to start reading from the input string
	 	 * @return {openpgp_type_s2k} Object representation
	 	 */
	 	function read(input, position) {
	 		var mypos = position;
	 		this.type = input[mypos++].charCodeAt();
	 		switch (this.type) {
	 		case 0: // Simple S2K
	 			// Octet 1: hash algorithm
	 			this.hashAlgorithm = input[mypos++].charCodeAt();
	 			this.s2kLength = 1;
	 			break;
	 
	 		case 1: // Salted S2K
	 			// Octet 1: hash algorithm
	 			this.hashAlgorithm = input[mypos++].charCodeAt();
	 
	 			// Octets 2-9: 8-octet salt value
	 			this.saltValue = input.substring(mypos, mypos+8);
	 			mypos += 8;
	 			this.s2kLength = 9;
	 			break;
	 
	 		case 3: // Iterated and Salted S2K
	 			// Octet 1: hash algorithm
	 			this.hashAlgorithm = input[mypos++].charCodeAt();
	 
	 			// Octets 2-9: 8-octet salt value
	 			this.saltValue = input.substring(mypos, mypos+8);
	 			mypos += 8;
	 
	 			// Octet 10: count, a one-octet, coded value
	 			this.EXPBIAS = 6;
	 			var c = input[mypos++].charCodeAt();
	 			this.count = (16 + (c & 15)) << ((c >> 4) + this.EXPBIAS);
	 			this.s2kLength = 10;
	 			break;
	 
	 		case 101:
	 			if(input.substring(mypos+1, mypos+4) == "GNU") {
	 				this.hashAlgorithm = input[mypos++].charCodeAt();
	 				mypos += 3; // GNU
	 				var gnuExtType = 1000 + input[mypos++].charCodeAt();
	 				if(gnuExtType == 1001) {
	 					this.type = gnuExtType;
	 					this.s2kLength = 5;
	 					// GnuPG extension mode 1001 -- don't write secret key at all
	 				} else {
	 					util.print_error("unknown s2k gnu protection mode! "+this.type);
	 				}
	 			} else {
	 				util.print_error("unknown s2k type! "+this.type);
	 			}
	 			break;
	 
	 		case 2: // Reserved value
	 		default:
	 			util.print_error("unknown s2k type! "+this.type);
	 			break;
	 		}
	 		return this;
	 	}
	 	
	 	
	 	/**
	 	 * writes an s2k hash based on the inputs.
	 	 * @return {String} Produced key of hashAlgorithm hash length
	 	 */
	 	function write(type, hash, passphrase, salt, c){
	 	    this.type = type;
	 	    if(this.type == 3){this.saltValue = salt;
	 	        this.hashAlgorithm = hash;
	 	        this.count = (16 + (c & 15)) << ((c >> 4) + 6);
	 	        this.s2kLength = 10;
	 	    }
	 	    return this.produce_key(passphrase);
	 	}
	 
	 	/**
	 	 * Produces a key using the specified passphrase and the defined 
	 	 * hashAlgorithm 
	 	 * @param {String} passphrase Passphrase containing user input
	 	 * @return {String} Produced key with a length corresponding to 
	 	 * hashAlgorithm hash length
	 	 */
	 	function produce_key(passphrase, numBytes) {
	 		passphrase = util.encode_utf8(passphrase);
	 		if (this.type == 0) {
	 			return openpgp_crypto_hashData(this.hashAlgorithm,passphrase);
	 		} else if (this.type == 1) {
	 			return openpgp_crypto_hashData(this.hashAlgorithm,this.saltValue+passphrase);
	 		} else if (this.type == 3) {
	 			var isp = [];
	 			isp[0] = this.saltValue+passphrase;
	 			while (isp.length*(this.saltValue+passphrase).length < this.count)
	 				isp.push(this.saltValue+passphrase);
	 			isp = isp.join('');			
	 			if (isp.length > this.count)
	 				isp = isp.substr(0, this.count);
	 			if(numBytes && (numBytes == 24 || numBytes == 32)){ //This if accounts for RFC 4880 3.7.1.1 -- If hash size is greater than block size, use leftmost bits.  If blocksize larger than hash size, we need to rehash isp and prepend with 0.
	 			    var key = openpgp_crypto_hashData(this.hashAlgorithm,isp);
	 			    return key + openpgp_crypto_hashData(this.hashAlgorithm,String.fromCharCode(0)+isp);
	 			}
	 			return openpgp_crypto_hashData(this.hashAlgorithm,isp);
	 		} else return null;
	 	}
	 	
	 	this.read = read;
	 	this.write = write;
	 	this.produce_key = produce_key;
	 }
	 // GPG4Browsers - An OpenPGP implementation in javascript
	 // Copyright (C) 2011 Recurity Labs GmbH
	 // 
	 // This library is free software; you can redistribute it and/or
	 // modify it under the terms of the GNU Lesser General Public
	 // License as published by the Free Software Foundation; either
	 // version 2.1 of the License, or (at your option) any later version.
	 // 
	 // This library is distributed in the hope that it will be useful,
	 // but WITHOUT ANY WARRANTY; without even the implied warranty of
	 // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
	 // Lesser General Public License for more details.
	 // 
	 // You should have received a copy of the GNU Lesser General Public
	 // License along with this library; if not, write to the Free Software
	 // Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
	 
	 var Util = function() {
	 
	     this.emailRegEx = /[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?/;
	 
	     // ' <--- un-bork sytax highlighting!
	 	
	 	this.hexdump = function(str) {
	 	    var r=[];
	 	    var e=str.length;
	 	    var c=0;
	 	    var h;
	 	    var i = 0;
	 	    while(c<e){
	 	        h=str.charCodeAt(c++).toString(16);
	 	        while(h.length<2) h="0"+h;
	 	        r.push(" "+h);
	 	        i++;
	 	        if (i % 32 == 0)
	 	        	r.push("\n           ");
	 	    }
	 	    return r.join('');
	 	};
	 	
	 	/**
	 	 * Create hexstring from a binary
	 	 * @param {String} str String to convert
	 	 * @return {String} String containing the hexadecimal values
	 	 */
	 	this.hexstrdump = function(str) {
	 		if (str == null)
	 			return "";
	 	    var r=[];
	 	    var e=str.length;
	 	    var c=0;
	 	    var h;
	 	    while(c<e){
	 	        h=str[c++].charCodeAt().toString(16);
	 	        while(h.length<2) h="0"+h;
	 	        r.push(""+h);
	 	    }
	 	    return r.join('');
	 	};
	 	
	 	/**
	 	 * Create binary string from a hex encoded string
	 	 * @param {String} str Hex string to convert
	 	 * @return {String} String containing the binary values
	 	 */
	 	this.hex2bin = function(hex) {
	 	    var str = '';
	 	    for (var i = 0; i < hex.length; i += 2)
	 	        str += String.fromCharCode(parseInt(hex.substr(i, 2), 16));
	 	    return str;
	 	};
	 	
	 	/**
	 	 * Creating a hex string from an binary array of integers (0..255)
	 	 * @param {String} str Array of bytes to convert
	 	 * @return {String} Hexadecimal representation of the array
	 	 */
	 	this.hexidump = function(str) {
	 	    var r=[];
	 	    var e=str.length;
	 	    var c=0;
	 	    var h;
	 	    while(c<e){
	 	        h=str[c++].toString(16);
	 	        while(h.length<2) h="0"+h;
	 	        r.push(""+h);
	 	    }
	 	    return r.join('');
	 	};
	 
	 
	 	/**
	 	 * Convert a native javascript string to a string of utf8 bytes
	 	 * @param {String} str The string to convert
	 	 * @return {String} A valid squence of utf8 bytes
	 	 */
	 	this.encode_utf8 = function(str) {
	 		return unescape(encodeURIComponent(str));
	 	};
	 
	 	/**
	 	 * Convert a string of utf8 bytes to a native javascript string
	 	 * @param {String} utf8 A valid squence of utf8 bytes
	 	 * @return {String} A native javascript string
	 	 */
	 	this.decode_utf8 = function(utf8) {
	 		try {
	       return decodeURIComponent(escape(utf8));
	     } catch (e) {
	       return utf8;
	     }
	 	};
	 
	 	var str2bin = function(str, result) {
	 		for (var i = 0; i < str.length; i++) {
	 			result[i] = str.charCodeAt(i);
	 		}
	 
	 		return result;
	 	};
	 	
	 	var bin2str = function(bin) {
	 		var result = [];
	 
	 		for (var i = 0; i < bin.length; i++) {
	 			result.push(String.fromCharCode(bin[i]));
	 		}
	 
	 		return result.join('');
	 	};
	 
	 	/**
	 	 * Convert a string to an array of integers(0.255)
	 	 * @param {String} str String to convert
	 	 * @return {Integer[]} An array of (binary) integers
	 	 */
	 	this.str2bin = function(str) { 
	 		return str2bin(str, new Array(str.length));
	 	};
	 	
	 	
	 	/**
	 	 * Convert an array of integers(0.255) to a string 
	 	 * @param {Integer[]} bin An array of (binary) integers to convert
	 	 * @return {String} The string representation of the array
	 	 */
	 	this.bin2str = bin2str;
	 	
	 	/**
	 	 * Convert a string to a Uint8Array
	 	 * @param {String} str String to convert
	 	 * @return {Uint8Array} The array of (binary) integers
	 	 */
	 	this.str2Uint8Array = function(str) { 
	 		return str2bin(str, new Uint8Array(new ArrayBuffer(str.length))); 
	 	};
	 	
	 	/**
	 	 * Convert a Uint8Array to a string. This currently functions 
	 	 * the same as bin2str. 
	 	 * @param {Uint8Array} bin An array of (binary) integers to convert
	 	 * @return {String} String representation of the array
	 	 */
	 	this.Uint8Array2str = bin2str;
	 	
	 	/**
	 	 * Calculates a 16bit sum of a string by adding each character 
	 	 * codes modulus 65535
	 	 * @param {String} text String to create a sum of
	 	 * @return {Integer} An integer containing the sum of all character 
	 	 * codes % 65535
	 	 */
	 	this.calc_checksum = function(text) {
	 		var checksum = {  s: 0, add: function (sadd) { this.s = (this.s + sadd) % 65536; }};
	 		for (var i = 0; i < text.length; i++) {
	 			checksum.add(text.charCodeAt(i));
	 		}
	 		return checksum.s;
	 	};
	 	
	 	/**
	 	 * Helper function to print a debug message. Debug 
	 	 * messages are only printed if
	 	 * openpgp.config.debug is set to true. The calling
	 	 * Javascript context MUST define
	 	 * a "showMessages(text)" function. Line feeds ('\n')
	 	 * are automatically converted to HTML line feeds '<br/>'
	 	 * @param {String} str String of the debug message
	 	 * @return {String} An HTML tt entity containing a paragraph with a 
	 	 * style attribute where the debug message is HTMLencoded in. 
	 	 */
	 	this.print_debug = function(str) {
	 		if (openpgp.config.debug) {
	 			compat.print_debug(str);
	 		}
	 	};
	 	
	 	/**
	 	 * Helper function to print a debug message. Debug 
	 	 * messages are only printed if
	 	 * openpgp.config.debug is set to true. The calling
	 	 * Javascript context MUST define
	 	 * a "showMessages(text)" function. Line feeds ('\n')
	 	 * are automatically converted to HTML line feeds '<br/>'
	 	 * Different than print_debug because will call hexstrdump iff necessary.
	 	 * @param {String} str String of the debug message
	 	 * @return {String} An HTML tt entity containing a paragraph with a 
	 	 * style attribute where the debug message is HTMLencoded in. 
	 	 */
	 	this.print_debug_hexstr_dump = function(str,strToHex) {
	 		if (openpgp.config.debug) {
	 			str = str + this.hexstrdump(strToHex);
	 			this.print_debug(str);
	 		}
	 	};
	 	
	 	/**
	 	 * Helper function to print an error message. 
	 	 * The calling Javascript context MUST define
	 	 * a "showMessages(text)" function. Line feeds ('\n')
	 	 * are automatically converted to HTML line feeds '<br/>'
	 	 * @param {String} str String of the error message
	 	 * @return {String} A HTML paragraph entity with a style attribute 
	 	 * containing the HTML encoded error message
	 	 */
	 	this.print_error = function(str) {
	 		compat.print_error(str);
	 	};
	 	
	 	/**
	 	 * Helper function to print an info message. 
	 	 * The calling Javascript context MUST define
	 	 * a "showMessages(text)" function. Line feeds ('\n')
	 	 * are automatically converted to HTML line feeds '<br/>'.
	 	 * @param {String} str String of the info message
	 	 * @return {String} A HTML paragraph entity with a style attribute 
	 	 * containing the HTML encoded info message
	 	 */
	 	this.print_info = function(str) {
	 		compat.print_info(str);
	 	};
	 	
	 	this.print_warning = function(str) {
	 		compat.print_warning(str);
	 	};
	 	
	 	this.getLeftNBits = function (string, bitcount) {
	 		var rest = bitcount % 8;
	 		if (rest == 0)
	 			return string.substring(0, bitcount / 8);
	 		var bytes = (bitcount - rest) / 8 +1;
	 		var result = string.substring(0, bytes);
	 		return this.shiftRight(result, 8-rest); // +String.fromCharCode(string.charCodeAt(bytes -1) << (8-rest) & 0xFF);
	 	};
	 
	 	/**
	 	 * Shifting a string to n bits right
	 	 * @param {String} value The string to shift
	 	 * @param {Integer} bitcount Amount of bits to shift (MUST be smaller 
	 	 * than 9)
	 	 * @return {String} Resulting string. 
	 	 */
	 	this.shiftRight = function(value, bitcount) {
	 		var temp = util.str2bin(value);
	         if (bitcount % 8 != 0) {
	         	for (var i = temp.length-1; i >= 0; i--) {
	         		temp[i] >>= bitcount % 8;
	         		if (i > 0)
	         			temp[i] |= (temp[i - 1] << (8 - (bitcount % 8))) & 0xFF;
	         	}
	         } else {
	         	return value;
	         }
	         return util.bin2str(temp);
	 	};
	 	
	 	/**
	 	 * Return the algorithm type as string
	 	 * @return {String} String representing the message type
	 	 */
	 	this.get_hashAlgorithmString = function(algo) {
	 		switch(algo) {
	 		case 1:
	 			return "MD5";
	 		case 2:
	 			return "SHA1";
	 		case 3:
	 			return "RIPEMD160";
	 		case 8:
	 			return "SHA256";
	 		case 9:
	 			return "SHA384";
	 		case 10:
	 			return "SHA512";
	 		case 11:
	 			return "SHA224";
	 		}
	 		return "unknown";
	 	};
	 };
	 
	 /**
	  * an instance that should be used. 
	  */
	 var util = new Util();
	 exports.OpenPGP = _openpgp;
	 exports.openpgp = openpgp;
	 exports.ciphers = {
	 	symmetric : {
	 		AES: {
	 			encrypt : AESencrypt,
	 			keyExpansion : keyExpansion
	 		},
	 		Blowfish : {
	 			encrypt : BFencrypt
	 		},
	 		Cast5 : {
	 			encrypt : cast5_encrypt
	 		},
	 		DES : {
	 			createKeys : des_createKeys,
	 			desede : desede,
	 			des : des
	 		},
	 		Twofish : {
	 			encrypt : TFencrypt
	 		}
	 	},
	 	asymmetric : {
	 		RSA : RSA,
	 		DSA : DSA,
	 		Elgamal : Elgamal
	 	}
	 };
	 exports.crypto = {
	 	asymetricEncrypt : openpgp_crypto_asymetricEncrypt,
	 	asymetricDecrypt : openpgp_crypto_asymetricDecrypt,
	 	symmetricEncrypt : openpgp_crypto_symmetricEncrypt,
	 	symmetricDecrypt : openpgp_crypto_symmetricDecrypt,
	 	verifySignature  : openpgp_crypto_verifySignature,
	 	signData : openpgp_crypto_signData,
	 	getPrefixRandom : openpgp_crypto_getPrefixRandom,
	 	generateSessionKey : openpgp_crypto_generateSessionKey,
	 	testRSA : openpgp_crypto_testRSA
	 };
	 exports.packet = {
	 	KeyMaterial : openpgp_packet_keymaterial,
	 	UserID : openpgp_packet_userid,
	 	Signature : openpgp_packet_signature
	 };
	 exports.msg = {
	 	PrivateKey : openpgp_msg_privatekey
	 };
	 exports.type = {
	 	MPI : openpgp_type_mpi
	 };
	 exports.encoding = {
	 	eme_pkcs1_decode : openpgp_encoding_eme_pkcs1_decode,
	 	eme_pkcs1_encode : openpgp_encoding_eme_pkcs1_encode,
	 	armor : openpgp_encoding_armor
	 };
	 exports.keyring = openpgp_keyring;
	 exports.hash = {
	 	MD5 : MD5,
	 	SHA : {
	 		str : {
	 			sha1 : str_sha1,
	 			sha224 : str_sha224,
	 			sha256 : str_sha256,
	 			sha384 : str_sha384,
	 			sha512 : str_sha512
	 		}
	 	},
	 	RipeMD : {
	 		hash : RMD,
	 		str : RMDstring
	 	}
	 };
	 exports.util = util;
	 exports.compat = compat;
	 exports.bigint = {
	 	BigInteger : BigInteger,
	 	nbi : nbi,
	 	nbv : nbv,
	 	Montgomery : Montgomery,
	 	Classic : Classic,
	 	nbits : nbits
	 };
})(this);

},{}],26:[function(require,module,exports){
// Generated by IcedCoffeeScript 1.6.3-g
(function() {
  var AES, BlockCipher, G, Global, scrub_vec,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };



  BlockCipher = require('./algbase').BlockCipher;

  scrub_vec = require('./util').scrub_vec;

  Global = (function() {
    function Global() {
      var i;
      this.SBOX = [];
      this.INV_SBOX = [];
      this.SUB_MIX = (function() {
        var _i, _results;
        _results = [];
        for (i = _i = 0; _i < 4; i = ++_i) {
          _results.push([]);
        }
        return _results;
      })();
      this.INV_SUB_MIX = (function() {
        var _i, _results;
        _results = [];
        for (i = _i = 0; _i < 4; i = ++_i) {
          _results.push([]);
        }
        return _results;
      })();
      this.init();
      this.RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];
    }

    Global.prototype.init = function() {
      var d, i, sx, t, x, x2, x4, x8, xi, _i, _results;
      d = (function() {
        var _i, _results;
        _results = [];
        for (i = _i = 0; _i < 256; i = ++_i) {
          if (i < 128) {
            _results.push(i << 1);
          } else {
            _results.push((i << 1) ^ 0x11b);
          }
        }
        return _results;
      })();
      x = 0;
      xi = 0;
      _results = [];
      for (i = _i = 0; _i < 256; i = ++_i) {
        sx = xi ^ (xi << 1) ^ (xi << 2) ^ (xi << 3) ^ (xi << 4);
        sx = (sx >>> 8) ^ (sx & 0xff) ^ 0x63;
        this.SBOX[x] = sx;
        this.INV_SBOX[sx] = x;
        x2 = d[x];
        x4 = d[x2];
        x8 = d[x4];
        t = (d[sx] * 0x101) ^ (sx * 0x1010100);
        this.SUB_MIX[0][x] = (t << 24) | (t >>> 8);
        this.SUB_MIX[1][x] = (t << 16) | (t >>> 16);
        this.SUB_MIX[2][x] = (t << 8) | (t >>> 24);
        this.SUB_MIX[3][x] = t;
        t = (x8 * 0x1010101) ^ (x4 * 0x10001) ^ (x2 * 0x101) ^ (x * 0x1010100);
        this.INV_SUB_MIX[0][sx] = (t << 24) | (t >>> 8);
        this.INV_SUB_MIX[1][sx] = (t << 16) | (t >>> 16);
        this.INV_SUB_MIX[2][sx] = (t << 8) | (t >>> 24);
        this.INV_SUB_MIX[3][sx] = t;
        if (x === 0) {
          _results.push(x = xi = 1);
        } else {
          x = x2 ^ d[d[d[x8 ^ x2]]];
          _results.push(xi ^= d[d[xi]]);
        }
      }
      return _results;
    };

    return Global;

  })();

  G = new Global();

  AES = (function(_super) {
    __extends(AES, _super);

    AES.blockSize = 4 * 4;

    AES.prototype.blockSize = AES.blockSize;

    AES.keySize = 256 / 8;

    AES.prototype.keySize = AES.keySize;

    AES.ivSize = AES.blockSize;

    AES.prototype.ivSize = AES.ivSize;

    function AES(key) {
      this._key = key.clone();
      this._doReset();
    }

    AES.prototype._doReset = function() {
      var invKsRow, keySize, keyWords, ksRow, ksRows, t, _i, _j, _results;
      keyWords = this._key.words;
      keySize = this._key.sigBytes / 4;
      this._nRounds = keySize + 6;
      ksRows = (this._nRounds + 1) * 4;
      this._keySchedule = [];
      for (ksRow = _i = 0; 0 <= ksRows ? _i < ksRows : _i > ksRows; ksRow = 0 <= ksRows ? ++_i : --_i) {
        this._keySchedule[ksRow] = ksRow < keySize ? keyWords[ksRow] : (t = this._keySchedule[ksRow - 1], (ksRow % keySize) === 0 ? (t = (t << 8) | (t >>> 24), t = (G.SBOX[t >>> 24] << 24) | (G.SBOX[(t >>> 16) & 0xff] << 16) | (G.SBOX[(t >>> 8) & 0xff] << 8) | G.SBOX[t & 0xff], t ^= G.RCON[(ksRow / keySize) | 0] << 24) : keySize > 6 && ksRow % keySize === 4 ? t = (G.SBOX[t >>> 24] << 24) | (G.SBOX[(t >>> 16) & 0xff] << 16) | (G.SBOX[(t >>> 8) & 0xff] << 8) | G.SBOX[t & 0xff] : void 0, this._keySchedule[ksRow - keySize] ^ t);
      }
      this._invKeySchedule = [];
      _results = [];
      for (invKsRow = _j = 0; 0 <= ksRows ? _j < ksRows : _j > ksRows; invKsRow = 0 <= ksRows ? ++_j : --_j) {
        ksRow = ksRows - invKsRow;
        t = this._keySchedule[ksRow - (invKsRow % 4 ? 0 : 4)];
        _results.push(this._invKeySchedule[invKsRow] = invKsRow < 4 || ksRow <= 4 ? t : G.INV_SUB_MIX[0][G.SBOX[t >>> 24]] ^ G.INV_SUB_MIX[1][G.SBOX[(t >>> 16) & 0xff]] ^ G.INV_SUB_MIX[2][G.SBOX[(t >>> 8) & 0xff]] ^ G.INV_SUB_MIX[3][G.SBOX[t & 0xff]]);
      }
      return _results;
    };

    AES.prototype.encryptBlock = function(M, offset) {
      if (offset == null) {
        offset = 0;
      }
      return this._doCryptBlock(M, offset, this._keySchedule, G.SUB_MIX, G.SBOX);
    };

    AES.prototype.decryptBlock = function(M, offset) {
      var _ref, _ref1;
      if (offset == null) {
        offset = 0;
      }
      _ref = [M[offset + 3], M[offset + 1]], M[offset + 1] = _ref[0], M[offset + 3] = _ref[1];
      this._doCryptBlock(M, offset, this._invKeySchedule, G.INV_SUB_MIX, G.INV_SBOX);
      return _ref1 = [M[offset + 3], M[offset + 1]], M[offset + 1] = _ref1[0], M[offset + 3] = _ref1[1], _ref1;
    };

    AES.prototype.scrub = function() {
      scrub_vec(this._keySchedule);
      scrub_vec(this._invKeySchedule);
      return this._key.scrub();
    };

    AES.prototype._doCryptBlock = function(M, offset, keySchedule, SUB_MIX, SBOX) {
      var ksRow, round, s0, s1, s2, s3, t0, t1, t2, t3, _i, _ref;
      s0 = M[offset] ^ keySchedule[0];
      s1 = M[offset + 1] ^ keySchedule[1];
      s2 = M[offset + 2] ^ keySchedule[2];
      s3 = M[offset + 3] ^ keySchedule[3];
      ksRow = 4;
      for (round = _i = 1, _ref = this._nRounds; 1 <= _ref ? _i < _ref : _i > _ref; round = 1 <= _ref ? ++_i : --_i) {
        t0 = SUB_MIX[0][s0 >>> 24] ^ SUB_MIX[1][(s1 >>> 16) & 0xff] ^ SUB_MIX[2][(s2 >>> 8) & 0xff] ^ SUB_MIX[3][s3 & 0xff] ^ keySchedule[ksRow++];
        t1 = SUB_MIX[0][s1 >>> 24] ^ SUB_MIX[1][(s2 >>> 16) & 0xff] ^ SUB_MIX[2][(s3 >>> 8) & 0xff] ^ SUB_MIX[3][s0 & 0xff] ^ keySchedule[ksRow++];
        t2 = SUB_MIX[0][s2 >>> 24] ^ SUB_MIX[1][(s3 >>> 16) & 0xff] ^ SUB_MIX[2][(s0 >>> 8) & 0xff] ^ SUB_MIX[3][s1 & 0xff] ^ keySchedule[ksRow++];
        t3 = SUB_MIX[0][s3 >>> 24] ^ SUB_MIX[1][(s0 >>> 16) & 0xff] ^ SUB_MIX[2][(s1 >>> 8) & 0xff] ^ SUB_MIX[3][s2 & 0xff] ^ keySchedule[ksRow++];
        s0 = t0;
        s1 = t1;
        s2 = t2;
        s3 = t3;
      }
      t0 = ((SBOX[s0 >>> 24] << 24) | (SBOX[(s1 >>> 16) & 0xff] << 16) | (SBOX[(s2 >>> 8) & 0xff] << 8) | SBOX[s3 & 0xff]) ^ keySchedule[ksRow++];
      t1 = ((SBOX[s1 >>> 24] << 24) | (SBOX[(s2 >>> 16) & 0xff] << 16) | (SBOX[(s3 >>> 8) & 0xff] << 8) | SBOX[s0 & 0xff]) ^ keySchedule[ksRow++];
      t2 = ((SBOX[s2 >>> 24] << 24) | (SBOX[(s3 >>> 16) & 0xff] << 16) | (SBOX[(s0 >>> 8) & 0xff] << 8) | SBOX[s1 & 0xff]) ^ keySchedule[ksRow++];
      t3 = ((SBOX[s3 >>> 24] << 24) | (SBOX[(s0 >>> 16) & 0xff] << 16) | (SBOX[(s1 >>> 8) & 0xff] << 8) | SBOX[s2 & 0xff]) ^ keySchedule[ksRow++];
      M[offset] = t0;
      M[offset + 1] = t1;
      M[offset + 2] = t2;
      return M[offset + 3] = t3;
    };

    return AES;

  })(BlockCipher);

  exports.AES = AES;

}).call(this);

},{"./algbase":27,"./util":45}],27:[function(require,module,exports){
// Generated by IcedCoffeeScript 1.6.3-g
(function() {
  var BlockCipher, BufferedBlockAlgorithm, Hasher, StreamCipher, WordArray, util,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };



  WordArray = require('./wordarray').WordArray;

  util = require('./util');

  BufferedBlockAlgorithm = (function() {
    BufferedBlockAlgorithm.prototype._minBufferSize = 0;

    function BufferedBlockAlgorithm() {
      this.reset();
    }

    BufferedBlockAlgorithm.prototype.reset = function() {
      this._data = new WordArray();
      return this._nDataBytes = 0;
    };

    BufferedBlockAlgorithm.prototype._append = function(data) {
      this._data.concat(data);
      return this._nDataBytes += data.sigBytes;
    };

    BufferedBlockAlgorithm.prototype._process = function(doFlush) {
      var blockSizeBytes, data, dataSigBytes, dataWords, nBlocksReady, nBytesReady, nWordsReady, offset, processedWords, _i, _ref;
      data = this._data;
      dataWords = data.words;
      dataSigBytes = data.sigBytes;
      blockSizeBytes = this.blockSize * 4;
      nBlocksReady = dataSigBytes / blockSizeBytes;
      if (doFlush) {
        nBlocksReady = Math.ceil(nBlocksReady);
      } else {
        nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);
      }
      nWordsReady = nBlocksReady * this.blockSize;
      nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);
      if (nWordsReady) {
        for (offset = _i = 0, _ref = this.blockSize; _ref > 0 ? _i < nWordsReady : _i > nWordsReady; offset = _i += _ref) {
          this._doProcessBlock(dataWords, offset);
        }
        processedWords = dataWords.splice(0, nWordsReady);
        data.sigBytes -= nBytesReady;
      }
      return new WordArray(processedWords, nBytesReady);
    };

    BufferedBlockAlgorithm.prototype.copy_to = function(out) {
      out._data = this._data.clone();
      return out._nDataBytes = this._nDataBytes;
    };

    BufferedBlockAlgorithm.prototype.clone = function() {
      var obj;
      obj = new BufferedBlockAlgorithm();
      this.copy_to(obj);
      return obj;
    };

    return BufferedBlockAlgorithm;

  })();

  Hasher = (function(_super) {
    __extends(Hasher, _super);

    function Hasher() {
      Hasher.__super__.constructor.call(this);
    }

    Hasher.prototype.reset = function() {
      Hasher.__super__.reset.call(this);
      this._doReset();
      return this;
    };

    Hasher.prototype.update = function(messageUpdate) {
      this._append(messageUpdate);
      this._process();
      return this;
    };

    Hasher.prototype.finalize = function(messageUpdate) {
      if (messageUpdate) {
        this._append(messageUpdate);
      }
      return this._doFinalize();
    };

    return Hasher;

  })(BufferedBlockAlgorithm);

  exports.BlockCipher = BlockCipher = (function() {
    function BlockCipher(key) {}

    BlockCipher.prototype.encryptBlock = function(M, offset) {};

    return BlockCipher;

  })();

  StreamCipher = (function() {
    function StreamCipher() {}

    StreamCipher.prototype.encryptBlock = function(word_array, dst_offset) {
      var n_words, pad;
      if (dst_offset == null) {
        dst_offset = 0;
      }
      pad = this.get_pad();
      n_words = Math.min(word_array.words.length - dst_offset, this.bsiw);
      word_array.xor(pad, {
        dst_offset: dst_offset,
        n_words: n_words
      });
      pad.scrub();
      return this.bsiw;
    };

    StreamCipher.prototype.encrypt = function(word_array) {
      var i, _i, _ref, _ref1;
      for (i = _i = 0, _ref = word_array.words.length, _ref1 = this.bsiw; _ref1 > 0 ? _i < _ref : _i > _ref; i = _i += _ref1) {
        this.encryptBlock(word_array, i);
      }
      return word_array;
    };

    StreamCipher.prototype.bulk_encrypt = function(_arg, cb) {
      var async_args, input, progress_hook, slice_args, what,
        _this = this;
      input = _arg.input, progress_hook = _arg.progress_hook, what = _arg.what;
      slice_args = {
        update: function(lo, hi) {
          var i, _i, _ref, _results;
          _results = [];
          for (i = _i = lo, _ref = _this.bsiw; _ref > 0 ? _i < hi : _i > hi; i = _i += _ref) {
            _results.push(_this.encryptBlock(input, i));
          }
          return _results;
        },
        finalize: function() {
          return input;
        },
        default_n: this.bsiw * 1024
      };
      async_args = {
        progress_hook: progress_hook,
        cb: cb,
        what: what
      };
      return util.bulk(input.sigBytes, slice_args, async_args);
    };

    return StreamCipher;

  })();

  exports.BlockCipher = BlockCipher;

  exports.Hasher = Hasher;

  exports.BufferedBlockAlgorithm = BufferedBlockAlgorithm;

  exports.StreamCipher = StreamCipher;

}).call(this);

},{"./util":45,"./wordarray":46}],28:[function(require,module,exports){
// Generated by IcedCoffeeScript 1.6.3-f
(function() {
  var CombineBase, Concat, HMAC, SHA3, SHA512, WordArray, XOR, bulk_sign, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };



  _ref = require('./hmac'), HMAC = _ref.HMAC, bulk_sign = _ref.bulk_sign;

  SHA512 = require('./sha512').SHA512;

  SHA3 = require('./sha3').SHA3;

  WordArray = require('./wordarray').WordArray;

  CombineBase = (function() {
    function CombineBase() {
      this.hasherBlockSize = this.hashers[0].hasherBlockSize;
      this.hasherBlockSizeBytes = this.hasherBlockSize * 4;
      this.reset();
    }

    CombineBase.prototype.reset = function() {
      var h, _i, _len, _ref1;
      _ref1 = this.hashers;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        h = _ref1[_i];
        h.reset();
      }
      return this;
    };

    CombineBase.prototype.update = function(w) {
      var h, _i, _len, _ref1;
      _ref1 = this.hashers;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        h = _ref1[_i];
        h.update(w);
      }
      return this;
    };

    CombineBase.prototype.scrub = function() {
      var h, _i, _len, _ref1;
      _ref1 = this.hashers;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        h = _ref1[_i];
        h.scrub();
      }
      return this;
    };

    CombineBase.prototype.finalize = function(w) {
      var h, hashes, out, _i, _len, _ref1;
      hashes = (function() {
        var _i, _len, _ref1, _results;
        _ref1 = this.hashers;
        _results = [];
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          h = _ref1[_i];
          _results.push(h.finalize(w));
        }
        return _results;
      }).call(this);
      out = hashes[0];
      _ref1 = hashes.slice(1);
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        h = _ref1[_i];
        this._coalesce(out, h);
        h.scrub();
      }
      return out;
    };

    return CombineBase;

  })();

  Concat = (function(_super) {
    __extends(Concat, _super);

    function Concat(key, klasses) {
      var hm, i, klass, subkey, subkeys;
      if (klasses == null) {
        klasses = [SHA512, SHA3];
      }
      subkeys = key.split(klasses.length);
      this.hashers = (function() {
        var _i, _len, _results;
        _results = [];
        for (i = _i = 0, _len = klasses.length; _i < _len; i = ++_i) {
          klass = klasses[i];
          subkey = subkeys[i];
          hm = new HMAC(subkey, klass);
          subkey.scrub();
          _results.push(hm);
        }
        return _results;
      })();
      Concat.__super__.constructor.call(this);
    }

    Concat.get_output_size = function() {
      return SHA512.output_size + SHA3.output_size;
    };

    Concat.prototype._coalesce = function(out, h) {
      return out.concat(h);
    };

    Concat.prototype.get_output_size = function() {
      var h, tot, _i, _len, _ref1;
      tot = 0;
      _ref1 = this.hashers;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        h = _ref1[_i];
        tot += h.get_output_size();
      }
      return tot;
    };

    Concat.sign = function(_arg) {
      var input, key;
      key = _arg.key, input = _arg.input;
      return (new Concat(key)).finalize(input);
    };

    Concat.bulk_sign = function(args, cb) {
      args.klass = Concat;
      args.what = "HMAC-SHA512-SHA3";
      return bulk_sign(args, cb);
    };

    return Concat;

  })(CombineBase);

  XOR = (function(_super) {
    __extends(XOR, _super);

    function XOR(key, klasses) {
      var klass;
      if (klasses == null) {
        klasses = [SHA512, SHA3];
      }
      this.hashers = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = klasses.length; _i < _len; _i++) {
          klass = klasses[_i];
          _results.push(new HMAC(key, klass));
        }
        return _results;
      })();
      XOR.__super__.constructor.call(this);
    }

    XOR.prototype.reset = function() {
      var h, i, _i, _len, _ref1;
      XOR.__super__.reset.call(this);
      _ref1 = this.hashers;
      for (i = _i = 0, _len = _ref1.length; _i < _len; i = ++_i) {
        h = _ref1[i];
        h.update(new WordArray([i]));
      }
      return this;
    };

    XOR.get_output_size = function() {
      return Math.max(SHA512.output_size, SHA3.output_size);
    };

    XOR.prototype._coalesce = function(out, h) {
      return out.xor(h, {});
    };

    XOR.prototype.get_output_size = function() {
      var h;
      return Math.max.apply(Math, (function() {
        var _i, _len, _ref1, _results;
        _ref1 = this.hashers;
        _results = [];
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          h = _ref1[_i];
          _results.push(h.get_output_size());
        }
        return _results;
      }).call(this));
    };

    XOR.sign = function(_arg) {
      var input, key;
      key = _arg.key, input = _arg.input;
      return (new XOR(key)).finalize(input);
    };

    XOR.bulk_sign = function(arg, cb) {
      arg.klass = XOR;
      arg.what = "HMAC-SHA512-XOR-SHA3";
      return bulk_sign(arg, cb);
    };

    return XOR;

  })(CombineBase);

  exports.Concat = Concat;

  exports.XOR = XOR;

}).call(this);

},{"./hmac":33,"./sha3":42,"./sha512":43,"./wordarray":46}],29:[function(require,module,exports){
// Generated by IcedCoffeeScript 1.6.3-g
(function() {
  var Cipher, Counter, StreamCipher, WordArray, bulk_encrypt, encrypt, iced, __iced_k, __iced_k_noop,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  iced = require('iced-coffee-script/lib/coffee-script/iced').runtime;
  __iced_k = __iced_k_noop = function() {};

  WordArray = require('./wordarray').WordArray;

  StreamCipher = require('./algbase').StreamCipher;

  Counter = (function() {
    Counter.prototype.WORD_MAX = 0xffffffff;

    function Counter(_arg) {
      var i, len, value;
      value = _arg.value, len = _arg.len;
      this._value = value != null ? value.clone() : (len == null ? len = 2 : void 0, new WordArray((function() {
        var _i, _results;
        _results = [];
        for (i = _i = 0; 0 <= len ? _i < len : _i > len; i = 0 <= len ? ++_i : --_i) {
          _results.push(0);
        }
        return _results;
      })()));
    }

    Counter.prototype.inc = function() {
      var go, i;
      go = true;
      i = this._value.words.length - 1;
      while (go && i >= 0) {
        if ((++this._value.words[i]) > Counter.WORD_MAX) {
          this._value.words[i] = 0;
        } else {
          go = false;
        }
        i--;
      }
      return this;
    };

    Counter.prototype.inc_le = function() {
      var go, i;
      go = true;
      i = 0;
      while (go && i < this._value.words.length) {
        if ((++this._value.words[i]) > Counter.WORD_MAX) {
          this._value.words[i] = 0;
        } else {
          go = false;
        }
        i++;
      }
      return this;
    };

    Counter.prototype.get = function() {
      return this._value;
    };

    Counter.prototype.copy = function() {
      return this._value.clone();
    };

    return Counter;

  })();

  Cipher = (function(_super) {
    __extends(Cipher, _super);

    function Cipher(_arg) {
      this.block_cipher = _arg.block_cipher, this.iv = _arg.iv;
      Cipher.__super__.constructor.call(this);
      this.bsiw = this.block_cipher.blockSize / 4;
      if (!(this.iv.sigBytes === this.block_cipher.blockSize)) {
        throw new Error("IV is wrong length (" + this.iv.sigBytes + ")");
      }
      this.ctr = new Counter({
        value: this.iv
      });
    }

    Cipher.prototype.scrub = function() {
      return this.block_cipher.scrub();
    };

    Cipher.prototype.get_pad = function() {
      var pad;
      pad = this.ctr.copy();
      this.ctr.inc();
      this.block_cipher.encryptBlock(pad.words);
      return pad;
    };

    return Cipher;

  })(StreamCipher);

  encrypt = function(_arg) {
    var block_cipher, cipher, input, iv, ret;
    block_cipher = _arg.block_cipher, iv = _arg.iv, input = _arg.input;
    cipher = new Cipher({
      block_cipher: block_cipher,
      iv: iv
    });
    ret = cipher.encrypt(input);
    cipher.scrub();
    return ret;
  };

  bulk_encrypt = function(_arg, cb) {
    var block_cipher, cipher, input, iv, progress_hook, ret, what, ___iced_passed_deferral, __iced_deferrals, __iced_k,
      _this = this;
    __iced_k = __iced_k_noop;
    ___iced_passed_deferral = iced.findDeferral(arguments);
    block_cipher = _arg.block_cipher, iv = _arg.iv, input = _arg.input, progress_hook = _arg.progress_hook, what = _arg.what;
    cipher = new Cipher({
      block_cipher: block_cipher,
      iv: iv
    });
    (function(__iced_k) {
      __iced_deferrals = new iced.Deferrals(__iced_k, {
        parent: ___iced_passed_deferral,
        filename: "src/ctr.iced",
        funcname: "bulk_encrypt"
      });
      cipher.bulk_encrypt({
        input: input,
        progress_hook: progress_hook,
        what: what
      }, __iced_deferrals.defer({
        assign_fn: (function() {
          return function() {
            return ret = arguments[0];
          };
        })(),
        lineno: 121
      }));
      __iced_deferrals._fulfill();
    })(function() {
      return cb(ret);
    });
  };

  exports.Counter = Counter;

  exports.Cipher = Cipher;

  exports.encrypt = encrypt;

  exports.bulk_encrypt = bulk_encrypt;

}).call(this);

},{"./algbase":27,"./wordarray":46,"iced-coffee-script/lib/coffee-script/iced":22}],30:[function(require,module,exports){
// Generated by IcedCoffeeScript 1.6.3-f
(function() {
  var AES, Base, Concat, Decryptor, SHA512, Salsa20, TwoFish, V, WordArray, ctr, decrypt, iced, make_esc, pbkdf2, salsa20, __iced_k, __iced_k_noop, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  iced = require('iced-coffee-script/lib/coffee-script/iced').runtime;
  __iced_k = __iced_k_noop = function() {};

  WordArray = require('./wordarray').WordArray;

  salsa20 = require('./salsa20');

  AES = require('./aes').AES;

  TwoFish = require('./twofish').TwoFish;

  ctr = require('./ctr');

  Concat = require('./combine').Concat;

  SHA512 = require('./sha512').SHA512;

  pbkdf2 = require('./pbkdf2').pbkdf2;

  Salsa20 = require('./salsa20').Salsa20;

  _ref = require('./enc'), Base = _ref.Base, V = _ref.V;

  make_esc = require('iced-error').make_esc;

  Decryptor = (function(_super) {
    __extends(Decryptor, _super);

    Decryptor.prototype.version = V[1];

    function Decryptor(_arg) {
      var key;
      key = _arg.key;
      Decryptor.__super__.constructor.call(this, {
        key: key
      });
      this._i = 0;
    }

    Decryptor.prototype.read_header = function(cb) {
      var err, wa;
      err = (wa = this.ct.unshift(2)) == null ? new Error("Ciphertext underrun in header") : !(wa.equal(new WordArray(this.version.header))) ? new Error("Bad header") : null;
      return cb(err);
    };

    Decryptor.prototype.verify_sig = function(key, cb) {
      var computed, err, received, ___iced_passed_deferral, __iced_deferrals, __iced_k,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      (function(__iced_k) {
        if ((received = _this.ct.unshift(Concat.get_output_size() / 4)) == null) {
          return __iced_k(err = new Error("Ciphertext underrun in signature"));
        } else {
          (function(__iced_k) {
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              filename: "src/dec.iced",
              funcname: "Decryptor.verify_sig"
            });
            _this.sign({
              input: _this.ct,
              key: key,
              salt: _this.salt
            }, __iced_deferrals.defer({
              assign_fn: (function() {
                return function() {
                  err = arguments[0];
                  return computed = arguments[1];
                };
              })(),
              lineno: 65
            }));
            __iced_deferrals._fulfill();
          })(function() {
            return __iced_k(err = err != null ? err : received.equal(computed) ? null : new Error('Signature mismatch or bad decryption key'));
          });
        }
      })(function() {
        return cb(err);
      });
    };

    Decryptor.prototype.unshift_iv = function(n_bytes, which, cb) {
      var err, iv;
      err = (iv = this.ct.unshift(n_bytes / 4)) != null ? null : new Error("Ciphertext underrun in " + which);
      return cb(err, iv);
    };

    Decryptor.prototype.read_salt = function(cb) {
      var err;
      err = (this.salt = this.ct.unshift(2)) == null ? new Error("Ciphertext underrrun in read_salt") : null;
      return cb(err);
    };

    Decryptor.prototype.generate_keys = function(_arg, cb) {
      var keys, progress_hook, ___iced_passed_deferral, __iced_deferrals, __iced_k,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      progress_hook = _arg.progress_hook;
      (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: "src/dec.iced",
          funcname: "Decryptor.generate_keys"
        });
        _this.pbkdf2({
          salt: _this.salt,
          progress_hook: progress_hook
        }, __iced_deferrals.defer({
          assign_fn: (function() {
            return function() {
              return keys = arguments[0];
            };
          })(),
          lineno: 116
        }));
        __iced_deferrals._fulfill();
      })(function() {
        return cb(keys);
      });
    };

    Decryptor.prototype.run = function(_arg, cb) {
      var ct1, ct2, data, esc, iv, progress_hook, pt, ___iced_passed_deferral, __iced_deferrals, __iced_k,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      data = _arg.data, progress_hook = _arg.progress_hook;
      esc = make_esc(cb, "Decryptor::run");
      this.ct = WordArray.from_buffer(data);
      (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: "src/dec.iced",
          funcname: "Decryptor.run"
        });
        _this.read_header(esc(__iced_deferrals.defer({
          lineno: 143
        })));
        __iced_deferrals._fulfill();
      })(function() {
        (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "src/dec.iced",
            funcname: "Decryptor.run"
          });
          _this.read_salt(esc(__iced_deferrals.defer({
            lineno: 144
          })));
          __iced_deferrals._fulfill();
        })(function() {
          (function(__iced_k) {
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              filename: "src/dec.iced",
              funcname: "Decryptor.run"
            });
            _this.generate_keys({
              progress_hook: progress_hook
            }, __iced_deferrals.defer({
              assign_fn: (function(__slot_1) {
                return function() {
                  return __slot_1.keys = arguments[0];
                };
              })(_this),
              lineno: 145
            }));
            __iced_deferrals._fulfill();
          })(function() {
            (function(__iced_k) {
              __iced_deferrals = new iced.Deferrals(__iced_k, {
                parent: ___iced_passed_deferral,
                filename: "src/dec.iced",
                funcname: "Decryptor.run"
              });
              _this.verify_sig(_this.keys.hmac, esc(__iced_deferrals.defer({
                lineno: 146
              })));
              __iced_deferrals._fulfill();
            })(function() {
              (function(__iced_k) {
                __iced_deferrals = new iced.Deferrals(__iced_k, {
                  parent: ___iced_passed_deferral,
                  filename: "src/dec.iced",
                  funcname: "Decryptor.run"
                });
                _this.unshift_iv(AES.ivSize, "AES", esc(__iced_deferrals.defer({
                  assign_fn: (function() {
                    return function() {
                      return iv = arguments[0];
                    };
                  })(),
                  lineno: 147
                })));
                __iced_deferrals._fulfill();
              })(function() {
                (function(__iced_k) {
                  __iced_deferrals = new iced.Deferrals(__iced_k, {
                    parent: ___iced_passed_deferral,
                    filename: "src/dec.iced",
                    funcname: "Decryptor.run"
                  });
                  _this.run_aes({
                    iv: iv,
                    input: _this.ct,
                    key: _this.keys.aes,
                    progress_hook: progress_hook
                  }, esc(__iced_deferrals.defer({
                    assign_fn: (function() {
                      return function() {
                        return ct2 = arguments[0];
                      };
                    })(),
                    lineno: 148
                  })));
                  __iced_deferrals._fulfill();
                })(function() {
                  (function(__iced_k) {
                    __iced_deferrals = new iced.Deferrals(__iced_k, {
                      parent: ___iced_passed_deferral,
                      filename: "src/dec.iced",
                      funcname: "Decryptor.run"
                    });
                    _this.unshift_iv(TwoFish.ivSize, "2fish", esc(__iced_deferrals.defer({
                      assign_fn: (function() {
                        return function() {
                          return iv = arguments[0];
                        };
                      })(),
                      lineno: 149
                    })));
                    __iced_deferrals._fulfill();
                  })(function() {
                    (function(__iced_k) {
                      __iced_deferrals = new iced.Deferrals(__iced_k, {
                        parent: ___iced_passed_deferral,
                        filename: "src/dec.iced",
                        funcname: "Decryptor.run"
                      });
                      _this.run_twofish({
                        iv: iv,
                        input: _this.ct,
                        key: _this.keys.twofish,
                        progress_hook: progress_hook
                      }, esc(__iced_deferrals.defer({
                        assign_fn: (function() {
                          return function() {
                            return ct1 = arguments[0];
                          };
                        })(),
                        lineno: 150
                      })));
                      __iced_deferrals._fulfill();
                    })(function() {
                      (function(__iced_k) {
                        __iced_deferrals = new iced.Deferrals(__iced_k, {
                          parent: ___iced_passed_deferral,
                          filename: "src/dec.iced",
                          funcname: "Decryptor.run"
                        });
                        _this.unshift_iv(Salsa20.ivSize, "Salsa", esc(__iced_deferrals.defer({
                          assign_fn: (function() {
                            return function() {
                              return iv = arguments[0];
                            };
                          })(),
                          lineno: 151
                        })));
                        __iced_deferrals._fulfill();
                      })(function() {
                        (function(__iced_k) {
                          __iced_deferrals = new iced.Deferrals(__iced_k, {
                            parent: ___iced_passed_deferral,
                            filename: "src/dec.iced",
                            funcname: "Decryptor.run"
                          });
                          _this.run_salsa20({
                            iv: iv,
                            input: _this.ct,
                            key: _this.keys.salsa20,
                            output_iv: false,
                            progress_hook: progress_hook
                          }, esc(__iced_deferrals.defer({
                            assign_fn: (function() {
                              return function() {
                                return pt = arguments[0];
                              };
                            })(),
                            lineno: 152
                          })));
                          __iced_deferrals._fulfill();
                        })(function() {
                          return cb(null, pt.to_buffer());
                        });
                      });
                    });
                  });
                });
              });
            });
          });
        });
      });
    };

    return Decryptor;

  })(Base);

  decrypt = function(_arg, cb) {
    var data, dec, err, key, progress_hook, pt, ___iced_passed_deferral, __iced_deferrals, __iced_k,
      _this = this;
    __iced_k = __iced_k_noop;
    ___iced_passed_deferral = iced.findDeferral(arguments);
    key = _arg.key, data = _arg.data, progress_hook = _arg.progress_hook;
    dec = new Decryptor({
      key: key
    });
    (function(__iced_k) {
      __iced_deferrals = new iced.Deferrals(__iced_k, {
        parent: ___iced_passed_deferral,
        filename: "src/dec.iced",
        funcname: "decrypt"
      });
      dec.run({
        data: data,
        progress_hook: progress_hook
      }, __iced_deferrals.defer({
        assign_fn: (function() {
          return function() {
            err = arguments[0];
            return pt = arguments[1];
          };
        })(),
        lineno: 170
      }));
      __iced_deferrals._fulfill();
    })(function() {
      dec.scrub();
      return cb(err, pt);
    });
  };

  exports.Decryptor = Decryptor;

  exports.decrypt = decrypt;

}).call(this);

},{"./aes":26,"./combine":28,"./ctr":29,"./enc":32,"./pbkdf2":36,"./salsa20":38,"./sha512":43,"./twofish":44,"./wordarray":46,"iced-coffee-script/lib/coffee-script/iced":22,"iced-error":23}],31:[function(require,module,exports){
var Buffer=require("__browserify_Buffer").Buffer;// Generated by IcedCoffeeScript 1.6.3-f
(function() {
  var ADRBG, DRBG, Lock, WordArray, XOR, hmac, iced, sha3, sha512, __iced_k, __iced_k_noop;

  iced = require('iced-coffee-script/lib/coffee-script/iced').runtime;
  __iced_k = __iced_k_noop = function() {};

  hmac = require('./hmac');

  XOR = require('./combine').XOR;

  sha512 = require('./sha512');

  sha3 = require('./sha3');

  WordArray = require('./wordarray').WordArray;

  Lock = require('./lock').Lock;

  DRBG = (function() {
    function DRBG(entropy, personalization_string, hmac_func) {
      this.hmac = hmac_func || hmac.sign;
      this.security_strength = 256;
      entropy = this.check_entropy(entropy);
      personalization_string || (personalization_string = new WordArray([]));
      this._instantiate(entropy, personalization_string);
    }

    DRBG.prototype.check_entropy = function(entropy, reseed) {
      if (reseed == null) {
        reseed = false;
      }
      if ((entropy.sigBytes * 8 * 2) < ((reseed ? 2 : 3) * this.security_strength)) {
        throw new Error("entropy must be at least " + (1.5 * this.security_strength) + " bits.");
      }
      return entropy;
    };

    DRBG.prototype._hmac = function(key, input) {
      return this.hmac({
        key: key,
        input: input
      });
    };

    DRBG.prototype._update = function(provided_data) {
      var V, V_in;
      V = new WordArray([0], 1);
      if (provided_data != null) {
        V = V.concat(provided_data);
      }
      V_in = this.V.clone().concat(V);
      this.K = this._hmac(this.K, V_in);
      V_in.scrub();
      V.scrub();
      this.V = this._hmac(this.K, this.V);
      if (provided_data != null) {
        V_in = this.V.clone().concat(new WordArray([1 << 24], 1)).concat(provided_data);
        this.K = this._hmac(this.K, V_in);
        V_in.scrub();
        this.V = this._hmac(this.K, this.V);
      }
      return provided_data != null ? provided_data.scrub() : void 0;
    };

    DRBG.prototype._instantiate = function(entropy, personalization_string) {
      var i, n, seed_material;
      seed_material = entropy.concat(personalization_string);
      n = 64;
      this.K = WordArray.from_buffer(new Buffer((function() {
        var _i, _results;
        _results = [];
        for (i = _i = 0; 0 <= n ? _i < n : _i > n; i = 0 <= n ? ++_i : --_i) {
          _results.push(0);
        }
        return _results;
      })()));
      this.V = WordArray.from_buffer(new Buffer((function() {
        var _i, _results;
        _results = [];
        for (i = _i = 0; 0 <= n ? _i < n : _i > n; i = 0 <= n ? ++_i : --_i) {
          _results.push(1);
        }
        return _results;
      })()));
      this._update(seed_material);
      entropy.scrub();
      return this.reseed_counter = 1;
    };

    DRBG.prototype.reseed = function(entropy) {
      this._update(this.check_entropy(entropy, true));
      return this.reseed_counter = 1;
    };

    DRBG.prototype.generate = function(num_bytes) {
      var i, tmp, _ref;
      if ((num_bytes * 8) > 7500) {
        throw new Error("generate cannot generate > 7500 bits in 1 call.");
      }
      if (this.reseed_counter >= 10000) {
        throw new Error("Need a reseed!");
      }
      tmp = [];
      i = 0;
      while ((tmp.length === 0) || (tmp.length * tmp[0].length * 4) < num_bytes) {
        this.V = this._hmac(this.K, this.V);
        tmp.push(this.V.words);
      }
      this._update();
      this.reseed_counter += 1;
      return (new WordArray((_ref = []).concat.apply(_ref, tmp))).truncate(num_bytes);
    };

    return DRBG;

  })();

  ADRBG = (function() {
    function ADRBG(gen_seed, hmac) {
      this.gen_seed = gen_seed;
      this.hmac = hmac;
      this.drbg = null;
      this.lock = new Lock();
    }

    ADRBG.prototype.generate = function(n, cb) {
      var ret, seed, ___iced_passed_deferral, __iced_deferrals, __iced_k,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: "src/drbg.iced",
          funcname: "ADRBG.generate"
        });
        _this.lock.acquire(__iced_deferrals.defer({
          lineno: 148
        }));
        __iced_deferrals._fulfill();
      })(function() {
        (function(__iced_k) {
          if (_this.drbg == null) {
            (function(__iced_k) {
              __iced_deferrals = new iced.Deferrals(__iced_k, {
                parent: ___iced_passed_deferral,
                filename: "src/drbg.iced",
                funcname: "ADRBG.generate"
              });
              _this.gen_seed(256, __iced_deferrals.defer({
                assign_fn: (function() {
                  return function() {
                    return seed = arguments[0];
                  };
                })(),
                lineno: 150
              }));
              __iced_deferrals._fulfill();
            })(function() {
              return __iced_k(_this.drbg = new DRBG(seed, null, _this.hmac));
            });
          } else {
            return __iced_k();
          }
        })(function() {
          (function(__iced_k) {
            if (_this.drbg.reseed_counter > 100) {
              (function(__iced_k) {
                __iced_deferrals = new iced.Deferrals(__iced_k, {
                  parent: ___iced_passed_deferral,
                  filename: "src/drbg.iced",
                  funcname: "ADRBG.generate"
                });
                _this.gen_seed(256, __iced_deferrals.defer({
                  assign_fn: (function() {
                    return function() {
                      return seed = arguments[0];
                    };
                  })(),
                  lineno: 153
                }));
                __iced_deferrals._fulfill();
              })(function() {
                return __iced_k(_this.drbg.reseed(seed));
              });
            } else {
              return __iced_k();
            }
          })(function() {
            ret = _this.drbg.generate(n);
            _this.lock.release();
            return cb(ret);
          });
        });
      });
    };

    return ADRBG;

  })();

  exports.DRBG = DRBG;

  exports.ADRBG = ADRBG;

}).call(this);

},{"./combine":28,"./hmac":33,"./lock":34,"./sha3":42,"./sha512":43,"./wordarray":46,"__browserify_Buffer":18,"iced-coffee-script/lib/coffee-script/iced":22}],32:[function(require,module,exports){
// Generated by IcedCoffeeScript 1.6.3-f
(function() {
  var AES, Base, Concat, Encryptor, SHA512, TwoFish, V, WordArray, XOR, ctr, encrypt, iced, make_esc, pbkdf2, prng, salsa20, util, __iced_k, __iced_k_noop, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  iced = require('iced-coffee-script/lib/coffee-script/iced').runtime;
  __iced_k = __iced_k_noop = function() {};

  WordArray = require('./wordarray').WordArray;

  salsa20 = require('./salsa20');

  AES = require('./aes').AES;

  TwoFish = require('./twofish').TwoFish;

  ctr = require('./ctr');

  _ref = require('./combine'), XOR = _ref.XOR, Concat = _ref.Concat;

  SHA512 = require('./sha512').SHA512;

  pbkdf2 = require('./pbkdf2').pbkdf2;

  util = require('./util');

  prng = require('./prng');

  make_esc = require('iced-error').make_esc;

  V = {
    "1": {
      header: [0x1c94d7de, 1],
      pbkdf2_iters: 1024,
      salt_size: 8,
      hmac_key_size: 768 / 8
    }
  };

  Base = (function() {
    function Base(_arg) {
      var key;
      key = _arg.key;
      this.key = WordArray.from_buffer(key);
      this.derived_keys = {};
    }

    Base.prototype.pbkdf2 = function(_arg, cb) {
      var args, end, i, k, keys, len, lens, progress_hook, raw, salt, salt_hex, tot, v, ___iced_passed_deferral, __iced_deferrals, __iced_k,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      salt = _arg.salt, progress_hook = _arg.progress_hook;
      salt_hex = salt.to_hex();
      (function(__iced_k) {
        if ((keys = _this.derived_keys[salt_hex]) == null) {
          lens = {
            hmac: _this.version.hmac_key_size,
            aes: AES.keySize,
            twofish: TwoFish.keySize,
            salsa20: salsa20.Salsa20.keySize
          };
          tot = 0;
          for (k in lens) {
            v = lens[k];
            tot += v;
          }
          args = {
            key: _this.key.clone(),
            c: _this.version.pbkdf2_iters,
            klass: XOR,
            dkLen: tot,
            progress_hook: progress_hook,
            salt: salt
          };
          (function(__iced_k) {
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              filename: "src/enc.iced",
              funcname: "Base.pbkdf2"
            });
            pbkdf2(args, __iced_deferrals.defer({
              assign_fn: (function() {
                return function() {
                  return raw = arguments[0];
                };
              })(),
              lineno: 74
            }));
            __iced_deferrals._fulfill();
          })(function() {
            keys = {};
            i = 0;
            for (k in lens) {
              v = lens[k];
              len = v / 4;
              end = i + len;
              keys[k] = new WordArray(raw.words.slice(i, end));
              i = end;
            }
            return __iced_k(_this.derived_keys[salt_hex] = keys);
          });
        } else {
          return __iced_k();
        }
      })(function() {
        return cb(keys);
      });
    };

    Base.prototype._check_scrubbed = function(key, where, ecb, okcb) {
      if (!key.is_scrubbed()) {
        return okcb();
      } else {
        return ecb(new Error("" + where + ": Failed due to scrubbed key!"), null);
      }
    };

    Base.prototype.sign = function(_arg, cb) {
      var input, key, out, progress_hook, salt, ___iced_passed_deferral, __iced_deferrals, __iced_k,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      input = _arg.input, key = _arg.key, salt = _arg.salt, progress_hook = _arg.progress_hook;
      (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: "src/enc.iced",
          funcname: "Base.sign"
        });
        _this._check_scrubbed(key, "HMAC", cb, __iced_deferrals.defer({
          lineno: 114
        }));
        __iced_deferrals._fulfill();
      })(function() {
        input = (new WordArray(_this.version.header)).concat(salt).concat(input);
        (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "src/enc.iced",
            funcname: "Base.sign"
          });
          Concat.bulk_sign({
            key: key,
            input: input,
            progress_hook: progress_hook
          }, __iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                return out = arguments[0];
              };
            })(),
            lineno: 116
          }));
          __iced_deferrals._fulfill();
        })(function() {
          input.scrub();
          return cb(null, out);
        });
      });
    };

    Base.prototype.run_salsa20 = function(_arg, cb) {
      var ct, input, iv, key, output_iv, progress_hook, ___iced_passed_deferral, __iced_deferrals, __iced_k,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      input = _arg.input, key = _arg.key, iv = _arg.iv, output_iv = _arg.output_iv, progress_hook = _arg.progress_hook;
      (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: "src/enc.iced",
          funcname: "Base.run_salsa20"
        });
        _this._check_scrubbed(key, "Salsa20", cb, __iced_deferrals.defer({
          lineno: 132
        }));
        __iced_deferrals._fulfill();
      })(function() {
        (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "src/enc.iced",
            funcname: "Base.run_salsa20"
          });
          salsa20.bulk_encrypt({
            input: input,
            key: key,
            iv: iv,
            progress_hook: progress_hook
          }, __iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                return ct = arguments[0];
              };
            })(),
            lineno: 133
          }));
          __iced_deferrals._fulfill();
        })(function() {
          if (output_iv) {
            ct = iv.clone().concat(ct);
          }
          return cb(null, ct);
        });
      });
    };

    Base.prototype.run_twofish = function(_arg, cb) {
      var block_cipher, ct, input, iv, key, progress_hook, ___iced_passed_deferral, __iced_deferrals, __iced_k,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      input = _arg.input, key = _arg.key, iv = _arg.iv, progress_hook = _arg.progress_hook;
      (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: "src/enc.iced",
          funcname: "Base.run_twofish"
        });
        _this._check_scrubbed(key, "Twofish", cb, __iced_deferrals.defer({
          lineno: 148
        }));
        __iced_deferrals._fulfill();
      })(function() {
        block_cipher = new TwoFish(key);
        (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "src/enc.iced",
            funcname: "Base.run_twofish"
          });
          ctr.bulk_encrypt({
            block_cipher: block_cipher,
            iv: iv,
            input: input,
            progress_hook: progress_hook,
            what: "twofish"
          }, __iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                return ct = arguments[0];
              };
            })(),
            lineno: 150
          }));
          __iced_deferrals._fulfill();
        })(function() {
          block_cipher.scrub();
          return cb(null, iv.clone().concat(ct));
        });
      });
    };

    Base.prototype.run_aes = function(_arg, cb) {
      var block_cipher, ct, input, iv, key, progress_hook, ___iced_passed_deferral, __iced_deferrals, __iced_k,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      input = _arg.input, key = _arg.key, iv = _arg.iv, progress_hook = _arg.progress_hook;
      (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: "src/enc.iced",
          funcname: "Base.run_aes"
        });
        _this._check_scrubbed(key, "AES", cb, __iced_deferrals.defer({
          lineno: 165
        }));
        __iced_deferrals._fulfill();
      })(function() {
        block_cipher = new AES(key);
        (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "src/enc.iced",
            funcname: "Base.run_aes"
          });
          ctr.bulk_encrypt({
            block_cipher: block_cipher,
            iv: iv,
            input: input,
            progress_hook: progress_hook,
            what: "aes"
          }, __iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                return ct = arguments[0];
              };
            })(),
            lineno: 167
          }));
          __iced_deferrals._fulfill();
        })(function() {
          block_cipher.scrub();
          return cb(null, iv.clone().concat(ct));
        });
      });
    };

    Base.prototype.scrub = function() {
      var key, key_ring, salt, _ref1, _results;
      this.key.scrub();
      _ref1 = this.derived_keys;
      _results = [];
      for (salt in _ref1) {
        key_ring = _ref1[salt];
        _results.push((function() {
          var _i, _len, _results1;
          _results1 = [];
          for (_i = 0, _len = key_ring.length; _i < _len; _i++) {
            key = key_ring[_i];
            _results1.push(key.scrub());
          }
          return _results1;
        })());
      }
      return _results;
    };

    return Base;

  })();

  Encryptor = (function(_super) {
    __extends(Encryptor, _super);

    Encryptor.prototype.version = V[1];

    function Encryptor(_arg) {
      var key, rng;
      key = _arg.key, rng = _arg.rng;
      Encryptor.__super__.constructor.call(this, {
        key: key
      });
      this.rng = rng || prng.generate;
      this.last_salt = null;
    }

    Encryptor.prototype.pick_random_ivs = function(_arg, cb) {
      var iv_lens, ivs, k, progress_hook, v, ___iced_passed_deferral, __iced_deferrals, __iced_k,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      progress_hook = _arg.progress_hook;
      iv_lens = {
        aes: AES.ivSize,
        twofish: TwoFish.ivSize,
        salsa20: salsa20.Salsa20.ivSize
      };
      ivs = {};
      (function(__iced_k) {
        var _i, _k, _keys, _ref1, _results, _while;
        _ref1 = iv_lens;
        _keys = (function() {
          var _results1;
          _results1 = [];
          for (_k in _ref1) {
            _results1.push(_k);
          }
          return _results1;
        })();
        _i = 0;
        _results = [];
        _while = function(__iced_k) {
          var _break, _continue, _next;
          _break = function() {
            return __iced_k(_results);
          };
          _continue = function() {
            return iced.trampoline(function() {
              ++_i;
              return _while(__iced_k);
            });
          };
          _next = function(__iced_next_arg) {
            _results.push(__iced_next_arg);
            return _continue();
          };
          if (!(_i < _keys.length)) {
            return _break();
          } else {
            k = _keys[_i];
            v = _ref1[k];
            (function(__iced_k) {
              __iced_deferrals = new iced.Deferrals(__iced_k, {
                parent: ___iced_passed_deferral,
                filename: "src/enc.iced",
                funcname: "Encryptor.pick_random_ivs"
              });
              _this.rng(v, __iced_deferrals.defer({
                assign_fn: (function(__slot_1, __slot_2) {
                  return function() {
                    return __slot_1[__slot_2] = arguments[0];
                  };
                })(ivs, k),
                lineno: 269
              }));
              __iced_deferrals._fulfill();
            })(_next);
          }
        };
        _while(__iced_k);
      })(function() {
        return cb(ivs);
      });
    };

    Encryptor.prototype.resalt = function(_arg, cb) {
      var progress_hook, ___iced_passed_deferral, __iced_deferrals, __iced_k,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      progress_hook = _arg.progress_hook;
      (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: "src/enc.iced",
          funcname: "Encryptor.resalt"
        });
        _this.rng(_this.version.salt_size, __iced_deferrals.defer({
          assign_fn: (function(__slot_1) {
            return function() {
              return __slot_1.salt = arguments[0];
            };
          })(_this),
          lineno: 281
        }));
        __iced_deferrals._fulfill();
      })(function() {
        (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "src/enc.iced",
            funcname: "Encryptor.resalt"
          });
          _this.pbkdf2({
            progress_hook: progress_hook,
            salt: _this.salt
          }, __iced_deferrals.defer({
            assign_fn: (function(__slot_1) {
              return function() {
                return __slot_1.keys = arguments[0];
              };
            })(_this),
            lineno: 282
          }));
          __iced_deferrals._fulfill();
        })(function() {
          return cb();
        });
      });
    };

    Encryptor.prototype.run = function(_arg, cb) {
      var ct1, ct2, ct3, data, esc, ivs, progress_hook, pt, ret, sig, ___iced_passed_deferral, __iced_deferrals, __iced_k,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      data = _arg.data, progress_hook = _arg.progress_hook;
      esc = make_esc(cb, "Encryptor::run");
      (function(__iced_k) {
        if (_this.salt == null) {
          (function(__iced_k) {
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              filename: "src/enc.iced",
              funcname: "Encryptor.run"
            });
            _this.resalt({
              progress_hook: progress_hook
            }, __iced_deferrals.defer({
              lineno: 308
            }));
            __iced_deferrals._fulfill();
          })(__iced_k);
        } else {
          return __iced_k();
        }
      })(function() {
        (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "src/enc.iced",
            funcname: "Encryptor.run"
          });
          _this.pick_random_ivs({
            progress_hook: progress_hook
          }, __iced_deferrals.defer({
            assign_fn: (function() {
              return function() {
                return ivs = arguments[0];
              };
            })(),
            lineno: 309
          }));
          __iced_deferrals._fulfill();
        })(function() {
          pt = WordArray.from_buffer(data);
          (function(__iced_k) {
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              filename: "src/enc.iced",
              funcname: "Encryptor.run"
            });
            _this.run_salsa20({
              input: pt,
              key: _this.keys.salsa20,
              progress_hook: progress_hook,
              iv: ivs.salsa20,
              output_iv: true
            }, esc(__iced_deferrals.defer({
              assign_fn: (function() {
                return function() {
                  return ct1 = arguments[0];
                };
              })(),
              lineno: 311
            })));
            __iced_deferrals._fulfill();
          })(function() {
            (function(__iced_k) {
              __iced_deferrals = new iced.Deferrals(__iced_k, {
                parent: ___iced_passed_deferral,
                filename: "src/enc.iced",
                funcname: "Encryptor.run"
              });
              _this.run_twofish({
                input: ct1,
                key: _this.keys.twofish,
                progress_hook: progress_hook,
                iv: ivs.twofish
              }, esc(__iced_deferrals.defer({
                assign_fn: (function() {
                  return function() {
                    return ct2 = arguments[0];
                  };
                })(),
                lineno: 312
              })));
              __iced_deferrals._fulfill();
            })(function() {
              (function(__iced_k) {
                __iced_deferrals = new iced.Deferrals(__iced_k, {
                  parent: ___iced_passed_deferral,
                  filename: "src/enc.iced",
                  funcname: "Encryptor.run"
                });
                _this.run_aes({
                  input: ct2,
                  key: _this.keys.aes,
                  progress_hook: progress_hook,
                  iv: ivs.aes
                }, esc(__iced_deferrals.defer({
                  assign_fn: (function() {
                    return function() {
                      return ct3 = arguments[0];
                    };
                  })(),
                  lineno: 313
                })));
                __iced_deferrals._fulfill();
              })(function() {
                (function(__iced_k) {
                  __iced_deferrals = new iced.Deferrals(__iced_k, {
                    parent: ___iced_passed_deferral,
                    filename: "src/enc.iced",
                    funcname: "Encryptor.run"
                  });
                  _this.sign({
                    input: ct3,
                    key: _this.keys.hmac,
                    progress_hook: progress_hook,
                    salt: _this.salt
                  }, esc(__iced_deferrals.defer({
                    assign_fn: (function() {
                      return function() {
                        return sig = arguments[0];
                      };
                    })(),
                    lineno: 314
                  })));
                  __iced_deferrals._fulfill();
                })(function() {
                  ret = (new WordArray(_this.version.header)).concat(_this.salt).concat(sig).concat(ct3).to_buffer();
                  util.scrub_buffer(data);
                  return cb(null, ret);
                });
              });
            });
          });
        });
      });
    };

    return Encryptor;

  })(Base);

  encrypt = function(_arg, cb) {
    var data, enc, err, key, progress_hook, ret, rng, ___iced_passed_deferral, __iced_deferrals, __iced_k,
      _this = this;
    __iced_k = __iced_k_noop;
    ___iced_passed_deferral = iced.findDeferral(arguments);
    key = _arg.key, data = _arg.data, rng = _arg.rng, progress_hook = _arg.progress_hook;
    enc = new Encryptor({
      key: key,
      rng: rng
    });
    (function(__iced_k) {
      __iced_deferrals = new iced.Deferrals(__iced_k, {
        parent: ___iced_passed_deferral,
        filename: "src/enc.iced",
        funcname: "encrypt"
      });
      enc.run({
        data: data,
        progress_hook: progress_hook
      }, __iced_deferrals.defer({
        assign_fn: (function() {
          return function() {
            err = arguments[0];
            return ret = arguments[1];
          };
        })(),
        lineno: 342
      }));
      __iced_deferrals._fulfill();
    })(function() {
      enc.scrub();
      return cb(err, ret);
    });
  };

  exports.V = V;

  exports.encrypt = encrypt;

  exports.Base = Base;

  exports.Encryptor = Encryptor;

}).call(this);

},{"./aes":26,"./combine":28,"./ctr":29,"./pbkdf2":36,"./prng":37,"./salsa20":38,"./sha512":43,"./twofish":44,"./util":45,"./wordarray":46,"iced-coffee-script/lib/coffee-script/iced":22,"iced-error":23}],33:[function(require,module,exports){
// Generated by IcedCoffeeScript 1.6.3-f
(function() {
  var HMAC, SHA512, bulk_sign, iced, sign, util, __iced_k, __iced_k_noop;

  iced = require('iced-coffee-script/lib/coffee-script/iced').runtime;
  __iced_k = __iced_k_noop = function() {};

  SHA512 = require('./sha512').SHA512;

  util = require('./util');

  HMAC = (function() {
    HMAC.outputSize = 512 / 8;

    HMAC.prototype.outputSize = HMAC.outputSize;

    function HMAC(key, klass) {
      var i, _i, _ref;
      if (klass == null) {
        klass = SHA512;
      }
      this.key = key.clone();
      this.hasher = new klass();
      this.hasherBlockSize = this.hasher.blockSize;
      this.hasherBlockSizeBytes = this.hasherBlockSize * 4;
      if (this.key.sigBytes > this.hasherBlockSizeBytes) {
        this.key = this.hasher.finalize(this.key);
      }
      this.key.clamp();
      this._oKey = this.key.clone();
      this._iKey = this.key.clone();
      for (i = _i = 0, _ref = this.hasherBlockSize; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        this._oKey.words[i] ^= 0x5c5c5c5c;
        this._iKey.words[i] ^= 0x36363636;
      }
      this._oKey.sigBytes = this._iKey.sigBytes = this.hasherBlockSizeBytes;
      this.reset();
    }

    HMAC.prototype.get_output_size = function() {
      return this.hasher.output_size;
    };

    HMAC.prototype.reset = function() {
      return this.hasher.reset().update(this._iKey);
    };

    HMAC.prototype.update = function(wa) {
      this.hasher.update(wa);
      return this;
    };

    HMAC.prototype.finalize = function(wa) {
      var innerHash, innerHash2, out;
      innerHash = this.hasher.finalize(wa);
      this.hasher.reset();
      innerHash2 = this._oKey.clone().concat(innerHash);
      out = this.hasher.finalize(innerHash2);
      innerHash.scrub();
      innerHash2.scrub();
      return out;
    };

    HMAC.prototype.scrub = function() {
      this.key.scrub();
      this._iKey.scrub();
      return this._oKey.scrub();
    };

    return HMAC;

  })();

  sign = function(_arg) {
    var eng, hash_class, input, key, out;
    key = _arg.key, input = _arg.input, hash_class = _arg.hash_class;
    eng = new HMAC(key, hash_class);
    out = eng.finalize(input.clamp());
    eng.scrub();
    return out;
  };

  bulk_sign = function(_arg, cb) {
    var eng, input, key, klass, progress_hook, res, slice_args, what, ___iced_passed_deferral, __iced_deferrals, __iced_k,
      _this = this;
    __iced_k = __iced_k_noop;
    ___iced_passed_deferral = iced.findDeferral(arguments);
    key = _arg.key, input = _arg.input, progress_hook = _arg.progress_hook, klass = _arg.klass, what = _arg.what;
    klass || (klass = HMAC);
    what || (what = "hmac_sha512");
    eng = new klass(key);
    input.clamp();
    slice_args = {
      update: function(lo, hi) {
        return eng.update(input.slice(lo, hi));
      },
      finalize: function() {
        return eng.finalize();
      },
      default_n: eng.hasherBlockSize * 1000
    };
    (function(__iced_k) {
      __iced_deferrals = new iced.Deferrals(__iced_k, {
        parent: ___iced_passed_deferral,
        filename: "src/hmac.iced",
        funcname: "bulk_sign"
      });
      util.bulk(input.sigBytes, slice_args, {
        what: what,
        progress_hook: progress_hook,
        cb: __iced_deferrals.defer({
          assign_fn: (function() {
            return function() {
              return res = arguments[0];
            };
          })(),
          lineno: 137
        })
      });
      __iced_deferrals._fulfill();
    })(function() {
      eng.scrub();
      return cb(res);
    });
  };

  exports.HMAC = HMAC;

  exports.sign = sign;

  exports.bulk_sign = bulk_sign;

}).call(this);

},{"./sha512":43,"./util":45,"iced-coffee-script/lib/coffee-script/iced":22}],34:[function(require,module,exports){
// Generated by IcedCoffeeScript 1.6.3-f
(function() {
  var Lock, NamedLock, Table, iced, __iced_k, __iced_k_noop,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  iced = require('iced-coffee-script/lib/coffee-script/iced').runtime;
  __iced_k = __iced_k_noop = function() {};

  Lock = (function() {
    function Lock() {
      this._open = true;
      this._waiters = [];
    }

    Lock.prototype.acquire = function(cb) {
      if (this._open) {
        this._open = false;
        return cb();
      } else {
        return this._waiters.push(cb);
      }
    };

    Lock.prototype.release = function() {
      var w;
      if (this._waiters.length) {
        w = this._waiters.shift();
        return w();
      } else {
        return this._open = true;
      }
    };

    Lock.prototype.open = function() {
      return this._open;
    };

    return Lock;

  })();

  NamedLock = (function(_super) {
    __extends(NamedLock, _super);

    function NamedLock(tab, name) {
      this.tab = tab;
      this.name = name;
      NamedLock.__super__.constructor.call(this);
      this.refs = 0;
    }

    NamedLock.prototype.incref = function() {
      return ++this.refs;
    };

    NamedLock.prototype.decref = function() {
      return --this.refs;
    };

    NamedLock.prototype.release = function() {
      NamedLock.__super__.release.call(this);
      if (this.decref() === 0) {
        return delete this.tab[this.name];
      }
    };

    return NamedLock;

  })(Lock);

  Table = (function() {
    function Table() {
      this.locks = {};
    }

    Table.prototype.create = function(name) {
      var l;
      l = new NamedLock(this, name);
      return this.locks[name] = l;
    };

    Table.prototype.acquire = function(name, cb, wait) {
      var l, was_open, ___iced_passed_deferral, __iced_deferrals, __iced_k,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      l = this.locks[name] || this.create(name);
      was_open = l._open;
      l.incref();
      (function(__iced_k) {
        if (wait || l._open) {
          (function(__iced_k) {
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              filename: "src/lock.iced",
              funcname: "Table.acquire"
            });
            l.acquire(__iced_deferrals.defer({
              lineno: 68
            }));
            __iced_deferrals._fulfill();
          })(__iced_k);
        } else {
          return __iced_k(l = null);
        }
      })(function() {
        return cb(l, was_open);
      });
    };

    Table.prototype.lookup = function(name) {
      return this.locks[name];
    };

    return Table;

  })();

  exports.Lock = Lock;

  exports.Table = Table;

}).call(this);

},{"iced-coffee-script/lib/coffee-script/iced":22}],35:[function(require,module,exports){
var Buffer=require("__browserify_Buffer").Buffer;// Generated by IcedCoffeeScript 1.6.3-g
(function() {
  var k, v, _ref, _ref1;



  _ref = require('./enc');
  for (k in _ref) {
    v = _ref[k];
    exports[k] = v;
  }

  _ref1 = require('./dec');
  for (k in _ref1) {
    v = _ref1[k];
    exports[k] = v;
  }

  exports.prng = require('./prng');

  exports.Buffer = Buffer;

  exports.WordArray = require('./wordarray').WordArray;

  exports.ciphers = {
    AES: require('./aes').AES,
    TwoFish: require('./twofish').TwoFish
  };

  exports.hash = {
    SHA1: require('./sha1').SHA1,
    SHA224: require('./sha224').SHA224,
    SHA256: require('./sha256').SHA256,
    SHA512: require('./sha512').SHA512,
    SHA3: require('./sha3').SHA3
  };

}).call(this);

},{"./aes":26,"./dec":30,"./enc":32,"./prng":37,"./sha1":39,"./sha224":40,"./sha256":41,"./sha3":42,"./sha512":43,"./twofish":44,"./wordarray":46,"__browserify_Buffer":18}],36:[function(require,module,exports){
// Generated by IcedCoffeeScript 1.6.3-g
(function() {
  var HMAC, PBKDF2, WordArray, iced, pbkdf2, util, __iced_k, __iced_k_noop;

  iced = require('iced-coffee-script/lib/coffee-script/iced').runtime;
  __iced_k = __iced_k_noop = function() {};

  HMAC = require('./hmac').HMAC;

  WordArray = require('./wordarray').WordArray;

  util = require('./util');

  PBKDF2 = (function() {
    function PBKDF2(_arg) {
      var klass;
      this.key = _arg.key, this.salt = _arg.salt, this.c = _arg.c, klass = _arg.klass;
      klass || (klass = HMAC);
      this.prf = new klass(this.key);
    }

    PBKDF2.prototype._PRF = function(input) {
      this.prf.reset();
      return this.prf.finalize(input);
    };

    PBKDF2.prototype._gen_T_i = function(_arg, cb) {
      var U, i, progress_hook, ret, seed, stop, ___iced_passed_deferral, __iced_deferrals, __iced_k,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      i = _arg.i, progress_hook = _arg.progress_hook;
      progress_hook(0);
      seed = this.salt.clone().concat(new WordArray([i]));
      U = this._PRF(seed);
      ret = U.clone();
      i = 1;
      (function(__iced_k) {
        var _results, _while;
        _results = [];
        _while = function(__iced_k) {
          var _break, _continue, _next;
          _break = function() {
            return __iced_k(_results);
          };
          _continue = function() {
            return iced.trampoline(function() {
              return _while(__iced_k);
            });
          };
          _next = function(__iced_next_arg) {
            _results.push(__iced_next_arg);
            return _continue();
          };
          if (!(i < _this.c)) {
            return _break();
          } else {
            stop = Math.min(_this.c, i + 128);
            while (i < stop) {
              U = _this._PRF(U);
              ret.xor(U, {});
              i++;
            }
            progress_hook(i);
            (function(__iced_k) {
              __iced_deferrals = new iced.Deferrals(__iced_k, {
                parent: ___iced_passed_deferral,
                filename: "src/pbkdf2.iced",
                funcname: "PBKDF2._gen_T_i"
              });
              util.default_delay(0, 0, __iced_deferrals.defer({
                lineno: 57
              }));
              __iced_deferrals._fulfill();
            })(_next);
          }
        };
        _while(__iced_k);
      })(function() {
        progress_hook(i);
        return cb(ret);
      });
    };

    PBKDF2.prototype.gen = function(_arg, cb) {
      var bs, dkLen, flat, i, n, ph, progress_hook, tmp, tph, words, ___iced_passed_deferral, __iced_deferrals, __iced_k,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      dkLen = _arg.dkLen, progress_hook = _arg.progress_hook;
      bs = this.prf.get_output_size();
      n = Math.ceil(dkLen / bs);
      words = [];
      tph = null;
      ph = function(block) {
        return function(iter) {
          return typeof progress_hook === "function" ? progress_hook({
            what: "pbkdf2",
            total: n * _this.c,
            i: block * _this.c + iter
          }) : void 0;
        };
      };
      ph(0)(0);
      (function(__iced_k) {
        var _i, _results, _while;
        i = 1;
        _results = [];
        _while = function(__iced_k) {
          var _break, _continue, _next;
          _break = function() {
            return __iced_k(_results);
          };
          _continue = function() {
            return iced.trampoline(function() {
              ++i;
              return _while(__iced_k);
            });
          };
          _next = function(__iced_next_arg) {
            _results.push(__iced_next_arg);
            return _continue();
          };
          if (!(i <= n)) {
            return _break();
          } else {

            (function(__iced_k) {
              __iced_deferrals = new iced.Deferrals(__iced_k, {
                parent: ___iced_passed_deferral,
                filename: "src/pbkdf2.iced",
                funcname: "PBKDF2.gen"
              });
              _this._gen_T_i({
                i: i,
                progress_hook: ph(i - 1)
              }, __iced_deferrals.defer({
                assign_fn: (function() {
                  return function() {
                    return tmp = arguments[0];
                  };
                })(),
                lineno: 78
              }));
              __iced_deferrals._fulfill();
            })(function() {
              return _next(words.push(tmp.words));
            });
          }
        };
        _while(__iced_k);
      })(function() {
        var _ref;
        ph(n)(0);
        flat = (_ref = []).concat.apply(_ref, words);
        _this.key.scrub();
        _this.prf.scrub();
        return cb(new WordArray(flat, dkLen));
      });
    };

    return PBKDF2;

  })();

  pbkdf2 = function(_arg, cb) {
    var c, dkLen, eng, key, klass, out, progress_hook, salt, ___iced_passed_deferral, __iced_deferrals, __iced_k,
      _this = this;
    __iced_k = __iced_k_noop;
    ___iced_passed_deferral = iced.findDeferral(arguments);
    key = _arg.key, salt = _arg.salt, c = _arg.c, dkLen = _arg.dkLen, progress_hook = _arg.progress_hook, klass = _arg.klass;
    eng = new PBKDF2({
      key: key,
      salt: salt,
      c: c,
      klass: klass
    });
    (function(__iced_k) {
      __iced_deferrals = new iced.Deferrals(__iced_k, {
        parent: ___iced_passed_deferral,
        filename: "src/pbkdf2.iced",
        funcname: "pbkdf2"
      });
      eng.gen({
        dkLen: dkLen,
        progress_hook: progress_hook
      }, __iced_deferrals.defer({
        assign_fn: (function() {
          return function() {
            return out = arguments[0];
          };
        })(),
        lineno: 103
      }));
      __iced_deferrals._fulfill();
    })(function() {
      return cb(out);
    });
  };

  exports.pbkdf2 = pbkdf2;

  exports.PBKDF2 = PBKDF2;

}).call(this);

},{"./hmac":33,"./util":45,"./wordarray":46,"iced-coffee-script/lib/coffee-script/iced":22}],37:[function(require,module,exports){
var Buffer=require("__browserify_Buffer").Buffer;// Generated by IcedCoffeeScript 1.6.3-f
(function() {
  var ADRBG, PRNG, WordArray, XOR, browser_rng, e, generate, iced, more_entropy, native_rng, rng, util, __iced_k, __iced_k_noop, _prng, _ref;

  iced = require('iced-coffee-script/lib/coffee-script/iced').runtime;
  __iced_k = __iced_k_noop = function() {};

  more_entropy = require('more-entropy');

  ADRBG = require('./drbg').ADRBG;

  WordArray = require('./wordarray').WordArray;

  XOR = require('./combine').XOR;

  util = require('./util');

  browser_rng = function(n) {
    var v;
    v = new Uint8Array(n);
    window.crypto.getRandomValues(v);
    return new Buffer(v);
  };

  if ((typeof window !== "undefined" && window !== null ? (_ref = window.crypto) != null ? _ref.getRandomValues : void 0 : void 0) != null) {
    native_rng = browser_rng;
  } else {
    try {
      rng = require('cry' + 'pto').rng;
      if (rng != null) {
        native_rng = rng;
      }
    } catch (_error) {
      e = _error;
    }
  }

  if (native_rng == null) {
    throw new Error('No rng found; tried requiring "crypto" and window.crypto');
  }

  PRNG = (function() {
    function PRNG() {
      var _this = this;
      this.meg = new more_entropy.Generator();
      this.adrbg = new ADRBG((function(n, cb) {
        return _this.gen_seed(n, cb);
      }), XOR.sign);
    }

    PRNG.prototype.now_to_buffer = function() {
      var buf, d, ms, s;
      d = Date.now();
      ms = d % 1000;
      s = Math.floor(d / 1000);
      buf = new Buffer(8);
      buf.writeUInt32BE(s, 0);
      buf.writeUInt32BE(ms, 4);
      return buf;
    };

    PRNG.prototype.gen_seed = function(nbits, cb) {
      var b, bufs, cat, nbytes, wa, words, ___iced_passed_deferral, __iced_deferrals, __iced_k,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      nbytes = nbits / 8;
      bufs = [];
      bufs.push(this.now_to_buffer());
      (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: "src/prng.iced",
          funcname: "PRNG.gen_seed"
        });
        _this.meg.generate(nbits, __iced_deferrals.defer({
          assign_fn: (function() {
            return function() {
              return words = arguments[0];
            };
          })(),
          lineno: 68
        }));
        __iced_deferrals._fulfill();
      })(function() {
        var _i, _len;
        bufs.push(_this.now_to_buffer());
        bufs.push(new Buffer(words));
        bufs.push(native_rng(nbytes));
        bufs.push(_this.now_to_buffer());
        cat = Buffer.concat(bufs);
        wa = WordArray.from_buffer(cat);
        util.scrub_buffer(cat);
        for (_i = 0, _len = bufs.length; _i < _len; _i++) {
          b = bufs[_i];
          util.scrub_buffer(b);
        }
        return cb(wa);
      });
    };

    PRNG.prototype.generate = function(n, cb) {
      return this.adrbg.generate(n, cb);
    };

    return PRNG;

  })();

  _prng = null;

  generate = function(n, cb) {
    if (_prng == null) {
      _prng = new PRNG();
    }
    return _prng.generate(n, cb);
  };

  exports.PRNG = PRNG;

  exports.generate = generate;

  exports.native_rng = native_rng;

}).call(this);

},{"./combine":28,"./drbg":31,"./util":45,"./wordarray":46,"__browserify_Buffer":18,"iced-coffee-script/lib/coffee-script/iced":22,"more-entropy":48}],38:[function(require,module,exports){
var Buffer=require("__browserify_Buffer").Buffer;// Generated by IcedCoffeeScript 1.6.3-g
(function() {
  var Cipher, Counter, Salsa20, Salsa20Core, Salsa20WordStream, StreamCipher, WordArray, asum, bulk_encrypt, encrypt, endian_reverse, fixup_uint32, iced, util, __iced_k, __iced_k_noop, _ref, _ref1,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  iced = require('iced-coffee-script/lib/coffee-script/iced').runtime;
  __iced_k = __iced_k_noop = function() {};

  WordArray = require('./wordarray').WordArray;

  Counter = require('./ctr').Counter;

  fixup_uint32 = require('./util').fixup_uint32;

  StreamCipher = require('./algbase').StreamCipher;

  util = require('./util');

  asum = function(out, v) {
    var e, i, _i, _len;
    for (i = _i = 0, _len = v.length; _i < _len; i = ++_i) {
      e = v[i];
      out[i] += e;
    }
    return false;
  };

  endian_reverse = function(x) {
    return ((x >> 24) & 0xff) | (((x >> 16) & 0xff) << 8) | (((x >> 8) & 0xff) << 16) | ((x & 0xff) << 24);
  };

  Salsa20Core = (function() {
    Salsa20Core.prototype.sigma = WordArray.from_buffer_le(new Buffer("expand 32-byte k"));

    Salsa20Core.prototype.tau = WordArray.from_buffer_le(new Buffer("expand 16-byte k"));

    Salsa20Core.blockSize = 64;

    Salsa20Core.prototype.blockSize = Salsa20Core.blockSize;

    Salsa20Core.keySize = 32;

    Salsa20Core.prototype.keySize = Salsa20Core.keySize;

    Salsa20Core.ivSize = 192 / 8;

    Salsa20Core.prototype.ivSize = Salsa20Core.ivSize;

    Salsa20Core.prototype.rounds = 20;

    function Salsa20Core(key, nonce) {
      var _ref;
      this.key = key;
      this.nonce = nonce;
      if (!(((this.key.sigBytes === 16) && (this.nonce.sigBytes === 8)) || ((this.key.sigBytes === 32) && ((_ref = this.nonce.sigBytes) === 8 || _ref === 24)))) {
        throw new Error("Bad key/nonce lengths");
      }
      if (this.nonce.sigBytes === 24) {
        this.nonce_setup();
      }
      this.input = this.key_iv_setup(this.nonce, this.key);
      this._reset();
    }

    Salsa20Core.prototype.scrub = function() {
      this.key.scrub();
      this.nonce.scrub();
      return util.scrub_vec(this.input);
    };

    Salsa20Core.prototype.nonce_setup = function() {
      var n0, n1;
      n0 = new WordArray(this.nonce.words.slice(0, 4));
      n1 = new WordArray(this.nonce.words.slice(4));
      this.key = this.hsalsa20(n0, this.key);
      return this.nonce = n1;
    };

    Salsa20Core.prototype.hsalsa20 = function(nonce, key) {
      var i, indexes, input, v;
      input = this.key_iv_setup(nonce, key);
      input[8] = nonce.words[2];
      input[9] = nonce.words[3];
      v = this._core(input);
      indexes = [0, 5, 10, 15, 6, 7, 8, 9];
      v = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = indexes.length; _i < _len; _i++) {
          i = indexes[_i];
          _results.push(fixup_uint32(v[i]));
        }
        return _results;
      })();
      util.scrub_vec(input);
      return new WordArray(v);
    };

    Salsa20Core.prototype.key_iv_setup = function(nonce, key) {
      var A, C, i, out, _i, _j, _k, _ref;
      out = [];
      for (i = _i = 0; _i < 4; i = ++_i) {
        out[i + 1] = key.words[i];
      }
      _ref = key.sigBytes === 32 ? [this.sigma, key.words.slice(4)] : [this.tau, key.words], C = _ref[0], A = _ref[1];
      for (i = _j = 0; _j < 4; i = ++_j) {
        out[i + 11] = A[i];
      }
      for (i = _k = 0; _k < 4; i = ++_k) {
        out[i * 5] = C.words[i];
      }
      out[6] = nonce.words[0];
      out[7] = nonce.words[1];
      return out;
    };

    Salsa20Core.prototype.counter_setup = function() {
      this.input[8] = this.counter.get().words[0];
      return this.input[9] = this.counter.get().words[1];
    };

    Salsa20Core.prototype._reset = function() {
      return this.counter = new Counter({
        len: 2
      });
    };

    Salsa20Core.prototype._generateBlock = function() {
      var v;
      this.counter_setup();
      v = this._core(this.input);
      asum(v, this.input);
      this.counter.inc_le();
      return v;
    };

    Salsa20Core.prototype._core = function(v) {
      var i, u, x0, x1, x10, x11, x12, x13, x14, x15, x2, x3, x4, x5, x6, x7, x8, x9, _i, _ref;
      x0 = v[0], x1 = v[1], x2 = v[2], x3 = v[3], x4 = v[4], x5 = v[5], x6 = v[6], x7 = v[7], x8 = v[8], x9 = v[9], x10 = v[10], x11 = v[11], x12 = v[12], x13 = v[13], x14 = v[14], x15 = v[15];
      for (i = _i = 0, _ref = this.rounds; _i < _ref; i = _i += 2) {
        u = x0 + x12;
        x4 ^= (u << 7) | (u >>> (32 - 7));
        u = x4 + x0;
        x8 ^= (u << 9) | (u >>> (32 - 9));
        u = x8 + x4;
        x12 ^= (u << 13) | (u >>> (32 - 13));
        u = x12 + x8;
        x0 ^= (u << 18) | (u >>> (32 - 18));
        u = x5 + x1;
        x9 ^= (u << 7) | (u >>> (32 - 7));
        u = x9 + x5;
        x13 ^= (u << 9) | (u >>> (32 - 9));
        u = x13 + x9;
        x1 ^= (u << 13) | (u >>> (32 - 13));
        u = x1 + x13;
        x5 ^= (u << 18) | (u >>> (32 - 18));
        u = x10 + x6;
        x14 ^= (u << 7) | (u >>> (32 - 7));
        u = x14 + x10;
        x2 ^= (u << 9) | (u >>> (32 - 9));
        u = x2 + x14;
        x6 ^= (u << 13) | (u >>> (32 - 13));
        u = x6 + x2;
        x10 ^= (u << 18) | (u >>> (32 - 18));
        u = x15 + x11;
        x3 ^= (u << 7) | (u >>> (32 - 7));
        u = x3 + x15;
        x7 ^= (u << 9) | (u >>> (32 - 9));
        u = x7 + x3;
        x11 ^= (u << 13) | (u >>> (32 - 13));
        u = x11 + x7;
        x15 ^= (u << 18) | (u >>> (32 - 18));
        u = x0 + x3;
        x1 ^= (u << 7) | (u >>> (32 - 7));
        u = x1 + x0;
        x2 ^= (u << 9) | (u >>> (32 - 9));
        u = x2 + x1;
        x3 ^= (u << 13) | (u >>> (32 - 13));
        u = x3 + x2;
        x0 ^= (u << 18) | (u >>> (32 - 18));
        u = x5 + x4;
        x6 ^= (u << 7) | (u >>> (32 - 7));
        u = x6 + x5;
        x7 ^= (u << 9) | (u >>> (32 - 9));
        u = x7 + x6;
        x4 ^= (u << 13) | (u >>> (32 - 13));
        u = x4 + x7;
        x5 ^= (u << 18) | (u >>> (32 - 18));
        u = x10 + x9;
        x11 ^= (u << 7) | (u >>> (32 - 7));
        u = x11 + x10;
        x8 ^= (u << 9) | (u >>> (32 - 9));
        u = x8 + x11;
        x9 ^= (u << 13) | (u >>> (32 - 13));
        u = x9 + x8;
        x10 ^= (u << 18) | (u >>> (32 - 18));
        u = x15 + x14;
        x12 ^= (u << 7) | (u >>> (32 - 7));
        u = x12 + x15;
        x13 ^= (u << 9) | (u >>> (32 - 9));
        u = x13 + x12;
        x14 ^= (u << 13) | (u >>> (32 - 13));
        u = x14 + x13;
        x15 ^= (u << 18) | (u >>> (32 - 18));
      }
      return [x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15];
    };

    return Salsa20Core;

  })();

  exports.Salsa20WordStream = Salsa20WordStream = (function(_super) {
    __extends(Salsa20WordStream, _super);

    function Salsa20WordStream() {
      _ref = Salsa20WordStream.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    Salsa20WordStream.prototype._reset = function() {
      return Salsa20WordStream.__super__._reset.call(this);
    };

    Salsa20WordStream.prototype.getWordArray = function(nbytes) {
      var blocks, i, nblocks, w, words, _i, _len, _ref1;
      if ((nbytes == null) || nbytes === this.blockSize) {
        words = this._generateBlock();
      } else {
        nblocks = Math.ceil(nbytes / this.blockSize);
        blocks = (function() {
          var _i, _results;
          _results = [];
          for (i = _i = 0; 0 <= nblocks ? _i < nblocks : _i > nblocks; i = 0 <= nblocks ? ++_i : --_i) {
            _results.push(this._generateBlock());
          }
          return _results;
        }).call(this);
        words = (_ref1 = []).concat.apply(_ref1, blocks);
      }
      for (i = _i = 0, _len = words.length; _i < _len; i = ++_i) {
        w = words[i];
        words[i] = endian_reverse(w);
      }
      return new WordArray(words, nbytes);
    };

    return Salsa20WordStream;

  })(Salsa20Core);

  exports.Salsa20 = Salsa20 = (function(_super) {
    __extends(Salsa20, _super);

    function Salsa20() {
      _ref1 = Salsa20.__super__.constructor.apply(this, arguments);
      return _ref1;
    }

    Salsa20.prototype._reset = function() {
      Salsa20.__super__._reset.call(this);
      return this._i = this.blockSize;
    };

    Salsa20.prototype.getBytes = function(needed) {
      var bsz, n, v;
      if (needed == null) {
        needed = this.blockSize;
      }
      v = [];
      bsz = this.blockSize;
      if ((this._i === bsz) && (needed === bsz)) {
        return this._generateBlockBuffer();
      } else {
        while (needed > 0) {
          if (this._i === bsz) {
            this._generateBlockBuffer();
            this._i = 0;
          }
          n = Math.min(needed, bsz - this._i);
          v.push((n === bsz ? this._buf : this._buf.slice(this._i, this._i + n)));
          this._i += n;
          needed -= n;
        }
        return Buffer.concat(v);
      }
    };

    Salsa20.prototype._generateBlockBuffer = function() {
      var e, i, v, _i, _len;
      this._buf = new Buffer(this.blockSize);
      v = this._generateBlock();
      for (i = _i = 0, _len = v.length; _i < _len; i = ++_i) {
        e = v[i];
        this._buf.writeUInt32LE(fixup_uint32(e), i * 4);
      }
      return this._buf;
    };

    return Salsa20;

  })(Salsa20Core);

  exports.Cipher = Cipher = (function(_super) {
    __extends(Cipher, _super);

    function Cipher(_arg) {
      var iv, key;
      key = _arg.key, iv = _arg.iv;
      Cipher.__super__.constructor.call(this);
      this.salsa = new Salsa20WordStream(key, iv);
      this.bsiw = this.salsa.blockSize / 4;
    }

    Cipher.prototype.scrub = function() {
      return this.salsa.scrub();
    };

    Cipher.prototype.get_pad = function() {
      var pad;
      pad = this.salsa.getWordArray();
      return pad;
    };

    return Cipher;

  })(StreamCipher);

  exports.encrypt = encrypt = function(_arg) {
    var cipher, input, iv, key, ret;
    key = _arg.key, iv = _arg.iv, input = _arg.input;
    cipher = new Cipher({
      key: key,
      iv: iv
    });
    ret = cipher.encrypt(input);
    cipher.scrub();
    return ret;
  };

  exports.bulk_encrypt = bulk_encrypt = function(_arg, cb) {
    var cipher, input, iv, key, progress_hook, ret, ___iced_passed_deferral, __iced_deferrals, __iced_k,
      _this = this;
    __iced_k = __iced_k_noop;
    ___iced_passed_deferral = iced.findDeferral(arguments);
    key = _arg.key, iv = _arg.iv, input = _arg.input, progress_hook = _arg.progress_hook;
    cipher = new Cipher({
      key: key,
      iv: iv
    });
    (function(__iced_k) {
      __iced_deferrals = new iced.Deferrals(__iced_k, {
        parent: ___iced_passed_deferral,
        filename: "src/salsa20.iced",
        funcname: "bulk_encrypt"
      });
      cipher.bulk_encrypt({
        input: input,
        progress_hook: progress_hook,
        what: "salsa20"
      }, __iced_deferrals.defer({
        assign_fn: (function() {
          return function() {
            return ret = arguments[0];
          };
        })(),
        lineno: 249
      }));
      __iced_deferrals._fulfill();
    })(function() {
      cipher.scrub();
      return cb(ret);
    });
  };

}).call(this);

},{"./algbase":27,"./ctr":29,"./util":45,"./wordarray":46,"__browserify_Buffer":18,"iced-coffee-script/lib/coffee-script/iced":22}],39:[function(require,module,exports){
// Generated by IcedCoffeeScript 1.6.3-g
(function() {
  var Hasher, SHA1, W, WordArray, transform, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };



  WordArray = require('./wordarray').WordArray;

  Hasher = require('./algbase').Hasher;

  W = [];

  SHA1 = (function(_super) {
    __extends(SHA1, _super);

    function SHA1() {
      _ref = SHA1.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    SHA1.blockSize = 512 / 32;

    SHA1.prototype.blockSize = SHA1.blockSize;

    SHA1.output_size = 5;

    SHA1.prototype.output_size = SHA1.output_size;

    SHA1.prototype._doReset = function() {
      return this._hash = new WordArray([0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0]);
    };

    SHA1.prototype._doProcessBlock = function(M, offset) {
      var H, a, b, c, d, e, i, n, t, _i;
      H = this._hash.words;
      a = H[0];
      b = H[1];
      c = H[2];
      d = H[3];
      e = H[4];
      for (i = _i = 0; _i < 80; i = ++_i) {
        if (i < 16) {
          W[i] = M[offset + i] | 0;
        } else {
          n = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];
          W[i] = (n << 1) | (n >>> 31);
        }
        t = ((a << 5) | (a >>> 27)) + e + W[i];
        if (i < 20) {
          t += ((b & c) | (~b & d)) + 0x5a827999;
        } else if (i < 40) {
          t += (b ^ c ^ d) + 0x6ed9eba1;
        } else if (i < 60) {
          t += ((b & c) | (b & d) | (c & d)) - 0x70e44324;
        } else {
          t += (b ^ c ^ d) - 0x359d3e2a;
        }
        e = d;
        d = c;
        c = (b << 30) | (b >>> 2);
        b = a;
        a = t;
      }
      H[0] = (H[0] + a) | 0;
      H[1] = (H[1] + b) | 0;
      H[2] = (H[2] + c) | 0;
      H[3] = (H[3] + d) | 0;
      return H[4] = (H[4] + e) | 0;
    };

    SHA1.prototype._doFinalize = function() {
      var data, dataWords, nBitsLeft, nBitsTotal;
      data = this._data;
      dataWords = data.words;
      nBitsTotal = this._nDataBytes * 8;
      nBitsLeft = data.sigBytes * 8;
      dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
      dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);
      dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;
      data.sigBytes = dataWords.length * 4;
      this._process();
      return this._hash;
    };

    SHA1.prototype.copy_to = function(obj) {
      SHA1.__super__.copy_to.call(this, obj);
      return obj._hash = this._hash.clone();
    };

    SHA1.prototype.clone = function() {
      var out;
      out = new SHA1();
      this.copy_to(out);
      return out;
    };

    return SHA1;

  })(Hasher);

  transform = transform = function(x) {
    var out;
    out = (new SHA1).finalize(x);
    x.scrub();
    return out;
  };

  exports.SHA1 = SHA1;

  exports.transform = transform;

}).call(this);

},{"./algbase":27,"./wordarray":46}],40:[function(require,module,exports){
// Generated by IcedCoffeeScript 1.6.3-g
(function() {
  var SHA224, SHA256, WordArray, transform, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };



  WordArray = require('./wordarray').WordArray;

  SHA256 = require('./sha256').SHA256;

  SHA224 = (function(_super) {
    __extends(SHA224, _super);

    function SHA224() {
      _ref = SHA224.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    SHA224.prototype._doReset = function() {
      return this._hash = new WordArray([0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939, 0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4]);
    };

    SHA224.prototype._doFinalize = function() {
      var hash;
      hash = SHA224.__super__._doFinalize.call(this);
      hash.sigBytes -= 4;
      return hash;
    };

    SHA224.prototype.clone = function() {
      var out;
      out = new SHA224();
      this.copy_to(out);
      return out;
    };

    return SHA224;

  })(SHA256);

  transform = function(x) {
    var out;
    out = (new SHA224).finalize(x);
    x.scrub();
    return out;
  };

  exports.SHA224 = SHA224;

  exports.transform = transform;

}).call(this);

},{"./sha256":41,"./wordarray":46}],41:[function(require,module,exports){
// Generated by IcedCoffeeScript 1.6.3-g
(function() {
  var Global, Hasher, SHA256, WordArray, glbl, transform, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };



  WordArray = require('./wordarray').WordArray;

  Hasher = require('./algbase').Hasher;

  Global = (function() {
    function Global() {
      this.H = [];
      this.K = [];
      this.W = [];
      this.init();
    }

    Global.prototype.isPrime = function(n) {
      var f, sqn, _i;
      if (n === 2 || n === 3 || n === 5 || n === 7) {
        return true;
      }
      if (n === 1 || n === 4 || n === 6 || n === 8 || n === 9) {
        return false;
      }
      sqn = Math.ceil(Math.sqrt(n));
      for (f = _i = 2; 2 <= sqn ? _i <= sqn : _i >= sqn; f = 2 <= sqn ? ++_i : --_i) {
        if ((n % f) === 0) {
          return false;
        }
      }
      return true;
    };

    Global.prototype.getFractionalBits = function(n) {
      return ((n - (n | 0)) * 0x100000000) | 0;
    };

    Global.prototype.init = function() {
      var n, nPrime, _results;
      n = 2;
      nPrime = 0;
      _results = [];
      while (nPrime < 64) {
        if (this.isPrime(n)) {
          if (nPrime < 8) {
            this.H[nPrime] = this.getFractionalBits(Math.pow(n, 1 / 2));
          }
          this.K[nPrime] = this.getFractionalBits(Math.pow(n, 1 / 3));
          nPrime++;
        }
        _results.push(n++);
      }
      return _results;
    };

    return Global;

  })();

  glbl = new Global();

  SHA256 = (function(_super) {
    __extends(SHA256, _super);

    function SHA256() {
      _ref = SHA256.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    SHA256.blockSize = 512 / 32;

    SHA256.prototype.blockSize = SHA256.blockSize;

    SHA256.output_size = 256 / 32;

    SHA256.prototype.output_size = SHA256.output_size;

    SHA256.prototype._doReset = function() {
      return this._hash = new WordArray(glbl.H.slice(0));
    };

    SHA256.prototype._doProcessBlock = function(M, offset) {
      var H, K, W, a, b, c, ch, d, e, f, g, gamma0, gamma0x, gamma1, gamma1x, h, i, maj, sigma0, sigma1, t1, t2, _i;
      H = this._hash.words;
      W = glbl.W;
      K = glbl.K;
      a = H[0];
      b = H[1];
      c = H[2];
      d = H[3];
      e = H[4];
      f = H[5];
      g = H[6];
      h = H[7];
      for (i = _i = 0; _i < 64; i = ++_i) {
        if (i < 16) {
          W[i] = M[offset + i] | 0;
        } else {
          gamma0x = W[i - 15];
          gamma0 = ((gamma0x << 25) | (gamma0x >>> 7)) ^ ((gamma0x << 14) | (gamma0x >>> 18)) ^ (gamma0x >>> 3);
          gamma1x = W[i - 2];
          gamma1 = ((gamma1x << 15) | (gamma1x >>> 17)) ^ ((gamma1x << 13) | (gamma1x >>> 19)) ^ (gamma1x >>> 10);
          W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];
        }
        ch = (e & f) ^ (~e & g);
        maj = (a & b) ^ (a & c) ^ (b & c);
        sigma0 = ((a << 30) | (a >>> 2)) ^ ((a << 19) | (a >>> 13)) ^ ((a << 10) | (a >>> 22));
        sigma1 = ((e << 26) | (e >>> 6)) ^ ((e << 21) | (e >>> 11)) ^ ((e << 7) | (e >>> 25));
        t1 = h + sigma1 + ch + K[i] + W[i];
        t2 = sigma0 + maj;
        h = g;
        g = f;
        f = e;
        e = (d + t1) | 0;
        d = c;
        c = b;
        b = a;
        a = (t1 + t2) | 0;
      }
      H[0] = (H[0] + a) | 0;
      H[1] = (H[1] + b) | 0;
      H[2] = (H[2] + c) | 0;
      H[3] = (H[3] + d) | 0;
      H[4] = (H[4] + e) | 0;
      H[5] = (H[5] + f) | 0;
      H[6] = (H[6] + g) | 0;
      return H[7] = (H[7] + h) | 0;
    };

    SHA256.prototype._doFinalize = function() {
      var data, dataWords, nBitsLeft, nBitsTotal;
      data = this._data;
      dataWords = data.words;
      nBitsTotal = this._nDataBytes * 8;
      nBitsLeft = data.sigBytes * 8;
      dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
      dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);
      dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;
      data.sigBytes = dataWords.length * 4;
      this._process();
      return this._hash;
    };

    SHA256.prototype.copy_to = function(obj) {
      SHA256.__super__.copy_to.call(this, obj);
      return obj._hash = this._hash.clone();
    };

    SHA256.prototype.clone = function() {
      var out;
      out = new SHA256();
      this.copy_to(out);
      return out;
    };

    return SHA256;

  })(Hasher);

  transform = function(x) {
    var out;
    out = (new SHA256).finalize(x);
    x.scrub();
    return out;
  };

  exports.SHA256 = SHA256;

  exports.transform = transform;

}).call(this);

},{"./algbase":27,"./wordarray":46}],42:[function(require,module,exports){
// Generated by IcedCoffeeScript 1.6.3-f
(function() {
  var Global, Hasher, SHA3, WordArray, X64Word, X64WordArray, glbl, _ref, _ref1,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };



  _ref = require('./wordarray'), WordArray = _ref.WordArray, X64Word = _ref.X64Word, X64WordArray = _ref.X64WordArray;

  Hasher = require('./algbase').Hasher;

  Global = (function() {
    function Global() {
      this.RHO_OFFSETS = [];
      this.PI_INDEXES = [];
      this.ROUND_CONSTANTS = [];
      this.T = [];
      this.compute_rho_offsets();
      this.compute_pi_indexes();
      this.compute_round_constants();
      this.make_reusables();
    }

    Global.prototype.compute_rho_offsets = function() {
      var newX, newY, t, x, y, _i, _results;
      x = 1;
      y = 0;
      _results = [];
      for (t = _i = 0; _i < 24; t = ++_i) {
        this.RHO_OFFSETS[x + 5 * y] = ((t + 1) * (t + 2) / 2) % 64;
        newX = y % 5;
        newY = (2 * x + 3 * y) % 5;
        x = newX;
        _results.push(y = newY);
      }
      return _results;
    };

    Global.prototype.compute_pi_indexes = function() {
      var x, y, _i, _results;
      _results = [];
      for (x = _i = 0; _i < 5; x = ++_i) {
        _results.push((function() {
          var _j, _results1;
          _results1 = [];
          for (y = _j = 0; _j < 5; y = ++_j) {
            _results1.push(this.PI_INDEXES[x + 5 * y] = y + ((2 * x + 3 * y) % 5) * 5);
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    Global.prototype.compute_round_constants = function() {
      var LFSR, bitPosition, i, j, roundConstantLsw, roundConstantMsw, _i, _j, _results;
      LFSR = 0x01;
      _results = [];
      for (i = _i = 0; _i < 24; i = ++_i) {
        roundConstantMsw = 0;
        roundConstantLsw = 0;
        for (j = _j = 0; _j < 7; j = ++_j) {
          if (LFSR & 0x01) {
            bitPosition = (1 << j) - 1;
            if (bitPosition < 32) {
              roundConstantLsw ^= 1 << bitPosition;
            } else {
              roundConstantMsw ^= 1 << (bitPosition - 32);
            }
          }
          if (LFSR & 0x80) {
            LFSR = (LFSR << 1) ^ 0x71;
          } else {
            LFSR <<= 1;
          }
        }
        _results.push(this.ROUND_CONSTANTS[i] = new X64Word(roundConstantMsw, roundConstantLsw));
      }
      return _results;
    };

    Global.prototype.make_reusables = function() {
      var i;
      return this.T = (function() {
        var _i, _results;
        _results = [];
        for (i = _i = 0; _i < 25; i = ++_i) {
          _results.push(new X64Word(0, 0));
        }
        return _results;
      })();
    };

    return Global;

  })();

  glbl = new Global();

  exports.SHA3 = SHA3 = (function(_super) {
    __extends(SHA3, _super);

    function SHA3() {
      _ref1 = SHA3.__super__.constructor.apply(this, arguments);
      return _ref1;
    }

    SHA3.outputLength = 512;

    SHA3.prototype.outputLength = SHA3.outputLength;

    SHA3.blockSize = (1600 - 2 * SHA3.outputLength) / 32;

    SHA3.prototype.blockSize = SHA3.blockSize;

    SHA3.output_size = SHA3.outputLength / 8;

    SHA3.prototype.output_size = SHA3.output_size;

    SHA3.prototype._doReset = function() {
      var i;
      return this._state = (function() {
        var _i, _results;
        _results = [];
        for (i = _i = 0; _i < 25; i = ++_i) {
          _results.push(new X64Word(0, 0));
        }
        return _results;
      })();
    };

    SHA3.prototype._doProcessBlock = function(M, offset) {
      var G, M2i, M2i1, T0, TLane, TPiLane, Tx, Tx1, Tx1Lane, Tx1Lsw, Tx1Msw, Tx2Lane, Tx4, i, lane, laneIndex, laneLsw, laneMsw, nBlockSizeLanes, rhoOffset, round, roundConstant, state, state0, tLsw, tMsw, x, y, _i, _j, _k, _l, _m, _n, _o, _p, _q, _results;
      G = glbl;
      state = this._state;
      nBlockSizeLanes = this.blockSize / 2;
      for (i = _i = 0; 0 <= nBlockSizeLanes ? _i < nBlockSizeLanes : _i > nBlockSizeLanes; i = 0 <= nBlockSizeLanes ? ++_i : --_i) {
        M2i = M[offset + 2 * i];
        M2i1 = M[offset + 2 * i + 1];
        M2i = (((M2i << 8) | (M2i >>> 24)) & 0x00ff00ff) | (((M2i << 24) | (M2i >>> 8)) & 0xff00ff00);
        M2i1 = (((M2i1 << 8) | (M2i1 >>> 24)) & 0x00ff00ff) | (((M2i1 << 24) | (M2i1 >>> 8)) & 0xff00ff00);
        lane = state[i];
        lane.high ^= M2i1;
        lane.low ^= M2i;
      }
      _results = [];
      for (round = _j = 0; _j < 24; round = ++_j) {
        for (x = _k = 0; _k < 5; x = ++_k) {
          tMsw = tLsw = 0;
          for (y = _l = 0; _l < 5; y = ++_l) {
            lane = state[x + 5 * y];
            tMsw ^= lane.high;
            tLsw ^= lane.low;
          }
          Tx = G.T[x];
          Tx.high = tMsw;
          Tx.low = tLsw;
        }
        for (x = _m = 0; _m < 5; x = ++_m) {
          Tx4 = G.T[(x + 4) % 5];
          Tx1 = G.T[(x + 1) % 5];
          Tx1Msw = Tx1.high;
          Tx1Lsw = Tx1.low;
          tMsw = Tx4.high ^ ((Tx1Msw << 1) | (Tx1Lsw >>> 31));
          tLsw = Tx4.low ^ ((Tx1Lsw << 1) | (Tx1Msw >>> 31));
          for (y = _n = 0; _n < 5; y = ++_n) {
            lane = state[x + 5 * y];
            lane.high ^= tMsw;
            lane.low ^= tLsw;
          }
        }
        for (laneIndex = _o = 1; _o < 25; laneIndex = ++_o) {
          lane = state[laneIndex];
          laneMsw = lane.high;
          laneLsw = lane.low;
          rhoOffset = G.RHO_OFFSETS[laneIndex];
          if (rhoOffset < 32) {
            tMsw = (laneMsw << rhoOffset) | (laneLsw >>> (32 - rhoOffset));
            tLsw = (laneLsw << rhoOffset) | (laneMsw >>> (32 - rhoOffset));
          } else {
            tMsw = (laneLsw << (rhoOffset - 32)) | (laneMsw >>> (64 - rhoOffset));
            tLsw = (laneMsw << (rhoOffset - 32)) | (laneLsw >>> (64 - rhoOffset));
          }
          TPiLane = G.T[G.PI_INDEXES[laneIndex]];
          TPiLane.high = tMsw;
          TPiLane.low = tLsw;
        }
        T0 = G.T[0];
        state0 = state[0];
        T0.high = state0.high;
        T0.low = state0.low;
        for (x = _p = 0; _p < 5; x = ++_p) {
          for (y = _q = 0; _q < 5; y = ++_q) {
            laneIndex = x + 5 * y;
            lane = state[laneIndex];
            TLane = G.T[laneIndex];
            Tx1Lane = G.T[((x + 1) % 5) + 5 * y];
            Tx2Lane = G.T[((x + 2) % 5) + 5 * y];
            lane.high = TLane.high ^ (~Tx1Lane.high & Tx2Lane.high);
            lane.low = TLane.low ^ (~Tx1Lane.low & Tx2Lane.low);
          }
        }
        lane = state[0];
        roundConstant = G.ROUND_CONSTANTS[round];
        lane.high ^= roundConstant.high;
        _results.push(lane.low ^= roundConstant.low);
      }
      return _results;
    };

    SHA3.prototype._doFinalize = function() {
      var blockSizeBits, data, dataWords, hashWords, i, lane, laneLsw, laneMsw, nBitsLeft, nBitsTotal, outputLengthBytes, outputLengthLanes, state, _i;
      data = this._data;
      dataWords = data.words;
      nBitsTotal = this._nDataBytes * 8;
      nBitsLeft = data.sigBytes * 8;
      blockSizeBits = this.blockSize * 32;
      dataWords[nBitsLeft >>> 5] |= 0x1 << (24 - nBitsLeft % 32);
      dataWords[((Math.ceil((nBitsLeft + 1) / blockSizeBits) * blockSizeBits) >>> 5) - 1] |= 0x80;
      data.sigBytes = dataWords.length * 4;
      this._process();
      state = this._state;
      outputLengthBytes = this.outputLength / 8;
      outputLengthLanes = outputLengthBytes / 8;
      hashWords = [];
      for (i = _i = 0; 0 <= outputLengthLanes ? _i < outputLengthLanes : _i > outputLengthLanes; i = 0 <= outputLengthLanes ? ++_i : --_i) {
        lane = state[i];
        laneMsw = lane.high;
        laneLsw = lane.low;
        laneMsw = (((laneMsw << 8) | (laneMsw >>> 24)) & 0x00ff00ff) | (((laneMsw << 24) | (laneMsw >>> 8)) & 0xff00ff00);
        laneLsw = (((laneLsw << 8) | (laneLsw >>> 24)) & 0x00ff00ff) | (((laneLsw << 24) | (laneLsw >>> 8)) & 0xff00ff00);
        hashWords.push(laneLsw);
        hashWords.push(laneMsw);
      }
      return new WordArray(hashWords, outputLengthBytes);
    };

    SHA3.prototype.copy_to = function(obj) {
      var s;
      SHA3.__super__.copy_to.call(this, obj);
      return obj._state = (function() {
        var _i, _len, _ref2, _results;
        _ref2 = this._state;
        _results = [];
        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
          s = _ref2[_i];
          _results.push(s.clone());
        }
        return _results;
      }).call(this);
    };

    SHA3.prototype.scrub = function() {};

    SHA3.prototype.clone = function() {
      var out;
      out = new SHA3();
      this.copy_to(out);
      return out;
    };

    return SHA3;

  })(Hasher);

  exports.transform = function(x) {
    var out;
    out = (new SHA3).finalize(x);
    x.scrub();
    return out;
  };

}).call(this);

},{"./algbase":27,"./wordarray":46}],43:[function(require,module,exports){
// Generated by IcedCoffeeScript 1.6.3-g
(function() {
  var Global, Hasher, SHA512, X64Word, X64WordArray, glbl, _ref, _ref1,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };



  _ref = require('./wordarray'), X64Word = _ref.X64Word, X64WordArray = _ref.X64WordArray;

  Hasher = require('./algbase').Hasher;

  Global = (function() {
    Global.prototype.convert = function(raw) {
      var i, _i, _ref1, _results;
      _results = [];
      for (i = _i = 0, _ref1 = raw.length; _i < _ref1; i = _i += 2) {
        _results.push(new X64Word(raw[i], raw[i + 1]));
      }
      return _results;
    };

    function Global() {
      var i;
      this.K = this.convert([0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd, 0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc, 0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019, 0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118, 0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe, 0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2, 0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1, 0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694, 0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3, 0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65, 0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483, 0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5, 0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210, 0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4, 0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725, 0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70, 0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926, 0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df, 0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8, 0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b, 0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001, 0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30, 0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910, 0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8, 0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53, 0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8, 0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb, 0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3, 0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60, 0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec, 0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9, 0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b, 0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207, 0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178, 0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6, 0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b, 0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493, 0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c, 0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a, 0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817]);
      this.I = new X64WordArray(this.convert([0x6a09e667, 0xf3bcc908, 0xbb67ae85, 0x84caa73b, 0x3c6ef372, 0xfe94f82b, 0xa54ff53a, 0x5f1d36f1, 0x510e527f, 0xade682d1, 0x9b05688c, 0x2b3e6c1f, 0x1f83d9ab, 0xfb41bd6b, 0x5be0cd19, 0x137e2179]));
      this.W = (function() {
        var _i, _results;
        _results = [];
        for (i = _i = 0; _i < 80; i = ++_i) {
          _results.push(new X64Word(0, 0));
        }
        return _results;
      })();
    }

    return Global;

  })();

  glbl = new Global();

  exports.SHA512 = SHA512 = (function(_super) {
    __extends(SHA512, _super);

    function SHA512() {
      _ref1 = SHA512.__super__.constructor.apply(this, arguments);
      return _ref1;
    }

    SHA512.blockSize = 1024 / 32;

    SHA512.prototype.blockSize = SHA512.blockSize;

    SHA512.output_size = 512 / 8;

    SHA512.prototype.output_size = SHA512.output_size;

    SHA512.prototype._doReset = function() {
      return this._hash = glbl.I.clone();
    };

    SHA512.prototype._doProcessBlock = function(M, offset) {
      var H, H0, H0h, H0l, H1, H1h, H1l, H2, H2h, H2l, H3, H3h, H3l, H4, H4h, H4l, H5, H5h, H5l, H6, H6h, H6l, H7, H7h, H7l, Ki, Kih, Kil, W, Wi, Wi16, Wi16h, Wi16l, Wi7, Wi7h, Wi7l, Wih, Wil, ah, al, bh, bl, ch, chh, chl, cl, dh, dl, eh, el, fh, fl, gamma0h, gamma0l, gamma0x, gamma0xh, gamma0xl, gamma1h, gamma1l, gamma1x, gamma1xh, gamma1xl, gh, gl, hh, hl, i, majh, majl, sigma0h, sigma0l, sigma1h, sigma1l, t1h, t1l, t2h, t2l, _i;
      H = this._hash.words;
      W = glbl.W;
      H0 = H[0];
      H1 = H[1];
      H2 = H[2];
      H3 = H[3];
      H4 = H[4];
      H5 = H[5];
      H6 = H[6];
      H7 = H[7];
      H0h = H0.high;
      H0l = H0.low;
      H1h = H1.high;
      H1l = H1.low;
      H2h = H2.high;
      H2l = H2.low;
      H3h = H3.high;
      H3l = H3.low;
      H4h = H4.high;
      H4l = H4.low;
      H5h = H5.high;
      H5l = H5.low;
      H6h = H6.high;
      H6l = H6.low;
      H7h = H7.high;
      H7l = H7.low;
      ah = H0h;
      al = H0l;
      bh = H1h;
      bl = H1l;
      ch = H2h;
      cl = H2l;
      dh = H3h;
      dl = H3l;
      eh = H4h;
      el = H4l;
      fh = H5h;
      fl = H5l;
      gh = H6h;
      gl = H6l;
      hh = H7h;
      hl = H7l;
      for (i = _i = 0; _i < 80; i = ++_i) {
        Wi = W[i];
        if (i < 16) {
          Wih = Wi.high = M[offset + i * 2] | 0;
          Wil = Wi.low = M[offset + i * 2 + 1] | 0;
        } else {
          gamma0x = W[i - 15];
          gamma0xh = gamma0x.high;
          gamma0xl = gamma0x.low;
          gamma0h = ((gamma0xh >>> 1) | (gamma0xl << 31)) ^ ((gamma0xh >>> 8) | (gamma0xl << 24)) ^ (gamma0xh >>> 7);
          gamma0l = ((gamma0xl >>> 1) | (gamma0xh << 31)) ^ ((gamma0xl >>> 8) | (gamma0xh << 24)) ^ ((gamma0xl >>> 7) | (gamma0xh << 25));
          gamma1x = W[i - 2];
          gamma1xh = gamma1x.high;
          gamma1xl = gamma1x.low;
          gamma1h = ((gamma1xh >>> 19) | (gamma1xl << 13)) ^ ((gamma1xh << 3) | (gamma1xl >>> 29)) ^ (gamma1xh >>> 6);
          gamma1l = ((gamma1xl >>> 19) | (gamma1xh << 13)) ^ ((gamma1xl << 3) | (gamma1xh >>> 29)) ^ ((gamma1xl >>> 6) | (gamma1xh << 26));
          Wi7 = W[i - 7];
          Wi7h = Wi7.high;
          Wi7l = Wi7.low;
          Wi16 = W[i - 16];
          Wi16h = Wi16.high;
          Wi16l = Wi16.low;
          Wil = gamma0l + Wi7l;
          Wih = gamma0h + Wi7h + ((Wil >>> 0) < (gamma0l >>> 0) ? 1 : 0);
          Wil = Wil + gamma1l;
          Wih = Wih + gamma1h + ((Wil >>> 0) < (gamma1l >>> 0) ? 1 : 0);
          Wil = Wil + Wi16l;
          Wih = Wih + Wi16h + ((Wil >>> 0) < (Wi16l >>> 0) ? 1 : 0);
          Wi.high = Wih;
          Wi.low = Wil;
        }
        chh = (eh & fh) ^ (~eh & gh);
        chl = (el & fl) ^ (~el & gl);
        majh = (ah & bh) ^ (ah & ch) ^ (bh & ch);
        majl = (al & bl) ^ (al & cl) ^ (bl & cl);
        sigma0h = ((ah >>> 28) | (al << 4)) ^ ((ah << 30) | (al >>> 2)) ^ ((ah << 25) | (al >>> 7));
        sigma0l = ((al >>> 28) | (ah << 4)) ^ ((al << 30) | (ah >>> 2)) ^ ((al << 25) | (ah >>> 7));
        sigma1h = ((eh >>> 14) | (el << 18)) ^ ((eh >>> 18) | (el << 14)) ^ ((eh << 23) | (el >>> 9));
        sigma1l = ((el >>> 14) | (eh << 18)) ^ ((el >>> 18) | (eh << 14)) ^ ((el << 23) | (eh >>> 9));
        Ki = glbl.K[i];
        Kih = Ki.high;
        Kil = Ki.low;
        t1l = hl + sigma1l;
        t1h = hh + sigma1h + ((t1l >>> 0) < (hl >>> 0) ? 1 : 0);
        t1l = t1l + chl;
        t1h = t1h + chh + ((t1l >>> 0) < (chl >>> 0) ? 1 : 0);
        t1l = t1l + Kil;
        t1h = t1h + Kih + ((t1l >>> 0) < (Kil >>> 0) ? 1 : 0);
        t1l = t1l + Wil;
        t1h = t1h + Wih + ((t1l >>> 0) < (Wil >>> 0) ? 1 : 0);
        t2l = sigma0l + majl;
        t2h = sigma0h + majh + ((t2l >>> 0) < (sigma0l >>> 0) ? 1 : 0);
        hh = gh;
        hl = gl;
        gh = fh;
        gl = fl;
        fh = eh;
        fl = el;
        el = (dl + t1l) | 0;
        eh = (dh + t1h + ((el >>> 0) < (dl >>> 0) ? 1 : 0)) | 0;
        dh = ch;
        dl = cl;
        ch = bh;
        cl = bl;
        bh = ah;
        bl = al;
        al = (t1l + t2l) | 0;
        ah = (t1h + t2h + ((al >>> 0) < (t1l >>> 0) ? 1 : 0)) | 0;
      }
      H0l = H0.low = H0l + al;
      H0.high = H0h + ah + ((H0l >>> 0) < (al >>> 0) ? 1 : 0);
      H1l = H1.low = H1l + bl;
      H1.high = H1h + bh + ((H1l >>> 0) < (bl >>> 0) ? 1 : 0);
      H2l = H2.low = H2l + cl;
      H2.high = H2h + ch + ((H2l >>> 0) < (cl >>> 0) ? 1 : 0);
      H3l = H3.low = H3l + dl;
      H3.high = H3h + dh + ((H3l >>> 0) < (dl >>> 0) ? 1 : 0);
      H4l = H4.low = H4l + el;
      H4.high = H4h + eh + ((H4l >>> 0) < (el >>> 0) ? 1 : 0);
      H5l = H5.low = H5l + fl;
      H5.high = H5h + fh + ((H5l >>> 0) < (fl >>> 0) ? 1 : 0);
      H6l = H6.low = H6l + gl;
      H6.high = H6h + gh + ((H6l >>> 0) < (gl >>> 0) ? 1 : 0);
      H7l = H7.low = H7l + hl;
      return H7.high = H7h + hh + ((H7l >>> 0) < (hl >>> 0) ? 1 : 0);
    };

    SHA512.prototype._doFinalize = function() {
      var dataWords, nBitsLeft, nBitsTotal;
      dataWords = this._data.words;
      nBitsTotal = this._nDataBytes * 8;
      nBitsLeft = this._data.sigBytes * 8;
      dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
      dataWords[(((nBitsLeft + 128) >>> 10) << 5) + 30] = Math.floor(nBitsTotal / 0x100000000);
      dataWords[(((nBitsLeft + 128) >>> 10) << 5) + 31] = nBitsTotal;
      this._data.sigBytes = dataWords.length * 4;
      this._process();
      return this._hash.toX32();
    };

    SHA512.prototype.copy_to = function(obj) {
      SHA512.__super__.copy_to.call(this, obj);
      return obj._hash = this._hash.clone();
    };

    SHA512.prototype.clone = function() {
      var out;
      out = new SHA512();
      this.copy_to(out);
      return out;
    };

    return SHA512;

  })(Hasher);

  exports.transform = function(x) {
    var out;
    out = (new SHA512).finalize(x);
    x.scrub();
    return out;
  };

}).call(this);

},{"./algbase":27,"./wordarray":46}],44:[function(require,module,exports){
// Generated by IcedCoffeeScript 1.6.3-g
(function() {
  var BlockCipher, G, Global, TwoFish, scrub_vec,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };



  BlockCipher = require('./algbase').BlockCipher;

  scrub_vec = require('./util').scrub_vec;

  Global = (function() {
    function Global() {
      this.P = [[0xA9, 0x67, 0xB3, 0xE8, 0x04, 0xFD, 0xA3, 0x76, 0x9A, 0x92, 0x80, 0x78, 0xE4, 0xDD, 0xD1, 0x38, 0x0D, 0xC6, 0x35, 0x98, 0x18, 0xF7, 0xEC, 0x6C, 0x43, 0x75, 0x37, 0x26, 0xFA, 0x13, 0x94, 0x48, 0xF2, 0xD0, 0x8B, 0x30, 0x84, 0x54, 0xDF, 0x23, 0x19, 0x5B, 0x3D, 0x59, 0xF3, 0xAE, 0xA2, 0x82, 0x63, 0x01, 0x83, 0x2E, 0xD9, 0x51, 0x9B, 0x7C, 0xA6, 0xEB, 0xA5, 0xBE, 0x16, 0x0C, 0xE3, 0x61, 0xC0, 0x8C, 0x3A, 0xF5, 0x73, 0x2C, 0x25, 0x0B, 0xBB, 0x4E, 0x89, 0x6B, 0x53, 0x6A, 0xB4, 0xF1, 0xE1, 0xE6, 0xBD, 0x45, 0xE2, 0xF4, 0xB6, 0x66, 0xCC, 0x95, 0x03, 0x56, 0xD4, 0x1C, 0x1E, 0xD7, 0xFB, 0xC3, 0x8E, 0xB5, 0xE9, 0xCF, 0xBF, 0xBA, 0xEA, 0x77, 0x39, 0xAF, 0x33, 0xC9, 0x62, 0x71, 0x81, 0x79, 0x09, 0xAD, 0x24, 0xCD, 0xF9, 0xD8, 0xE5, 0xC5, 0xB9, 0x4D, 0x44, 0x08, 0x86, 0xE7, 0xA1, 0x1D, 0xAA, 0xED, 0x06, 0x70, 0xB2, 0xD2, 0x41, 0x7B, 0xA0, 0x11, 0x31, 0xC2, 0x27, 0x90, 0x20, 0xF6, 0x60, 0xFF, 0x96, 0x5C, 0xB1, 0xAB, 0x9E, 0x9C, 0x52, 0x1B, 0x5F, 0x93, 0x0A, 0xEF, 0x91, 0x85, 0x49, 0xEE, 0x2D, 0x4F, 0x8F, 0x3B, 0x47, 0x87, 0x6D, 0x46, 0xD6, 0x3E, 0x69, 0x64, 0x2A, 0xCE, 0xCB, 0x2F, 0xFC, 0x97, 0x05, 0x7A, 0xAC, 0x7F, 0xD5, 0x1A, 0x4B, 0x0E, 0xA7, 0x5A, 0x28, 0x14, 0x3F, 0x29, 0x88, 0x3C, 0x4C, 0x02, 0xB8, 0xDA, 0xB0, 0x17, 0x55, 0x1F, 0x8A, 0x7D, 0x57, 0xC7, 0x8D, 0x74, 0xB7, 0xC4, 0x9F, 0x72, 0x7E, 0x15, 0x22, 0x12, 0x58, 0x07, 0x99, 0x34, 0x6E, 0x50, 0xDE, 0x68, 0x65, 0xBC, 0xDB, 0xF8, 0xC8, 0xA8, 0x2B, 0x40, 0xDC, 0xFE, 0x32, 0xA4, 0xCA, 0x10, 0x21, 0xF0, 0xD3, 0x5D, 0x0F, 0x00, 0x6F, 0x9D, 0x36, 0x42, 0x4A, 0x5E, 0xC1, 0xE0], [0x75, 0xF3, 0xC6, 0xF4, 0xDB, 0x7B, 0xFB, 0xC8, 0x4A, 0xD3, 0xE6, 0x6B, 0x45, 0x7D, 0xE8, 0x4B, 0xD6, 0x32, 0xD8, 0xFD, 0x37, 0x71, 0xF1, 0xE1, 0x30, 0x0F, 0xF8, 0x1B, 0x87, 0xFA, 0x06, 0x3F, 0x5E, 0xBA, 0xAE, 0x5B, 0x8A, 0x00, 0xBC, 0x9D, 0x6D, 0xC1, 0xB1, 0x0E, 0x80, 0x5D, 0xD2, 0xD5, 0xA0, 0x84, 0x07, 0x14, 0xB5, 0x90, 0x2C, 0xA3, 0xB2, 0x73, 0x4C, 0x54, 0x92, 0x74, 0x36, 0x51, 0x38, 0xB0, 0xBD, 0x5A, 0xFC, 0x60, 0x62, 0x96, 0x6C, 0x42, 0xF7, 0x10, 0x7C, 0x28, 0x27, 0x8C, 0x13, 0x95, 0x9C, 0xC7, 0x24, 0x46, 0x3B, 0x70, 0xCA, 0xE3, 0x85, 0xCB, 0x11, 0xD0, 0x93, 0xB8, 0xA6, 0x83, 0x20, 0xFF, 0x9F, 0x77, 0xC3, 0xCC, 0x03, 0x6F, 0x08, 0xBF, 0x40, 0xE7, 0x2B, 0xE2, 0x79, 0x0C, 0xAA, 0x82, 0x41, 0x3A, 0xEA, 0xB9, 0xE4, 0x9A, 0xA4, 0x97, 0x7E, 0xDA, 0x7A, 0x17, 0x66, 0x94, 0xA1, 0x1D, 0x3D, 0xF0, 0xDE, 0xB3, 0x0B, 0x72, 0xA7, 0x1C, 0xEF, 0xD1, 0x53, 0x3E, 0x8F, 0x33, 0x26, 0x5F, 0xEC, 0x76, 0x2A, 0x49, 0x81, 0x88, 0xEE, 0x21, 0xC4, 0x1A, 0xEB, 0xD9, 0xC5, 0x39, 0x99, 0xCD, 0xAD, 0x31, 0x8B, 0x01, 0x18, 0x23, 0xDD, 0x1F, 0x4E, 0x2D, 0xF9, 0x48, 0x4F, 0xF2, 0x65, 0x8E, 0x78, 0x5C, 0x58, 0x19, 0x8D, 0xE5, 0x98, 0x57, 0x67, 0x7F, 0x05, 0x64, 0xAF, 0x63, 0xB6, 0xFE, 0xF5, 0xB7, 0x3C, 0xA5, 0xCE, 0xE9, 0x68, 0x44, 0xE0, 0x4D, 0x43, 0x69, 0x29, 0x2E, 0xAC, 0x15, 0x59, 0xA8, 0x0A, 0x9E, 0x6E, 0x47, 0xDF, 0x34, 0x35, 0x6A, 0xCF, 0xDC, 0x22, 0xC9, 0xC0, 0x9B, 0x89, 0xD4, 0xED, 0xAB, 0x12, 0xA2, 0x0D, 0x52, 0xBB, 0x02, 0x2F, 0xA9, 0xD7, 0x61, 0x1E, 0xB4, 0x50, 0x04, 0xF6, 0xC2, 0x16, 0x25, 0x86, 0x56, 0x55, 0x09, 0xBE, 0x91]];
      this.P_00 = 1;
      this.P_01 = 0;
      this.P_02 = 0;
      this.P_03 = 1;
      this.P_04 = 1;
      this.P_10 = 0;
      this.P_11 = 0;
      this.P_12 = 1;
      this.P_13 = 1;
      this.P_14 = 0;
      this.P_20 = 1;
      this.P_21 = 1;
      this.P_22 = 0;
      this.P_23 = 0;
      this.P_24 = 0;
      this.P_30 = 0;
      this.P_31 = 1;
      this.P_32 = 1;
      this.P_33 = 0;
      this.P_34 = 1;
      this.GF256_FDBK = 0x169;
      this.GF256_FDBK_2 = this.GF256_FDBK / 2;
      this.GF256_FDBK_4 = this.GF256_FDBK / 4;
      this.RS_GF_FDBK = 0x14D;
      this.SK_STEP = 0x02020202;
      this.SK_BUMP = 0x01010101;
      this.SK_ROTL = 9;
    }

    return Global;

  })();

  G = new Global();

  exports.TwoFish = TwoFish = (function(_super) {
    __extends(TwoFish, _super);

    TwoFish.blockSize = 4 * 4;

    TwoFish.prototype.blockSize = TwoFish.blockSize;

    TwoFish.keySize = 256 / 8;

    TwoFish.prototype.keySize = TwoFish.keySize;

    TwoFish.ivSize = TwoFish.blockSize;

    TwoFish.prototype.ivSize = TwoFish.ivSize;

    function TwoFish(key) {
      this._key = key.clone();
      this.gMDS0 = [];
      this.gMDS1 = [];
      this.gMDS2 = [];
      this.gMDS3 = [];
      this.gSubKeys = [];
      this.gSBox = [];
      this.k64Cnt = 0;
      this._doReset();
    }

    TwoFish.prototype.getByte = function(x, n) {
      return (x >>> (n * 8)) & 0xFF;
    };

    TwoFish.prototype.switchEndianness = function(word) {
      return ((word & 0xff) << 24) | (((word >> 8) & 0xff) << 16) | (((word >> 16) & 0xff) << 8) | ((word >> 24) & 0xff);
    };

    TwoFish.prototype.LFSR1 = function(x) {
      return (x >> 1) ^ ((x & 0x01) !== 0 ? G.GF256_FDBK_2 : 0);
    };

    TwoFish.prototype.LFSR2 = function(x) {
      return (x >> 2) ^ ((x & 0x02) !== 0 ? G.GF256_FDBK_2 : 0) ^ ((x & 0x01) !== 0 ? G.GF256_FDBK_4 : 0);
    };

    TwoFish.prototype.Mx_X = function(x) {
      return x ^ this.LFSR2(x);
    };

    TwoFish.prototype.Mx_Y = function(x) {
      return x ^ this.LFSR1(x) ^ this.LFSR2(x);
    };

    TwoFish.prototype.RS_rem = function(x) {
      var b, g2, g3;
      b = (x >>> 24) & 0xff;
      g2 = ((b << 1) ^ ((b & 0x80) !== 0 ? G.RS_GF_FDBK : 0)) & 0xff;
      g3 = ((b >>> 1) ^ ((b & 0x01) !== 0 ? G.RS_GF_FDBK >>> 1 : 0)) ^ g2;
      return (x << 8) ^ (g3 << 24) ^ (g2 << 16) ^ (g3 << 8) ^ b;
    };

    TwoFish.prototype.RS_MDS_Encode = function(k0, k1) {
      var i, r, _i, _j;
      r = k1;
      for (i = _i = 0; _i < 4; i = ++_i) {
        r = this.RS_rem(r);
      }
      r ^= k0;
      for (i = _j = 0; _j < 4; i = ++_j) {
        r = this.RS_rem(r);
      }
      return r;
    };

    TwoFish.prototype.F32 = function(x, k32) {
      var b0, b1, b2, b3, k0, k1, k2, k3, m, res;
      b0 = this.getByte(x, 0);
      b1 = this.getByte(x, 1);
      b2 = this.getByte(x, 2);
      b3 = this.getByte(x, 3);
      k0 = k32[0];
      k1 = k32[1];
      k2 = k32[2];
      k3 = k32[3];
      m = this.k64Cnt & 3;
      res = m === 1 ? this.gMDS0[(G.P[G.P_01][b0] & 0xff) ^ this.getByte(k0, 0)] ^ this.gMDS1[(G.P[G.P_11][b1] & 0xff) ^ this.getByte(k0, 1)] ^ this.gMDS2[(G.P[G.P_21][b2] & 0xff) ^ this.getByte(k0, 2)] ^ this.gMDS3[(G.P[G.P_31][b3] & 0xff) ^ this.getByte(k0, 3)] : (m === 0 ? (b0 = (G.P[G.P_04][b0] & 0xff) ^ this.getByte(k3, 0), b1 = (G.P[G.P_14][b1] & 0xff) ^ this.getByte(k3, 1), b2 = (G.P[G.P_24][b2] & 0xff) ^ this.getByte(k3, 2), b3 = (G.P[G.P_34][b3] & 0xff) ^ this.getByte(k3, 3)) : void 0, m === 0 || m === 3 ? (b0 = (G.P[G.P_03][b0] & 0xff) ^ this.getByte(k2, 0), b1 = (G.P[G.P_13][b1] & 0xff) ^ this.getByte(k2, 1), b2 = (G.P[G.P_23][b2] & 0xff) ^ this.getByte(k2, 2), b3 = (G.P[G.P_33][b3] & 0xff) ^ this.getByte(k2, 3)) : void 0, this.gMDS0[(G.P[G.P_01][(G.P[G.P_02][b0] & 0xff) ^ this.getByte(k1, 0)] & 0xff) ^ this.getByte(k0, 0)] ^ this.gMDS1[(G.P[G.P_11][(G.P[G.P_12][b1] & 0xff) ^ this.getByte(k1, 1)] & 0xff) ^ this.getByte(k0, 1)] ^ this.gMDS2[(G.P[G.P_21][(G.P[G.P_22][b2] & 0xff) ^ this.getByte(k1, 2)] & 0xff) ^ this.getByte(k0, 2)] ^ this.gMDS3[(G.P[G.P_31][(G.P[G.P_32][b3] & 0xff) ^ this.getByte(k1, 3)] & 0xff) ^ this.getByte(k0, 3)]);
      return res;
    };

    TwoFish.prototype.Fe32_0 = function(x) {
      return this.gSBox[0x000 + 2 * (x & 0xff)] ^ this.gSBox[0x001 + 2 * ((x >>> 8) & 0xff)] ^ this.gSBox[0x200 + 2 * ((x >>> 16) & 0xff)] ^ this.gSBox[0x201 + 2 * ((x >>> 24) & 0xff)];
    };

    TwoFish.prototype.Fe32_3 = function(x) {
      return this.gSBox[0x000 + 2 * ((x >>> 24) & 0xff)] ^ this.gSBox[0x001 + 2 * (x & 0xff)] ^ this.gSBox[0x200 + 2 * ((x >>> 8) & 0xff)] ^ this.gSBox[0x201 + 2 * ((x >>> 16) & 0xff)];
    };

    TwoFish.prototype._doReset = function() {
      var A, B, b0, b1, b2, b3, i, j, k0, k1, k2, k3, k32e, k32o, m, m1, mX, mY, p, q, sBoxKeys, _i, _j, _k, _l, _ref, _ref1, _results;
      k32e = [];
      k32o = [];
      sBoxKeys = [];
      m1 = [];
      mX = [];
      mY = [];
      this.k64Cnt = this._key.words.length / 2;
      if (this.k64Cnt < 1) {
        throw "Key size less than 64 bits";
      }
      if (this.k64Cnt > 4) {
        throw "Key size larger than 256 bits";
      }
      for (i = _i = 0; _i < 256; i = ++_i) {
        j = G.P[0][i] & 0xff;
        m1[0] = j;
        mX[0] = this.Mx_X(j) & 0xff;
        mY[0] = this.Mx_Y(j) & 0xff;
        j = G.P[1][i] & 0xff;
        m1[1] = j;
        mX[1] = this.Mx_X(j) & 0xff;
        mY[1] = this.Mx_Y(j) & 0xff;
        this.gMDS0[i] = m1[G.P_00] | mX[G.P_00] << 8 | mY[G.P_00] << 16 | mY[G.P_00] << 24;
        this.gMDS1[i] = mY[G.P_10] | mY[G.P_10] << 8 | mX[G.P_10] << 16 | m1[G.P_10] << 24;
        this.gMDS2[i] = mX[G.P_20] | mY[G.P_20] << 8 | m1[G.P_20] << 16 | mY[G.P_20] << 24;
        this.gMDS3[i] = mX[G.P_30] | m1[G.P_30] << 8 | mY[G.P_30] << 16 | mX[G.P_30] << 24;
      }
      for (i = _j = 0, _ref = this.k64Cnt; 0 <= _ref ? _j < _ref : _j > _ref; i = 0 <= _ref ? ++_j : --_j) {
        p = i * 2;
        k32e[i] = this.switchEndianness(this._key.words[p]);
        k32o[i] = this.switchEndianness(this._key.words[p + 1]);
        sBoxKeys[this.k64Cnt - 1 - i] = this.RS_MDS_Encode(k32e[i], k32o[i]);
      }
      for (i = _k = 0, _ref1 = 40 / 2; 0 <= _ref1 ? _k < _ref1 : _k > _ref1; i = 0 <= _ref1 ? ++_k : --_k) {
        q = i * G.SK_STEP;
        A = this.F32(q, k32e);
        B = this.F32(q + G.SK_BUMP, k32o);
        B = B << 8 | B >>> 24;
        A += B;
        this.gSubKeys[i * 2] = A;
        A += B;
        this.gSubKeys[i * 2 + 1] = A << G.SK_ROTL | A >>> (32 - G.SK_ROTL);
      }
      k0 = sBoxKeys[0];
      k1 = sBoxKeys[1];
      k2 = sBoxKeys[2];
      k3 = sBoxKeys[3];
      this.gSBox = [];
      _results = [];
      for (i = _l = 0; _l < 256; i = ++_l) {
        b0 = b1 = b2 = b3 = i;
        m = this.k64Cnt & 3;
        if (m === 1) {
          this.gSBox[i * 2] = this.gMDS0[(G.P[G.P_01][b0] & 0xff) ^ this.getByte(k0, 0)];
          this.gSBox[i * 2 + 1] = this.gMDS1[(G.P[G.P_11][b1] & 0xff) ^ this.getByte(k0, 1)];
          this.gSBox[i * 2 + 0x200] = this.gMDS2[(G.P[G.P_21][b2] & 0xff) ^ this.getByte(k0, 2)];
          _results.push(this.gSBox[i * 2 + 0x201] = this.gMDS3[(G.P[G.P_31][b3] & 0xff) ^ this.getByte(k0, 3)]);
        } else {
          if (m === 0) {
            b0 = (G.P[G.P_04][b0] & 0xff) ^ this.getByte(k3, 0);
            b1 = (G.P[G.P_14][b1] & 0xff) ^ this.getByte(k3, 1);
            b2 = (G.P[G.P_24][b2] & 0xff) ^ this.getByte(k3, 2);
            b3 = (G.P[G.P_34][b3] & 0xff) ^ this.getByte(k3, 3);
          }
          if (m === 0 || m === 3) {
            b0 = (G.P[G.P_03][b0] & 0xff) ^ this.getByte(k2, 0);
            b1 = (G.P[G.P_13][b1] & 0xff) ^ this.getByte(k2, 1);
            b2 = (G.P[G.P_23][b2] & 0xff) ^ this.getByte(k2, 2);
            b3 = (G.P[G.P_33][b3] & 0xff) ^ this.getByte(k2, 3);
          }
          this.gSBox[i * 2] = this.gMDS0[(G.P[G.P_01][(G.P[G.P_02][b0] & 0xff) ^ this.getByte(k1, 0)] & 0xff) ^ this.getByte(k0, 0)];
          this.gSBox[i * 2 + 1] = this.gMDS1[(G.P[G.P_11][(G.P[G.P_12][b1] & 0xff) ^ this.getByte(k1, 1)] & 0xff) ^ this.getByte(k0, 1)];
          this.gSBox[i * 2 + 0x200] = this.gMDS2[(G.P[G.P_21][(G.P[G.P_22][b2] & 0xff) ^ this.getByte(k1, 2)] & 0xff) ^ this.getByte(k0, 2)];
          _results.push(this.gSBox[i * 2 + 0x201] = this.gMDS3[(G.P[G.P_31][(G.P[G.P_32][b3] & 0xff) ^ this.getByte(k1, 3)] & 0xff) ^ this.getByte(k0, 3)]);
        }
      }
      return _results;
    };

    TwoFish.prototype.scrub = function() {
      scrub_vec(this.gSubKeys);
      scrub_vec(this.gSBox);
      return this._key.scrub();
    };

    TwoFish.prototype.decryptBlock = function(M, offset) {
      var k, r, t0, t1, x0, x1, x2, x3, _i;
      if (offset == null) {
        offset = 0;
      }
      x2 = this.switchEndianness(M[offset]) ^ this.gSubKeys[4];
      x3 = this.switchEndianness(M[offset + 1]) ^ this.gSubKeys[5];
      x0 = this.switchEndianness(M[offset + 2]) ^ this.gSubKeys[6];
      x1 = this.switchEndianness(M[offset + 3]) ^ this.gSubKeys[7];
      k = 8 + 2 * 16 - 1;
      for (r = _i = 0; _i < 16; r = _i += 2) {
        t0 = this.Fe32_0(x2);
        t1 = this.Fe32_3(x3);
        x1 ^= t0 + 2 * t1 + this.gSubKeys[k--];
        x0 = (x0 << 1 | x0 >>> 31) ^ (t0 + t1 + this.gSubKeys[k--]);
        x1 = x1 >>> 1 | x1 << 31;
        t0 = this.Fe32_0(x0);
        t1 = this.Fe32_3(x1);
        x3 ^= t0 + 2 * t1 + this.gSubKeys[k--];
        x2 = (x2 << 1 | x2 >>> 31) ^ (t0 + t1 + this.gSubKeys[k--]);
        x3 = x3 >>> 1 | x3 << 31;
      }
      M[offset] = this.switchEndianness(x0 ^ this.gSubKeys[0]);
      M[offset + 1] = this.switchEndianness(x1 ^ this.gSubKeys[1]);
      M[offset + 2] = this.switchEndianness(x2 ^ this.gSubKeys[2]);
      return M[offset + 3] = this.switchEndianness(x3 ^ this.gSubKeys[3]);
    };

    TwoFish.prototype.encryptBlock = function(M, offset) {
      var k, r, t0, t1, x0, x1, x2, x3, _i;
      if (offset == null) {
        offset = 0;
      }
      x0 = this.switchEndianness(M[offset]) ^ this.gSubKeys[0];
      x1 = this.switchEndianness(M[offset + 1]) ^ this.gSubKeys[1];
      x2 = this.switchEndianness(M[offset + 2]) ^ this.gSubKeys[2];
      x3 = this.switchEndianness(M[offset + 3]) ^ this.gSubKeys[3];
      k = 8;
      for (r = _i = 0; _i < 16; r = _i += 2) {
        t0 = this.Fe32_0(x0);
        t1 = this.Fe32_3(x1);
        x2 ^= t0 + t1 + this.gSubKeys[k++];
        x2 = x2 >>> 1 | x2 << 31;
        x3 = (x3 << 1 | x3 >>> 31) ^ (t0 + 2 * t1 + this.gSubKeys[k++]);
        t0 = this.Fe32_0(x2);
        t1 = this.Fe32_3(x3);
        x0 ^= t0 + t1 + this.gSubKeys[k++];
        x0 = x0 >>> 1 | x0 << 31;
        x1 = (x1 << 1 | x1 >>> 31) ^ (t0 + 2 * t1 + this.gSubKeys[k++]);
      }
      M[offset] = this.switchEndianness(x2 ^ this.gSubKeys[4]);
      M[offset + 1] = this.switchEndianness(x3 ^ this.gSubKeys[5]);
      M[offset + 2] = this.switchEndianness(x0 ^ this.gSubKeys[6]);
      return M[offset + 3] = this.switchEndianness(x1 ^ this.gSubKeys[7]);
    };

    return TwoFish;

  })(BlockCipher);

}).call(this);

},{"./algbase":27,"./util":45}],45:[function(require,module,exports){
// Generated by IcedCoffeeScript 1.6.3-g
(function() {
  var default_delay, iced, uint_max, __iced_k, __iced_k_noop;

  iced = require('iced-coffee-script/lib/coffee-script/iced').runtime;
  __iced_k = __iced_k_noop = function() {};

  uint_max = Math.pow(2, 32);

  exports.fixup_uint32 = function(x) {
    var ret, x_pos;
    ret = x > uint_max || x < 0 ? (x_pos = Math.abs(x) % uint_max, x < 0 ? uint_max - x_pos : x_pos) : x;
    return ret;
  };

  exports.scrub_buffer = function(b) {
    var i, _i, _ref, _results;
    _results = [];
    for (i = _i = 0, _ref = b.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      _results.push(b.writeUInt8(0, i));
    }
    return _results;
  };

  exports.scrub_vec = function(v) {
    var i, _i, _ref, _results;
    _results = [];
    for (i = _i = 0, _ref = v.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      _results.push(v[i] = 0);
    }
    return _results;
  };

  exports.default_delay = default_delay = function(i, n, cb) {
    var ___iced_passed_deferral, __iced_deferrals, __iced_k,
      _this = this;
    __iced_k = __iced_k_noop;
    ___iced_passed_deferral = iced.findDeferral(arguments);
    (function(__iced_k) {
      if (typeof setImmediate !== "undefined" && setImmediate !== null) {
        (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "src/util.iced",
            funcname: "default_delay"
          });
          setImmediate(__iced_deferrals.defer({
            lineno: 29
          }));
          __iced_deferrals._fulfill();
        })(__iced_k);
      } else {
        (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "src/util.iced",
            funcname: "default_delay"
          });
          setTimeout(__iced_deferrals.defer({
            lineno: 31
          }), 1);
          __iced_deferrals._fulfill();
        })(__iced_k);
      }
    })(function() {
      return cb();
    });
  };

  exports.bulk = function(n_input_bytes, _arg, _arg1) {
    var call_ph, cb, default_n, delay, finalize, i, left, n, n_words, progress_hook, ret, total_words, update, what, ___iced_passed_deferral, __iced_deferrals, __iced_k,
      _this = this;
    __iced_k = __iced_k_noop;
    ___iced_passed_deferral = iced.findDeferral(arguments);
    update = _arg.update, finalize = _arg.finalize, default_n = _arg.default_n;
    delay = _arg1.delay, n = _arg1.n, cb = _arg1.cb, what = _arg1.what, progress_hook = _arg1.progress_hook;
    i = 0;
    left = 0;
    total_words = Math.ceil(n_input_bytes / 4);
    delay || (delay = default_delay);
    n || (n = default_n);
    call_ph = function(i) {
      return typeof progress_hook === "function" ? progress_hook({
        what: what,
        i: i,
        total: total_words
      }) : void 0;
    };
    call_ph(0);
    (function(__iced_k) {
      var _results, _while;
      _results = [];
      _while = function(__iced_k) {
        var _break, _continue, _next;
        _break = function() {
          return __iced_k(_results);
        };
        _continue = function() {
          return iced.trampoline(function() {
            return _while(__iced_k);
          });
        };
        _next = function(__iced_next_arg) {
          _results.push(__iced_next_arg);
          return _continue();
        };
        if (!((left = total_words - i) > 0)) {
          return _break();
        } else {
          n_words = Math.min(n, left);
          update(i, i + n_words);
          call_ph(i);
          (function(__iced_k) {
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              filename: "src/util.iced",
              funcname: "bulk"
            });
            delay(i, total_words, __iced_deferrals.defer({
              lineno: 65
            }));
            __iced_deferrals._fulfill();
          })(function() {
            return _next(i += n_words);
          });
        }
      };
      _while(__iced_k);
    })(function() {
      call_ph(total_words);
      ret = finalize();
      return cb(ret);
    });
  };

}).call(this);

},{"iced-coffee-script/lib/coffee-script/iced":22}],46:[function(require,module,exports){
var Buffer=require("__browserify_Buffer").Buffer;// Generated by IcedCoffeeScript 1.6.3-f
(function() {
  var WordArray, X64Word, X64WordArray, util;



  util = require('./util');

  exports.WordArray = WordArray = (function() {
    function WordArray(words, sigBytes) {
      this.words = words || [];
      this.sigBytes = sigBytes != null ? sigBytes : this.words.length * 4;
    }

    WordArray.prototype.concat = function(wordArray) {
      var i, thatByte, thatSigBytes, thatWords, _i;
      thatWords = wordArray.words;
      thatSigBytes = wordArray.sigBytes;
      this.clamp();
      if (this.sigBytes % 4) {
        for (i = _i = 0; 0 <= thatSigBytes ? _i < thatSigBytes : _i > thatSigBytes; i = 0 <= thatSigBytes ? ++_i : --_i) {
          thatByte = (thatWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
          this.words[(this.sigBytes + i) >>> 2] |= thatByte << (24 - ((this.sigBytes + i) % 4) * 8);
        }
      } else {
        this.words = this.words.concat(thatWords);
      }
      this.sigBytes += thatSigBytes;
      return this;
    };

    WordArray.prototype.clamp = function() {
      this.words[this.sigBytes >>> 2] &= 0xffffffff << (32 - (this.sigBytes % 4) * 8);
      this.words.length = Math.ceil(this.sigBytes / 4);
      return this;
    };

    WordArray.prototype.clone = function() {
      return new WordArray(this.words.slice(0), this.sigBytes);
    };

    WordArray.prototype.to_buffer = function() {
      var ch, out, p, w, _i, _len, _ref;
      out = new Buffer(this.sigBytes);
      p = 0;
      _ref = this.words;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        w = _ref[_i];
        if (!((this.sigBytes - p) >= 4)) {
          continue;
        }
        w = util.fixup_uint32(w);
        out.writeUInt32BE(w, p);
        p += 4;
      }
      while (p < this.sigBytes) {
        ch = (this.words[p >>> 2] >>> (24 - (p % 4) * 8)) & 0xff;
        out.writeUInt8(ch, p);
        p++;
      }
      return out;
    };

    WordArray.prototype.split = function(n) {
      var i, out, sz;
      if (!(((this.sigBytes % 4) === 0) && ((this.words.length % n) === 0))) {
        throw new Error("bad key alignment");
      }
      sz = this.words.length / n;
      out = (function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 0, _ref = this.words.length; sz > 0 ? _i < _ref : _i > _ref; i = _i += sz) {
          _results.push(new WordArray(this.words.slice(i, i + sz)));
        }
        return _results;
      }).call(this);
      return out;
    };

    WordArray.prototype.to_utf8 = function() {
      return this.to_buffer().toString('utf8');
    };

    WordArray.prototype.to_hex = function() {
      return this.to_buffer().toString('hex');
    };

    WordArray.prototype.to_uint8_array = function() {
      return new Uint8Array(this.to_buffer());
    };

    WordArray.from_buffer = function(b) {
      var ch, last, p, words;
      words = [];
      p = 0;
      while ((b.length - p) >= 4) {
        words.push(b.readUInt32BE(p));
        p += 4;
      }
      if (p < b.length) {
        last = 0;
        while (p < b.length) {
          ch = b.readUInt8(p);
          last |= ch << (24 - (p % 4) * 8);
          p++;
        }
        last = util.fixup_uint32(last);
        words.push(last);
      }
      return new WordArray(words, b.length);
    };

    WordArray.from_buffer_le = function(b) {
      var ch, last, p, words;
      words = [];
      p = 0;
      while ((b.length - p) >= 4) {
        words.push(b.readUInt32LE(p));
        p += 4;
      }
      if (p < b.length) {
        last = 0;
        while (p < b.length) {
          ch = b.readUInt8(p);
          last |= ch << ((p % 4) * 8);
          p++;
        }
        last = util.fixup_uint32(last);
        words.push(last);
      }
      return new WordArray(words, b.length);
    };

    WordArray.from_utf8 = function(s) {
      return WordArray.from_buffer(new Buffer(s, 'utf8'));
    };

    WordArray.from_utf8_le = function(s) {
      return WordArray.from_buffer_le(new Buffer(s, 'utf8'));
    };

    WordArray.from_hex = function(s) {
      return WordArray.from_buffer(new Buffer(s, 'hex'));
    };

    WordArray.from_hex_le = function(s) {
      return WordArray.from_buffer_le(new Buffer(s, 'hex'));
    };

    WordArray.prototype.equal = function(wa) {
      var i, ret, w, _i, _len, _ref;
      ret = true;
      if (wa.sigBytes !== this.sigBytes) {
        ret = false;
      } else {
        _ref = this.words;
        for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
          w = _ref[i];
          if (util.fixup_uint32(w) !== util.fixup_uint32(wa.words[i])) {
            ret = false;
          }
        }
      }
      return ret;
    };

    WordArray.prototype.xor = function(wa2, _arg) {
      var dst_offset, i, n_words, src_offset, tmp, _i;
      dst_offset = _arg.dst_offset, src_offset = _arg.src_offset, n_words = _arg.n_words;
      if (!dst_offset) {
        dst_offset = 0;
      }
      if (!src_offset) {
        src_offset = 0;
      }
      if (n_words == null) {
        n_words = wa2.words.length - src_offset;
      }
      if (this.words.length < dst_offset + n_words) {
        throw new Error("dest range exceeded (" + this.words.length + " < " + (dst_offset + n_words) + ")");
      }
      if (wa2.words.length < src_offset + n_words) {
        throw new Error("source range exceeded");
      }
      for (i = _i = 0; 0 <= n_words ? _i < n_words : _i > n_words; i = 0 <= n_words ? ++_i : --_i) {
        tmp = this.words[dst_offset + i] ^ wa2.words[src_offset + i];
        this.words[dst_offset + i] = util.fixup_uint32(tmp);
      }
      return this;
    };

    WordArray.prototype.truncate = function(n_bytes) {
      var n_words;
      if (!(n_bytes <= this.sigBytes)) {
        throw new Error("Cannot truncate: " + n_bytes + " > " + this.sigBytes);
      }
      n_words = Math.ceil(n_bytes / 4);
      return new WordArray(this.words.slice(0, n_words), n_bytes);
    };

    WordArray.prototype.unshift = function(n_words) {
      var ret;
      if (this.words.length >= n_words) {
        ret = this.words.splice(0, n_words);
        this.sigBytes -= n_words * 4;
        return new WordArray(ret);
      } else {
        return null;
      }
    };

    WordArray.prototype.is_scrubbed = function() {
      var w, _i, _len, _ref;
      _ref = this.words;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        w = _ref[_i];
        if (w !== 0) {
          return false;
        }
      }
      return true;
    };

    WordArray.prototype.scrub = function() {
      return util.scrub_vec(this.words);
    };

    WordArray.prototype.slice = function(low, hi) {
      var n, sb;
      n = this.words.length;
      if (!((low < hi) && (hi <= n))) {
        throw new Error("Bad WordArray slice [" + low + "," + hi + ")] when only " + n + " avail");
      }
      sb = (hi - low) * 4;
      if (hi === n) {
        sb -= n * 4 - this.sigBytes;
      }
      return new WordArray(this.words.slice(low, hi), sb);
    };

    return WordArray;

  })();

  exports.X64Word = X64Word = (function() {
    function X64Word(high, low) {
      this.high = high;
      this.low = low;
    }

    X64Word.prototype.clone = function() {
      return new X64Word(this.high, this.low);
    };

    return X64Word;

  })();

  exports.X64WordArray = X64WordArray = (function() {
    function X64WordArray(words, sigBytes) {
      this.sigBytes = sigBytes;
      this.words = words || [];
      if (!this.sigBytes) {
        this.sigBytes = this.words.length * 8;
      }
    }

    X64WordArray.prototype.toX32 = function() {
      var v, w, _i, _len, _ref;
      v = [];
      _ref = this.words;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        w = _ref[_i];
        v.push(w.high);
        v.push(w.low);
      }
      return new WordArray(v, this.sigBytes);
    };

    X64WordArray.prototype.clone = function() {
      var w;
      return new X64WordArray((function() {
        var _i, _len, _ref, _results;
        _ref = this.words;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          w = _ref[_i];
          _results.push(w.clone());
        }
        return _results;
      }).call(this), this.sigBytes);
    };

    return X64WordArray;

  })();

}).call(this);

},{"./util":45,"__browserify_Buffer":18}],47:[function(require,module,exports){
// Generated by IcedCoffeeScript 1.6.3-g
(function() {
  var Generator, iced, __iced_k, __iced_k_noop;

  iced = require('iced-coffee-script/lib/coffee-script/iced').runtime;
  __iced_k = __iced_k_noop = function() {};

  Generator = Generator = (function() {
    function Generator(opts) {
      opts = opts || {};
      this.loop_delay = opts.loop_delay || 10;
      this.work_min = opts.work_min || 1;
      this.auto_stop_bits = opts.auto_stop_bits || 4096;
      this.max_bits_per_delta = opts.max_bits_per_delta || 4;
      this.entropies = [];
      this.running = true;
      this.timer_race_loop();
    }

    Generator.prototype.generate = function(bits_wanted, cb) {
      var e, harvested_bits, res, ___iced_passed_deferral, __iced_deferrals, __iced_k,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      harvested_bits = 0;
      res = [];
      (function(__iced_k) {
        var _results, _while;
        _results = [];
        _while = function(__iced_k) {
          var _break, _continue, _next;
          _break = function() {
            return __iced_k(_results);
          };
          _continue = function() {
            return iced.trampoline(function() {
              return _while(__iced_k);
            });
          };
          _next = function(__iced_next_arg) {
            _results.push(__iced_next_arg);
            return _continue();
          };
          if (!(harvested_bits < bits_wanted)) {
            return _break();
          } else {
            (function(__iced_k) {
              if (_this.entropies.length) {
                e = _this.entropies.splice(0, 1)[0];
                harvested_bits += e[1];
                return __iced_k(res.push(e[0]));
              } else {
                (function(__iced_k) {
                  __iced_deferrals = new iced.Deferrals(__iced_k, {
                    parent: ___iced_passed_deferral,
                    filename: "src/generator.iced",
                    funcname: "Generator.generate"
                  });
                  setTimeout(__iced_deferrals.defer({
                    lineno: 22
                  }), _this.loop_delay);
                  __iced_deferrals._fulfill();
                })(__iced_k);
              }
            })(_next);
          }
        };
        _while(__iced_k);
      })(function() {
        return cb(res);
      });
    };

    Generator.prototype.stop = function() {
      return this.running = false;
    };

    Generator.prototype.resume = function() {
      return this.running = true;
    };

    Generator.prototype.reset = function() {
      this.entropies = [];
      return this.total_bits = 0;
    };

    Generator.prototype.count_unused_bits = function() {
      var bits, e, _i, _len, _ref;
      bits = 0;
      _ref = this.entropies;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        e = _ref[_i];
        bits += e[1];
      }
      return bits;
    };

    Generator.prototype.timer_race_loop = function() {
      var count, delta, entropy, v, ___iced_passed_deferral, __iced_deferrals, __iced_k, _results, _while,
        _this = this;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      this._last_count = null;
      _results = [];
      _while = function(__iced_k) {
        var _break, _continue, _next;
        _break = function() {
          return __iced_k(_results);
        };
        _continue = function() {
          return iced.trampoline(function() {
            return _while(__iced_k);
          });
        };
        _next = function(__iced_next_arg) {
          _results.push(__iced_next_arg);
          return _continue();
        };
        if (!true) {
          return _break();
        } else {
          if (_this.running && (_this.count_unused_bits() < _this.auto_stop_bits)) {
            count = _this.millisecond_count();
            if ((_this._last_count != null) && (delta = count - _this._last_count)) {
              entropy = Math.floor(_this.log_2(Math.abs(delta)));
              entropy = Math.min(_this.max_bits_per_delta, entropy);
              v = [delta, entropy];
              _this.entropies.push(v);
            }
            _this._last_count = count;
          }
          (function(__iced_k) {
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              filename: "src/generator.iced",
              funcname: "Generator.timer_race_loop"
            });
            setTimeout(__iced_deferrals.defer({
              lineno: 48
            }), _this.loop_delay);
            __iced_deferrals._fulfill();
          })(_next);
        }
      };
      _while(__iced_k);
    };

    Generator.prototype.log_2 = function(x) {
      return Math.log(x) / Math.LN2;
    };

    Generator.prototype.millisecond_count = function() {
      var d, i, x;
      d = Date.now();
      i = x = 0;
      while (Date.now() < d + this.work_min + 1) {
        i++;
        x = Math.sin(Math.sqrt(Math.log(i + x)));
      }
      return i;
    };

    return Generator;

  })();

  if (typeof window !== "undefined" && window !== null) {
    window.Generator = Generator;
  }

  if (typeof exports !== "undefined" && exports !== null) {
    exports.Generator = Generator;
  }

}).call(this);

},{"iced-coffee-script/lib/coffee-script/iced":22}],48:[function(require,module,exports){
// Generated by IcedCoffeeScript 1.6.3-g
(function() {


  exports.Generator = require('../lib/generator').Generator;

}).call(this);

},{"../lib/generator":47}],49:[function(require,module,exports){
(function() {
  var BrowserRunner, iced, mods, __iced_k, __iced_k_noop;

  iced = require('iced-coffee-script/lib/coffee-script/iced').runtime;
  __iced_k = __iced_k_noop = function() {};

  mods = {
    cfb: require('../files/cfb.iced'),
    fermat2: require('../files/fermat2.iced'),
    miller_rabin: require('../files/miller_rabin.iced'),
    rsa: require('../files/rsa.iced')
  };

  BrowserRunner = require('iced-test').BrowserRunner;

  window.onload = function() {
    var br, rc, ___iced_passed_deferral, __iced_deferrals, __iced_k,
      _this = this;
    __iced_k = __iced_k_noop;
    ___iced_passed_deferral = iced.findDeferral(arguments);
    br = new BrowserRunner({
      log: "log",
      rc: "rc"
    });
    __iced_deferrals = new iced.Deferrals(__iced_k, {
      parent: ___iced_passed_deferral,
      funcname: "onload"
    });
    br.run(mods, __iced_deferrals.defer({
      assign_fn: (function() {
        return function() {
          return rc = arguments[0];
        };
      })(),
      lineno: 11
    }));
    __iced_deferrals._fulfill();
  };

}).call(this);


},{"../files/cfb.iced":51,"../files/fermat2.iced":52,"../files/miller_rabin.iced":53,"../files/rsa.iced":54,"iced-coffee-script/lib/coffee-script/iced":22,"iced-test":24}],50:[function(require,module,exports){
(function() {


  exports.carmichaels = ["561", "41041", "825265", "321197185", "5394826801", "232250619601", "9746347772161", "1436697831295441", "60977817398996785", "7156857700403137441", "1791562810662585767521", "87674969936234821377601", "6553130926752006031481761", "1590231231043178376951698401", "35237869211718889547310642241", "32809426840359564991177172754241", "2810864562635368426005268142616001", "349407515342287435050603204719587201", "125861887849639969847638681038680787361", "12758106140074522771498516740500829830401"];

  exports.primes = ["282755483533707287054752184321121345766861480697448703443857012153264407439766013042402571", "370332600450952648802345609908335058273399487356359263038584017827194636172568988257769601", "463199005416013829210323411514132845972525641604435693287586851332821637442813833942427923", "374413471625854958269706803072259202131399386829497836277471117216044734280924224462969371", "664869143773196608462001772779382650311673568542237852546715913135688434614731717844868261", "309133826845331278722882330592890120369379620942948199356542318795450228858357445635314757", "976522637021306403150551933319006137720124048624544172072735055780411834104862667155922841", "635752334942676003169313626814655695963315290125751655287486460091602385142405742365191277", "625161793954624746211679299331621567931369768944205635791355694727774487677706013842058779", "204005728266090048777253207241416669051476369216501266754813821619984472224780876488344279"];

}).call(this);


},{}],51:[function(require,module,exports){
var Buffer=require("__browserify_Buffer").Buffer;(function() {
  var decrypt, encrypt, _ref;



  _ref = require('../../lib/cfb'), encrypt = _ref.encrypt, decrypt = _ref.decrypt;

  exports.nist_sp800_38a__f_3_17 = function(T, cb) {
    var c, ciphertext, ct_ours, ct_raw, iv, key, p, plaintext, pt2, pt_raw;
    key = new Buffer("603deb1015ca71be2b73aef0857d77811f352c073b6108d72d9810a30914dff4", 'hex');
    iv = new Buffer("000102030405060708090a0b0c0d0e0f", "hex");
    pt_raw = ["6bc1bee22e409f96e93d7e117393172a", "ae2d8a571e03ac9c9eb76fac45af8e51", "30c81c46a35ce411e5fbc1191a0a52ef", "f69f2445df4f9b17ad2b417be66c3710"];
    ct_raw = ["dc7e84bfda79164b7ecd8486985d3860", "39ffed143b28b1c832113c6331e5407b", "df10132415e54b92a13ed0a8267ae2f9", "75a385741ab9cef82031623d55b1e471"];
    plaintext = Buffer.concat((function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = pt_raw.length; _i < _len; _i++) {
        p = pt_raw[_i];
        _results.push(new Buffer(p, 'hex'));
      }
      return _results;
    })());
    ciphertext = Buffer.concat((function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = ct_raw.length; _i < _len; _i++) {
        c = ct_raw[_i];
        _results.push(new Buffer(c, 'hex'));
      }
      return _results;
    })());
    ct_ours = encrypt({
      key: key,
      plaintext: plaintext,
      iv: iv
    });
    T.equal(ct_ours.toString(), ciphertext.toString(), "encryption produced expected result");
    pt2 = decrypt({
      key: key,
      ciphertext: ciphertext,
      iv: iv
    });
    T.equal(pt2.toString(), plaintext.toString(), "decryption produced expected result");
    return cb();
  };

}).call(this);


},{"../../lib/cfb":2,"__browserify_Buffer":18}],52:[function(require,module,exports){
(function() {
  var fermat2_test, nbs, nbv, numbers, small_primes, _ref;



  _ref = require('../../lib/primegen'), small_primes = _ref.small_primes, fermat2_test = _ref.fermat2_test;

  nbv = require('openpgp').bigint.nbv;

  nbs = require('../../lib/bn').nbs;

  numbers = require('../data/numbers.iced');

  exports.test_small_primes = function(T, cb) {
    var p, _i, _len, _ref1;
    _ref1 = small_primes.slice(1);
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      p = _ref1[_i];
      T.assert(fermat2_test(nbv(p)), "Prime " + p);
    }
    return cb();
  };

  exports.test_small_composites = function(T, cb) {
    var p, _i, _len, _ref1;
    _ref1 = small_primes.slice(1);
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      p = _ref1[_i];
      T.assert(!(fermat2_test(nbv(p).add(nbv(3)))), "Composite " + p + " + 3");
    }
    return cb();
  };

  exports.test_carmichael_numbers = function(T, cb) {
    var C, c, _i, _len;
    C = numbers.carmichaels;
    for (_i = 0, _len = C.length; _i < _len; _i++) {
      c = C[_i];
      T.assert(fermat2_test(nbs(c)), "Carmichael # " + c);
    }
    return cb();
  };

  exports.test_larger_primes = function(T, cb) {
    var P, p, _i, _len;
    P = numbers.primes;
    for (_i = 0, _len = P.length; _i < _len; _i++) {
      p = P[_i];
      T.assert(fermat2_test(nbs(p)), "Prime " + p);
    }
    return cb();
  };

  exports.test_larger_composites = function(T, cb) {
    var P, c, i, p, _i, _len, _ref1;
    P = numbers.primes;
    _ref1 = P.slice(0, P.length - 1);
    for (i = _i = 0, _len = _ref1.length; _i < _len; i = ++_i) {
      p = _ref1[i];
      c = nbs(p).multiply(nbs(P[i + 1]));
      T.assert(!(fermat2_test(c)), "Composite " + (c.toString()));
    }
    return cb();
  };

}).call(this);


},{"../../lib/bn":1,"../../lib/primegen":4,"../data/numbers.iced":50,"openpgp":25}],53:[function(require,module,exports){
(function() {
  var iced, miller_rabin, nbs, numbers, run_mr, __iced_k, __iced_k_noop;

  iced = require('iced-coffee-script/lib/coffee-script/iced').runtime;
  __iced_k = __iced_k_noop = function() {};

  miller_rabin = require('../../lib/primegen').miller_rabin;

  numbers = require('../data/numbers.iced');

  nbs = require('../../lib/bn').nbs;

  run_mr = function(p, desired, what, T, cb) {
    var err, is_prime, s, ___iced_passed_deferral, __iced_deferrals, __iced_k,
      _this = this;
    __iced_k = __iced_k_noop;
    ___iced_passed_deferral = iced.findDeferral(arguments);
    (function(__iced_k) {
      __iced_deferrals = new iced.Deferrals(__iced_k, {
        parent: ___iced_passed_deferral,
        funcname: "run_mr"
      });
      miller_rabin({
        p: p,
        iter: 32
      }, __iced_deferrals.defer({
        assign_fn: (function() {
          return function() {
            err = arguments[0];
            return is_prime = arguments[1];
          };
        })(),
        lineno: 6
      }));
      __iced_deferrals._fulfill();
    })(function() {
      s = p.toString();
      T.assert(!(typeof err !== "undefined" && err !== null), "" + what + " " + s + " had an error: " + (typeof err !== "undefined" && err !== null ? err.toString() : ''));
      T.assert(is_prime === desired, "" + what + " " + s + " primality = " + desired);
      return cb();
    });
  };

  exports.test_primes = function(T, cb) {
    var p, ___iced_passed_deferral, __iced_deferrals, __iced_k,
      _this = this;
    __iced_k = __iced_k_noop;
    ___iced_passed_deferral = iced.findDeferral(arguments);
    (function(__iced_k) {
      var _i, _len, _ref, _results, _while;
      _ref = numbers.primes;
      _len = _ref.length;
      _i = 0;
      _results = [];
      _while = function(__iced_k) {
        var _break, _continue, _next;
        _break = function() {
          return __iced_k(_results);
        };
        _continue = function() {
          return iced.trampoline(function() {
            ++_i;
            return _while(__iced_k);
          });
        };
        _next = function(__iced_next_arg) {
          _results.push(__iced_next_arg);
          return _continue();
        };
        if (!(_i < _len)) {
          return _break();
        } else {
          p = _ref[_i];
          (function(__iced_k) {
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              funcname: "test_primes"
            });
            run_mr(nbs(p), true, "prime", T, __iced_deferrals.defer({
              lineno: 14
            }));
            __iced_deferrals._fulfill();
          })(_next);
        }
      };
      _while(__iced_k);
    })(function() {
      return cb();
    });
  };

  exports.test_composites = function(T, cb) {
    var P, bn, c, i, p, ___iced_passed_deferral, __iced_deferrals, __iced_k,
      _this = this;
    __iced_k = __iced_k_noop;
    ___iced_passed_deferral = iced.findDeferral(arguments);
    P = numbers.primes;
    (function(__iced_k) {
      var _i, _len, _ref, _results, _while;
      _ref = P.slice(0, P.length - 1);
      _len = _ref.length;
      i = 0;
      _results = [];
      _while = function(__iced_k) {
        var _break, _continue, _next;
        _break = function() {
          return __iced_k(_results);
        };
        _continue = function() {
          return iced.trampoline(function() {
            ++i;
            return _while(__iced_k);
          });
        };
        _next = function(__iced_next_arg) {
          _results.push(__iced_next_arg);
          return _continue();
        };
        if (!(i < _len)) {
          return _break();
        } else {
          p = _ref[i];
          c = nbs(p).multiply(nbs(P[i + 1]));
          (function(__iced_k) {
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              funcname: "test_composites"
            });
            run_mr(c, false, "composite", T, __iced_deferrals.defer({
              lineno: 21
            }));
            __iced_deferrals._fulfill();
          })(_next);
        }
      };
      _while(__iced_k);
    })(function() {
      (function(__iced_k) {
        var _i, _len, _ref, _results, _while;
        _ref = numbers.carmichaels;
        _len = _ref.length;
        _i = 0;
        _results = [];
        _while = function(__iced_k) {
          var _break, _continue, _next;
          _break = function() {
            return __iced_k(_results);
          };
          _continue = function() {
            return iced.trampoline(function() {
              ++_i;
              return _while(__iced_k);
            });
          };
          _next = function(__iced_next_arg) {
            _results.push(__iced_next_arg);
            return _continue();
          };
          if (!(_i < _len)) {
            return _break();
          } else {
            c = _ref[_i];
            bn = nbs(c);
            (function(__iced_k) {
              __iced_deferrals = new iced.Deferrals(__iced_k, {
                parent: ___iced_passed_deferral,
                funcname: "test_composites"
              });
              run_mr(bn, false, "Carmichael", T, __iced_deferrals.defer({
                lineno: 24
              }));
              __iced_deferrals._fulfill();
            })(_next);
          }
        };
        _while(__iced_k);
      })(function() {
        return cb();
      });
    });
  };

}).call(this);


},{"../../lib/bn":1,"../../lib/primegen":4,"../data/numbers.iced":50,"iced-coffee-script/lib/coffee-script/iced":22}],54:[function(require,module,exports){
(function() {
  var MediumRandomFountain, RSA, iced, random_zn, rf, run_test, __iced_k, __iced_k_noop, _ref;

  iced = require('iced-coffee-script/lib/coffee-script/iced').runtime;
  __iced_k = __iced_k_noop = function() {};

  RSA = require('../../lib/rsa').RSA;

  _ref = require('../../lib/primegen'), MediumRandomFountain = _ref.MediumRandomFountain, random_zn = _ref.random_zn;

  rf = new MediumRandomFountain();

  run_test = function(T, nbits, n, cb) {
    var cmp, err, i, key, x, y, z, ___iced_passed_deferral, __iced_deferrals, __iced_k,
      _this = this;
    __iced_k = __iced_k_noop;
    ___iced_passed_deferral = iced.findDeferral(arguments);
    (function(__iced_k) {
      __iced_deferrals = new iced.Deferrals(__iced_k, {
        parent: ___iced_passed_deferral,
        funcname: "run_test"
      });
      setTimeout(__iced_deferrals.defer({
        lineno: 7
      }), 10);
      __iced_deferrals._fulfill();
    })(function() {
      (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          funcname: "run_test"
        });
        RSA.generate({
          nbits: nbits
        }, __iced_deferrals.defer({
          assign_fn: (function() {
            return function() {
              err = arguments[0];
              return key = arguments[1];
            };
          })(),
          lineno: 8
        }));
        __iced_deferrals._fulfill();
      })(function() {
        T.assert(!(typeof err !== "undefined" && err !== null), "Generating keypair worked");
        (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            funcname: "run_test"
          });
          setTimeout(__iced_deferrals.defer({
            lineno: 10
          }), 10);
          __iced_deferrals._fulfill();
        })(function() {
          T.waypoint("generated " + nbits + " bit key!");
          (function(__iced_k) {
            var _i, _results, _while;
            i = 0;
            _results = [];
            _while = function(__iced_k) {
              var _break, _continue, _next;
              _break = function() {
                return __iced_k(_results);
              };
              _continue = function() {
                return iced.trampoline(function() {
                  ++i;
                  return _while(__iced_k);
                });
              };
              _next = function(__iced_next_arg) {
                _results.push(__iced_next_arg);
                return _continue();
              };
              if (!(i < n)) {
                return _break();
              } else {

                x = random_zn(rf, key.pub.n);
                y = key.encrypt(x);
                (function(__iced_k) {
                  __iced_deferrals = new iced.Deferrals(__iced_k, {
                    parent: ___iced_passed_deferral,
                    funcname: "run_test"
                  });
                  setTimeout(__iced_deferrals.defer({
                    lineno: 15
                  }), 2);
                  __iced_deferrals._fulfill();
                })(function() {
                  z = key.decrypt(y);
                  T.waypoint("did encrypt/decrypt #" + i);
                  (function(__iced_k) {
                    __iced_deferrals = new iced.Deferrals(__iced_k, {
                      parent: ___iced_passed_deferral,
                      funcname: "run_test"
                    });
                    setTimeout(__iced_deferrals.defer({
                      lineno: 18
                    }), 10);
                    __iced_deferrals._fulfill();
                  })(function() {
                    cmp = x.compareTo(z);
                    return _next(T.equal(cmp, 0, "Encrypt " + (x.toString())));
                  });
                });
              }
            };
            _while(__iced_k);
          })(function() {
            return cb();
          });
        });
      });
    });
  };

  exports.run_test_512 = function(T, cb) {
    var ___iced_passed_deferral, __iced_deferrals, __iced_k,
      _this = this;
    __iced_k = __iced_k_noop;
    ___iced_passed_deferral = iced.findDeferral(arguments);
    (function(__iced_k) {
      __iced_deferrals = new iced.Deferrals(__iced_k, {
        parent: ___iced_passed_deferral,
        funcname: "run_test_512"
      });
      run_test(T, 512, 10, __iced_deferrals.defer({
        lineno: 24
      }));
      __iced_deferrals._fulfill();
    })(function() {
      return cb();
    });
  };

  exports.run_test_1024 = function(T, cb) {
    var ___iced_passed_deferral, __iced_deferrals, __iced_k,
      _this = this;
    __iced_k = __iced_k_noop;
    ___iced_passed_deferral = iced.findDeferral(arguments);
    (function(__iced_k) {
      __iced_deferrals = new iced.Deferrals(__iced_k, {
        parent: ___iced_passed_deferral,
        funcname: "run_test_1024"
      });
      run_test(T, 1024, 10, __iced_deferrals.defer({
        lineno: 28
      }));
      __iced_deferrals._fulfill();
    })(function() {
      return cb();
    });
  };

  exports.run_test_2048 = function(T, cb) {
    var ___iced_passed_deferral, __iced_deferrals, __iced_k,
      _this = this;
    __iced_k = __iced_k_noop;
    ___iced_passed_deferral = iced.findDeferral(arguments);
    (function(__iced_k) {
      __iced_deferrals = new iced.Deferrals(__iced_k, {
        parent: ___iced_passed_deferral,
        funcname: "run_test_2048"
      });
      run_test(T, 2048, 5, __iced_deferrals.defer({
        lineno: 32
      }));
      __iced_deferrals._fulfill();
    })(function() {
      return cb();
    });
  };

  exports.run_test_3072 = function(T, cb) {
    var ___iced_passed_deferral, __iced_deferrals, __iced_k,
      _this = this;
    __iced_k = __iced_k_noop;
    ___iced_passed_deferral = iced.findDeferral(arguments);
    (function(__iced_k) {
      __iced_deferrals = new iced.Deferrals(__iced_k, {
        parent: ___iced_passed_deferral,
        funcname: "run_test_3072"
      });
      run_test(T, 3072, 3, __iced_deferrals.defer({
        lineno: 36
      }));
      __iced_deferrals._fulfill();
    })(function() {
      return cb();
    });
  };

  exports.run_test_4096 = function(T, cb) {
    var ___iced_passed_deferral, __iced_deferrals, __iced_k,
      _this = this;
    __iced_k = __iced_k_noop;
    ___iced_passed_deferral = iced.findDeferral(arguments);
    (function(__iced_k) {
      __iced_deferrals = new iced.Deferrals(__iced_k, {
        parent: ___iced_passed_deferral,
        funcname: "run_test_4096"
      });
      run_test(T, 4096, 2, __iced_deferrals.defer({
        lineno: 40
      }));
      __iced_deferrals._fulfill();
    })(function() {
      return cb();
    });
  };

}).call(this);


},{"../../lib/primegen":4,"../../lib/rsa":6,"iced-coffee-script/lib/coffee-script/iced":22}]},{},[49])
;